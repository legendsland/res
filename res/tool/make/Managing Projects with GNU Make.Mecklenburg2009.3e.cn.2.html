<!DOCTYPE html><html class="translated-ltr" style=""><!--
 Page saved with SingleFile 
 url: file:///home/zy/ws/res/res/tool/make/Managing%20Projects%20with%20GNU%20Make.Mecklenburg2009.html 
 saved date: Mon Apr 29 2024 21:16:46 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/78d22652ffd0b9e4a61705f858c5b7b918e44564">
<meta charset="utf-8">


<title>Managing Projects with GNU Make.Mecklenburg2009.3e</title>
<style></style>
<style>@page{margin-left:8px;margin-right:8px}p{margin-top:10px;margin-bottom:10px}em{font-style:italic;font-family:serif}strong{font-weight:bold;font-family:serif}code em,em code,pre em{font-family:monospace;font-style:italic}strong code,pre strong{font-family:monospace;font-weight:bold}code{font-family:"DejaVu Sans Mono",monospace}h1,h2,h3,h4{text-align:left;page-break-inside:avoid;page-break-after:avoid;font-weight:bold;display:block;font-family:sans-serif}.title{font-family:sans-serif;font-weight:bold}h1{font-size:1.5em;color:#000033}h2{font-size:1.3em;color:#000080}h3{font-size:1.1em;color:#00009C}img{max-width:100%;margin:auto}.figure-contents{page-break-after:avoid;page-break-inside:avoid;padding-bottom:0.10em}.figure{background:#F5F5F5;page-break-inside:avoid;padding:5px;text-align:center}.figure .title{page-break-before:avoid;margin:0;text-align:center;font-weight:normal;font-style:italic;font-family:serif}pre{white-space:pre-wrap;font-family:"DejaVu Sans Mono",monospace;font-size:85%;margin-left:1.5em;margin-bottom:10px}.book .titlepage .title{font-size:2em;text-align:center}.author h3{font-family:serif;font-size:1.7em;font-style:italic;text-align:center}.editor h3,.editor h4{color:black;margin:10px 0 10px 0;font-weight:normal;font-style:normal;font-size:1em;font-family:serif}dd{margin-left:1.5em}ol{margin-left:1em;padding-left:1em;list-style-type:decimal}ul{margin-left:1em;padding-left:1em;list-style:square outside}.simplelist{margin-left:1.5em;margin-top:0;width:100%}.simplelist td{border:none;font-size:medium;padding:0}.example .title{font-weight:normal;font-style:italic;font-family:serif;page-break-after:avoid}.example{background-color:#F5F5F5}.note{width:95%;margin:10px 10px 10px 5px;page-break-inside:avoid;border:dashed black 1px;background-color:#F5F5F5}.note>*{padding-left:5px;padding-right:5px}.note h3{text-align:left!important;page-break-after:avoid}.tip h3:after,.note h3:after{content:" ✎"}table{margin-top:0.5em;max-width:100%;border-collapse:collapse;border-spacing:0}th{color:black;background-color:#F5F5F5;border:black 1px solid;font-weight:bold;font-family:sans-serif;font-size:smaller;padding:0.2em;margin:0;text-align:left}td{border:black 1px solid;padding:0.2em;margin:0;border-spacing:0;font-size:smaller}.table .title{font-size:medium;font-weight:normal;font-style:italic;font-family:serif;page-break-after:avoid;margin-bottom:0.50em}table code{font-size:x-small}code.function{color:rgb(0,128,0)}@font-face{font-family:"DejaVu Serif";font-style:normal;font-weight:normal;src:}@font-face{font-family:"DejaVu Sans Mono";font-weight:normal;font-style:normal;src:}body{font-family:"DejaVu Serif",serif;margin:0;padding:0;text-align:left}</style>
<style></style>
<style>@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb form{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-size:10pt;width:420px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS{clear:both;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}</style><meta name="referrer" content="no-referrer"><link type="image/x-icon" rel="shortcut icon" href="data:application/octet-stream;base64,"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container"><div id="OEBPS/cover.html"><div>

    <div id="OEBPS/cover.html.cover-image">
      <img src="data:image/jpg;base64,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9FAFH+yLQ3sF86GS8ggaCOdzllViC3tklRz7VRsfCunWM2oyBrib+0sm7W4lMiynbtyQenyjGBxityigDF0nwxY6PHFHDLdzRW4xbx3Nw0qwKBgBQfQcAnJA71DF4O0qC+nnjN0sFxKZ5bIXDfZ2kJyWMfTk8kdCecV0FFAGPc+F9Ivf7W+1WvnDVUSO7DsSGVV2qB/dxyeO5z1qu/g3SporVJ/tEzW9wLnzGmIeWQR+XlyMbvk4569810FFAGHP4V0+XV31OJ7q1nljWOcWtw0Szqv3QwHoCQCMHHGaty6JYS3WnXDQYbTizWyqSFQsu0nb0JwSBnpk1o0UAZQ8O6eNfm1orI13LHHGwaQlPk3bSF6ZG48+9Ry+GNOmint5BMbK4laaa08wiKRmOWyByQTklc4OTxzWzRQBk6h4dsNSu9PuZhMj2BfyPJlMYAZdrA7e2OKSDw1plvrUmqxxOLh4o4tvmHy1VM7cJ0BG48+9a9FAGUmlrpGn6kdIhQ3dy8t0BM5KyTsONx6gZCj2A4rkf7H3ac+pQ3Wt2PiWWMSTi3VlEk4XGGhwYmGQBn0/i716HRQBW043Z0y1N+sa3hhTzxF90SYG7HtnNWaKKACiiigAooooAKwrj/j5l/3z/Ot2sK4/4+Zf98/zoA2bf/j2i/3B/KpKjt/+PaL/AHB/KpKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArCuP8Aj5l/3z/Ot2sK4/4+Zf8AfP8AOgDZt/8Aj2i/3B/KpKjt/wDj2i/3B/KpKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigArCuP+PmX/fP863awrj/j5l/3z/OgDVt54Rbx/vU+4P4h6VJ9oh/56x/99CiigA+0Q/8APWP/AL6FH2iH/nrH/wB9CiigA+0Q/wDPWP8A76FH2iH/AJ6x/wDfQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/AD1j/wC+hR9oh/56x/8AfQoooAPtEP8Az1j/AO+hR9oh/wCesf8A30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/wA9Y/8AvoUfaIf+esf/AH0KKKAD7RD/AM9Y/wDvoUfaIf8AnrH/AN9CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/8APWP/AL6FH2iH/nrH/wB9CiigA+0Q/wDPWP8A76FH2iH/AJ6x/wDfQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/AD1j/wC+hR9oh/56x/8AfQoooAPtEP8Az1j/AO+hR9oh/wCesf8A30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/wA9Y/8AvoUfaIf+esf/AH0KKKAD7RD/AM9Y/wDvoUfaIf8AnrH/AN9CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/8APWP/AL6FH2iH/nrH/wB9CiigA+0Q/wDPWP8A76FH2iH/AJ6x/wDfQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/AD1j/wC+hR9oh/56x/8AfQoooAPtEP8Az1j/AO+hR9oh/wCesf8A30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/wA9Y/8AvoUfaIf+esf/AH0KKKAD7RD/AM9Y/wDvoUfaIf8AnrH/AN9CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/89Y/++hR9oh/56x/99CiigA+0Q/8APWP/AL6FH2iH/nrH/wB9CiigA+0Q/wDPWP8A76FH2iH/AJ6x/wDfQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/PWP/voUfaIf+esf/fQoooAPtEP/AD1j/wC+hR9oh/56x/8AfQoooAPtEP8Az1j/AO+hR9oh/wCesf8A30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/z1j/76FH2iH/nrH/30KKKAD7RD/wA9Y/8AvoUfaIf+esf/AH0KKKAD7RD/AM9Y/wDvoUfaIf8AnrH/AN9CiigA+0Q/89Y/++hWHPLGbiX94n3z/EPWiigD/9k=" alt="使用 GNU Make 管理项目，第三版">
    </div>
  </div></div>
<div id="OEBPS/index.html"><div>
<div class="book" title="使用 GNU Make 管理项目，第三版"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/index.html.I__tt2"></a>使用 GNU Make 管理项目，第三版</h1><h1 class="title"><a></a>Managing Projects with GNU Make, 3rd Edition</h1></div><div><div class="author"><h3 class="author"><span class="firstname">罗伯特·梅克伦堡</span></h3><h3 class="author"><span class="firstname">Robert Mecklenburg</span></h3></div></div><div class="editor"><h4>编辑</h4><h4>Editor</h4><h3 class="editor"><span class="firstname">安迪·奥拉姆</span></h3><h3 class="editor"><span class="firstname">Andy Oram</span></h3></div><div><p class="copyright">版权所有 © 2009 O'Reilly Media, Inc.</p><p class="copyright">Copyright © 2009 O'Reilly Media, Inc.</p></div><div><div class="legalnotice" title="法律声明"><a id="OEBPS/index.html.id3049770"></a><p><span class="inlinemediaobject"><img src="data:image/gif;base64,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PXLnvnhUoOtxaW1TLJAGw1oh1dwzsFG9yzVPW8DCJkkFiCkdA6QmI7OGDgekvOiDHJpZj261qadtY2sr9iPRJslllYSRA1Pp201ltkCMyL6lSvvdcP10lU+N7egM9yPFhg4GcpuQDcT3HyS4p76bTR566vnMp273rwHOajOXxNkemkCtB5KATW8Y46n/Lt/XuFhqT7N74gxZMUbibdCH86UDA+BuAi5gW+gkD+XVfkiSodNpgrQcxKe+tYoLjRHhogRwHeLAwwhAAQvUBgPcZs+X1x30hzC2ecwtVM+wSdOeF2pf3jVjdz1+EpN79+AX0fhD9IfdyyrqjLnUqEN31aq0QwfvUGb7SSgw1l0ZAPASL/dC7E3LwHu3ZxP2e9/9jrS1N34lCTA7nxww8mUr/m003jflIS9p786Q8pXXrQ1boqfdxprHn0/3dC41kLDzifRopva6Ju93xNcewy4ZAEn5ZAAHHBvo5KNIwodqeywhfqboWhXv017Wi8MkARagGIkkYF+UyD0iHjxyYfOnhPukU376jzcqzNQa8ZqcBqwtAwFuBsBwutj//vjPv/73z//++///ABiAAjiABFiABniACJiACriADNiADviAEBiBEjiBFFiBFniBGJiBGriBHNiBHviBIBiCIsgRAQEAOw==" alt=""></span></p><p><span class="inlinemediaobject"></span></p></div></div>奥莱利媒体</div><hr></div></div></div></div>
<div id="OEBPS/examples_page.html"><div>
<div class="preface" title="关于补充文件的注意事项"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/examples_page.html.id3071145"></a>关于补充文件的注意事项</h1><h1 class="title"><a></a>A Note Regarding Supplemental Files</h1></div></div></div><p>本书的补充文件和示例可以在<a class="ulink" href="http://examples.oreilly.com/9780596006105/">http://examples.oreilly.com/9780596006105/</a>找到。请使用标准桌面网络浏览器访问这些文件，因为可能无法从所有电子阅读器设备访问这些文件。</p><p>Supplemental files and examples for this book can be found at <a class="ulink" href="http://examples.oreilly.com/9780596006105/">http://examples.oreilly.com/9780596006105/</a>. Please use a standard desktop web browser to access these files, as they may not be accessible from all ereader devices.</p><p>书中引用的所有代码文件或示例都可以在线获取。对于附带光盘的实体书，我们尽可能发布所有 CD/DVD 内容。请注意，虽然我们通过免费下载提供尽可能多的媒体内容，但我们有时会受到许可限制。如有任何问题或疑虑，请发送至<span class="email"><a class="email" href="#OEBPS/mailto:booktech@oreilly.com">booktech@oreilly.com</a></span>。</p><p>All code files or examples referenced in the book will be available online. For physical books that ship with an accompanying disc, whenever possible, we’ve posted all CD/DVD content. Note that while we provide as much of the media content as we are able via free download, we are sometimes limited by licensing restrictions. Please direct any questions or concerns to <span class="email"><a class="email" href="#OEBPS/mailto:booktech@oreilly.com">booktech@oreilly.com</a></span>.</p></div></div></div>
<div id="OEBPS/pr02.html"><div>
<div class="preface" title="前言"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr02.html.make3-PREFACE-2"></a>前言</h1><h1 class="title"><a></a>Foreword</h1></div></div></div><p>make<em class="command">实用</em>程序是一个诱人的仆人，总是在那里并且总是乐于助人。就像许多小说和电影中不可或缺的助手一样，<em class="command">make</em>一开始只是一个不受重视的恳求者，你可以给他做一些零工，然后逐渐接管整个企业。</p><p>The <em class="command">make</em> utility is an enticing
    servant, always there and always accommodating. Like the indispensable
    sidekicks found in many novels and movies, <em class="command">make</em> starts out as the underappreciated
    supplicant to whom you throw a few odd jobs, and then gradually takes over
    the entire enterprise.</p><p>当我的导师、O'Reilly 经典著作《<span class="emphasis"><em>Managing Projects with make</em></span>》的作者 Steve Talbott 注意到我的痴迷并要求我编写第二版时，我已经到了将<em class="command">make</em>置于我接触的每个项目中心的最后阶段。事实证明，这对我来说是一次重要的成长经历（也是一次相当狂野的旅程），也是我进入 O'Reilly 奇妙世界的机会，但我们并没有真正考虑过结果会在市场上停留多久。一版十三年？<span class="emphasis"><em></em></span></p><p>I had reached the terminal stage of putting <em class="command">make</em> at the center of every project I touched
    when Steve Talbott, my supervisor and the author of the original O'Reilly
    classic <span class="emphasis"><em>Managing Projects with make</em></span>, noticed my
    obsession and asked me to write the second edition. It proved to be a key
    growth experience for me (as well as a pretty wild ride) and my entry into
    the wonderful world of O'Reilly, but we didn't really think about how long
    the result would stay on the market. Thirteen years for one
    edition?</p><p>当我还是一名专业技术作家时，我深深地沉浸在很久以前的回忆中，我将沉迷于一份项目符号列表来总结自第二版《<span class="emphasis"><em>使用 make 管理项目》</em></span>问世以来<em class="command">make的演变：</em><span class="emphasis"><em></em></span></p><p>Enthralled in the memories of those days long ago when I was a
    professional technical writer, I'll indulge myself with a bulleted list to
    summarize the evolution of <em class="command">make</em> since
    the second edition of <span class="emphasis"><em>Managing Projects with make</em></span> hit
    the stands:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>当本书第二版出版时，GNU 版本的<em class="command">make已经成为最认真的程序员的选择，它超越了整个行业，并成为事实上的标准。</em></p></li><li class="listitem"><p>The GNU version of <em class="command">make</em>,
        already the choice of most serious coders when the second edition of
        the book came out, overran the industry and turned into the de facto
        standard.</p></li><li class="listitem"><p>GNU/Linux 的兴起使得 GNU 编译器工具链变得更加普遍，其中包括 GNU 版本的<em class="command">make</em>。仅举一个例子，Linux 内核本身严重依赖 GNU <em class="command">make</em>提供的扩展，如本书<a class="link" href="#OEBPS/ch11.html" title="第 11 章 Makefile 示例">第 11 章</a>所述。</p></li><li class="listitem"><p>The rise of GNU/Linux made the GNU compiler tool chain even more
        common, and that includes the GNU version of <em class="command">make</em>. As just one example, the Linux kernel
        itself relies heavily on extensions provided by GNU <em class="command">make</em>, as documented in <a class="link" href="#OEBPS/ch11.html" title="Chapter&nbsp;11.&nbsp;Example Makefiles">Chapter 11</a> of this book.</p></li><li class="listitem"><p><em class="command">采用 BSD (Darwin) 的变体作为 Mac OS X 的核心延续了 GNU 工具链和 GNU make</em>占据主导地位的趋势。</p></li><li class="listitem"><p>The adoption of a variant of BSD (Darwin) as the core of Mac OS
        X continues the trend toward the dominance of the GNU tool chain and
        GNU <em class="command">make</em>.</p></li><li class="listitem"><p>人们发现了越来越多的技巧来以健壮、无错误、可移植和灵活的方式使用<em class="command">make</em> 。大型项目中常见问题的标准解决方案已经在编程社区中发展起来。现在是时候将这些解决方案从民间传说领域转移到记录实践领域了，正如本书所做的那样。</p></li><li class="listitem"><p>More and more tricks are being discovered for using <em class="command">make</em> in a robust, error-free, portable, and
        flexible way. Standard solutions to common problems on large projects
        have grown up in the programming community. It's time to move many of
        these solutions from the realm of folklore to the realm of documented
        practices, as this book does.</p></li><li class="listitem"><p>特别是，需要新的实践来使<em class="command">make</em>适应 C++ 和 Java© 语言，而在发明<em class="command">make</em>时这些语言还不存在。为了说明时间的流沙，最初的
        <em class="command">版本</em>包含支持两种 FORTRAN 变体的特殊功能（其中的痕迹仍然存在！）并且与 SCCS 的集成相当无效。）</p></li><li class="listitem"><p>In particular, new practices are required to adapt <em class="command">make</em> to the C++ and Java© languages, which
        did not exist when <em class="command">make</em> was
        invented. To illustrate the shifting sands of time, the original
        <em class="command">make</em> contained special features to
        support two variants of FORTRAN—of which vestiges remain!—and rather
        ineffective integration with SCCS.)</p></li><li class="listitem"><p>尽管困难重重，<em class="command">make</em>仍然是几乎所有计算机开发项目的关键工具。13 年前，make 的许多（且富有洞察力的）批评者都不会预见到这<em class="command">一点</em>。这些年，替代者不断涌现，犹如龙牙已种下。每个新工具都应该绕过
        <em class="command">make</em>设计的限制，而且大多数确实巧妙且令人钦佩。然而<em class="command">制作</em>的简单性使其始终保持至高无上的地位。</p></li><li class="listitem"><p>Against all odds, <em class="command">make</em> has
        remained a critical tool for nearly all computer development projects.
        None of <em class="command">make</em>'s many (and
        insightful) critics would have predicted this 13 years ago. Over these
        years, replacements sprang up repeatedly, as if dragon's teeth had
        been sown. Each new tool was supposed to bypass the limitations in
        <em class="command">make</em>'s design, and most were indeed
        ingenious and admirable. Yet the simplicity of <em class="command">make</em> has kept it supreme.</p></li></ul></div><p>当我看到这些趋势时，大约十年来，我一直在想编写新版本的《<span class="emphasis"><em>使用 make 管理项目》</em></span>。但我感觉到需要比我拥有更广泛专业经验的人。最后，罗伯特·梅克伦堡出现了，他的专业知识让 O'Reilly 的我们所有人惊叹不已。我很高兴让他接手这本书并退休，担任 kibitzer 的角色，这让我在这本书的版权页上得到了提及。 （顺便说一句，我们将本书置于 GNU 自由文档许可证之下，以反映 GNU <em class="command">make</em>的 GPL 状态。）</p><p>As I watched these trends, it had been in the back of my mind for
    about a decade to write a new edition of <span class="emphasis"><em>Managing Projects with
    make</em></span>. But I sensed that someone with a broader range of
    professional experience than mine was required. Finally, Robert
    Mecklenburg came along and wowed us all at O'Reilly with his expertise. I
    was happy to let him take over the book and to retire to the role of
    kibitzer, which earns me a mention on the copyright page of this book.
    (Incidentally, we put the book under the GNU Free Documentation License to
    mirror the GPL status of GNU <em class="command">make</em>.)</p><p>罗伯特过于谦虚，不愿吹捧他的博士学位，但他在这一努力中所运用的思考的深度和精确性在本书中清晰可见。也许对这本书来说更重要的是他对实用性的关注。他致力于让<em class="command">make</em>为您服务，这种承诺的范围从对效率的警惕到巧妙地避免在<span class="emphasis"><em>makefile</em></span>的自记录中出现印刷错误。</p><p>Robert is too modest to tout his Ph.D., but the depth and precision
    of thinking he must have applied to that endeavor comes through clearly in
    this book. Perhaps more important to the book is his focus on
    practicality. He's committed to making <em class="command">make</em> work for you, and this commitment ranges
    from being alert about efficiency to being clever about making even
    typographical errors in <span class="emphasis"><em>makefile</em></span>s
    self-documenting.</p><p>这是一个伟大的时刻：奥莱利最早、最经久不衰的书籍之一的新版本诞生了。坐下来阅读一下，几乎每个项目背景中的一个不起眼的小工具如何体现出您从未想象过的力量。不要满足于嘎吱作响且令人不满意的<span class="emphasis"><em>makefile</em></span>，立即扩展您的潜力。</p><p>This is a great moment: the creation of a new edition of one of
    O'Reilly's earliest and most enduring books. Sit back and read about how
    an unassuming little tool at the background of almost every project
    embodies powers you never imagined. Don't settle for creaky and
    unsatisfying <span class="emphasis"><em>makefile</em></span>s—expand your potential
    today.</p><p><span class="emphasis"><em>—Andy Oram</em></span>  <span class="emphasis"><em>编辑，O'Reilly Media </em></span>  <span class="emphasis"><em>2004 年 8 月 19 日</em></span></p><p><span class="emphasis"><em>—Andy Oram </em></span>  <span class="emphasis"><em>Editor, O'Reilly
    Media</em></span>  <span class="emphasis"><em>August 19, 2004</em></span></p></div></div></div>
<div id="OEBPS/pr03.html"><div>
<div class="preface" title="奉献精神"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr03.html.make3-PREFACE-3"></a>奉献精神</h1><h1 class="title"><a></a>Dedication</h1></div></div></div><p><span class="emphasis"><em>献给拉尔夫和巴夫</em></span></p><p><span class="emphasis"><em>For Ralph and Buff</em></span></p></div></div></div>
<div id="OEBPS/pr04.html"><div>
<div class="preface" title="前言"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04.html.make3-PREFACE-4"></a>前言</h1><h1 class="title"><a></a>Preface</h1></div></div></div><div class="sect1" title="通向第三版之路"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04.html.make3-PREFACE-4-SECT-1"></a>通向第三版之路</h1><h1 class="title"><a></a>The Road to the Third Edition</h1></div></div></div><p>我第一次接触<em class="command">make</em>是在 1979 年，当时还是伯克利大学的一名本科生。我很高兴能使用“最新”设备：一台具有 128 KB RAM 的 DEC PDP 11/70、一台 ADM 3a“玻璃终端”、伯克利 Unix、以及其他 20 个同时用户！有一次，当作业到期时，我记得计算登录需要多长时间——从输入用户名到收到提示，需要五分钟。</p><p>My first exposure to <em class="command">make</em> was
      as an undergraduate at Berkeley in 1979. I was thrilled to be working
      with the "latest" equipment: a DEC PDP 11/70 with 128 kilobytes of RAM,
      an ADM 3a "glass tty," Berkeley Unix, and 20 other simultaneous users!
      Once, when an assignment was due, I remember timing how long it took to
      log in—five minutes from typing my username until I got a prompt.</p><p>离开学校后，我再次开始从事 Unix 工作是在 1984 年。这次是在 NASA 艾姆斯研究中心担任程序员。我们购买了第一批基于微机的 Unix 系统，即 68000（不是 68010 或 20），它有 1 MB 的 RAM 和 Unix 版本 7，同时只有 6 个用户。我的上一个项目是一个用 C 语言编写的交互式卫星数据分析系统，使用<em class="command">yacc</em> / <em class="command">lex</em>
      命令语言，当然还有<em class="command">make</em>。</p><p>After leaving school, it was 1984 before I got to work on Unix
      again. This time it was as a programmer at NASA's Ames Research Center.
      We purchased one of the first microcomputer-based Unix systems, a 68000
      (not a 68010 or 20) that had a megabyte of RAM and Unix Version 7—with
      only six simultaneous users. My last project there was an interactive
      satellite data analysis system written in C with a <em class="command">yacc</em>/<em class="command">lex</em>
      command language, and, of course, <em class="command">make</em>.</p><p>到 1988 年，我回到了学校，并致力于一个构建基于样条线的几何建模器的项目。该系统由大约 120,000 行 C 代码组成，分布在大约 20 个可执行文件中。该系统是使用<em class="filename">makefile</em>模板构建的，这些模板通过名为<em class="command">genmakefile 的</em>手动工具（本质上与<em class="command">imake</em>类似）扩展为普通的<em class="filename">makefile</em>。该工具执行简单的文件包含、条件编译和一些自定义逻辑来管理源代码和二进制树。当时人们普遍认为
      <em class="command">make</em>需要这样的包装器才能成为完整的构建工具。几年前，我发现了
      <acronym class="acronym">GNU</acronym>项目和<acronym class="acronym">GNU </acronym><em class="command">make</em>，并意识到包装程序可能是不必要的。我在没有模板或生成器的情况下重建了构建系统。令我懊恼的是，我最终在接下来的四年里维护了构建系统（直到今天我仍然愚蠢地重复这种模式）。该构建系统可移植到五种版本的 Unix，并包括单独的源代码和二叉树、自动夜间构建以及支持开发人员通过构建系统填充缺失的对象进行部分签出。<em class="command"></em><em class="command"></em><em class="command"></em><acronym class="acronym"></acronym><acronym class="acronym"></acronym> <em class="command"></em></p><p>By 1988, I had gone back to school and was working on a project to
      build a spline-based geometric modeler. The system consisted of about
      120,000 lines of C, spread across 20 or so executables. The system was
      built using <em class="filename">makefile</em> templates that
      were expanded into normal <em class="filename">makefile</em>s
      by a hand-rolled tool call <em class="command">genmakefile</em> (similar in spirit to <em class="command">imake</em>). The tool performed simple file
      inclusion, conditional compilation, and some custom logic to manage
      source and binary trees. It was a common belief in those days that
      <em class="command">make</em> required such a wrapper to be a
      complete build tool. Several years earlier, I had discovered the
      <acronym class="acronym">GNU</acronym> project and <acronym class="acronym">GNU</acronym> <em class="command">make</em> and realized that the wrapper program was
      probably unnecessary. I rebuilt the build system without the templates
      or a generator. To my chagrin, I wound up maintaining the build system
      for the next four years (a pattern I foolishly repeat to this day). The
      build system was portable to five flavors of Unix and included separate
      source and binary trees, automated nightly builds, and support for
      partial checkouts by developers with the build system filling in the
      missing objects.</p><p><em class="command">我对make 的</em>下一次有趣的接触是在 1996 年，当时我正在开发一个商业 CAD 系统。我的工作是使用 Microsoft C++ 编译器将 200 万行 C++（以及 400,000 行 Lisp）从 Unix 移植到 Windows NT。就在那时我发现了 Cygwin 项目。作为移植的一个重要副产品，我重新设计了构建系统以支持 NT。该构建系统还支持单独的源代码树和二叉树、多种 Unix 风格、多种图形支持、自动夜间构建和测试以及使用参考构建进行部分开发人员检查。</p><p>My next interesting encounter with <em class="command">make</em> came in 1996, working on a commercial CAD
      system. It was my job to port 2 million lines of C++ (and 400,000 lines
      of Lisp) from Unix to Windows NT, using the Microsoft C++ compiler.
      That's when I discovered the Cygwin project. As an important byproduct
      of the port, I reworked the build system to support NT. This build
      system also supported separate source and binary trees, many flavors of
      Unix, several varieties of graphics support, automated nightly builds
      and tests, and partial developer checkouts with reference builds.</p><p>2000 年，我开始使用 Java 编写实验室信息管理系统。这是我多年来工作过的第一个真正不同的开发环境。大多数程序员都有 Windows 背景，许多人似乎都知道 Java 作为他们的第一门编程语言。构建环境几乎完全由商业 Java 集成开发环境 (IDE) 生成的项目文件组成。尽管项目文件已签入，但它很少“开箱即用”，并且程序员经常坐在彼此的隔间中解决构建问题。</p><p>In 2000, I began working in Java writing laboratory information
      management systems. This was one of the first really different
      development environments I'd worked in for many years. Most of the
      programmers came from a Windows background and many seemed to know Java
      as their first programming language. The build environment consisted
      almost entirely of the project file generated by a commercial Java
      Integrated Development Environment (IDE). Although the project file was
      checked in, it rarely worked "out of the box" and programmers often sat
      in each other's cubes working through build problems.</p><p>当然，我开始使用<em class="command">make</em>编写构建系统，但是发生了奇怪的事情。许多开发人员不愿意使用任何命令行工具。此外，许多人并没有牢牢掌握环境变量、命令行选项等概念，也没有理解用于构建程序的工具。 IDE 隐藏了所有这些问题。为了解决这些问题，我正在编写的构建系统变得更加复杂。我开始添加更好的错误消息、前置条件检查、开发人员机器配置的管理以及对 IDE 的支持。</p><p>Of course, I began to write a build system using <em class="command">make</em>, but an odd thing happened. Many of the
      developers were reluctant to use any command-line tool. Further, many
      did not have a firm grasp of such concepts as environment variables,
      command-line options, or an understanding of the tools used to build
      programs. The IDE hid all of these issues. To address these issues, the
      build system I was writing became more complex. I began to add better
      error messages, precondition checking, management of the developer's
      machine configuration, and support for IDEs.</p><p>一路上，我读了几十遍<acronym class="acronym">GNU </acronym> <em class="command">make</em>手册。当我寻找更多材料时，我发现了这本书的第二版。它充满了有价值的材料，但遗憾的是缺乏
      <acronym class="acronym">GNU </acronym> <em class="command">make</em>的细节。考虑到它的年龄，这并不奇怪。该卷经受住了时间的考验，但到 2003 年需要更新。第三版主要关注<acronym class="acronym">GNU </acronym> <em class="command">make</em>。正如 Paul Smith（<acronym class="acronym">GNU </acronym> <em class="command">make</em>维护者）所写：“不要为编写可移植的 ` <span class="emphasis"><em>makefile</em></span> ' 而烦恼，而是使用可移植的
      <span class="emphasis"><em>make</em></span>！”</p><p>Along the way, I'd read the <acronym class="acronym">GNU</acronym> <em class="command">make</em> manual several dozen times. As I looked
      for more material, I found the second edition of this book. It was
      filled with valuable material, but was sadly lacking in details of
      <acronym class="acronym">GNU</acronym> <em class="command">make</em>. That
      wasn't surprising, considering its age. The volume had stood the test of
      time, but by 2003 needed updating. The third edition focuses primarily
      on <acronym class="acronym">GNU</acronym> <em class="command">make</em>. As
      Paul Smith (the <acronym class="acronym">GNU</acronym> <em class="command">make</em> maintainer) writes: "Don't hassle with
      writing portable `<span class="emphasis"><em>makefile</em></span>s', use a portable
      <span class="emphasis"><em>make</em></span> instead!"</p></div></div></div></div>
<div id="OEBPS/pr04s02.html"><div>
<div class="sect1" title="此版本的新增内容"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04s02.html.make3-PREFACE-4-SECT-2"></a>此版本的新增内容</h1><h1 class="title"><a></a>What's New in This Edition</h1></div></div></div><p>本书中的几乎所有材料都是新的。我将材料分为三个部分。</p><p>Almost all the material in this book is new. I've divided the
      material into three parts.</p><p><a class="link" href="#OEBPS/pt01.html" title="第一部分 基本概念">第一部分</a>，<span class="emphasis"><em>基本概念</em></span><code class="literal">make</code>，对 GNU特性以及如何使用它们进行了相当详细的检查。</p><p><a class="link" href="#OEBPS/pt01.html" title="Part&nbsp;I.&nbsp;Basic Concepts">Part I</a>, <span class="emphasis"><em>Basic
      Concepts</em></span>, provides a moderately detailed examination of the
      GNU <code class="literal">make</code> features and how to use
      them.</p><p><a class="link" href="#OEBPS/ch01.html" title="第 1 章 如何编写简单的 Makefile">第 1 章</a>，通过一个简单但完整的示例<em class="command">进行</em>简要介绍。它解释了<em class="command">make</em>的基本概念，例如目标和先决条件，并涵盖了<em class="filename">makefile</em>的语法。这应该足以让您开始创建第一个<em class="filename">makefile</em>。</p><p><a class="link" href="#OEBPS/ch01.html" title="Chapter&nbsp;1.&nbsp;How to Write a Simple Makefile">Chapter 1</a>, is a brief
      introduction to <em class="command">make</em> with a simple,
      but complete example. It explains the basic concepts of <em class="command">make</em> such as targets and prerequisites, and
      covers the syntax of <em class="filename">makefile</em>s.
      This should be sufficient to get you going with your first <em class="filename">makefile</em>s.</p><p><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第2章</a>，讨论规则的结构和语法。详细介绍了显式规则和模式规则以及老式后缀规则。这里还讨论了特殊目标和简单依赖项生成。</p><p><a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>, discusses the
      structure and syntax of rules. Explicit rules and pattern rules are
      covered in great detail along with old-fashioned suffix rules. Special
      targets and simple dependency generation are also discussed here.</p><p><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>介绍了简单变量和递归变量。本章还讨论了如何解析<em class="filename">makefile 、何时扩展变量以及条件</em><em class="filename">makefile</em>处理的指令。</p><p><a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>, covers simple and
      recursive variables. This chapter also discusses how <em class="filename">makefile</em>s are parsed, when variables are
      expanded, and the directives for conditional <em class="filename">makefile</em> processing.</p><p><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章考察了</a><acronym class="acronym">GNU </acronym>
      <em class="command">make</em>支持的各种内置函数。这里介绍了用户定义的函数，并提供了大量示例，从简单的到高级概念的说明。</p><p><a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>, examines the wide
      variety of built-in functions supported by <acronym class="acronym">GNU</acronym>
      <em class="command">make</em>. User-defined functions are
      introduced here, with numerous examples ranging from the trivial to
      illustrations of advanced concepts.</p><p><a class="link" href="#OEBPS/ch05.html" title="第 5 章命令">第 5 章</a>解释了命令脚本的详细信息，包括如何解析和评估它们。在这里我们还讨论命令修饰符、检查命令退出状态和命令环境。我们探讨命令行限制的问题以及解决这些问题的一些方法。至此，您将了解
      本书中讨论的所有<acronym class="acronym">GNU </acronym> <em class="command">make功能。</em></p><p><a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">Chapter 5</a>, explains the details
      of command scripts, covering how they are parsed and evaluated. Here we
      also discuss command modifiers, checking command exit status, and the
      command environment. We explore the problems of command-line limits and
      some ways to work around these problems. At this point, you will know
      all the <acronym class="acronym">GNU</acronym> <em class="command">make</em>
      features discussed in this book.</p><p><a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题">第二部分</a>，<span class="emphasis"><em>高级和专业主题</em></span>，涵盖更大的主题，例如
      <code class="literal">make</code>在大型项目上的使用、可移植性和调试。</p><p><a class="link" href="#OEBPS/pt02.html" title="Part&nbsp;II.&nbsp;Advanced and Specialized Topics">Part II</a>, <span class="emphasis"><em>Advanced
      and Specialized Topics</em></span>, covers larger topics, such as using
      <code class="literal">make</code> on large projects, portability,
      and debugging.</p><p><a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章讨论了在</a><em class="command">make</em>中构建大型项目时遇到的许多问题。第一个主题是<em class="command">make</em>递归调用的使用，以及如何使用单个非递归<em class="filename">makefile实现这些</em><em class="filename">makefile</em>。此外，还讨论了大型系统的其他问题，例如文件系统布局、组件管理以及自动化构建和测试。<em class="filename"></em></p><p><a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>, discusses many
      issues encountered when building large projects in <em class="command">make</em>. The first topic is the use of recursive
      invocations of <em class="command">make</em>, as well as how
      to implement these <em class="filename">makefile</em>s with a
      single, nonrecursive <em class="filename">makefile</em>. In
      addition, other issues of large systems are discussed, such as
      filesystem layout, component management, and automated building and
      testing.</p><p><a class="link" href="#OEBPS/ch07.html" title="第 7 章可移植 Makefile">第 7 章，讨论</a><em class="filename">makefile</em>的可移植性问题，主要是在不同风格的 Unix 和 Windows 之间。详细讨论了 Cygwin Unix 仿真环境，以及由不可移植文件系统功能和工具引起的问题。</p><p><a class="link" href="#OEBPS/ch07.html" title="Chapter&nbsp;7.&nbsp;Portable Makefiles">Chapter 7</a>, discusses issues
      with portability of <em class="filename">makefile</em>s,
      primarily between various flavors of Unix and Windows. The Cygwin Unix
      emulation environment is discussed in some detail, along with issues
      arising from nonportable filesystem features and tools.</p><p><a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++">第 8 章</a>提供了如何分离源代码树和二叉树以及如何创建只读源代码树的具体示例。重新审视依赖性分析，重点是特定于语言的解决方案。本章和下一章与<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>中提出的许多问题密切相关。</p><p><a class="link" href="#OEBPS/ch08.html" title="Chapter&nbsp;8.&nbsp;C and C++">Chapter 8</a>, provides specific
      examples of how to separate source and binary trees and how to create
      read-only source trees. Dependency analysis is revisited, with an
      emphasis on language-specific solutions. This chapter and the next tie
      in closely with many issues raised in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>.</p><p><a class="link" href="#OEBPS/ch09.html" title="第 9 章 Java">第9章</a>，解释如何将<em class="command">make</em>应用于基于Java的开发环境。介绍了管理<code class="literal">CLASSPATH</code>变量、编译大量文件、创建 jar 和构建 Enterprise JavaBeans (EJB) 的技术。</p><p><a class="link" href="#OEBPS/ch09.html" title="Chapter&nbsp;9.&nbsp;Java">Chapter 9</a>, explains how to
      apply <em class="command">make</em> to Java-based development
      environments. Techniques for managing the <code class="literal">CLASSPATH</code> variable, compiling large numbers of
      files, creating jars, and constructing Enterprise JavaBeans (EJBs) are
      introduced.</p><p><a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能">第 10 章</a>首先回顾几个<em class="command">make</em>操作的性能特征，为如何编写高效的<em class="filename">makefile</em>提供上下文。讨论了识别和减少瓶颈的技术。 GNU
       <acronym class="acronym">make</acronym> 并行作业功能有一些详细的描述<em class="command">。</em></p><p><a class="link" href="#OEBPS/ch10.html" title="Chapter&nbsp;10.&nbsp;Improving the Performance of make">Chapter 10</a>, begins by
      reviewing the performance characteristics of several <em class="command">make</em> operations to provide context for how to
      write efficient <em class="filename">makefile</em>s.
      Techniques for identifying and reducing bottlenecks are discussed. The
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> parallel
      jobs feature is described in some detail.</p><p><a class="link" href="#OEBPS/ch11.html" title="第 11 章 Makefile 示例">第 11 章，提供了两个真实</a><em class="filename">makefile</em>的复杂示例。第一个是用于创建本书的<em class="filename">makefile</em> 。它很有趣，部分原因是相当极端的自动化程度，部分原因是它将<em class="command">make</em>应用于非传统领域。另一个示例包含 Linux 2.6 kbuild 系统的摘录。</p><p><a class="link" href="#OEBPS/ch11.html" title="Chapter&nbsp;11.&nbsp;Example Makefiles">Chapter 11</a>, provides two
      complex examples of real <em class="filename">makefile</em>s.
      The first is the <em class="filename">makefile</em> used to
      create this book. It is interesting, partly due to a fairly extreme
      degree of automation and partly because it applies <em class="command">make</em> to a nontraditional domain. The other
      example consists of excerpts from the Linux 2.6 kbuild system.</p><p><a class="link" href="#OEBPS/ch12.html" title="第 12 章调试 Makefile">第 12 章</a>，深入研究修复损坏的<em class="filename">makefile</em>的黑魔法。我们介绍一些技术来发现<em class="command">make</em>在幕后所做的事情以及如何减轻开发的痛苦。</p><p><a class="link" href="#OEBPS/ch12.html" title="Chapter&nbsp;12.&nbsp;Debugging Makefiles">Chapter 12</a>, delves into the
      black art of fixing broken <em class="filename">makefile</em>s. We introduce techniques for
      discovering what <em class="command">make</em> is doing under
      the covers and how to ease development pains.</p><p><a class="link" href="#OEBPS/pt03.html" title="第三部分。附录">第三部分</a>，
      <span class="emphasis"><em>附录</em></span>，包括补充材料。</p><p><a class="link" href="#OEBPS/pt03.html" title="Part&nbsp;III.&nbsp;Appendixes">Part III</a>,
      <span class="emphasis"><em>Appendixes</em></span>, includes supplemental material.</p><p><a class="link" href="#OEBPS/apa.html" title="附录 A. 运行 make">附录 A提供了</a><acronym class="acronym">GNU </acronym> <em class="command">make</em>命令行选项的参考指南。</p><p><a class="link" href="#OEBPS/apa.html" title="Appendix&nbsp;A.&nbsp;Running make">Appendix A</a>, provides a
      reference guide to <acronym class="acronym">GNU</acronym> <em class="command">make</em>'s command-line options.</p><p><a class="link" href="#OEBPS/apb.html" title="附录 B. 外部限制">附录 B探讨了</a><acronym class="acronym">GNU </acronym> <em class="command">make</em>的两种不太可能的功能的局限性：管理数据结构和执行算术。</p><p><a class="link" href="#OEBPS/apb.html" title="Appendix&nbsp;B.&nbsp;The Outer Limits">Appendix B</a>, explores the limits
      of <acronym class="acronym">GNU</acronym> <em class="command">make</em> with
      two unlikely capabilities: managing data structures and performing
      arithmetic.</p><p><a class="link" href="#OEBPS/apc.html" title="附录 C. GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)">附录 C</a>包含 GNU 自由文档许可证，本书的文本根据该许可证分发。</p><p><a class="link" href="#OEBPS/apc.html" title="Appendix&nbsp;C.&nbsp;GNU Free Documentation License—GNU Project—Free Software Foundation (FSF)">Appendix C</a>, contains the GNU
      Free Documentation License, under which the text of the book is
      distributed.</p></div></div></div>
<div id="OEBPS/pr04s03.html"><div>
<div class="sect1" title="本书中使用的约定"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04s03.html.make3-PREFACE-4-SECT-3"></a>本书中使用的约定</h1><h1 class="title"><a></a>Conventions Used in This Book</h1></div></div></div><p>本书使用以下印刷约定：</p><p>The following typographical conventions are used in this
      book:</p><div class="variablelist"><dl><dt><span class="term">斜体</span></dt><dt><span class="term">Italic</span></dt><dd><p>表示新术语、URL、电子邮件地址、文件名、文件扩展名、路径名和目录</p></dd><dd><p>Indicates new terms, URLs, email addresses, filenames, file
            extensions, pathnames, and directories</p></dd><dt><span class="term"><code class="literal">Constant width</code></span></dt><dt><span class="term"><code class="literal">Constant width</code></span></dt><dd><p>表示源代码命令、命令行选项、文件内容或命令的输出</p></dd><dd><p>Indicates source code commands, command-line options, the
            contents of files, or the output from commands</p></dd><dt><span class="term"><strong class="userinput"><code>Constant width
          bold</code></strong></span></dt><dt><span class="term"><strong class="userinput"><code>Constant width
          bold</code></strong></span></dt><dd><p>显示应由用户逐字键入的命令或其他文本</p></dd><dd><p>Shows commands or other text that should be typed literally
            by the user</p></dd><dt><span class="term"><em class="replaceable"><code>Constant width italic</code></em></span></dt><dt><span class="term"><em class="replaceable"><code>Constant width italic</code></em></span></dt><dd><p>显示应替换为用户提供的值的文本</p></dd><dd><p>Shows text that should be replaced with user-supplied
            values</p></dd></dl></div></div></div></div>
<div id="OEBPS/pr04s04.html"><div>
<div class="sect1" title="使用代码示例"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04s04.html.make3-PREFACE-4-SECT-4"></a>使用代码示例</h1><h1 class="title"><a></a>Using Code Examples</h1></div></div></div><p>本书旨在帮助您完成工作。一般来说，您可以在您的程序和文档中使用本书中的代码。除非您要复制大部分代码，否则您无需联系 O'Reilly 以获得许可。例如，编写使用本书中的几段代码的程序不需要许可。销售或分发 O'Reilly 书籍中示例的 CD-ROM
      <span class="emphasis"><em>确实</em></span>需要许可。通过引用本书和示例代码来回答问题不需要许可。将本书中的大量示例代码合并到您的产品文档中<span class="emphasis"><em>确实</em></span>需要许可。</p><p>This book is here to help you get your job done. In general, you
      may use the code in this book in your programs and documentation. You do
      not need to contact O'Reilly for permission unless you're reproducing a
      significant portion of the code. For example, writing a program that
      uses several chunks of code from this book does not require permission.
      Selling or distributing a CD-ROM of examples from O'Reilly books
      <span class="emphasis"><em>does</em></span> require permission. Answering a question by
      citing this book and quoting example code does not require permission.
      Incorporating a significant amount of example code from this book into
      your product's documentation <span class="emphasis"><em>does</em></span> require
      permission.</p><p>奥莱利赞赏但不要求注明出处。归属通常包括标题、作者、出版商和 ISBN。例如：“<span class="emphasis"><em>使用 GNU Make 管理项目</em></span>，第三版，作者：Robert Mecklenburg。版权所有 2005 O'Reilly Media, Inc.，0-596-00610-1。”</p><p>O'Reilly appreciates, but does not require, attribution. An
      attribution usually includes the title, author, publisher, and ISBN. For
      example: "<span class="emphasis"><em>Managing Projects with GNU Make</em></span>, Third
      Edition, by Robert Mecklenburg. Copyright 2005 O'Reilly Media, Inc.,
      0-596-00610-1."</p><p>如果您认为您对代码示例的使用不符合合理使用或上述许可的范围，请随时通过
      <span class="email"><a class="email" href="#OEBPS/mailto:permissions@oreilly.com">Permissions@oreilly.com</a></span>联系 O'Reilly 。</p><p>If you feel your use of code examples falls outside fair use or
      the permission given above, feel free to contact O'Reilly at
      <span class="email"><a class="email" href="#OEBPS/mailto:permissions@oreilly.com">permissions@oreilly.com</a></span>.</p></div></div></div>
<div id="OEBPS/pr04s05.html"><div>
<div class="sect1" title="评论和问题"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04s05.html.make3-PREFACE-4-SECT-5"></a>评论和问题</h1><h1 class="title"><a></a>Comments and Questions</h1></div></div></div><p>请向出版商提出有关本书的意见和问题：</p><p>Please address comments and questions concerning this book to the
      publisher:</p><table border="0" summary="Simple list" class="simplelist"><tbody><tr><td>奥莱利媒体公司</td></tr><tr><td>格拉文斯坦公路北1005号</td></tr><tr><td>塞瓦斯托波尔, CA 95472</td></tr><tr><td>(800) 998-9938（美国或加拿大）</td></tr><tr><td>(707) 829-0515（国际或本地）</td></tr><tr><td>(707) 829-0104（传真）</td></tr></tbody></table><p>O'Reilly 维护了本书的网页，其中列出了勘误表、示例和任何附加信息。您可以通过以下地址访问此页面：</p><p>O'Reilly maintains a web page for this book, which lists errata,
      examples, and any additional information. You can access this page
      at:</p><table border="0" summary="Simple list" class="simplelist"><tbody><tr><td><a class="ulink" href="http://www.oreilly.com/catalog/make3">http://www.oreilly.com/catalog/make3</a></td></tr></tbody></table><p>要评论或询问有关本书的技术问题，请发送电子邮件至：</p><p>To comment or ask technical questions about this book, send email
      to:</p><table border="0" summary="Simple list" class="simplelist"><tbody><tr><td><span class="email"><a class="email" href="#OEBPS/mailto:bookquestions@oreilly.com">bookquestions@oreilly.com</a></span></td></tr></tbody></table><p>有关 O'Reilly 书籍、会议、资源中心和 O'Reilly 网络的更多信息，请访问 O'Reilly 的网站：</p><p>For more information about O'Reilly books, conferences, Resource
      Centers, and the O'Reilly Network, see O'Reilly's web site at:</p><table border="0" summary="Simple list" class="simplelist"><tbody><tr><td><a class="ulink" href="http://www.oreilly.com/">http://www.oreilly.com</a></td></tr></tbody></table></div></div></div>
<div id="OEBPS/pr04s06.html"><div>
<div class="sect1" title="致谢"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pr04s06.html.make3-PREFACE-4-SECT-6"></a>致谢</h1><h1 class="title"><a></a>Acknowledgments</h1></div></div></div><p>我要感谢理查德·斯托曼（Richard Stallman）提供的愿景以及相信它可以实现的信念。当然，如果没有 Paul Smith，
       <acronym class="acronym">GNU </acronym> <em class="command">make</em>就不会以现在的形式存在。谢谢。</p><p>I'd like to thank Richard Stallman for providing a vision and the
      belief that it can come true. Of course, without Paul Smith,
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> would not
      exist in its current form today. Thank you.</p><p>我要感谢我的编辑安迪·奥拉姆 (Andy Oram) 的不懈支持和热情。</p><p>I'd like to thank my editor, Andy Oram, for his unflagging support
      and enthusiasm.</p><p>Cimarron Software 值得我感谢，他们提供了一个鼓励我开始这个项目的环境。 Realm Systems 也值得感谢，他们提供了一个鼓励我完成该项目的环境。我要特别感谢道格·亚当森、凯茜·安德森和彼得·布克曼。</p><p>Cimarron Software deserves my thanks for providing an environment
      that encouraged me to begin this project. Realm Systems also deserves
      thanks for providing an environment that encouraged me to finish the
      project. In particular, I'd like to thank Doug Adamson, Cathy Anderson,
      and Peter Bookman.</p><p>感谢我的审稿人 Simon Gerraty、John Macdonald 和 Paul Smith，他们提供了许多富有洞察力的评论并纠正了许多令人尴尬的错误。</p><p>Thanks to my reviewers, Simon Gerraty, John Macdonald, and Paul
      Smith, who provided many insightful comments and corrected many
      embarrassing errors.</p><p>以下人员对这项工作做出的宝贵贡献值得感谢：Steve Bayer、Richard Bogart、Beth Cobb、Julie Daily、David Johnson、Andrew Morton、Richard Pimentel、Brian Stevens 和 Linus Torvalds。非常感谢在波涛汹涌的大海中提供安全避难所的阴谋集团：克里斯汀·德莱尼、托尼·迪·塞拉、约翰·梅杰和丹尼尔·雷丁。</p><p>The following people deserve thanks for valuable contributions to
      this work: Steve Bayer, Richard Bogart, Beth Cobb, Julie Daily, David
      Johnson, Andrew Morton, Richard Pimentel, Brian Stevens, and Linus
      Torvalds. Many thanks to the cabal that provided a safe haven in stormy
      seas: Christine Delaney, Tony Di Sera, John Major, and Daniel
      Reading.</p><p>最后，我深深地感谢和爱我的妻子玛吉·卡斯滕以及我们的孩子威廉和詹姆斯，感谢他们在过去十六个月里的支持、鼓励和爱。感谢您与我分享这个。</p><p>Finally, my profound gratitude and love goes to my wife, Maggie
      Kasten, and our children, William and James, for their support,
      encouragement, and love during the last sixteen months. Thank you for
      sharing this with me.</p></div></div></div>
<div id="OEBPS/pt01.html"><div>
<div class="part" title="第一部分 基本概念"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pt01.html.make3-PART-1"></a>第一部分 基本概念</h1><h1 class="title"><a></a>Part&nbsp;I.&nbsp;Basic Concepts</h1></div></div></div><div class="partintro" title="基本概念" id="OEBPS/pt01.html.id2951876"><div></div><p>在<a class="link" href="#OEBPS/pt01.html" title="第一部分 基本概念">第一部分中，我们重点介绍</a><em class="command">make</em>的功能、它们的用途以及如何正确使用它们。我们首先进行简短的介绍和概述，这应该足以让您开始编写第一个
      <em class="filename">makefile</em>。这些章节随后介绍了
      <em class="command">make</em>规则、变量、函数，最后是命令脚本。</p><p>In <a class="link" href="#OEBPS/pt01.html" title="Part&nbsp;I.&nbsp;Basic Concepts">Part I</a>, we focus on the
      features of <em class="command">make</em>, what they do, and
      how to use them properly. We begin with a brief introduction and
      overview that should be enough to get you started on your first
      <em class="filename">makefile</em>. The chapters then cover
      <em class="command">make</em> rules, variables, functions, and
      finally command scripts.</p><p>当您完成<a class="link" href="#OEBPS/pt01.html" title="第一部分 基本概念">第一部分时，您将拥有相当完整的</a><acronym class="acronym">GNU </acronym> <em class="command">make</em>工作知识
      ，并掌握许多高级用法。</p><p>When you are finished with <a class="link" href="#OEBPS/pt01.html" title="Part&nbsp;I.&nbsp;Basic Concepts">Part
      I</a>, you will have a fairly complete working knowledge of
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> and have
      many advanced usages well in hand.</p><p><a class="link" href="#OEBPS/ch01.html" title="第 1 章 如何编写简单的 Makefile">第 1 章</a>，如何编写简单的 Makefile</p><p><a class="link" href="#OEBPS/ch01.html" title="Chapter&nbsp;1.&nbsp;How to Write a Simple Makefile">Chapter 1</a>, How to Write a
      Simple Makefile</p><p><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第2章</a>，规则</p><p><a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>, Rules</p><p><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第3章</a>,变量和宏</p><p><a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>, Variables and
      Macros</p><p><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>，函数</p><p><a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>, Functions</p><p><a class="link" href="#OEBPS/ch05.html" title="第 5 章命令">第 5 章</a>，命令</p><p><a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">Chapter 5</a>, Commands</p></div></div></div></div>
<div id="OEBPS/ch01.html"><div>
<div class="chapter" title="第 1 章 如何编写简单的 Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01.html.make3-CHP-1"></a>第 1 章 如何编写简单的 Makefile</h1><h1 class="title"><a></a>Chapter&nbsp;1.&nbsp;How to Write a Simple Makefile</h1></div></div></div><p>编程机制通常遵循相当简单的例程：编辑源文件、将源代码编译成可执行形式并调试结果。尽管将源代码转换为可执行文件被认为是例行公事，但如果做得不正确，程序员可能会浪费大量时间来追踪问题。大多数开发人员都经历过修改函数并运行新代码却发现他们的更改没有修复错误的挫败感。后来他们发现，由于某些程序错误，例如未能重新编译源代码、重新链接可执行文件或重建 jar，他们从未执行修改过的函数。此外，随着程序复杂性的增加，随着程序的不同版本的开发（可能是针对其他平台或其他版本的支持库等），这些平凡的任务可能会变得越来越容易出错。</p><p>The mechanics of programming usually follow a fairly simple
      routine of editing source files, compiling the source into an executable
      form, and debugging the result. Although transforming the source into an
      executable is considered routine, if done incorrectly a programmer can
      waste immense amounts of time tracking down the problem. Most developers
      have experienced the frustration of modifying a function and running the
      new code only to find that their change did not fix the bug. Later they
      discover that they were never executing their modified function because
      of some procedural error such as failing to recompile the source, relink
      the executable, or rebuild a jar. Moreover, as the program's complexity
      grows these mundane tasks can become increasingly error-prone as
      different versions of the program are developed, perhaps for other
      platforms or other versions of support libraries, etc.</p><p><em class="command">make</em>程序的目的是
      <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-786" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-787" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-788" class="indexterm"></a>将源代码转换为可执行文件的日常工作实现自动化。<em class="command">make</em> over 脚本的优点在于，您可以指定要<em class="command">make</em>的程序元素之间的关系，并且它通过这些关系和时间戳准确地知道每次需要重做哪些步骤才能生成所需的程序。使用此信息，<em class="command">make</em>还可以优化构建过程，避免不必要的步骤。</p><p>The <em class="command">make</em> program is intended to
      <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>automate the mundane aspects of transforming source code
      into an executable. The advantages of <em class="command">make</em> over scripts is that you can specify the
      relationships between the elements of your program to <em class="command">make</em>, and it knows through these relationships
      and timestamps exactly what steps need to be redone to produce the
      desired program each time. Using this information, <em class="command">make</em> can also optimize the build process
      avoiding unnecessary steps.</p><p><acronym class="acronym">GNU </acronym> <em class="command">make （以及</em><em class="command">make</em>
      的其他变体）正是这样做的。<em class="command">make</em>定义了一种用于描述源代码、中间文件和可执行文件之间关系的语言。它还提供管理备用配置、实现可重用规范库以及使用用户定义的宏参数化流程的功能。简而言之，<em class="command">make</em>可以被认为是开发过程的中心，它提供了应用程序组件的路线图以及它们如何组合在一起。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
      (and other variants of <em class="command">make</em>) do
      precisely this. <em class="command">make</em> defines a
      language for describing the relationships between source code,
      intermediate files, and executables. It also provides features to manage
      alternate configurations, implement reusable libraries of
      specifications, and parameterize processes with user-defined macros. In
      short, <em class="command">make</em> can be considered the
      center of the development process by providing a roadmap of an
      application's components and how they fit together.</p><p><em class="command">制作</em>使用的说明书
      一般保存<a id="OEBPS/ch01.html.make3-CHP-1-ITERM-789" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-790" class="indexterm"></a><em class="filename">在名为makefile</em>的文件中。这是构建传统“Hello, World”程序的<em class="filename">makefile ：</em></p><p>The specification that <em class="command">make</em>
      uses is generally saved <a class="indexterm"></a> <a class="indexterm"></a>in a file named <em class="filename">makefile</em>. Here is a <em class="filename">makefile</em> to build the traditional "Hello,
      World" program:</p><a id="OEBPS/ch01.html.I_1_tt3"></a><pre class="programlisting">你好：你好.c
        gcc hello.c -o 你好</pre><pre class="programlisting">hello: hello.c
        gcc hello.c -o hello</pre><p>要构建程序，请输入以下命令执行<em class="command">make ：</em></p><p>To build the program execute <em class="command">make</em> by typing:</p><a id="OEBPS/ch01.html.I_1_tt4"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong></pre><p>在您最喜欢的 shell 的命令提示符处。这将导致
      <em class="command">make</em>程序读取<em class="filename">makefile</em>并构建它在那里找到的第一个目标：</p><p>at the command prompt of your favorite shell. This will cause the
      <em class="command">make</em> program to read the <em class="filename">makefile</em> and build the first target it finds
      there:</p><a id="OEBPS/ch01.html.I_1_tt5"></a><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
gcc hello.c -o 你好</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc hello.c -o hello</pre><p>如果目标包含为 ac<a id="OEBPS/ch01.html.make3-CHP-1-ITERM-791" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-792" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-793" class="indexterm"></a>命令行参数，该目标已更新。如果未给出命令行目标，则使用文件中的第一个目标，称为<em class="firstterm">默认目标</em>。</p><p>If a target is included as a c<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>ommand-line argument, that target is updated. If no
      command-line targets are given, then the first target in the file is
      used, called the <em class="firstterm">default goal</em>.</p><p><em class="filename">通常，大多数makefile 的</em>默认目标是构建程序。这通常涉及许多步骤。通常，程序的源代码是不完整的，必须使用<em class="command">flex</em>或<em class="command">bison</em>等实用程序生成源代码。接下来，源代码被编译成二进制目标文件（C/C++ 的
      <em class="filename">.o文件、Java 的</em><em class="filename">.class</em>文件等）。然后，对于 C/C++，目标文件由链接器（通常通过编译器<em class="command">gcc</em>调用）绑定在一起以形成可执行程序。</p><p>Typically the default goal in most <em class="filename">makefile</em>s is to build a program. This usually
      involves many steps. Often the source code for the program is incomplete
      and the source must be generated using utilities such as <em class="command">flex</em> or <em class="command">bison</em>. Next the source is compiled into binary
      object files (<em class="filename">.o</em> files for C/C++,
      <em class="filename">.class</em> files for Java, etc.). Then,
      for C/C++, the object files are bound together by a linker (usually
      invoked through the compiler, <em class="command">gcc</em>) to
      form an executable program.</p><p>修改任何源文件并重新调用<em class="command">make</em>将导致重复这些命令中的一些（但通常不是全部），以便将源代码更改正确地合并到可执行文件中。规范文件或<em class="filename">makefile</em>描述源程序文件、中间程序文件和可执行程序文件之间的关系，以便<em class="command">make</em>可以执行更新可执行程序所需的最少工作量。</p><p>Modifying any of the source files and reinvoking <em class="command">make</em> will cause some, but usually not all, of
      these commands to be repeated so the source code changes are properly
      incorporated into the executable. The specification file, or <em class="filename">makefile</em>, describes the relationship between
      the source, intermediate, and executable program files so that <em class="command">make</em> can perform the minimum amount of work
      necessary to update the executable.</p><p><em class="command">因此， make</em>的主要价值
      来自于它能够执行构建应用程序所需的一系列复杂命令，并在可能的情况下优化这些操作，以减少编辑-编译-调试周期所需的时间。此外，<em class="command">make</em>足够灵活，可以在一种文件依赖于另一种文件的任何地方使用，从传统的 C/C++ 编程到 Java、TEX、数据库管理等。</p><p>So the principle value of <em class="command">make</em>
      comes from its ability to perform the complex series of commands
      necessary to build an application and to optimize these operations when
      possible to reduce the time taken by the edit-compile-debug cycle.
      Furthermore, <em class="command">make</em> is flexible enough
      to be used anywhere one kind of file depends on another from traditional
      programming in C/C++ to Java, TEX, database management, and more.</p><div class="sect1" title="目标和先决条件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01.html.make3-CHP-1-SECT-1"></a>目标和先决条件</h1><h1 class="title"><a></a>Targets and Prerequisites</h1></div></div></div><p>本质上一个<em class="filename">makefile</em>
        包含一个<a id="OEBPS/ch01.html.make3-CHP-1-ITERM-794" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-795" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-796" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-797" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-798" class="indexterm"></a>用于构建应用程序的规则集。<em class="command">make</em>看到的第一条规则被用作
        <em class="firstterm">默认规则</em>。规则由三<em class="firstterm">部分</em>
        组成：目标、先决条件和要执行的命令：</p><p>Essentially a <em class="filename">makefile</em>
        contains a <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>set of rules used to build an application. The first
        rule seen by <em class="command">make</em> is used as the
        <em class="firstterm">default rule</em>. A <em class="firstterm">rule</em>
        consists of three parts: the target, its prerequisites, and the
        command(s) to perform:</p><a id="OEBPS/ch01.html.I_1_tt6"></a><pre class="programlisting"><em class="replaceable"><code>target</code></em>: <sub>1 </sub><sub>2</sub><em class="replaceable"><code>prereq</code></em>
               <sub></sub> 
               <em class="replaceable"><code>prereq</code></em>
               <sub></sub>
               <em class="replaceable"><code>commands</code></em></pre><pre class="programlisting"><em class="replaceable"><code>target</code></em>: <em class="replaceable"><code>prereq</code></em>
               <sub>1</sub> 
               <em class="replaceable"><code>prereq</code></em>
               <sub>2</sub>
               <em class="replaceable"><code>commands</code></em></pre><p>目标<em class="firstterm">是</em>必须的文件或事物
        <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-799" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-800" class="indexterm"></a>被制作。先决<em class="firstterm">条件</em>或
        <em class="firstterm">依赖项</em>是成功创建目标之前必须存在的文件。这些
        <em class="firstterm">命令</em>是将根据先决条件创建目标的 shell 命令。</p><p>The <em class="firstterm">target</em> is the file or thing that must
        <a class="indexterm"></a> <a class="indexterm"></a>be made. The <em class="firstterm">prerequisites</em> or
        <em class="firstterm">dependents</em> are those files that must exist
        before the target can be successfully created. And the
        <em class="firstterm">commands</em> are those shell commands that will
        create the target from the prerequisites.</p><p><em class="filename">以下是将 C 文件foo.c</em>编译为目标文件<em class="filename">foo.o 的</em>规则：</p><p>Here is a rule for compiling a C file, <em class="filename">foo.c</em>, into an object file, <em class="filename">foo.o</em>:</p><a id="OEBPS/ch01.html.I_1_tt7"></a><pre class="programlisting">foo.o: foo.c foo.h
        gcc -c foo.c</pre><pre class="programlisting">foo.o: foo.c foo.h
        gcc -c foo.c</pre><p>目标文件<em class="filename">foo.o</em>
        出现在冒号之前。先决条件<em class="filename">foo.c</em>和<em class="filename">foo.h</em>出现在冒号之后。命令脚本通常出现在以下几行中，前面有一个制表符。</p><p>The target file <em class="filename">foo.o</em>
        appears before the colon. The prerequisites <em class="filename">foo.c</em> and <em class="filename">foo.h</em> appear after the colon. The command
        script usually appears on the following lines and is preceded by a tab
        character.</p><p>当要求<em class="command">make</em>评估规则时，它首先查找先决条件和目标指示的文件。如果任何先决条件具有关联规则，<em class="command">请</em>首先尝试更新这些规则。接下来，考虑目标文件。如果任何先决条件比目标新，则通过执行命令重新创建目标。每个命令行都会传递到 shell 并在其自己的子 shell 中执行。如果任何命令生成错误，则目标的构建将终止并<em class="command">退出</em>。如果一个文件最近修改过，则该文件被认为比另一个文件新。</p><p>When <em class="command">make</em> is asked to
        evaluate a rule, it begins by finding the files indicated by the
        prerequisites and target. If any of the prerequisites has an
        associated rule, <em class="command">make</em> attempts to
        update those first. Next, the target file is considered. If any
        prerequisite is newer than the target, the target is remade by
        executing the commands. Each command line is passed to the shell and
        is executed in its own subshell. If any of the commands generates an
        error, the building of the target is terminated and <em class="command">make</em> exits. One file is considered newer
        than another if it has been modified more recently.</p><p>这是一个计算输入中“fee”、“fie”、“foe”和“fum”单词出现次数的程序。它使用由简单的主驱动驱动的<em class="command">柔性扫描仪：</em></p><p>Here is a program to count the number of occurrences of the
        words "fee," "fie," "foe," and "fum" in its input. It uses a <em class="command">flex</em> scanner driven by a simple main:</p><a id="OEBPS/ch01.html.I_1_tt8"></a><pre class="programlisting">#include &lt;stdio.h&gt;

extern int Fee_count、fie_count、foe_count、fum_count；
外部 int yylex( 无效 );

int main( int argc, char ** argv )
{
    yylex();
    printf( "%d %d %d %d\n", Fee_count, fie_count, foe_count, fum_count );
    退出（0）；
}</pre><pre class="programlisting">#include &lt;stdio.h&gt;

extern int fee_count, fie_count, foe_count, fum_count;
extern int yylex( void );

int main( int argc, char ** argv )
{
    yylex( );
    printf( "%d %d %d %d\n", fee_count, fie_count, foe_count, fum_count );
    exit( 0 );
}</pre><p>扫描仪非常简单：</p><p>The scanner is very simple:</p><a id="OEBPS/ch01.html.I_1_tt9"></a><pre class="programlisting">        int 费用计数 = 0;
        int fie_count = 0;
        int 敌人计数 = 0;
        int fum_count = 0;
%%
费用fee_count++；
fie fie_count++；
敌人foe_count++；
福姆福姆_计数++；</pre><pre class="programlisting">        int fee_count = 0;
        int fie_count = 0;
        int foe_count = 0;
        int fum_count = 0;
%%
fee     fee_count++;
fie     fie_count++;
foe     foe_count++;
fum     fum_count++;</pre><p><em class="filename">该程序的 makefile</em>也非常简单：</p><p>The <em class="filename">makefile</em> for this
        program is also quite simple:</p><a id="OEBPS/ch01.html.I_1_tt10"></a><pre class="programlisting">count_words: count_words.o lexer.o -lfl
        gcc count_words.o lexer.o -lfl -o count_words

count_words.o: count_words.c
        gcc -c count_words.c

词法分析器.o: 词法分析器.c
        gcc -c 词法分析器.c

词法分析器.c: 词法分析器.l
        flex -t lexer.l &gt; lexer.c</pre><pre class="programlisting">count_words: count_words.o lexer.o -lfl
        gcc count_words.o lexer.o -lfl -o count_words

count_words.o: count_words.c
        gcc -c count_words.c

lexer.o: lexer.c
        gcc -c lexer.c

lexer.c: lexer.l
        flex -t lexer.l &gt; lexer.c</pre><p>当第一次执行这个<em class="filename">makefile时，我们看到：</em></p><p>When this <em class="filename">makefile</em> is
        executed for the first time, we see:</p><a id="OEBPS/ch01.html.I_1_tt11"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -c count_words.c
flex -t lexer.l &gt; lexer.c
gcc -c 词法分析器.c
gcc count_words.o lexer.o -lfl -o count_words</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -c count_words.c
flex -t lexer.l &gt; lexer.c
gcc -c lexer.c
gcc count_words.o lexer.o -lfl -o count_words</pre><p>我们现在有了一个可执行程序。当然，真实的程序通常包含比这更多的模块。另外，正如您稍后将看到的，这个<em class="filename">makefile没有使用</em><em class="command">make</em>的大部分功能，因此它比必要的更加冗长。尽管如此，这是一个实用且有用的<em class="filename">makefile</em>。例如，在编写这个例子的过程中，我在试验程序时执行了几十次<em class="filename">makefile 。</em></p><p>We now have an executable program. Of course, real programs
        typically consist of more modules than this. Also, as you will see
        later, this <em class="filename">makefile</em> does not use
        most of the features of <em class="command">make</em> so
        it's more verbose than necessary. Nevertheless, this is a functional
        and useful <em class="filename">makefile</em>. For
        instance, during the writing of this example, I executed the <em class="filename">makefile</em> several dozen times while
        experimenting with the program.</p><p>当您查看<em class="filename">makefile</em>
        和示例时<a id="OEBPS/ch01.html.make3-CHP-1-ITERM-801" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-802" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-803" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-804" class="indexterm"></a><em class="command">执行时，您可能会注意到make</em>执行命令的顺序几乎与它们在<em class="filename">makefile</em>中出现的顺序相反。这种
        <span class="emphasis"><em>自上而下的</em></span>风格很常见<a id="OEBPS/ch01.html.make3-CHP-1-ITERM-805" class="indexterm"></a> <a id="OEBPS/ch01.html.make3-CHP-1-ITERM-806" class="indexterm"></a>在<em class="filename">makefile</em>中。通常，最通用的目标形式首先在 makefile 中指定
        <em class="filename">，</em>详细信息留到以后再说。<em class="command">make</em>程序以多种方式支持这种风格。其中最主要的是<em class="command">make</em>的两阶段执行模型和递归变量。我们将在后面的章节中详细讨论这些内容。</p><p>As you look at the <em class="filename">makefile</em>
        and sample <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>execution, you may notice that the order in which
        commands are executed by <em class="command">make</em> are
        nearly the opposite to the order they occur in the <em class="filename">makefile</em>. This
        <span class="emphasis"><em>top-down</em></span> style is common <a class="indexterm"></a> <a class="indexterm"></a>in <em class="filename">makefile</em>s.
        Usually the most general form of target is specified first in the
        <em class="filename">makefile</em> and the details are left
        for later. The <em class="command">make</em> program
        supports this style in many ways. Chief among these is <em class="command">make</em>'s two-phase execution model and
        recursive variables. We will discuss these in great detail in later
        chapters.</p></div></div></div></div>
<div id="OEBPS/ch01s02.html"><div>
<div class="sect1" title="依赖性检查"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01s02.html.make3-CHP-1-SECT-2"></a>依赖性检查</h1><h1 class="title"><a></a>Dependency Checking</h1></div></div></div><p><em class="command">make 是</em>如何决定要做什么的？让我们更详细地回顾一下之前的执行以找出答案。</p><p>How did <em class="command">make</em> decide what to
        do? Let's go over the previous execution in more detail to find
        out.</p><p>首先<em class="command">要</em>注意的是
        <a id="OEBPS/ch01s02.html.make3-CHP-1-ITERM-807" class="indexterm"></a> <a id="OEBPS/ch01s02.html.make3-CHP-1-ITERM-808" class="indexterm"></a>命令行不包含目标，因此它决定设置默认目标<em class="filename">count_words</em>。它检查<a id="OEBPS/ch01s02.html.make3-CHP-1-ITERM-809" class="indexterm"></a> <a id="OEBPS/ch01s02.html.make3-CHP-1-ITERM-810" class="indexterm"></a>先决条件并看到三个：<em class="filename">count_words.o</em>、<em class="filename">lexer.o</em>和<code class="option">-lfl</code>。
         <em class="command">make</em>现在考虑如何构建
        <em class="filename">count_words.o</em>并查看它的规则。再次，它检查先决条件，注意到<em class="filename">count_words.c</em>没有规则，但该文件存在，因此<em class="command">make通过执行以下命令来执行将</em><em class="filename">count_words.c</em>转换为<em class="filename">count_words.o 的</em>命令：</p><p>First <em class="command">make</em> notices that the
        <a class="indexterm"></a> <a class="indexterm"></a>command line contains no targets so it decides to make
        the default goal, <em class="filename">count_words</em>. It
        checks for <a class="indexterm"></a> <a class="indexterm"></a>prerequisites and sees three: <em class="filename">count_words.o</em>, <em class="filename">lexer.o</em>, and <code class="option">-lfl</code>.
        <em class="command">make</em> now considers how to build
        <em class="filename">count_words.o</em> and sees a rule for
        it. Again, it checks the prerequisites, notices that <em class="filename">count_words.c</em> has no rules but that the
        file exists, so <em class="command">make</em> executes the
        commands to transform <em class="filename">count_words.c</em> into <em class="filename">count_words.o</em> by executing the
        command:</p><a id="OEBPS/ch01s02.html.I_1_tt12"></a><pre class="programlisting">gcc -c count_words.c</pre><pre class="programlisting">gcc -c count_words.c</pre><p>这种目标到先决条件、目标到先决条件的“链接”是<em class="command">make</em>分析<em class="filename">makefile</em>以确定要执行的命令的典型方式。</p><p>This "chaining" of targets to prerequisites to targets to
        prerequisites is typical of how <em class="command">make</em> analyzes a <em class="filename">makefile</em> to decide the commands to be
        performed.</p><p><em class="command">make</em>考虑的下一个先决条件
        是<em class="filename">lexer.o</em>。规则链再次指向<em class="filename">lexer.c</em> 
        ，但这次该文件不存在。<em class="command">make</em>找到从<em class="filename">lexer.l生成</em><em class="filename">lexer.c 的</em>规则，因此它运行<em class="command">flex</em>程序。现在<em class="filename">lexer.c</em>已存在，它可以运行<em class="command">gcc</em>命令。<em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em></p><p>The next prerequisite <em class="command">make</em>
        considers is <em class="filename">lexer.o</em>. Again the
        chain of rules leads to <em class="filename">lexer.c</em>
        but this time the file does not exist. <em class="command">make</em> finds the rule for generating <em class="filename">lexer.c</em> from <em class="filename">lexer.l</em> so it runs the <em class="command">flex</em> program. Now that <em class="filename">lexer.c</em> exists it can run the <em class="command">gcc</em> command.</p><p>最后<em class="command">进行</em>检查
        <code class="option">-lfl</code>。<em class="command">gcc</em><code class="option">-l</code>的选项指示必须链接到应用程序中的系统库。 “fl”指示的实际库名称是<em class="filename">libfl.a</em>。
         <acronym class="acronym">GNU </acronym><em class="command">make</em>
        包含对此语法的特殊支持。当看到该形式的先决条件时， <em class="command">make搜索</em><em class="filename">libNAME.so</em>形式的文件
        ；如果未找到匹配项，则会搜索<em class="filename">libNAME.a</em>。这里<em class="command">make</em>找到<em class="filename">/usr/lib/libfl.a</em>并继续最后的操作，链接。<em class="command"></em><em class="filename"></em><acronym class="acronym"></acronym> <em class="command"></em><code class="option">-l&lt;NAME&gt;</code><em class="command"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><em class="filename"></em></p><p>Finally, <em class="command">make</em> examines
        <code class="option">-lfl</code>. The <code class="option">-l</code> option to <em class="command">gcc</em> indicates a system library that must be
        linked into the application. The actual library name indicated by "fl"
        is <em class="filename">libfl.a</em>.
        <acronym class="acronym">GNU</acronym> <em class="command">make</em>
        includes special support for this syntax. When a prerequisite of the
        form<code class="option">-l&lt;NAME&gt;</code> is seen, <em class="command">make</em> searches for a file of the form
        <em class="filename">libNAME.so</em>; if no match is found,
        it then searches for <em class="filename">libNAME.a</em>.
        Here <em class="command">make</em> finds <em class="filename">/usr/lib/libfl.a</em> and proceeds with the
        final action, linking.</p></div></div></div>
<div id="OEBPS/ch01s03.html"><div>
<div class="sect1" title="最大限度地减少重建"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01s03.html.make3-CHP-1-SECT-3"></a>最大限度地减少重建</h1><h1 class="title"><a></a>Minimizing Rebuilds</h1></div></div></div><p>当我们运行我们的程序时，我们<a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-811" class="indexterm"></a> <a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-812" class="indexterm"></a> <a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-813" class="indexterm"></a> <a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-814" class="indexterm"></a> <a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-815" class="indexterm"></a> <a id="OEBPS/ch01s03.html.make3-CHP-1-ITERM-816" class="indexterm"></a>发现除了打印费用、fies、foes 和 fums 之外，它还打印输入文件中的文本。这不是我们想要的。问题是我们忘记了词法分析器中的一些规则，而<em class="command">Flex</em>正在将这些无法识别的文本传递到其输出。为了解决这个问题，我们只需添加一个“任意字符”规则和一个换行规则：</p><p>When we run our program, we <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>discover that aside from printing fees, fies, foes, and
        fums, it also prints text from the input file. This is not what we
        want. The problem is that we have forgotten some rules in our lexical
        analyzer and <em class="command">flex</em> is passing this
        unrecognized text to its output. To solve this problem we simply add
        an "any character" rule and a newline rule:</p><a id="OEBPS/ch01s03.html.I_1_tt13"></a><pre class="programlisting">        int 费用计数 = 0;
        int fie_count = 0;
        int 敌人计数 = 0;
        int fum_count = 0;
%%
费用fee_count++；
fie fie_count++；
敌人foe_count++；
福姆福姆_计数++；
。
\n</pre><pre class="programlisting">        int fee_count = 0;
        int fie_count = 0;
        int foe_count = 0;
        int fum_count = 0;
%%
fee     fee_count++;
fie     fie_count++;
foe     foe_count++;
fum     fum_count++;
.
\n</pre><p>编辑此文件后，我们需要重建应用程序来测试我们的修复：</p><p>After editing this file we need to rebuild the application to
        test our fix:</p><a id="OEBPS/ch01s03.html.I_1_tt14"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
flex -t lexer.l &gt; lexer.c
gcc -c 词法分析器.c
gcc count_words.o lexer.o -lfl -ocount_words</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
flex -t lexer.l &gt; lexer.c
gcc -c lexer.c
gcc count_words.o lexer.o -lfl -ocount_words</pre><p>请注意，这次文件<em class="filename">count_words.c</em>没有重新编译。当
        <em class="command">make</em>分析规则时，它发现<em class="filename">count_words.o存在，并且比其先决条件</em><em class="filename">count_words.c</em>
        更新，因此无需执行任何操作即可使文件更新。然而，在分析<em class="filename">lexer.c时， </em><em class="command">make</em>发现先决条件<em class="filename">lexer.l比其目标</em><em class="filename">lexer.c</em>新，因此<em class="command">make</em>必须更新<em class="filename">lexer.c</em>。这反过来又导致了<em class="filename">lexer.o</em>和<em class="filename">count_words</em>的更新。现在我们的字数统计程序已经修复了：</p><p>Notice this time the file <em class="filename">count_words.c</em> was not recompiled. When
        <em class="command">make</em> analyzed the rule, it
        discovered that <em class="filename">count_words.o</em>
        existed and was newer than its prerequisite <em class="filename">count_words.c</em> so no action was necessary to
        bring the file up to date. While analyzing <em class="filename">lexer.c</em>, however, <em class="command">make</em> saw that the prerequisite <em class="filename">lexer.l</em> was newer than its target <em class="filename">lexer.c</em> so <em class="command">make</em> must update <em class="filename">lexer.c</em>. This, in turn, caused the update
        of <em class="filename">lexer.o</em> and then <em class="filename">count_words</em>. Now our word counting program
        is fixed:</p><a id="OEBPS/ch01s03.html.I_1_tt15"></a><pre class="programlisting">$ <strong class="userinput"><code>count_words &lt; lexer.l</code></strong>
3 3 3 3</pre><pre class="programlisting">$<strong class="userinput"><code>count_words &lt; lexer.l</code></strong>
3 3 3 3</pre></div></div></div>
<div id="OEBPS/ch01s04.html"><div>
<div class="sect1" title="调用make"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01s04.html.make3-CHP-1-SECT-4"></a>调用make</h1><h1 class="title"><a></a>Invoking make</h1></div></div></div><p>前面的例子<a id="OEBPS/ch01s04.html.make3-CHP-1-ITERM-817" class="indexterm"></a> <a id="OEBPS/ch01s04.html.make3-CHP-1-ITERM-818" class="indexterm"></a>假使，假设：</p><p>The previous examples <a class="indexterm"></a> <a class="indexterm"></a>assume that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>所有项目源代码和<em class="command">make</em>描述文件都存储在一个目录中。</p></li><li class="listitem"><p>All the project source code and the <em class="command">make</em> description file are stored in a
            single directory.</p></li><li class="listitem"><p>make<em class="command">描述</em>文件称为<em class="filename">makefile</em>、<em class="filename">Makefile</em>或<em class="filename">GNUMakefile</em>。</p></li><li class="listitem"><p>The <em class="command">make</em> description file
            is called <em class="filename">makefile</em>, <em class="filename">Makefile</em>, or <em class="filename">GNUMakefile</em>.</p></li><li class="listitem"><p><em class="command">执行make命令时</em><em class="filename">，makefile</em>驻留在用户的当前目录中。<em class="command"></em></p></li><li class="listitem"><p>The <em class="filename">makefile</em> resides in
            the user's current directory when executing the <em class="command">make</em> command.</p></li></ul></div><p>当在这些条件下调用<em class="command">make</em>时，它​​会自动创建它看到的第一个目标。要更新不同的目标（或更新多个目标），请在命令行中包含目标名称：</p><p>When <em class="command">make</em> is invoked under
        these conditions, it automatically creates the first target it sees.
        To update a different target (or to update more than one target)
        include the target name on the command line:</p><a id="OEBPS/ch01s04.html.I_1_tt16"></a><pre class="programlisting">$<strong class="userinput"><code>make lexer.c</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>make lexer.c</code></strong></pre><p>当执行<em class="command">make</em>时，它会读取描述文件并识别要更新的目标。如果目标或其任何必备文件已过期（或丢失），则规则命令脚本中的 shell 命令将一次执行一个。运行命令后，<em class="command">make</em>假定目标是最新的并移至下一个目标或退出。</p><p>When <em class="command">make</em> is executed, it
        will read the description file and identify the target to be updated.
        If the target or any of its prerequisite files are out of date (or
        missing) the shell commands in the rule's command script will be
        executed one at a time. After the commands are run <em class="command">make</em> assumes the target is up to date and
        moves on to the next target or exits.</p><p>如果您指定的目标已经是最新的，<em class="command">make</em>会这么说并立即退出，不执行任何其他操作：</p><p>If the target you specify is already up to date, <em class="command">make</em> will say so and immediately exit, doing
        nothing else:</p><a id="OEBPS/ch01s04.html.I_1_tt17"></a><pre class="programlisting">$ <strong class="userinput"><code>make lexer.c</code></strong>
make: `lexer.c' 是最新的。</pre><pre class="programlisting">$<strong class="userinput"><code>make lexer.c</code></strong>
make: `lexer.c' is up to date.</pre><p>如果您指定的目标不在 makefile 中<em class="filename">并且</em>没有隐式规则（在<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>中讨论），
        <code class="literal">make</code>则会响应：</p><p>If you specify a target that is not in the <em class="filename">makefile</em> and for which there is no implicit
        rule (discussed in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>),
        <code class="literal">make</code> will respond with:</p><a id="OEBPS/ch01s04.html.I_1_tt18"></a><pre class="programlisting">$ <strong class="userinput"><code>make non-existent-target</code></strong>
make: *** 没有规则使目标成为“不存在的目标”。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make non-existent-target</code></strong>
make: *** No rule to make target `non-existent-target'.  Stop.</pre><p><em class="command">make</em>有许多命令行选项。最有用的之一是<code class="option">—just-print</code>(或
        <code class="option">-n</code>)，它告诉<em class="command">make</em>显示将为特定目标执行的命令，而不实际执行它们。这在编写<em class="filename">makefile</em>时特别​​有价值。还可以在命令行上设置几乎所有<em class="filename">makefile变量来覆盖默认值或</em><em class="filename">makefile</em>中设置的值
        。</p><p><em class="command">make</em> has many command-line
        options. One of the most useful is <code class="option">—just-print</code> (or
        <code class="option">-n</code>) which tells <em class="command">make</em> to display the commands it would
        execute for a particular target without actually executing them. This
        is particularly valuable while writing <em class="filename">makefile</em>s. It is also possible to set
        almost any <em class="filename">makefile</em> variable on
        the command line to override the default value or the value set in the
        <em class="filename">makefile</em>.</p></div></div></div>
<div id="OEBPS/ch01s05.html"><div>
<div class="sect1" title="基本 Makefile 语法"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch01s05.html.make3-CHP-1-SECT-5"></a>基本 Makefile 语法</h1><h1 class="title"><a></a>Basic Makefile Syntax</h1></div></div></div><p>现在你已经有了基本的<a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-819" class="indexterm"></a> <a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-820" class="indexterm"></a>了解了<em class="command">make</em>
        你几乎可以编写自己的<em class="filename">makefile</em>了。在这里，我们将介绍<em class="filename">makefile</em>的足够语法和结构，以便您开始使用<em class="command">make</em>。</p><p>Now that you have a basic <a class="indexterm"></a> <a class="indexterm"></a>understanding of <em class="command">make</em>
        you can almost write your own <em class="filename">makefile</em>s. Here we'll cover enough of the
        syntax and structure of a <em class="filename">makefile</em> for you to start using <em class="command">make</em>.</p><p><em class="filename">Makefile</em>通常是自上而下构建的，因此
        <code class="literal">all</code>默认情况下会更新最通用的目标（通常称为 ）。越来越详细的目标随之而来的是程序维护的目标，例如<code class="literal">clean</code>删除不需要的临时文件的目标，最后出现。正如您可以从这些目标名称中猜测到的那样，目标不必是实际文件，任何名称都可以。</p><p><em class="filename">Makefile</em>s are usually
        structured top-down so that the most general target, often called
        <code class="literal">all</code>, is updated by default. More
        and more detailed targets follow with targets for program maintenance,
        such as a <code class="literal">clean</code> target to delete
        unwanted temporary files, coming last. As you can guess from these
        target names, targets do not have to be actual files, any name will
        do.</p><p>在上面的例子中，我们看到了规则的简化形式。规则的更完整（但仍不完全完整）的形式是：</p><p>In the example above we saw a simplified form of a rule. The
        more complete (but still not quite complete) form of a rule is:</p><a id="OEBPS/ch01s05.html.I_1_tt19"></a><pre class="programlisting"><em class="replaceable"><code>target</code></em>
               <sub>1 </sub> 
               <sub>2 </sub><sub>3</sub> : <sub>1 </sub><sub>2 </sub><sub>1 </sub><sub>2 </sub><sub>3</sub><em class="replaceable"><code>target</code></em>
               <sub></sub> 
               <em class="replaceable"><code>target</code></em>
               <sub></sub><em class="replaceable"><code>prerequisite</code></em>
               <sub></sub> 
               <em class="replaceable"><code>prerequisite</code></em>
               <sub></sub>
               <em class="replaceable"><code>command</code></em>
               <sub></sub>
               <em class="replaceable"><code>command</code></em>
               <sub></sub>
               <em class="replaceable"><code>command</code></em>
               <sub></sub></pre><pre class="programlisting"><em class="replaceable"><code>target</code></em>
               <sub>1</sub> 
               <em class="replaceable"><code>target</code></em>
               <sub>2</sub> 
               <em class="replaceable"><code>target</code></em>
               <sub>3</sub> : <em class="replaceable"><code>prerequisite</code></em>
               <sub>1</sub> 
               <em class="replaceable"><code>prerequisite</code></em>
               <sub>2</sub>
               <em class="replaceable"><code>command</code></em>
               <sub>1</sub>
               <em class="replaceable"><code>command</code></em>
               <sub>2</sub>
               <em class="replaceable"><code>command</code></em>
               <sub>3</sub></pre><p>一个或多个目标出现在冒号左侧，零个或多个先决条件可以出现在冒号右侧。如果右侧没有列出先决条件，则仅更新不存在的目标。更新目标所执行的命令集是<a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-821" class="indexterm"></a> <a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-822" class="indexterm"></a>有时称为<em class="firstterm">命令脚本</em>，但大多数情况下只是
        <span class="emphasis"><em>命令</em></span>。</p><p>One or more targets appear to the left of the colon and zero or
        more prerequisites can appear to the right of the colon. If no
        prerequisites are listed to the right, then only the target(s) that do
        not exist are updated. The set of commands executed to update a target
        are <a class="indexterm"></a> <a class="indexterm"></a>sometimes called the <em class="firstterm">command
        script</em>, but most often just the
        <span class="emphasis"><em>commands</em></span>.</p><p>每个命令<span class="emphasis"><em>必须</em></span>以制表符开头。这个（模糊的）语法告诉<em class="command">make</em>制表符后面的字符将被传递到子 shell 中执行。如果您不小心插入制表符作为非命令行的第一个字符，则在大多数情况下<em class="command">make</em>会将以下文本解释为命令。如果您很幸运并且错误的制表符被识别为语法错误，您将收到以下消息：</p><p>Each command <span class="emphasis"><em>must</em></span> begin with a tab
        character. This (obscure) syntax tells <em class="command">make</em> that the characters that follow the tab
        are to be passed to a subshell for execution. If you accidentally
        insert a tab as the first character of a noncommand line, <em class="command">make</em> will interpret the following text as a
        command under most circumstances. If you're lucky and your errant tab
        character is recognized as a syntax error you will receive the
        message:</p><a id="OEBPS/ch01s05.html.I_1_tt20"></a><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
Makefile:6: *** 命令在第一个目标之前开始。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Makefile:6: *** commands commence before first target.  Stop.</pre><p><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">我们将在第 2 章</a>中讨论制表符的复杂性。</p><p>We'll discuss the complexities of the tab character in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>.</p><p>评论字符<a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-823" class="indexterm"></a> <a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-824" class="indexterm"></a>对于<em class="command">make</em>来说是哈希值或井号，.从井号到行尾的所有文本都将被忽略。注释可以缩进，并且忽略前导空格。注释字符不会在命令文本中引入<em class="command">make</em>注释。整行（包括 和后续字符）将传递给 shell 执行。如何处理取决于你的 shell。</p><p>The comment character <a class="indexterm"></a> <a class="indexterm"></a>for <em class="command">make</em> is the hash
        or pound sign, . All text from the pound sign to the end of line is
        ignored. Comments can be indented and leading whitespace is ignored.
        The comment character does not introduce a <em class="command">make</em> comment in the text of commands. The
        entire line, including the and subsequent characters, is passed to the
        shell for execution. How it is handled there depends on your
        shell.</p><p>长队可以继续<a id="OEBPS/ch01s05.html.make3-CHP-1-ITERM-825" class="indexterm"></a>使用标准 Unix 转义字符反斜杠 (\)。以这种方式继续命令是很常见的。先决条件列表用反斜杠继续也是很常见的。稍后我们将介绍处理长先决条件列表的其他方法。</p><p>Long lines can be continued <a class="indexterm"></a>using the standard Unix escape character backslash (\).
        It is common for commands to be continued in this way. It is also
        common for lists of prerequisites to be continued with backslash.
        Later we'll cover other ways of handling long prerequisite
        lists.</p><p>您现在已经有了足够的背景来编写简单的<em class="filename">makefile</em>。<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>将详细介绍规则，然后是<a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">第 3 章中的</a><em class="command">make</em>变量和<a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">第 5 章</a>中的命令。现在您应该避免使用变量、宏和多行命令序列。<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><a class="link" href="#OEBPS/ch05.html" title="第 5 章命令"></a></p><p>You now have enough background to write simple <em class="filename">makefile</em>s. <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a> will cover rules in detail,
        followed by <em class="command">make</em> variables in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a> and commands in <a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">Chapter 5</a>. For now you should avoid the
        use of variables, macros, and multiline command sequences.</p></div></div></div>
<div id="OEBPS/ch02.html"><div>
<div class="chapter" title="第 2 章 规则"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02.html.make3-CHP-2"></a>第 2 章 规则</h1><h1 class="title"><a></a>Chapter&nbsp;2.&nbsp;Rules</h1></div></div></div><p>在上一章中，我们编写了一些规则来编译和链接我们的字数统计程序。这些规则中的每一个都定义一个目标，即要更新的文件。每个目标文件都依赖于一组先决条件，这些先决条件也是文件。当要求更新目标时，如果任何先决条件文件的修改时间比目标更新，<em class="command">则 make</em>将执行规则的命令脚本。由于一个规则的目标可以作为另一个规则的先决条件进行引用，因此目标和先决条件集形成<em class="firstterm">依赖关系</em>链或依赖关系图（“依赖关系图”的缩写）。构建和处理此依赖关系图以更新请求的目标就是<em class="command">make 的</em>全部内容。</p><p>In the last chapter, we wrote some rules to compile and link our
      word-counting program. Each of those rules defines a target, that is, a
      file to be updated. Each target file depends on a set of prerequisites,
      which are also files. When asked to update a target, <em class="command">make</em> will execute the command script of the
      rule if any of the prerequisite files has been modified more recently
      than the target. Since the target of one rule can be referenced as a
      prerequisite in another rule, the set of targets and prerequisites form
      a chain or graph of <em class="firstterm">dependencies</em> (short for
      "dependency graph"). Building and processing this dependency graph to
      update the requested target is what <em class="command">make</em> is all about.</p><p><em class="command">由于规则在make</em>中非常重要，因此有许多不同类型的规则。<em class="firstterm">明确的规则</em>，就像那些<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-826" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-827" class="indexterm"></a>在里面<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-828" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-829" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-830" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-831" class="indexterm"></a>前一章指出了要更新的具体目标（如果其任何先决条件已过时）。这是您将要编写的最常见的规则类型。<em class="firstterm">模式规则</em>使用<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-832" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-833" class="indexterm"></a>通配符而不是明确的文件名。这允许
      <em class="command">make</em>在任何需要更新与模式匹配的目标文件时应用该规则。<em class="firstterm">隐含规则</em> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-834" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-835" class="indexterm"></a><em class="command">是在make</em>内置的规则数据库中找到的模式规则或后缀规则。拥有内置的规则数据库使编写<em class="filename">makefile</em>变得更加容易，因为对于许多常见任务，
       <em class="command">make</em>已经知道文件类型、后缀和用于更新目标的程序。<em class="firstterm">静态模式规则</em>是<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-836" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-837" class="indexterm"></a>与常规模式规则类似，只不过它们仅适用于特定的目标文件列表。</p><p>Since rules are so important in <em class="command">make</em>, there are a number of different kinds of
      rules. <em class="firstterm">Explicit rules</em>, like the ones <a class="indexterm"></a> <a class="indexterm"></a>in the <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>previous chapter, indicate a specific target to be updated
      if it is out of date with respect to any of its prerequisites. This is
      the most common type of rule you will be writing. <em class="firstterm">Pattern
      rules</em> use <a class="indexterm"></a> <a class="indexterm"></a>wildcards instead of explicit filenames. This allows
      <em class="command">make</em> to apply the rule any time a
      target file matching the pattern needs to updated. <em class="firstterm">Implicit
      rules</em> <a class="indexterm"></a> <a class="indexterm"></a>are either pattern rules or suffix rules found in the
      rules database built-in to <em class="command">make</em>.
      Having a built-in database of rules makes writing <em class="filename">makefile</em>s easier since for many common tasks
      <em class="command">make</em> already knows the file types,
      suffixes, and programs for updating targets. <em class="firstterm">Static pattern
      rules</em> are <a class="indexterm"></a> <a class="indexterm"></a>like regular pattern rules except they apply only to a
      specific list of target files.</p><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>可以用作许多其他版本的<em class="command">make</em>的“直接”替代品，并包含一些专门用于<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-838" class="indexterm"></a>兼容性。<em class="firstterm">后缀规则</em>是
      <em class="command">make</em>编写通用规则的原始方法。<acronym class="acronym">GNU </acronym> <em class="command">make</em>包含对后缀规则的支持，但它们被认为已过时，已被更清晰、更通用的模式规则所取代。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em> can
      be used as a "drop in" replacement for many other versions of <em class="command">make</em> and includes several features
      specifically for <a class="indexterm"></a>compatibility. <em class="firstterm">Suffix rules</em> were
      <em class="command">make</em>'s original means for writing
      general rules. <acronym class="acronym">GNU</acronym> <em class="command">make</em> includes support for suffix rules, but
      they are considered obsolete having been replaced by pattern rules that
      are clearer and more general.</p><div class="sect1" title="明确的规则"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02.html.make3-CHP-2-SECT-1"></a>明确的规则</h1><h1 class="title"><a></a>Explicit Rules</h1></div></div></div><p>您将编写的大多数规则都是显式规则<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-839" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-840" class="indexterm"></a>指定特定文件作为目标和先决条件。一项规则可以有多个目标。这意味着
        <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-841" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-842" class="indexterm"></a>每个目标都与其他目标具有相同的先决条件。如果目标已过期，将执行相同的一组操作来更新每个目标。例如：</p><p>Most rules you will write are explicit rules <a class="indexterm"></a> <a class="indexterm"></a>that specify particular files as targets and
        prerequisites. A rule can have more than one target. This means
        <a class="indexterm"></a> <a class="indexterm"></a>that each target has the same set of prerequisites as
        the others. If the targets are out of date, the same set of actions
        will be performed to update each one. For instance:</p><a id="OEBPS/ch02.html.I_2_tt21"></a><pre class="programlisting">vpath.o 变量.o: make.h config.h getopt.h gettext.h dep.h</pre><pre class="programlisting">vpath.o variable.o: make.h config.h getopt.h gettext.h dep.h</pre><p>这表明<em class="filename">vpath.o</em>和<em class="filename">variable.o</em>都依赖于同一组C头文件。该行具有与以下相同的效果：</p><p>This indicates that both <em class="filename">vpath.o</em> and <em class="filename">variable.o</em> depend on the same set of C
        header files. This line has the same effect as:</p><a id="OEBPS/ch02.html.I_2_tt22"></a><pre class="programlisting">vpath.o: make.h config.h getopt.h gettext.h dep.h
变量.o：make.h config.h getopt.h gettext.h dep.h</pre><pre class="programlisting">vpath.o: make.h config.h getopt.h gettext.h dep.h
variable.o: make.h config.h getopt.h gettext.h dep.h</pre><p>这两个目标是独立处理的。如果任一目标文件相对于其任何先决条件而言已经过时（即任何头文件的修改时间都比目标文件更新），
        <em class="command">则 make</em>将通过执行与规则关联的命令来更新目标文件。</p><p>The two targets are handled independently. If either object file
        is out of date with respect to any of its prerequisites (that is, any
        header file has a newer modification time than the object file),
        <em class="command">make</em> will update the object file by
        executing the commands associated with the rule.</p><p>规则不必“一次性”定义。每次
        <em class="command">make</em>看到目标文件时，它都会将目标和先决条件添加到依赖关系图中。如果目标已被发现并存在于图中，则任何其他先决条件都会附加到<em class="command">make</em>的依赖关系图中的目标文件条目。在简单的情况下，这对于自然地打破长行以提高<em class="filename">makefile</em>的可读性很有用：</p><p>A rule does not have to be defined "all at once." Each time
        <em class="command">make</em> sees a target file it adds the
        target and prerequisites to the dependency graph. If a target has
        already been seen and exists in the graph, any additional
        prerequisites are appended to the target file entry in <em class="command">make</em>'s dependency graph. In the simple case,
        this is useful for breaking long lines naturally to improve the
        readability of the <em class="filename">makefile</em>:</p><a id="OEBPS/ch02.html.I_2_tt23"></a><pre class="programlisting">vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h 命令.h 变量.h vpath.h</pre><pre class="programlisting">vpath.o: vpath.c make.h config.h getopt.h gettext.h dep.h
vpath.o: filedef.h hash.h job.h commands.h variable.h vpath.h</pre><p>在更复杂的情况下，先决条件列表可以由管理方式截然不同的文件组成：</p><p>In more complex cases, the prerequisite list can be composed of
        files that are managed very differently:</p><a id="OEBPS/ch02.html.I_2_tt24"></a><pre class="programlisting"># 确保在编译 vpath.c 之前创建 lexer.c。
vpath.o: 词法分析器.c
...
# 使用特殊标志编译 vpath.c。
vpath.o: vpath.c
        $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $&lt;
...
# 包含程序生成的依赖项。
包括自动生成的依赖项.d</pre><pre class="programlisting"># Make sure lexer.c is created before vpath.c is compiled.
vpath.o: lexer.c
...
# Compile vpath.c with special flags.
vpath.o: vpath.c
        $(COMPILE.c) $(RULE_FLAGS) $(OUTPUT_OPTION) $&lt;
...
# Include dependencies generated by a program.
include auto-generated-dependencies.d</pre><p>第一条规则表示，每当更新<em class="filename">lexer.c</em>时，都必须更新
        <em class="filename">vpath.o目标（可能是因为生成</em><em class="filename">lexer.c</em>具有其他副作用）。该规则还可以确保先决条件始终在目标更新之前更新。 （注意规则的双向性质。在“向前”方向，规则表示如果 lexer.c<em class="filename">已</em>更新，则执行更新<em class="filename">vpath.o</em>的操作。在“向后”方向，规则表示如果我们需要制作或使用<em class="filename">vpath.o</em>确保<em class="filename">lexer.c</em>首先是最新的。）此规则可能会放置在管理<em class="filename">lexer.c</em>的规则附近，以便提醒开发人员这种微妙的关系。随后， <em class="filename">vpath.o</em>的编译规则被放置在其他编译规则中。此规则的命令使用三个<em class="command">make</em>变量。您将看到很多这样的变量，但现在您只需要知道变量是美元符号后跟单个字符或美元符号后跟括号中的单词。 （我将在本章后面解释更多内容，并在<a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">第 3 章</a>中解释更多内容。）最后，<em class="filename">.o</em> / <em class="filename">.h</em>依赖项包含在
        由外部程序管理的单独文件的<em class="filename">makefile中。</em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><em class="filename"></em><em class="filename"></em><em class="filename"></em></p><p>The first rule says that the <em class="filename">vpath.o</em> target must be updated whenever
        <em class="filename">lexer.c</em> is updated (perhaps
        because generating <em class="filename">lexer.c</em> has
        other side effects). The rule also works to ensure that a prerequisite
        is always updated before the target is updated. (Notice the
        bidirectional nature of rules. In the "forward" direction the rule
        says that if the <em class="filename">lexer.c</em> has been
        updated, perform the action to update <em class="filename">vpath.o</em>. In the "backward" direction, the
        rule says that if we need to make or use <em class="filename">vpath.o</em> ensure that <em class="filename">lexer.c</em> is up to date first.) This rule
        might be placed near the rules for managing <em class="filename">lexer.c</em> so developers are reminded of this
        subtle relationship. Later, the compilation rule for <em class="filename">vpath.o</em> is placed among other compilation
        rules. The command for this rule uses three <em class="command">make</em> variables. You'll be seeing a lot of
        these, but for now you just need to know that a variable is either a
        dollar sign followed by a single character or a dollar sign followed
        by a word in parentheses. (I will explain more later in this chapter
        and a lot more in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>.)
        Finally, the <em class="filename">.o</em>/<em class="filename">.h</em> dependencies are included in the
        <em class="filename">makefile</em> from a separate file
        managed by an external program.</p><div class="sect2" title="通配符"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02.html.make3-CHP-2-SECT-1.1"></a>通配符</h2><h2 class="title"><a></a>Wildcards</h2></div></div></div><p>一个<em class="filename">makefile</em>通常包含<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-843" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-844" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-845" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-846" class="indexterm"></a>长的<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-847" class="indexterm"></a>文件列表。为了简化此过程，<em class="command">make</em>支持通配符（也称为
          <em class="firstterm">globbing</em>）。<em class="command">make</em>的通配符与 Bourne shell 的通配符相同：<code class="literal">~</code>、<code class="literal">*</code>、<code class="literal">?</code>、
          <code class="literal">[...]</code>和<code class="literal">[^...]</code>。例如，<code class="literal">*.*</code>扩展到包含句点的所有文件。一个问号<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-848" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-849" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-850" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-851" class="indexterm"></a>代表任意单个字符，<code class="literal">[...]</code>代表一个<em class="firstterm">字符类</em>。要选择“相反”（否定）字符类，请使用<code class="literal">[^...]</code>。</p><p>A <em class="filename">makefile</em> often
          contains<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> long <a class="indexterm"></a>lists of files. To simplify this process <em class="command">make</em> supports wildcards (also known as
          <em class="firstterm">globbing</em>). <em class="command">make</em>'s wildcards are identical to the
          Bourne shell's: <code class="literal">~</code>, <code class="literal">*</code>, <code class="literal">?</code>,
          <code class="literal">[...]</code>, and <code class="literal">[^...]</code>. For instance, <code class="literal">*.*</code> expands to all the files containing a
          period. A question mark <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>represents any single character, and <code class="literal">[...]</code> represents a <em class="firstterm">character
          class</em>. To select the "opposite" (negated) character
          class use <code class="literal">[^...]</code>.</p><p>此外，波形符 ( <code class="literal">~</code>) 字符<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-852" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-853" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-854" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-855" class="indexterm"></a>可以用来表示当前用户的主目录。波浪号后跟用户名代表该用户的主目录。</p><p>In addition, the tilde (<code class="literal">~</code>)
          character <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>can be used to represent the current user's home
          directory. A tilde followed by a user name represents that user's
          home directory.</p><p>只要通配符出现在目标、先决条件或命令脚本上下文中，<em class="command">make</em>就会自动扩展通配符。其他<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-856" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-857" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-858" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-859" class="indexterm"></a>在上下文中，通配符可以通过调用函数来显式扩展。通配符对于创建适应性更强的<em class="filename">makefile</em>非常有用。例如，您可以使用通配符，而不是显式列出程序中的所有文件：<sup>[ <a id="OEBPS/ch02.html.make3-CHP-2-FNOTE-1" href="#OEBPS/ch02.html.ftn.make3-CHP-2-FNOTE-1" class="footnote">1</a> ]</sup></p><p>Wildcards are automatically expanded by <em class="command">make</em> whenever a wildcard appears in a
          target, prerequisite, or command script context. In other <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>contexts, wildcards can be expanded explicitly by
          calling a function. Wildcards can be very useful for creating more
          adaptable <em class="filename">makefile</em>s. For
          instance, instead of listing all the files in a program explicitly,
          you can use wildcards:<sup>[<a href="#OEBPS/ch02.html.ftn.make3-CHP-2-FNOTE-1" class="footnote">1</a>]</sup></p><a id="OEBPS/ch02.html.I_2_tt25"></a><pre class="programlisting">程序：*.c
        $(CC) -o $@ $^</pre><pre class="programlisting">prog: *.c
        $(CC) -o $@ $^</pre><p>小心使用通配符很重要，<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-860" class="indexterm"></a>然而。它们很容易被误用，如下例所示：</p><p>It is important to be careful with wildcards, <a class="indexterm"></a>however. It is easy to misuse them as the following
          example shows:</p><a id="OEBPS/ch02.html.I_2_tt26"></a><pre class="programlisting">*.o：常量.h</pre><pre class="programlisting">*.o: constants.h</pre><p>意图很明确：所有目标文件都依赖于头文件<em class="filename">constant.h</em>，但请考虑它如何在没有任何目标文件的干净目录上扩展：</p><p>The intent is clear: all object files depend on the header
          file <em class="filename">constants.h</em>, but consider
          how this expands on a clean directory without any object
          files:</p><a id="OEBPS/ch02.html.I_2_tt27"></a><pre class="programlisting">：常量.h</pre><pre class="programlisting">: constants.h</pre><p>这是一个合法的<em class="command">make</em>
          表达式，本身不会产生错误，但它也不会提供用户想要的依赖项。实现此规则的正确方法是对源文件执行通配符（因为它们始终存在）并将其转换为目标文件列表。当我们在<a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">第 4 章讨论</a><em class="command">make</em>函数时，我们将介绍这项技术。<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a></p><p>This is a legal <em class="command">make</em>
          expression and will not produce an error by itself, but it will also
          not provide the dependency the user wants. The proper way to
          implement this rule is to perform a wildcard on the source files
          (since they are always present) and transform that into a list of
          object files. We will cover this technique when we discuss <em class="command">make</em> functions in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>.</p><p>当 mp_make 扩展通配符时（或者实际上当 mp_make 查找任何文件时），它会读取并缓存目录内容。这种缓存显着提高了 mp_make 的性能。但是，一旦 mp_make 读取并缓存了目录内容，mp_make 将不会“看到”对该目录所做的任何更改。这可能是 mp_makefile 中神秘的错误来源。有时可以通过使用子 shell 和通配符（例如 shell 通配符）而不是 mp_make 自己的通配符来解决该问题，但有时这是不可能的，我们必须诉诸奇怪的技巧。</p><p>When mp_make expands a wildcard (or indeed when mp_make looks
          for any file), it reads and caches the directory contents. This
          caching improves mp_make's performance considerably. However, once
          mp_make has read and cached the directory contents, mp_make will not
          "see" any changes made to the directory. This can be a mysterious
          source of errors in a mp_makefile. The issue can sometimes be
          resolved by using a sub-shell and globbing (e.g., shell wildcards)
          rather than mp_make's own wildcards, but occasionally, this is not
          possible and we must resort to bizarre hacks. </p><p>最后，值得注意的是，当模式作为目标或先决条件出现时，<em class="command">make</em>会执行通配符扩展。但是，当该模式出现在命令中时，扩展由子 shell 执行。有时这可能很重要，因为<em class="command">make会在读取</em><em class="filename">makefile</em>后立即扩展通配符，但 shell 会在执行命令时很晚才扩展命令中的通配符。当进行大量复杂的文件操作时，两个通配符扩展可能会有很大不同。</p><p>Finally, it is worth noting that wildcard expansion is
          performed by <em class="command">make</em> when the
          pattern appears as a target or prerequisite. However, when the
          pattern appears in a command, the expansion is performed by the
          subshell. This can occasionally be important because <em class="command">make</em> will expand the wildcards immediately
          upon reading the <em class="filename">makefile</em>, but
          the shell will expand the wildcards in commands much later when the
          command is executed. When a lot of complex file manipulation is
          being done, the two wildcard expansions can be quite
          different.</p></div><div class="sect2" title="虚假目标"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02.html.make3-CHP-2-SECT-1.2"></a>虚假目标</h2><h2 class="title"><a></a>Phony Targets</h2></div></div></div><p>到目前为止，所有目标和<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-861" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-862" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-863" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-864" class="indexterm"></a>先决条件是要创建或更新的文件。这是典型的情况，但对于仅代表命令脚本的标签来说，目标通常很有用。例如，之前我们注意到许多
          <em class="filename">makefile</em>中的标准第一个目标称为<code class="literal">all</code>。不代表文件的目标称为<em class="firstterm">虚假目标</em>。另一个标准的虚假目标是<code class="literal">clean</code>：</p><p>Until now all targets and <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>prerequisites have been files to be created or
          updated. This is typically the case, but it is often useful for a
          target to be just a label representing a command script. For
          instance, earlier we noted that a standard first target in many
          <em class="filename">makefile</em>s is called <code class="literal">all</code>. Targets that do not represent files
          are known as <em class="firstterm">phony targets</em>. Another standard
          phony target is <code class="literal">clean</code>:</p><a id="OEBPS/ch02.html.I_2_tt28"></a><pre class="programlisting">干净的：
        rm -f *.o 词法分析器.c</pre><pre class="programlisting">clean:
        rm -f *.o lexer.c</pre><p>通常，虚假目标将始终被执行，因为与规则关联的命令不会创建目标名称。</p><p>Normally, phony targets will always be executed because the
          commands associated with the rule do not create the target
          name.</p><p>需要注意的是，<em class="command">make</em>无法区分文件目标和虚假目标。如果假冒目标的名称偶然以文件形式存在，则<em class="command">make</em>会将该文件与其依赖关系图中的假冒目标名称关联起来。例如，如果运行<em class="command">make </em><em class="command">clean</em>碰巧创建了
          <em class="filename">clean</em>文件，则会产生令人困惑的消息：<em class="command"></em> <em class="command"></em></p><p>It is important to note that <em class="command">make</em> cannot distinguish between a file
          target and phony target. If by chance the name of a phony target
          exists as a file, <em class="command">make</em> will
          associate the file with the phony target name in its dependency
          graph. If, for example, the file <em class="filename">clean</em> happened to be created running
          <em class="command">make</em> <em class="command">clean</em> would yield the confusing
          message:</p><a id="OEBPS/ch02.html.I_2_tt29"></a><pre class="programlisting">$ 清理干净
make：“clean”是最新的。</pre><pre class="programlisting">$ make clean
make: `clean' is up to date.</pre><p>由于大多数虚假目标不<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-865" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-866" class="indexterm"></a>如果有先决条件，<code class="literal">clean</code>目标将始终被认为是最新的并且永远不会执行。</p><p>Since most phony targets do not <a class="indexterm"></a> <a class="indexterm"></a>have prerequisites, the <code class="literal">clean</code> target would always be considered up
          to date and would never execute.</p><p>为了避免这个问题，<acronym class="acronym">GNU </acronym> <em class="command">make</em>包含一个特殊的目标 ，<code class="literal">.PHONY</code>来告诉<em class="command">make</em>目标不是真正的文件。任何目标都可以通过将其作为以下先决条件来声明为虚假目标
          <code class="literal">.PHONY</code>：</p><p>To avoid this problem, <acronym class="acronym">GNU</acronym> <em class="command">make</em> includes a special target, <code class="literal">.PHONY</code>, to tell <em class="command">make</em> that a target is not a real file. Any
          target can be declared phony by including it as a prerequisite of
          <code class="literal">.PHONY</code>:</p><a id="OEBPS/ch02.html.I_2_tt30"></a><pre class="programlisting">.PHONY：干净
干净的：
        rm -f *.o 词法分析器.c</pre><pre class="programlisting">.PHONY: clean
clean:
        rm -f *.o lexer.c</pre><p>现在，即使存在名为<em class="filename">clean 的文件， </em><em class="command">make</em>也将始终执行关联的命令。除了将目标标记为始终过期之外，指定目标是虚假的还可以告诉<em class="command">make</em>该文件不遵循从源文件创建目标文件的正常规则。因此，<em class="command">make</em>可以优化其正常的规则搜索以提高性能。<code class="literal">clean</code><em class="filename"></em><em class="command"></em><em class="command"></em></p><p>Now <em class="command">make</em> will always
          execute the commands associated with <code class="literal">clean</code> even if a file named <em class="filename">clean</em> exists. In addition to marking a
          target as always out of date, specifying that a target is phony
          tells <em class="command">make</em> that this file does
          not follow the normal rules for making a target file from a source
          file. Therefore, <em class="command">make</em> can
          optimize its normal rule search to improve performance.</p><p>使用虚假目标作为真实文件的先决条件几乎没有意义，因为虚假目标总是过时的，并且总是会导致目标文件被重新制作。然而，为虚假目标提供先决条件通常很有用。例如，<code class="literal">all</code>目标通常会给出要构建的程序列表：</p><p>It rarely makes sense to use a phony target as a prerequisite
          of a real file since the phony is always out of date and will always
          cause the target file to be remade. However, it is often useful to
          give phony targets prerequisites. For instance, the <code class="literal">all</code> target is usually given the list of
          programs to be built:</p><a id="OEBPS/ch02.html.I_2_tt31"></a><pre class="programlisting">.PHONY：全部
全部： bash bashbug</pre><pre class="programlisting">.PHONY: all
all: bash bashbug</pre><p>这里<code class="literal">all</code>目标创建<em class="command">bash</em> shell 程序和
          <em class="command">bashbug</em>错误报告工具。</p><p>Here the <code class="literal">all</code> target creates
          the <em class="command">bash</em> shell program and the
          <em class="command">bashbug</em> error reporting
          tool.</p><p>虚假目标也可以被视为嵌入<em class="filename">makefile</em>中的 shell 脚本。将虚假目标设置为另一个目标的先决条件将在创建实际目标之前调用虚假目标脚本。假设我们的磁盘空间紧张，并且在执行磁盘密集型任务之前我们想要显示可用的磁盘空间。我们可以写：</p><p>Phony targets can also be thought of as shell scripts embedded
          in a <em class="filename">makefile</em>. Making a phony
          target a prerequisite of another target will invoke the phony target
          script before making the actual target. Suppose we are tight on disk
          space and before executing a disk-intensive task we want to display
          available disk space. We could write:</p><a id="OEBPS/ch02.html.I_2_tt32"></a><pre class="programlisting">.PHONY：制作文档
制作文档：
        df -k 。 | awk 'NR == 2 { printf("%d 个可用\n", $$4 ) }'
        javadoc ...</pre><pre class="programlisting">.PHONY: make-documentation
make-documentation:
        df -k . | awk 'NR =  = 2 { printf( "%d available\n", $$4 ) }'
        javadoc ...</pre><p>这里的问题是我们可能<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-867" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-868" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-869" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-870" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-871" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-872" class="indexterm"></a>最终在不同的目标下多次指定<em class="command">df</em>和<em class="command">awk</em>命令，这是一个维护问题，因为如果我们在另一个系统上遇到具有不同格式的<em class="command">df</em>，我们将不得不更改每个实例。相反，我们可以将<em class="command">df</em>线放置在它自己的虚假目标中：</p><p>The problem here is that we may <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>end up specifying the <em class="command">df</em> and <em class="command">awk</em> commands many times under different
          targets, which is a maintenance problem since we'll have to change
          every instance if we encounter a <em class="command">df</em> on another system with a different
          format. Instead, we can place the <em class="command">df</em> line in its own phony target:</p><a id="OEBPS/ch02.html.I_2_tt33"></a><pre class="programlisting">.PHONY：制作文档
制作文档：df
        javadoc ...

.PHONY: df
df：
        df -k 。 | awk 'NR == 2 { printf("%d 个可用\n", $$4 ) }'</pre><pre class="programlisting">.PHONY: make-documentation
make-documentation: df
        javadoc ...

.PHONY: df
df:
        df -k . | awk 'NR =  = 2 { printf( "%d available\n", $$4 ) }'</pre><p><em class="command">通过将df</em>作为 的先决条件，我们可以使<em class="command">make</em>在生成文档之前调用<em class="command">df</em>目标。这很有效，因为它也是一个虚假目标。现在我可以轻松地在其他目标中重用<em class="command">df 。</em><em class="command"></em><code class="literal">make-documentation</code><code class="literal">make-documentation</code><em class="command"></em></p><p>We can cause <em class="command">make</em> to invoke
          our <em class="command">df</em> target before generating
          the documentation by making <em class="command">df</em> a
          prerequisite of <code class="literal">make-documentation</code>. This works well
          because <code class="literal">make-documentation</code> is
          also a phony target. Now I can easily reuse <em class="command">df</em> in other targets.</p><p>虚假目标还有许多其他好的用途。</p><p>There are a number of other good uses for phony
          targets.</p><p><em class="command">make</em>的输出可能会让人难以阅读<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-873" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-874" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-875" class="indexterm"></a>并调试。造成这种情况的原因有几个：
           <em class="filename">makefile</em>是自上而下编写的，而<em class="command">make</em>命令是自下而上执行的；此外，没有迹象表明当前正在评估哪条规则。如果在<em class="command">make输出中注释了主要目标，则</em><em class="command">make</em>的输出
          会更容易阅读。虚假目标是实现这一目标的有效方法。以下是取自<em class="command">bash </em><em class="filename">makefile</em>的示例：<em class="command"></em><em class="command"></em> <em class="filename"></em></p><p>The output of <em class="command">make</em> can be
          confusing to read <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>and debug. There are several reasons for this:
          <em class="filename">makefile</em>s are written top-down
          but the commands are executed by <em class="command">make</em> bottom-up; also, there is no
          indication which rule is currently being evaluated. The output of
          <em class="command">make</em> can be made much easier to
          read if major targets are commented in the <em class="command">make</em> output. Phony targets are a useful
          way to accomplish this. Here is an example taken from the <em class="command">bash</em> <em class="filename">makefile</em>:</p><a id="OEBPS/ch02.html.I_2_tt34"></a><pre class="programlisting">$（程序）：build_msg $（对象）$（BUILTINS_DEP）$（LIBDEP）
        $(RM) $@
        $(CC) $(LDFLAGS) -o $(程序) $(对象) $(LIBS)
        ls -l $(程序)
        大小$(程序)

.PHONY：build_msg
构建消息：
        @printf“#\n# 构建 $(程序)\n#\n”</pre><pre class="programlisting">$(Program): build_msg $(OBJECTS) $(BUILTINS_DEP) $(LIBDEP)
        $(RM) $@
        $(CC) $(LDFLAGS) -o $(Program) $(OBJECTS) $(LIBS)
        ls -l $(Program)
        size $(Program)

.PHONY: build_msg
build_msg:
        @printf "#\n# Building $(Program)\n#\n"</pre><p>由于<em class="command">printf</em>位于虚假目标中，因此会在更新任何先决条件之前立即打印该消息。如果构建消息被放置为<code class="literal">$(Program)</code>命令脚本的第一个命令，那么它将在所有编译和依赖项生成之后执行。需要注意的是，由于假目标总是过时的，因此即使假<code class="literal">build_msg</code>目标
          <code class="literal">$(Program)</code>没有过时，也会导致重新生成。在这种情况下，这似乎是一个合理的选择，因为大部分计算是在编译目标文件时执行的，因此始终只执行最终链接。</p><p>Because the <em class="command">printf</em> is in a
          phony target, the message is printed immediately before any
          prerequisites are updated. If the build message were instead placed
          as the first command of the <code class="literal">$(Program)</code> command script, then it would
          be executed after all compilation and dependency generation. It is
          important to note that because phony targets are always out of date,
          the phony <code class="literal">build_msg</code> target causes
          <code class="literal">$(Program)</code> to be regenerated even
          when it is not out of date. In this case, it seems a reasonable
          choice since most of the computation is performed while compiling
          the object files so only the final link will always be
          performed.</p><p>虚假目标也可用于<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-876" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-877" class="indexterm"></a><em class="filename">改进makefile</em>的“用户界面” 。通常目标是包含目录路径元素、附加文件名组件（例如版本号）和标准后缀的复杂字符串。这可能会使在命令行上指定目标文件名成为一项挑战。可以通过添加一个简单的虚假目标来避免该问题，其先决条件是实际的目标文件。</p><p>Phony targets can also be used to <a class="indexterm"></a> <a class="indexterm"></a>improve the "user interface" of a <em class="filename">makefile</em>. Often targets are complex
          strings containing directory path elements, additional filename
          components (such as version numbers) and standard suffixes. This can
          make specifying a target filename on the command line a challenge.
          The problem can be avoided by adding a simple phony target whose
          prerequisite is the actual target file.</p><p>按照惯例，有一组<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-878" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-879" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-880" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-881" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-882" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-883" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-884" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-885" class="indexterm"></a><em class="filename">许多makefile</em>或多或少都
          包含标准的虚假目标。<a class="link" href="#OEBPS/ch02.html.make3-CHP-2-TABLE-1" title="表 2-1。标准虚假目标">表 2-1</a>列出了这些标准目标。</p><p>By convention there are a set of <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>more or less standard phony targets that many
          <em class="filename">makefile</em>s include. <a class="link" href="#OEBPS/ch02.html.make3-CHP-2-TABLE-1" title="Table&nbsp;2-1.&nbsp;Standard phony targets">Table 2-1</a> lists these standard
          targets.</p><div class="table"><a id="OEBPS/ch02.html.make3-CHP-2-TABLE-1"></a><p class="title">表 2-1。标准虚假目标</p><p class="title">Table&nbsp;2-1.&nbsp;Standard phony targets</p><div class="table-contents"><table summary="Standard phony targets" style="border-collapse:collapse;border-top:0.5pt solid;border-bottom:0.5pt solid;border-left:0.5pt solid;border-right:0.5pt solid"><colgroup><col><col></colgroup><thead><tr><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>目标</p><p>Target</p></th><th style="border-bottom:0.5pt solid"><p>功能</p><p>Function</p></th></tr></thead><tbody><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">all</code>
                  </p><p> <code class="literal">all</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>执行构建应用程序的所有任务</p><p>Perform all tasks to build the
                  application</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">install</code>
                  </p><p> <code class="literal">install</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>从编译的二进制文件创建应用程序的安装</p><p>Create an installation of the application from
                  the compiled binaries</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">clean</code>
                  </p><p> <code class="literal">clean</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>删除从源生成的二进制文件</p><p>Delete the binary files generated from
                  sources</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">distclean</code>
                  </p><p> <code class="literal">distclean</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>删除原始源发行版中不存在的所有生成文件</p><p>Delete all the generated files that were not in
                  the original source distribution</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">TAGS</code>
                  </p><p> <code class="literal">TAGS</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>创建一个标签表供编辑者使用</p><p>Create a tags table for use by
                  editors</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">info</code>
                  </p><p> <code class="literal">info</code>
                  </p></td><td style="border-bottom:0.5pt solid"><p>从 Texinfo 源创建<acronym class="acronym">GNU信息文件</acronym></p><p>Create <acronym class="acronym">GNU</acronym> info files from
                  their Texinfo sources</p></td></tr><tr><td style="border-right:0.5pt solid"><p> <code class="literal">check</code>
                  </p><p> <code class="literal">check</code>
                  </p></td><td style=""><p>运行与此应用程序相关的任何测试</p><p>Run any tests associated with this
                  application</p></td></tr></tbody></table></div></div><p>该目标<code class="literal">TAGS</code>并不是真正的假目标，因为<em class="command">ctags</em>和<em class="command">etags</em>程序的输出是一个名为<em class="filename">TAGS</em>的文件。之所以将其包含在此处，是因为它是我们所知的唯一标准非虚假目标。</p><p>The target <code class="literal">TAGS</code> is not
          really a phony since the output of the <em class="command">ctags</em> and <em class="command">etags</em> programs is a file named <em class="filename">TAGS</em>. It is included here because it is
          the only standard nonphony target we know of.</p></div><div class="sect2" title="空目标"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02.html.make3-CHP-2-SECT-1.3"></a>空目标</h2><h2 class="title"><a></a>Empty Targets</h2></div></div></div><p>空目标类似于<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-886" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-887" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-888" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-889" class="indexterm"></a><em class="command">虚假目标，因为目标本身被用作利用make</em>功能的设备。虚假目标总是过时的，因此它们总是执行，并且总是导致其
          <em class="firstterm">依赖项</em>（与先决条件关联的目标）被重新创建。但是假设我们有一些命令，没有输出文件，只需要偶尔执行，并且我们不希望更新我们的依赖项？为此，我们可以制定一个规则，其目标<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-890" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-891" class="indexterm"></a>是一个空文件（有时称为 cookie）：</p><p>Empty targets are similar to <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>phony targets in that the target itself is used as a
          device to leverage the capabilities of <em class="command">make</em>. Phony targets are always out of
          date, so they always execute and they always cause their
          <em class="firstterm">dependent</em> (the target associated with the
          prerequisite) to be remade. But suppose we have some command, with
          no output file, that needs to be performed only occasionally and we
          don't want our dependents updated? For this, we can make a rule
          whose target <a class="indexterm"></a> <a class="indexterm"></a>is an empty file (sometimes referred to as a
          cookie):</p><a id="OEBPS/ch02.html.I_2_tt35"></a><pre class="programlisting">prog: 大小 prog.o
        $(CC) $(LDFLAGS) -o $@ $^

尺寸：prog.o
        尺寸$^
        触摸尺寸</pre><pre class="programlisting">prog: size prog.o
        $(CC) $(LDFLAGS) -o $@ $^

size: prog.o
        size $^
        touch size</pre><p>请注意，该<code class="literal">size</code>规则在完成后使用<em class="command">touch</em>创建一个名为<em class="filename">size 的</em>空文件。该空文件用于其<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-892" class="indexterm"></a>时间戳，以便<em class="command">make</em><code class="literal">size</code>仅当<em class="filename">prog.o</em>更新时才执行规则。此外，
           <em class="filename">prog</em><code class="literal">size</code>的先决条件不会强制更新
          <em class="filename">prog</em>，除非其目标文件也较新。<em class="filename"></em><em class="filename"></em></p><p>Notice that the <code class="literal">size</code> rule
          uses <em class="command">touch</em> to create an empty
          file named <em class="filename">size</em> after it
          completes. This empty file is used for its <a class="indexterm"></a>timestamp so that <em class="command">make</em> will execute the <code class="literal">size</code> rule only when <em class="filename">prog.o</em> has been updated. Furthermore, the
          <code class="literal">size</code> prerequisite to <em class="filename">prog</em> will not force an update of
          <em class="filename">prog</em> unless its object file is
          also newer.</p><p>空文件特别有用<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-893" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-894" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-895" class="indexterm"></a>与自动变量结合使用时<code class="literal">$?</code>。我们在<a class="link" href="#OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1" title="自动变量">第 2.2.1 节</a>中讨论自动变量
          ，但预览该变量不会有什么坏处。在规则的命令脚本部分中，<em class="command">make</em>将变量定义<code class="literal">$?</code>为比目标更新的先决条件集。下面是打印自上次执行<em class="command">make print以来已更改的所有文件的规则：</em></p><p>Empty files are particularly useful <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>when combined with the automatic variable <code class="literal">$?</code>. We discuss automatic variables in
          <a class="link" href="#OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1" title="Automatic Variables">Section 2.2.1</a>, but a
          preview of this variable won't hurt. Within the command script part
          of a rule, <em class="command">make</em> defines the
          variable <code class="literal">$?</code> to be the set of
          prerequisites that are newer than the target. Here is a rule to
          print all the files that have changed since the last time <em class="command">make print</em> was executed:</p><a id="OEBPS/ch02.html.I_2_tt36"></a><pre class="programlisting">打印：*.[hc]
        lpr$？
        触摸$@</pre><pre class="programlisting">print: *.[hc]
        lpr $?
        touch $@</pre><p>一般情况下可以使用空文件<a id="OEBPS/ch02.html.make3-CHP-2-ITERM-896" class="indexterm"></a> <a id="OEBPS/ch02.html.make3-CHP-2-ITERM-897" class="indexterm"></a>标记最后一次发生特定事件的时间。</p><p>Generally, empty files can be used <a class="indexterm"></a> <a class="indexterm"></a>to mark the last time a
          particular event has taken place.</p></div></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch02.html.ftn.make3-CHP-2-FNOTE-1" href="#OEBPS/ch02.html.make3-CHP-2-FNOTE-1" class="para">1</a> ]</sup>在更受控制的环境中，使用通配符选择程序中的文件被认为是不好的做法，因为恶意源文件可能会意外链接到程序中。</p><p><sup>[<a href="#OEBPS/ch02.html.make3-CHP-2-FNOTE-1" class="para">1</a>] </sup>In more controlled environments using wildcards to select
              the files in a program is considered bad practice because a
              rogue source file might be accidentally linked into a
              program.</p></div></div></div></div></div>
<div id="OEBPS/ch02s02.html"><div>
<div class="sect1" title="变量"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s02.html.make3-CHP-2-SECT-2"></a>变量</h1><h1 class="title"><a></a>Variables</h1></div></div></div><p>让我们看看一些变量<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-898" class="indexterm"></a>我们一直在我们的例子中使用。最简单的语法如下：</p><p>Let's look at some of the variables <a class="indexterm"></a>we have been using in our examples. The simplest ones
        have the syntax:</p><a id="OEBPS/ch02s02.html.I_2_tt37"></a><pre class="programlisting">$( <em class="replaceable"><code>variable-name</code></em>)</pre><pre class="programlisting">$(<em class="replaceable"><code>variable-name</code></em>)</pre><p>这表明我们要<em class="firstterm">扩展</em>名为 的变量<em class="replaceable"><code>variable-name</code></em>。变量可以包含几乎任何文本，变量名称可以包含大多数字符，包括标点符号。<code class="literal">COMPILE.c</code>例如，包含 C 编译命令的变量是。一般来说，变量名必须被 make 包围<code class="literal">$( )</code>或被<em class="command">make</em><code class="literal">${ }
        </code>识别。作为特殊情况，单字符变量名不需要括号。<em class="command"></em></p><p>This indicates that we want to <em class="firstterm">expand</em> the
        variable whose name is <em class="replaceable"><code>variable-name</code></em>.
        Variables can contain almost any text, and variable names can contain
        most characters including punctuation. The variable containing the C
        compile command is <code class="literal">COMPILE.c</code>, for
        example. In general, a variable name must be surrounded by <code class="literal">$( )</code> or <code class="literal">${ }
        </code>to be recognized by <em class="command">make</em>.
        As a special case, a single character variable name does not require
        the parentheses.</p><p>makefile通常会定义许多变量，但也有许多由<em class="command">make自动定义</em><em class="filename">的</em>特殊变量。有些可以由用户设置来控制<em class="command">make</em>的行为，而另一些则可以由
        <em class="command">make</em>设置来与用户的
        <em class="filename">makefile</em>进行通信。<em class="command"></em><em class="command"></em><em class="command"></em><em class="filename"></em></p><p>A <em class="filename">makefile</em> will typically
        define many variables, but there are also many special variables
        defined automatically by <em class="command">make</em>. Some
        can be set by the user to control <em class="command">make</em>'s behavior while others are set by
        <em class="command">make</em> to communicate with the user's
        <em class="filename">makefile</em>.</p><div class="sect2" title="自动变量"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1"></a>自动变量</h2><h2 class="title"><a></a>Automatic Variables</h2></div></div></div><p><em class="firstterm">自动变量由</em><em class="command">make</em>设置<em class="command"></em> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-899" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-900" class="indexterm"></a>规则之后<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-901" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-902" class="indexterm"></a>已匹配。它们提供对目标和先决条件列表中的元素的访问，因此您不必显式指定任何文件名。它们对于避免代码重复非常有用，但在定义更通用的模式规则（稍后讨论）时至关重要。</p><p><em class="firstterm">Automatic variables</em> are set by <em class="command">make</em> <a class="indexterm"></a> <a class="indexterm"></a>after a rule <a class="indexterm"></a> <a class="indexterm"></a>is matched. They provide access to elements from the
          target and prerequisite lists so you don't have to explicitly
          specify any filenames. They are very useful for avoiding code
          duplication, but are critical when defining more general pattern
          rules (discussed later).</p><p>有七个“核心”自动<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-903" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-904" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-905" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-906" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-907" class="indexterm"></a> <a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-908" class="indexterm"></a>变量：</p><p>There are seven "core" automatic <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>variables:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$@</code></span></dt><dt><span class="term"><code class="literal">$@</code></span></dt><dd><p>文件名代表<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-909" class="indexterm"></a>目标。</p></dd><dd><p>The filename representing <a class="indexterm"></a>the target.</p></dd><dt><span class="term"><code class="literal">$%</code></span></dt><dt><span class="term"><code class="literal">$%</code></span></dt><dd><p>的文件名元素<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-910" class="indexterm"></a>存档成员规范。</p></dd><dd><p>The filename element of an <a class="indexterm"></a>archive member specification.</p></dd><dt><span class="term"><code class="literal">$&lt;</code></span></dt><dt><span class="term"><code class="literal">$&lt;</code></span></dt><dd><p>第一个的文件名<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-911" class="indexterm"></a>前提条件。</p></dd><dd><p>The filename of the first <a class="indexterm"></a>prerequisite.</p></dd><dt><span class="term"><code class="literal">$?</code></span></dt><dt><span class="term"><code class="literal">$?</code></span></dt><dd><p>所有人的名字<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-912" class="indexterm"></a>比目标新的先决条件，以空格分隔。</p></dd><dd><p>The names of all <a class="indexterm"></a>prerequisites that are newer than the target,
                separated by spaces.</p></dd><dt><span class="term"><code class="literal">$^</code></span></dt><dt><span class="term"><code class="literal">$^</code></span></dt><dd><p>所有的文件名<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-913" class="indexterm"></a>先决条件，用空格分隔。该列表删除了重复的文件名，因为对于大多数用途，例如编译、复制等，不需要重复的文件名。</p></dd><dd><p>The filenames of all the <a class="indexterm"></a>prerequisites, separated by spaces. This list
                has duplicate filenames removed since for most uses, such as
                compiling, copying, etc., duplicates are not wanted.</p></dd><dt><span class="term"><code class="literal">$+</code></span></dt><dt><span class="term"><code class="literal">$+</code></span></dt><dd><p>类似于<code class="literal">$^</code>，这是的名称<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-914" class="indexterm"></a>所有先决条件均以空格分隔，但<code class="literal">$+</code>包含重复项除外。该变量是为特定情况创建的，例如重复值有意义的链接器参数。</p></dd><dd><p>Similar to <code class="literal">$^</code>, this
                is the names of <a class="indexterm"></a>all the prerequisites separated by spaces,
                except that <code class="literal">$+</code> includes
                duplicates. This variable was created for specific situations
                such as arguments to linkers where duplicate values have
                meaning.</p></dd><dt><span class="term"><code class="literal">$*</code></span></dt><dt><span class="term"><code class="literal">$*</code></span></dt><dd><p>目标文件名的主干。 A<a id="OEBPS/ch02s02.html.make3-CHP-2-ITERM-915" class="indexterm"></a>Stem 通常是不带后缀的文件名。 （我们将在<a class="link" href="#OEBPS/ch02s04.html" title="模式规则">第 2.4 节</a>稍后讨论如何计算词干。）不鼓励在模式规则之外使用它。</p></dd><dd><p>The stem of the target filename. A <a class="indexterm"></a>stem is typically a filename without its suffix.
                (We'll discuss how stems are computed later in <a class="link" href="#OEBPS/ch02s04.html" title="Pattern Rules">Section 2.4</a>.) Its use
                outside of pattern rules is discouraged.</p></dd></dl></div><p>另外，上面的每个变量都有两个变体，以便与其他<em class="command">make</em>兼容。一种变体仅返回值的目录部分。这通过在符号 、 等后面附加“D”来指示。<code class="literal">$(@D)</code>另一个<code class="literal">$(&lt;D)</code>变体仅返回值的文件部分。这是通过在符号、 、 等后面附加一个 F 来表示的。<code class="literal">$(@F)</code>请
          <code class="literal">$(&lt;F)</code>注意，这些变体名称的长度超过一个字符，因此必须用括号括起来。<acronym class="acronym">GNU </acronym> <em class="command">make</em><code class="function">dir</code>通过和函数提供了更具可读性的替代方案<code class="function">notdir</code>。我们将在<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>中讨论函数。</p><p>In addition, each of the above variables has two variants for
          compatibility with other <em class="command">make</em>s.
          One variant returns only the directory portion of the value. This is
          indicated by appending a "D" to the symbol, <code class="literal">$(@D)</code>, <code class="literal">$(&lt;D)</code>, etc. The other variant returns
          only the file portion of the value. This is indicated by appending
          an F to the symbol, <code class="literal">$(@F)</code>,
          <code class="literal">$(&lt;F)</code>, etc. Note that these
          variant names are more than one character long and so must be
          enclosed in parentheses. <acronym class="acronym">GNU</acronym> <em class="command">make</em> provides a more readable alternative
          with the <code class="function">dir</code> and <code class="function">notdir</code> functions. We will discuss
          functions in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>.</p><p>自动变量是在规则与其目标和先决条件匹配后由<em class="command">make设置的，因此这些变量仅在规则的命令脚本中可用。</em></p><p>Automatic variables are set by <em class="command">make</em> after a rule has been matched with
          its target and prerequisites so the variables are only available in
          the command script of a rule.</p><p>这是我们的<em class="filename">makefile</em>，其中显式文件名被适当的自动变量替换。</p><p>Here is our <em class="filename">makefile</em> with
          explicit filenames replaced by the appropriate automatic
          variable.</p><a id="OEBPS/ch02s02.html.I_2_tt38"></a><pre class="programlisting">count_words: count_words.o counter.o lexer.o -lfl
        海湾合作委员会 $^ -o $@

count_words.o: count_words.c
        海湾合作委员会 -c $&lt;

计数器.o: 计数器.c
        海湾合作委员会 -c $&lt;

词法分析器.o: 词法分析器.c
        海湾合作委员会 -c $&lt;

词法分析器.c: 词法分析器.l
        弹性 -t $&lt; &gt; $@</pre><pre class="programlisting">count_words: count_words.o counter.o lexer.o -lfl
        gcc $^ -o $@

count_words.o: count_words.c
        gcc -c $&lt;

counter.o: counter.c
        gcc -c $&lt;

lexer.o: lexer.c
        gcc -c $&lt;

lexer.c: lexer.l
        flex -t $&lt; &gt; $@</pre></div></div></div></div>
<div id="OEBPS/ch02s03.html"><div>
<div class="sect1" title="使用 VPATH 和 vpath 查找文件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s03.html.make3-CHP-2-SECT-3"></a>使用 VPATH 和 vpath 查找文件</h1><h1 class="title"><a></a>Finding Files with VPATH and vpath</h1></div></div></div><p>到目前为止我们的例子是<a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-917" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-918" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-919" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-920" class="indexterm"></a>很简单，<em class="filename">makefile</em>和源代码都位于一个目录中。现实世界的程序更加复杂（您最后一次处理单个目录项目是什么时候？）。让我们重构我们的示例并创建更真实的文件布局。我们可以修改我们的<a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-921" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-922" class="indexterm"></a><code class="function">main</code>通过重构为一个名为 的函数来实现字数统计程序<code class="function">counter</code>。</p><p>Our examples so far have been <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>simple enough that the <em class="filename">makefile</em> and sources all lived in a single
        directory. Real world programs are more complex (when's the last time
        you worked on a single directory project?). Let's refactor our example
        and create a more realistic file layout. We can modify our <a class="indexterm"></a> <a class="indexterm"></a>word counting program by refactoring <code class="function">main</code> into a function called <code class="function">counter</code>.</p><a id="OEBPS/ch02s03.html.I_2_tt39"></a><pre class="programlisting">#include &lt;lexer.h&gt;
#include &lt;计数器.h&gt;

无效计数器（ int counts[4] ）
{
    而 ( yylex( ) )
        ;

    计数[0] = 费用计数；
    计数[1] = fie_count;
    计数[2] = 敌人计数；
    计数[3] = fum_count;
}</pre><pre class="programlisting">#include &lt;lexer.h&gt;
#include &lt;counter.h&gt;

void counter( int counts[4] )
{
    while ( yylex( ) )
        ;

    counts[0] = fee_count;
    counts[1] = fie_count;
    counts[2] = foe_count;
    counts[3] = fum_count;
}</pre><p>可重用的库函数应该<a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-923" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-924" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-925" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-926" class="indexterm"></a>头文件中有一个声明，因此让我们创建
        包含声明的<em class="filename">counter.h ：</em></p><p>A reusable library function should <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>have a declaration in a header file, so let's create
        <em class="filename">counter.h</em> containing our
        declaration:</p><a id="OEBPS/ch02s03.html.I_2_tt40"></a><pre class="programlisting">#ifndef COUNTER_H_
#定义COUNTER_H_

外部无效
计数器( i​​nt counts[4] );

＃万一</pre><pre class="programlisting">#ifndef COUNTER_H_
#define COUNTER_H_

extern void
counter( int counts[4] );

#endif</pre><p><em class="filename">我们还可以将lexer.l</em>符号的声明放在<em class="filename">lexer.h</em>中：</p><p>We can also place the declarations for our <em class="filename">lexer.l</em> symbols in <em class="filename">lexer.h</em>:</p><a id="OEBPS/ch02s03.html.I_2_tt41"></a><pre class="programlisting">#ifndef LEXER_H_
#定义LEXER_H_

extern int Fee_count、fie_count、foe_count、fum_count；
外部 int yylex( 无效 );

＃万一</pre><pre class="programlisting">#ifndef LEXER_H_
#define LEXER_H_

extern int fee_count, fie_count, foe_count, fum_count;
extern int yylex( void );

#endif</pre><p>在传统的源代码树布局中，头文件被放置
        <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-927" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-928" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-929" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-930" class="indexterm"></a><em class="filename">位于include</em>目录中
        ，源代码位于<em class="filename">src</em>目录中。我们将这样做并将我们的
        <em class="filename">makefile</em>放在父目录中。我们的示例程序现在具有<a class="link" href="#OEBPS/ch02s03.html.make3-CHP-2-FIG-1" title="图 2-1。源树布局示例">如图 2-1</a>所示的布局。</p><p>In a traditional source tree layout the header files are placed
        <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>in an <em class="filename">include</em>
        directory and the source is placed in a <em class="filename">src</em> directory. We'll do this and put our
        <em class="filename">makefile</em> in the parent directory.
        Our example program now has the layout shown in <a class="link" href="#OEBPS/ch02s03.html.make3-CHP-2-FIG-1" title="Figure&nbsp;2-1.&nbsp;Example source tree layout">Figure 2-1</a>.</p><div class="figure"><a id="OEBPS/ch02s03.html.make3-CHP-2-FIG-1"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch02s03.html.I_2_tt42"></a><img src="data:image/png;base64,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" width="152" alt="源树布局示例"></div></div><p class="title">图 2-1。源树布局示例</p><p class="title">Figure&nbsp;2-1.&nbsp;Example source tree layout</p></div><p>由于我们的源文件现在包含头文件，因此这些新的依赖项应该记录在我们的<em class="filename">makefile</em>中，以便当头文件被修改时，相应的目标文件将被更新。</p><p>Since our source files now include header files, these new
        dependencies should be recorded in our <em class="filename">makefile</em> so that when a header file is
        modified, the corresponding object file will be updated.</p><a id="OEBPS/ch02s03.html.I_2_tt43"></a><pre class="programlisting">count_words: count_words.o counter.o lexer.o -lfl
        海湾合作委员会 $^ -o $@

count_words.o: count_words.c include/counter.h
        海湾合作委员会 -c $&lt;

counter.o: counter.c include/counter.h include/lexer.h
        海湾合作委员会 -c $&lt;

lexer.o: lexer.c include/lexer.h
        海湾合作委员会 -c $&lt;

词法分析器.c: 词法分析器.l
        弹性 -t $&lt; &gt; $@</pre><pre class="programlisting">count_words: count_words.o counter.o lexer.o -lfl
        gcc $^ -o $@

count_words.o: count_words.c include/counter.h
        gcc -c $&lt;

counter.o: counter.c include/counter.h include/lexer.h
        gcc -c $&lt;

lexer.o: lexer.c include/lexer.h
        gcc -c $&lt;

lexer.c: lexer.l
        flex -t $&lt; &gt; $@</pre><p>现在，当我们运行<em class="filename">makefile</em>时，我们得到：</p><p>Now when we run our <em class="filename">makefile</em>, we get:</p><a id="OEBPS/ch02s03.html.I_2_tt44"></a><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
make: *** 没有规则可以创建“count_words.o”所需的目标“count_words.c”。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
make: *** No rule to make target `count_words.c', needed by `count_words.o'.  Stop.</pre><p>哎呀，发生什么事了？ makefile<em class="filename">正在</em>尝试更新<em class="filename">count_words.c</em>，但那是源文件！让我们“玩<em class="command">make</em> ”吧。我们的第一个先决条件是<em class="filename">count_words.o</em>。我们发现该文件丢失并寻找创建该文件的规则。创建<em class="filename">count_words.o</em>的显式规则
        引用<em class="filename">count_words.c</em>。但是为什么<em class="command">make</em>找不到源文件呢？因为源文件位于<em class="filename">src</em>目录而不是当前目录中。除非您另有指示，否则<em class="command">make</em>将仅在当前目录中查找其目标和先决条件。我们如何让<em class="command">make在</em><em class="filename">src</em>目录中查找源文件？或者，更一般地说，我们如何告诉<em class="command">make</em>
        我们的源代码在哪里？</p><p>Oops, what happened? The <em class="filename">makefile</em> is trying to update <em class="filename">count_words.c</em>, but that's a source file!
        Let's "play <em class="command">make</em>." Our first
        prerequisite is <em class="filename">count_words.o</em>. We
        see the file is missing and look for a rule to create it. The explicit
        rule for creating <em class="filename">count_words.o</em>
        references <em class="filename">count_words.c</em>. But why
        can't <em class="command">make</em> find the source file?
        Because the source file is in the <em class="filename">src</em> directory not the current directory.
        Unless you direct it otherwise, <em class="command">make</em> will look only in the current directory
        for its targets and prerequisites. How do we get <em class="command">make</em> to look in the <em class="filename">src</em> directory for source files? Or, more
        generally, how do we tell <em class="command">make</em>
        where our source code is?</p><p>您可以使用和功能告诉<em class="command">make</em>在不同的目录中查找其源文件。为了解决眼前的问题，我们可以向<em class="filename">makefile</em>添加一个
        赋值：<code class="literal">VPATH</code><code class="literal">vpath</code><code class="literal">VPATH</code><em class="filename"></em></p><p>You can tell <em class="command">make</em> to look in
        different directories for its source files using the <code class="literal">VPATH</code> and <code class="literal">vpath</code> features. To fix our immediate
        problem, we can add a <code class="literal">VPATH</code>
        assignment to the <em class="filename">makefile</em>:</p><a id="OEBPS/ch02s03.html.I_2_tt45"></a><pre class="programlisting">VPATH = 源</pre><pre class="programlisting">VPATH = src</pre><p>这表明
        如果 make 想要的文件不在当前目录中，则<em class="command">它</em>
        应该在目录<em class="filename">src</em>中查找。现在，当我们运行<em class="filename">makefile</em>时，我们得到：</p><p>This indicates that <em class="command">make</em>
        should look in the directory <em class="filename">src</em>
        if the files it wants are not in the current directory. Now when we
        run our <em class="filename">makefile</em>, we get:</p><a id="OEBPS/ch02s03.html.I_2_tt46"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -c src/count_words.c -o count_words.o
src/count_words.c:2:21: counter.h: 没有这样的文件或目录
make: *** [count_words.o] 错误 1</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -c src/count_words.c -o count_words.o
src/count_words.c:2:21: counter.h: No such file or directory
make: *** [count_words.o] Error 1</pre><p>请注意，<em class="command">make</em>现在成功尝试编译第一个文件，并正确填写源的相对路径。这是使用的另一个原因<a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-931" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-932" class="indexterm"></a>自动变量：如果硬编码文件名，则<em class="command">make</em>无法使用适当的源路径。不幸的是，编译失败了，因为<em class="command">gcc</em>找不到包含文件。我们可以通过使用适当的选项“定制”隐式编译规则来解决这个最新问题<code class="option">-I</code>
        ：</p><p>Notice that <em class="command">make</em> now
        successfully tries to compile the first file, filling in correctly the
        relative path to the source. This is another reason to use <a class="indexterm"></a> <a class="indexterm"></a>automatic variables: <em class="command">make</em> cannot use the appropriate path to the
        source if you hardcode the filename. Unfortunately, the compilation
        dies because <em class="command">gcc</em> can't find the
        include file. We can fix this latest problem by "customizing" the
        implicit compilation rule with the appropriate <code class="option">-I</code>
        option:</p><a id="OEBPS/ch02s03.html.I_2_tt47"></a><pre class="programlisting">CPPFLAGS = -我包括</pre><pre class="programlisting">CPPFLAGS = -I include</pre><p><em class="command">并将gcc</em>的出现更改为
        <code class="literal">gcc$(CPPFLAGS)</code>.现在构建成功了：</p><p>and changing occurrences of <em class="command">gcc</em> to
        <code class="literal">gcc$(CPPFLAGS)</code>. Now the build succeeds:</p><a id="OEBPS/ch02s03.html.I_2_tt48"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -I include -c src/count_words.c -o count_words.o
gcc -I include -c src/counter.c -o counter.o
flex -t src/lexer.l &gt; lexer.c
gcc -I include -c lexer.c -o lexer.o
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -I include -c src/count_words.c -o count_words.o
gcc -I include -c src/counter.c -o counter.o
flex -t src/lexer.l &gt; lexer.c
gcc -I include -c lexer.c -o lexer.o
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words</pre><p>变量<code class="literal">VPATH</code>​<a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-933" class="indexterm"></a><em class="command">包含当make</em>需要文件时要搜索的目录列表
        。将在列表中搜索目标和先决条件，但不会搜索命令脚本中提到的文件。在 Unix 上目录列表可以用空格或冒号分隔，在 Windows 上可以用空格或分号分隔。我更喜欢使用空格，因为它适用于所有系统，并且我们可以避免整个冒号/分号的混乱。此外，用空格分隔的目录更容易阅读。</p><p>The <code class="literal">VPATH</code> variable<a class="indexterm"></a> consists of a list of directories to search when
        <em class="command">make</em> needs a file. The list will be
        searched for targets as well as prerequisites, but not for files
        mentioned in command scripts. The list of directories can be separated
        by spaces or colons on Unix and separated by spaces or semicolons on
        Windows. I prefer to use spaces since that works on all systems and we
        can avoid the whole colon/semicolon imbroglio. Also, the directories
        are easier to read when separated by spaces.</p><p>这个<code class="literal">VPATH</code>变量很好，因为它解决了我们上面的搜索问题，但它是一个相当大的锤子。<em class="command">make</em>将在每个目录中搜索它需要的<span class="emphasis"><em>任何</em></span>文件。如果列表中的多个位置存在同名文件<code class="literal">VPATH</code>，<em class="command">则 make</em>获取第一个文件。有时这可能是一个问题。</p><p>The <code class="literal">VPATH</code> variable is good
        because it solved our searching problem above, but it is a rather
        large hammer. <em class="command">make</em> will search each
        directory for <span class="emphasis"><em>any</em></span> file it needs. If a file of the
        same name exists in multiple places in the <code class="literal">VPATH</code> list, <em class="command">make</em> grabs the first one. Sometimes this can
        be a problem.</p><p>该<code class="literal">vpath</code>指令
        <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-934" class="indexterm"></a> <a id="OEBPS/ch02s03.html.make3-CHP-2-ITERM-935" class="indexterm"></a>是实现我们目标的更精确的方法。该指令的语法是：</p><p>The <code class="literal">vpath</code> directive
        <a class="indexterm"></a> <a class="indexterm"></a>is a more precise way to achieve our goals. The syntax
        of this directive is:</p><a id="OEBPS/ch02s03.html.I_2_tt49"></a><pre class="programlisting">虚拟路径<em class="replaceable"><code>pattern directory-list</code></em></pre><pre class="programlisting">vpath<em class="replaceable"><code>pattern directory-list</code></em></pre><p>所以我们之前的<code class="literal">VPATH</code>用法可以改写为：</p><p>So our previous <code class="literal">VPATH</code> use can
        be rewritten as:</p><a id="OEBPS/ch02s03.html.I_2_tt50"></a><pre class="programlisting">vpath %.c src
vpath %.l src
vpath %.h 包含</pre><pre class="programlisting">vpath %.c src
vpath %.l src
vpath %.h include</pre><p>现在我们已经告诉<em class="command">make</em>它应该在<em class="filename">src目录中搜索</em><em class="filename">.c</em>文件
        ，并且我们还添加了一行来在<em class="filename">include目录中搜索</em><em class="filename">.h</em>
        文件（这样我们就可以
        从头文件先决条件中删除<em class="filename">include/</em> ） 。在更复杂的应用程序中，这种控制可以节省大量令人头痛的事情和调试时间。<em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em></p><p>Now we've told <em class="command">make</em> that it
        should search for <em class="filename">.c</em> files in the
        <em class="filename">src</em> directory and we've also
        added a line to search for <em class="filename">.h</em>
        files in the <em class="filename">include</em> directory
        (so we can remove the <em class="filename">include/</em>
        from our header file prerequisites). In more complex applications,
        this control can save a lot of headache and debugging time.</p><p>这里我们用来<code class="literal">vpath</code>处理查找分布在多个目录中的源的问题。有一个相关但不同的问题，即如何构建应用程序，以便将目标文件写入“二进制树”，而源文件位于单独的“源树”中。正确使用<code class="literal">vpath</code>也可以帮助解决这个新问题，但任务很快就会变得复杂，<code class="literal">vpath</code>仅靠它是不够的。我们将在后面的章节中详细讨论这个问题。</p><p>Here we used <code class="literal">vpath</code> to handle
        the problem of finding source that is distributed among several
        directories. There is a related but different problem of how to build
        an application so that the object files are written into a "binary
        tree" while the source files live in a separate "source tree." Proper
        use of <code class="literal">vpath</code> can also help to solve
        this new problem, but the task quickly becomes complex and <code class="literal">vpath</code> alone is not sufficient. We'll discuss
        this problem in detail in later sections.</p></div></div></div>
<div id="OEBPS/ch02s04.html"><div>
<div class="sect1" title="模式规则"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s04.html.make3-CHP-2-SECT-4"></a>模式规则</h1><h1 class="title"><a></a>Pattern Rules</h1></div></div></div><p>我们的
        <em class="filename">makefile</em>示例<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-936" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-937" class="indexterm"></a>一直在看有点冗长。对于一个只有十几个文件或更少的小程序，我们可能不在乎，但对于具有数百或数千个文件的程序，指定每个目标、先决条件和命令脚本就变得行不通了。此外，这些命令本身代表了我们的<em class="filename">makefile</em>中的重复代码。如果命令包含错误或发生更改，我们将必须更新所有这些规则。这可能是一个主要的维护问题和错误来源。</p><p>The <em class="filename">makefile</em> examples we've
        <a class="indexterm"></a> <a class="indexterm"></a>been looking at are a bit verbose. For a small program
        of a dozen files or less we may not care, but for programs with
        hundreds or thousands of files, specifying each target, prerequisite,
        and command script becomes unworkable. Furthermore, the commands
        themselves represent duplicate code in our <em class="filename">makefile</em>. If the commands contain a bug or
        ever change, we would have to update all these rules. This can be a
        major maintenance problem and source of bugs.</p><p>许多读取一种文件类型并输出另一种文件类型的程序都符合标准约定。例如，所有 C 编译器都假定具有<em class="filename">.c后缀的文件包含 C 源代码，并且可以通过将</em><em class="filename">.c</em>后缀替换为
        <em class="filename">.o</em>（或某些 Windows 编译器的<em class="filename">.obj</em> ）来派生对象文件名。在上一章中，我们注意到<em class="command">Flex</em>输入文件使用<em class="filename">.l</em>后缀，并且<em class="command">Flex</em>生成<em class="filename">.c</em>文件。</p><p>Many programs that read one file type and output another conform
        to standard conventions. For instance, all C compilers assume that
        files that have a <em class="filename">.c</em> suffix
        contain C source code and that the object filename can be derived by
        replacing the <em class="filename">.c</em> suffix with
        <em class="filename">.o</em> (or <em class="filename">.obj</em> for some Windows compilers). In the
        previous chapter, we noticed that <em class="command">flex</em> input files use the <em class="filename">.l</em> suffix and that <em class="command">flex</em> generates <em class="filename">.c</em> files.</p><p>这些约定允许<em class="command">make</em>
        通过识别常见的文件名模式来简化规则创建
        <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-938" class="indexterm"></a>提供处理它们的内置规则。例如，通过使用这些内置规则，我们的 17 行<em class="filename">makefile</em>可以减少为：</p><p>These conventions allow <em class="command">make</em>
        to simplify rule creation by recognizing common filename patterns and
        <a class="indexterm"></a>providing built-in rules for processing them. For
        example, by using these built-in rules our 17-line <em class="filename">makefile</em> can be reduced to:</p><a id="OEBPS/ch02s04.html.I_2_tt51"></a><pre class="programlisting">VPATH = src 包含
CPPFLAGS = -我包括

count_words: counter.o lexer.o -lfl
count_words.o：计数器.h
counter.o: counter.h lexer.h
词法分析器.o: 词法分析器.h</pre><pre class="programlisting">VPATH    = src include
CPPFLAGS = -I include

count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h</pre><p>内置规则都是模式规则的实例。模式
        <em class="firstterm">规则</em>看起来与您已经见过的普通规则类似，只是文件的<em class="firstterm">主干</em>（后缀之前的部分）由字符表示<code class="literal">%</code>。该<em class="filename">makefile</em>之所以有效，是因为三个内置规则。第一个指定如何从<em class="filename">.c文件编译</em><em class="filename">.o</em>文件：<em class="filename"></em></p><p>The built-in rules are all instances of pattern rules. A
        <em class="firstterm">pattern rule</em> looks like the normal rules you
        have already seen except the <em class="firstterm">stem</em> of the file
        (the portion before the suffix) is represented by a <code class="literal">%</code> character. This <em class="filename">makefile</em> works because of three built-in
        rules. The first specifies how to compile a <em class="filename">.o</em> file from a <em class="filename">.c</em> file:</p><a id="OEBPS/ch02s04.html.I_2_tt52"></a><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>第二个指定如何从<em class="filename">.l文件创建</em><em class="filename">.c</em>文件：<em class="filename"></em></p><p>The second specifies how to make a <em class="filename">.c</em> file from a <em class="filename">.l</em> file:</p><a id="OEBPS/ch02s04.html.I_2_tt53"></a><pre class="programlisting">%.c: %.l
        @$(RM)$@
        $(LEX.l) $&lt; &gt; $@</pre><pre class="programlisting">%.c: %.l
        @$(RM) $@
        $(LEX.l) $&lt; &gt; $@</pre><p>最后，有一个特殊的规则可以从<em class="filename">.c</em>文件生成没有后缀的文件（始终是可执行文件）：</p><p>Finally, there is a special rule to generate a file with no
        suffix (always an executable) from a <em class="filename">.c</em> file:</p><a id="OEBPS/ch02s04.html.I_2_tt54"></a><pre class="programlisting">%：%.o
        $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><pre class="programlisting">%: %.o
        $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><p>我们将稍后详细介绍此语法，但首先让我们仔细检查<em class="command">make</em>的输出，看看<em class="command">make</em>如何应用这些内置规则。</p><p>We'll go into the details of this syntax in a bit, but first
        let's go over <em class="command">make</em>'s output
        carefully and see how <em class="command">make</em> applies
        these built-in rules.</p><p>当我们在七行<em class="filename">makefile</em>上运行<em class="command">make</em>时，输出为：<em class="filename"></em></p><p>When we run <em class="command">make</em> on our
        seven-line <em class="filename">makefile</em>, the output
        is:</p><a id="OEBPS/ch02s04.html.I_2_tt55"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc -I include -c -o count_words.o src/count_words.c
gcc -I include -c -o counter.o src/counter.c
flex -t src/lexer.l &gt; lexer.c
gcc -I include -c -o lexer.o lexer.c
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words
rm 词法分析器.c</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
gcc  -I include  -c -o count_words.o src/count_words.c
gcc  -I include  -c -o counter.o src/counter.c
flex  -t src/lexer.l &gt; lexer.c
gcc  -I include  -c -o lexer.o lexer.c
gcc   count_words.o counter.o lexer.o /lib/libfl.a   -o count_words
rm lexer.c</pre><p>首先，<em class="command">make</em>读取
        <em class="filename">makefile</em>并将默认目标设置为<em class="filename">count_words</em>，因为没有指定命令行目标。查看默认目标，
         <em class="command">make</em>确定了四个先决条件：
         <em class="filename">count_words.o （ </em><em class="filename">makefile</em>中缺少此先决条件，但由隐式规则提供）、<em class="filename">counter.o</em>、<em class="filename">lexer.o</em>和<code class="option">-lfl</code>。然后它尝试依次更新每个先决条件。</p><p>First, <em class="command">make</em> reads the
        <em class="filename">makefile</em> and sets the default
        goal to <em class="filename">count_words</em> since there
        are no command-line targets specified. Looking at the default goal,
        <em class="command">make</em> identifies four prerequisites:
        <em class="filename">count_words.o</em> (this prerequisite
        is missing from the <em class="filename">makefile</em>, but
        is provided by the implicit rule), <em class="filename">counter.o</em>, <em class="filename">lexer.o</em>, and <code class="option">-lfl</code>. It then
        tries to update each prerequisite in turn.</p><p>当<em class="command">make</em>检查第一个先决条件<em class="filename">count_words.o</em>时，
         <em class="command">make</em>没有找到它的显式规则，但发现了隐式规则。在本地目录中查找，
         <em class="command">make</em>找不到源文件，因此它开始搜索并在<em class="filename">src</em><code class="literal">VPATH</code>中找到匹配的源文件。由于<em class="filename">src/count_words.c</em>没有先决条件，
        <em class="command">因此 make</em>可以自由更新<em class="filename">count_words.o</em>，以便它运行隐式规则的命令。<em class="filename">counter.o</em>类似。当<em class="command">make</em>考虑
        <em class="filename">lexer.o</em>时，它无法找到相应的源文件（即使在<em class="filename">src</em>中），因此它假设此（不存在的源）是一个中间文件，并寻找一种从其他源文件生成<em class="filename">lexer.c</em>的方法。它发现一条
        从<em class="filename">.l</em>文件创建<em class="filename">.c</em>文件的规则，并注意到<em class="filename">lexer.l</em>存在。更新<em class="filename">lexer.l</em>不需要执行任何操作，因此它会继续执行更新<em class="filename">lexer.c 的</em>命令，该命令会生成<em class="command">flex</em>命令行。接下来
        <em class="command">make</em>从 C 源代码更新目标文件。使用<em class="filename"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><em class="command"></em><a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-939" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-940" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-941" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-942" class="indexterm"></a>像这样更新目标的规则序列称为<em class="firstterm">规则链接</em>。</p><p>When <em class="command">make</em> examines the first
        prerequisite, <em class="filename">count_words.o</em>,
        <em class="command">make</em> finds no explicit rule for it
        but discovers the implicit rule. Looking in the local directory,
        <em class="command">make</em> cannot find the source, so it
        begins searching the <code class="literal">VPATH</code> and
        finds a matching source file in <em class="filename">src</em>. Since <em class="filename">src/count_words.c</em> has no prerequisites,
        <em class="command">make</em> is free to update <em class="filename">count_words.o</em> so it runs the commands for
        the implicit rule. <em class="filename">counter.o</em> is
        similar. When <em class="command">make</em> considers
        <em class="filename">lexer.o</em>, it cannot find a
        corresponding source file (even in <em class="filename">src</em>) so it assumes this (nonexistent
        source) is an intermediate file and looks for a way to make <em class="filename">lexer.c</em> from some other source file. It
        discovers a rule to create a <em class="filename">.c</em>
        file from a <em class="filename">.l</em> file and notices
        that <em class="filename">lexer.l</em> exists. There is no
        action required to update <em class="filename">lexer.l</em>, so it moves on to the command for
        updating <em class="filename">lexer.c</em>, which yields
        the <em class="command">flex</em> command line. Next
        <em class="command">make</em> updates the object file from
        the C source. Using <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>sequences of rules like this to update a target is
        called <em class="firstterm">rule chaining</em>.</p><p>接下来，<em class="command">make</em>检查库规范<code class="option">-lfl</code>。它搜索系统的标准库目录并发现<em class="filename">/lib/libfl.a</em>。</p><p>Next, <em class="command">make</em> examines the
        library specification <code class="option">-lfl</code>. It searches the standard
        library directories for the system and discovers <em class="filename">/lib/libfl.a</em>.</p><p>现在<em class="command">make已经具备了更新</em><em class="filename">count_words</em>的所有先决条件，因此它执行最终的
        <em class="command">gcc</em>命令。最后，<em class="command">make</em>意识到它创建了一个不需要保留的中间文件，因此将其清除。</p><p>Now <em class="command">make</em> has all the
        prerequisites for updating <em class="filename">count_words</em>, so it executes the final
        <em class="command">gcc</em> command. Lastly, <em class="command">make</em> realizes it created an intermediate
        file that is not necessary to keep so it cleans it up.</p><p>正如您所看到的，在<em class="filename">makefile</em>中使用规则可以让您省略很多细节。规则可以具有复杂的交互，从而产生非常强大的行为。特别是，拥有通用规则的内置数据库使得许多类型的<em class="filename">makefile</em>
        规范变得非常简单。</p><p>As you can see, using rules in <em class="filename">makefile</em>s allows you to omit a lot of
        detail. Rules can have complex interactions that yield very powerful
        behaviors. In particular, having a built-in database of common rules
        makes many types of <em class="filename">makefile</em>
        specifications very simple.</p><p>这<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-943" class="indexterm"></a>内置规则可以是<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-944" class="indexterm"></a>通过更改命令脚本中变量的值进行自定义。典型的规则有许多变量，从要执行的程序开始，包括用于设置命令行选项主要分组的变量，例如输出文件、优化、调试等。您可以查看<em class="command">make</em>的默认设置通过运行<em class="command">make</em>
        来创建规则（和变量）<code class="option">—print-data-base</code>。</p><p>The <a class="indexterm"></a>built-in rules can be <a class="indexterm"></a>customized by changing the values of the variables in
        the command scripts. A typical rule has a host of variables, beginning
        with the program to execute, and including variables to set major
        groupings of command-line options, such as the output file,
        optimization, debugging, etc. You can look at <em class="command">make</em>'s default set of rules (and variables)
        by running <em class="command">make</em>
        <code class="option">—print-data-base</code>.</p><div class="sect2" title="模式"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s04.html.make3-CHP-2-SECT-4.1"></a>模式</h2><h2 class="title"><a></a>The Patterns</h2></div></div></div><p>a 中的百分号字符<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-945" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-946" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-947" class="indexterm"></a>模式规则大致相当于<code class="literal">*</code>Unix shell 中的规则。它代表任意数量的任意字符。百分比字符可以放置在模式内的任何位置，但只能出现一次。以下是百分比的一些有效用法：</p><p>The percent character in a <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>pattern rule is roughly equivalent to <code class="literal">*</code> in a Unix shell. It represents any
          number of any characters. The percent character can be placed
          anywhere within the pattern but can occur only once. Here are some
          valid uses of percent:</p><a id="OEBPS/ch02s04.html.I_2_tt56"></a><pre class="programlisting">%,v
所以
包装_%</pre><pre class="programlisting">%,v
s%.o
wrapper_%</pre><p>文件名中除百分比以外的字符按字面意思匹配。模式可以包含前缀或后缀或<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-948" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-949" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-950" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-951" class="indexterm"></a>两个都。当<em class="command">make</em>
          搜索要应用的模式规则时，它首先查找匹配的模式规则目标。模式规则目标必须以前缀开头并以后缀结尾（如果存在）。如果找到匹配项，则将前缀和后缀之间的字符作为名称的词干。接下来<em class="command">make</em>通过将词干替换为先决条件模式来查看模式规则的先决条件。如果生成的文件名存在或者可以通过应用另一个规则来生成，则进行匹配并应用该规则。词干必须至少包含一个字符。</p><p>Characters other than percent match literally within a
          filename. A pattern can contain a prefix or a suffix or <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>both. When <em class="command">make</em>
          searches for a pattern rule to apply, it first looks for a matching
          pattern rule target. The pattern rule target must start with the
          prefix and end with the suffix (if they exist). If a match is found,
          the characters between the prefix and suffix are taken as the stem
          of the name. Next <em class="command">make</em> looks at
          the prerequisites of the pattern rule by substituting the stem into
          the prerequisite pattern. If the resulting filename exists or can be
          made by applying another rule, a match is made and the rule is
          applied. The stem word must contain at least one character.</p><p>也可以有一个仅包含百分比字符的模式。此模式最常见的用途是构建 Unix 可执行程序。例如，以下是<acronym class="acronym">GNU</acronym> 
          为构建程序而包含的<em class="command">几个模式规则：</em></p><p>It is also possible to have a pattern containing only a
          percent character. The most common use of this pattern is to build a
          Unix executable program. For instance, here are several pattern
          rules <acronym class="acronym">GNU</acronym> <em class="command">make</em>
          includes for building programs:</p><a id="OEBPS/ch02s04.html.I_2_tt57"></a><pre class="programlisting">%: %.mod
        $(COMPILE.mod) -o $@ -e $@ $^

%: %.cpp
        $(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@

%：%.sh
        猫$&lt;&gt;$@
        chmod a+x $@</pre><pre class="programlisting">%: %.mod
        $(COMPILE.mod) -o $@ -e $@ $^

%: %.cpp
        $(LINK.cpp) $^ $(LOADLIBES) $(LDLIBS) -o $@

%: %.sh
        cat $&lt; &gt;$@
        chmod a+x $@</pre><p>这些模式将分别用于从 Modula 源文件、预处理的 C 源文件和 Bourne shell 脚本生成可执行文件。我们将在<a class="link" href="#OEBPS/ch02s05.html" title="隐式规则数据库">2.5 节</a>中看到更多隐含规则。</p><p>These patterns will be used to generate an executable from a
          Modula source file, a preprocessed C source file, and a Bourne shell
          script, respectively. We will see many more implicit rules in <a class="link" href="#OEBPS/ch02s05.html" title="The Implicit Rules Database">Section 2.5</a>.</p></div><div class="sect2" title="静态模式规则"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s04.html.make3-CHP-2-SECT-4.2"></a>静态模式规则</h2><h2 class="title"><a></a>Static Pattern Rules</h2></div></div></div><p>静态模式规则是其中之一<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-952" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-953" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-954" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-955" class="indexterm"></a>仅适用于特定目标列表。</p><p>A static pattern rule is one<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> that applies only to a specific list of
          targets.</p><a id="OEBPS/ch02s04.html.I_2_tt58"></a><pre class="programlisting">$(对象): %.o: %.c
        $(CC) -c $(CFLAGS) $&lt; -o $@</pre><pre class="programlisting">$(OBJECTS): %.o: %.c
        $(CC) -c $(CFLAGS) $&lt; -o $@</pre><p>此规则与普通模式规则之间的唯一区别是初始<code class="literal">$(OBJECTS)</code>: 规范。这将规则限制为
          <code class="literal">$(OBJECTS)</code>变量中列出的文件。</p><p>The only difference between this rule and an ordinary pattern
          rule is the initial <code class="literal">$(OBJECTS)</code>:
          specification. This limits the rule to the files listed in the
          <code class="literal">$(OBJECTS)</code> variable.</p><p>这与模式规则非常相似。每个对象<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-956" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-957" class="indexterm"></a>file in<code class="literal">$(OBJECTS)</code>
          与模式进行匹配<code class="literal">%.o</code>并提取其词干。然后将主干替换到模式中<code class="literal">%.c</code>以产生目标的先决条件。如果目标模式不存在，<em class="command">make</em>会发出警告。</p><p>This is very similar to a pattern rule. Each object <a class="indexterm"></a> <a class="indexterm"></a>file in <code class="literal">$(OBJECTS)</code>
          is matched against the pattern <code class="literal">%.o</code> and its stem is extracted. The stem is
          then substituted into the pattern <code class="literal">%.c</code> to yield the target's prerequisite. If
          the target pattern does not exist, <em class="command">make</em> issues a warning.</p><p>只要显式列出目标文件比通过后缀或其他模式识别目标文件更容易，就使用静态模式规则。</p><p>Use static pattern rules whenever it is easier to list the
          target files explicitly than to identify them by a suffix or other
          pattern.</p></div><div class="sect2" title="后缀规则"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s04.html.make3-CHP-2-SECT-4.3"></a>后缀规则</h2><h2 class="title"><a></a>Suffix Rules</h2></div></div></div><p>后缀规则是<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-958" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-959" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-960" class="indexterm"></a>定义隐式规则的原始（和过时）方式。因为其他版本的<em class="command">make</em>可能不支持
          <acronym class="acronym">GNU </acronym> <em class="command">make</em>的模式规则语法，所以您仍然会在用于广泛分发的<em class="filename">makefile</em>中看到后缀规则，因此能够阅读和理解语法非常重要。因此，尽管为目标系统编译<acronym class="acronym">GNU </acronym> <em class="command">make是</em><em class="filename">makefile</em>
          可移植性的首选方法，但在极少数情况下您可能仍然需要编写后缀规则。</p><p>Suffix rules are the <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>original (and obsolete) way of defining implicit
          rules. Because other versions of <em class="command">make</em> may not support
          <acronym class="acronym">GNU</acronym> <em class="command">make</em>'s
          pattern rule syntax, you will still see suffix rules in <em class="filename">makefile</em>s intended for a wide
          distribution so it is important to be able to read and understand
          the syntax. So, although compiling <acronym class="acronym">GNU</acronym> <em class="command">make</em> for the target system is the
          preferred method for <em class="filename">makefile</em>
          portability, you may still need to write suffix rules in rare
          circumstances.</p><p>后缀规则由一个或两个连接后用作目标的后缀组成：</p><p>Suffix rules consist of one or two suffixes concatenated and
          used as a target:</p><a id="OEBPS/ch02s04.html.I_2_tt59"></a><pre class="programlisting">.co:
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">.c.o:
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>这有点令人困惑，因为先决条件后缀在前，目标后缀在后。此规则与以下一组相同的目标和先决条件匹配：</p><p>This is a little confusing because the prerequisite suffix
          comes first and the target suffix second. This rule matches the same
          set of targets and prerequisites as:</p><a id="OEBPS/ch02s04.html.I_2_tt60"></a><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>后缀规则通过删除目标来形成文件的主干<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-961" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-962" class="indexterm"></a>后缀。它通过将目标后缀替换为先决条件后缀来形成先决条件。仅当两个后缀位于已知后缀列表中时，<em class="command">make</em>才会识别后缀规则。</p><p>The suffix rule forms the stem of the file by removing the
          target <a class="indexterm"></a> <a class="indexterm"></a>suffix. It forms the prerequisite by replacing the
          target suffix with the prerequisite suffix. The suffix rule is
          recognized by <em class="command">make</em> only if the
          two suffixes are in a list of known suffixes.</p><p>上述后缀规则称为双后缀规则，因为它包含两个后缀。还有单后缀规则。正如您可能想象的那样，单后缀规则仅包含一个后缀，即源文件的后缀。这些规则用于创建可执行文件，因为 Unix 可执行文件没有后缀：</p><p>The above suffix rule is known as a double-suffix rule since
          it contains two suffixes. There are also single-suffix rules. As you
          might imagine a single-suffix rule contains only one suffix, the
          suffix of the source file. These rules are used to create
          executables since Unix executables do not have a suffix:</p><a id="OEBPS/ch02s04.html.I_2_tt61"></a><pre class="programlisting">.p:
        $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><pre class="programlisting">.p:
        $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><p>该规则从 Pascal 源文件生成可执行映像。这与模式规则完全相似：</p><p>This rule produces an executable image from a Pascal source
          file. This is completely analogous to the pattern rule:</p><a id="OEBPS/ch02s04.html.I_2_tt62"></a><pre class="programlisting">%：%.p
        $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><pre class="programlisting">%: %.p
        $(LINK.p) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><p>已知后缀列表是语法中最奇怪的部分。特殊目标<code class="literal">.SUFFIXES</code>，用于设置已知后缀列表。这是默认定义的第一部分<code class="literal">.SUFFIXES</code>
          ：</p><p>The known suffix list is the strangest part of the syntax. A
          special target, <code class="literal">.SUFFIXES</code>, is
          used to set the list of known suffixes. Here is the first part of
          the default <code class="literal">.SUFFIXES</code>
          definition:</p><a id="OEBPS/ch02s04.html.I_2_tt63"></a><pre class="programlisting">.后缀：.out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l</pre><pre class="programlisting">.SUFFIXES: .out .a .ln .o .c .cc .C .cpp .p .f .F .r .y .l</pre><p>您只需在<em class="filename">makefile</em><code class="literal">.SUFFIXES</code>中添加规则即可添加自己的后缀：<em class="filename"></em></p><p>You can add your own suffixes by simply adding a <code class="literal">.SUFFIXES</code> rule to your <em class="filename">makefile</em>:</p><a id="OEBPS/ch02s04.html.I_2_tt64"></a><pre class="programlisting">.后缀：.pdf .fo .html .xml</pre><pre class="programlisting">.SUFFIXES: .pdf .fo .html .xml</pre><p>如果你想删除所有<a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-963" class="indexterm"></a> <a id="OEBPS/ch02s04.html.make3-CHP-2-ITERM-964" class="indexterm"></a>已知后缀（因为它们会干扰您的特殊后缀）只需指定任何先决条件：</p><p>If you want to delete all the <a class="indexterm"></a> <a class="indexterm"></a>known suffixes (because they are interfering with your
          special suffixes) simply specify no prerequisites:</p><a id="OEBPS/ch02s04.html.I_2_tt65"></a><pre class="programlisting">.后缀：</pre><pre class="programlisting">.SUFFIXES:</pre><p>您还可以使用命令行选项
          <code class="option">—no-builtin-rules</code>（或<code class="option">-r</code>）。</p><p>You can also use the command-line option
          <code class="option">—no-builtin-rules</code> (or <code class="option">-r</code>).</p><p>在本书的其余部分中，我们不会使用这种旧语法，因为<acronym class="acronym">GNU </acronym> <em class="command">make</em>的模式规则更清晰、更通用。</p><p>We will not use this old syntax in the rest of this book
          because <acronym class="acronym">GNU</acronym> <em class="command">make</em>'s pattern rules are clearer and more
          general.</p></div></div></div></div>
<div id="OEBPS/ch02s05.html"><div>
<div class="sect1" title="隐式规则数据库"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s05.html.make3-CHP-2-SECT-5"></a>隐式规则数据库</h1><h1 class="title"><a></a>The Implicit Rules Database</h1></div></div></div><p><acronym class="acronym">GNU </acronym> <em class="command">make</em> 
        3.80 内置了大约 90 个<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-965" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-966" class="indexterm"></a>隐含规则。隐式规则是模式规则或后缀规则。 C、C++、Pascal、FORTRAN、ratfor、Modula、Texinfo、 <sub>TEX</sub>（包括 Tangle 和 Weave）、Emacs Lisp、RCS 和 SCCS都有内置模式规则。此外，还有支持这些语言的程序的规则，例如
        <em class="command">cpp</em>、<em class="command">as</em>、<em class="command">yacc</em>、
         <em class="command">lex</em>、<em class="command">tangle</em>、<em class="command">weave</em>和 dvi 工具。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
        3.80 has about 90 built-in <a class="indexterm"></a> <a class="indexterm"></a>implicit rules. An implicit rule is either a pattern
        rule or a suffix rule. There are built-in pattern rules for C, C++,
        Pascal, FORTRAN, ratfor, Modula, Texinfo, T<sub>E</sub>X
        (including Tangle and Weave), Emacs Lisp, RCS, and SCCS. In addition,
        there are rules for supporting programs for these languages, such as
        <em class="command">cpp</em>, <em class="command">as</em>, <em class="command">yacc</em>,
        <em class="command">lex</em>, <em class="command">tangle</em>, <em class="command">weave</em> and dvi tools.</p><p>如果您正在使用这些工具中的任何一个，您可能会在内置规则中找到您需要的大部分内容。如果您使用一些不受支持的语言，例如 Java 或 XML，则必须编写自己的规则。但不用担心，您通常只需要一些规则来支持一种语言，而且它们很容易编写。</p><p>If you are using any of these tools, you'll probably find most
        of what you need in the built-in rules. If you're using some
        unsupported languages such as Java or XML, you will have to write
        rules of your own. But don't worry, you typically need only a few
        rules to support a language and they are quite easy to write.</p><p><em class="command">要检查make</em>中内置的规则数据库，请使用
        <code class="option">—print-data-base</code>命令行选项（<code class="option">-p</code>简称）。这将生成大约一千行输出。在版本和版权信息之后，<em class="command">make</em>打印其变量定义，每个变量定义前面都有一个注释，指示定义的“起源”。例如，变量可以是环境变量、默认值、自动变量等。变量之后是规则。<acronym class="acronym">GNU </acronym> <em class="command">make</em>使用的实际格式是：</p><p>To examine the rules database built into <em class="command">make</em>, use the
        <code class="option">—print-data-base</code> command-line option
        (<code class="option">-p</code> for short). This will generate about a thousand
        lines of output. After version and copyright information, <em class="command">make</em> prints its variable definitions each
        one preceded by a comment indicating the "origin" of the definition.
        For instance, variables can be environment variables, default values,
        automatic variables, etc. After the variables, come the rules. The
        actual format used by <acronym class="acronym">GNU</acronym> <em class="command">make</em> is:</p><a id="OEBPS/ch02s05.html.I_2_tt66"></a><pre class="programlisting">％： ％。C
# 要执行的命令（内置）：
        $(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><pre class="programlisting">%: %.C
#  commands to execute (built-in):
        $(LINK.C) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><p><em class="filename">对于makefile</em>定义的规则，注释将包括定义规则的文件和行：</p><p>For rules defined by the <em class="filename">makefile</em>, the comment will include the file
        and line where the rule was defined:</p><a id="OEBPS/ch02s05.html.I_2_tt67"></a><pre class="programlisting">%.html: %.xml
# 要执行的命令（来自“Makefile”，第 168 行）：
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;</pre><pre class="programlisting">%.html: %.xml
#  commands to execute (from `Makefile', line 168):
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;</pre><div class="sect2" title="使用隐式规则"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s05.html.make3-CHP-2-SECT-5.1"></a>使用隐式规则</h2><h2 class="title"><a></a>Working with Implicit Rules</h2></div></div></div><p>内置隐式规则<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-967" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-968" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-969" class="indexterm"></a>每当考虑目标并且没有明确的规则来更新它时就会应用。因此，使用隐式规则很简单：只需在将目标添加到<em class="filename">makefile</em>时不指定命令脚本即可。这会导致
          <em class="command">make</em>搜索其内置数据库以满足目标。通常这正是您想要的，但在极少数情况下您的开发环境可能会导致问题。例如，假设您有一个由 Lisp 和 C 源代码组成的混合语言环境。如果文件
          <em class="filename">editor.l</em>和<em class="filename">editor.c</em>都存在于同一目录中（假设其中一个是另一个被另一个访问的低级实现），那么
          <em class="command">make</em>将认为 Lisp 文件实际上是一个<em class="command">Flex</em>文件（回想一下，<em class="command">flex</em>文件使用
          <em class="filename">.l后缀）并且 C 源代码是</em><em class="command">flex</em>命令的输出
          。如果<em class="filename">editor.o</em>是目标，并且<em class="filename">editor.l</em>比<em class="filename">editor.c</em>新，<em class="command">make将尝试使用</em><em class="command">flex</em>的
          输出覆盖源代码来“更新”C 文件。嘎克。</p><p>The built-in implicit rules <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>are applied whenever a target is being considered and
          there is no explicit rule to update it. So using an implicit rule is
          easy: simply do not specify a command script when adding your target
          to the <em class="filename">makefile</em>. This causes
          <em class="command">make</em> to search its built-in
          database to satisfy the target. Usually this does just what you
          want, but in rare cases your development environment can cause
          problems. For instance, suppose you have a mixed language
          environment consisting of Lisp and C source code. If the file
          <em class="filename">editor.l</em> and <em class="filename">editor.c</em> both exist in the same directory
          (say one is a low-level implementation accessed by the other)
          <em class="command">make</em> will believe that the Lisp
          file is really a <em class="command">flex</em> file
          (recall <em class="command">flex</em> files use the
          <em class="filename">.l</em> suffix) and that the C
          source is the output of the <em class="command">flex</em>
          command. If <em class="filename">editor.o</em> is a
          target and <em class="filename">editor.l</em> is newer
          than <em class="filename">editor.c</em>, <em class="command">make</em> will attempt to "update" the C file
          with the output of <em class="command">flex</em>
          overwriting your source code. Gack.</p><p>要解决这个特定问题，您可以从内置规则库中删除有关<em class="command">flex</em>的两条规则，如下所示：</p><p>To work around this particular problem you can delete the two
          rules concerning <em class="command">flex</em> from the
          built-in rule base like this:</p><a id="OEBPS/ch02s05.html.I_2_tt68"></a><pre class="programlisting">%.o: %.l
%.c: %.l</pre><pre class="programlisting">%.o: %.l
%.c: %.l</pre><p><em class="command">没有命令脚本的模式将从make</em>的数据库中删除规则
          。在实践中，这样的情况非常罕见。然而，重要的是要记住内置规则数据库包含的规则将以您可能没有预料到的方式与您自己的<em class="filename">makefile进行交互。</em></p><p>A pattern with no command script will remove the rule from
          <em class="command">make</em>'s database. In practice,
          situations such as this are very rare. However, it is important to
          remember the built-in rules database contains rules that will
          interact with your own <em class="filename">makefile</em>s in ways you may not have
          anticipated.</p><p>我们已经看到了几个示例，说明<em class="command">make</em>如何在尝试更新目标时将规则“链接”在一起。这可能会导致一些复杂性，我们将在这里进行研究。当<em class="command">make</em>
          考虑如何更新目标时，它会在隐式规则中搜索与当前目标匹配的目标模式。对于与目标文件匹配的每个目标模式，<em class="command">make</em>将查找现有的匹配先决条件。也就是说，在匹配目标模式后，<em class="command">make</em>立即查找先决条件“源”文件。如果找到先决条件，则使用该规则。对于某些目标模式，有许多可能的源文件。例如，<em class="filename">.o文件可以由</em><em class="filename">.c</em>、<em class="filename">.cc</em>、<em class="filename">.cpp</em>、<em class="filename">.p</em>、<em class="filename">.f</em>、<em class="filename">.r</em>、<em class="filename">.s</em>和<em class="filename">.mod</em>文件创建。但是如果搜索完所有可能的规则后都没有找到来源怎么办？在这种情况下，<em class="command">make</em>将再次搜索规则，这次假设匹配的源文件应被视为新的更新目标。通过递归地执行此搜索，
           <em class="command">make</em>可以找到允许更新目标的规则“链”。我们在<em class="filename">lexer.o</em>示例中看到了这一点。即使
          通过调用<em class="filename">.l</em>到<em class="filename">.c</em>规则，然后调用<em class="filename">.c</em>到<em class="filename">.o</em>规则缺少中间<em class="filename">.c文件， </em><em class="command">make</em>也能够从<em class="filename">lexer.l更新</em><em class="filename">lexer.o</em>目标。<em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em></p><p>We have seen several examples of how <em class="command">make</em> will "chain" rules together while
          trying to update a target. This can lead to some complexity, which
          we'll examine here. When <em class="command">make</em>
          considers how to update a target, it searches the implicit rules for
          a target pattern that matches the target in hand. For each target
          pattern that matches the target file, <em class="command">make</em> will look for an existing matching
          prerequisite. That is, after matching the target pattern, <em class="command">make</em> immediately looks for the
          prerequisite "source" file. If the prerequisite is found, the rule
          is used. For some target patterns, there are many possible source
          files. For instance, a <em class="filename">.o</em> file
          can be made from <em class="filename">.c</em>, <em class="filename">.cc</em>, <em class="filename">.cpp</em>, <em class="filename">.p</em>, <em class="filename">.f</em>, <em class="filename">.r</em>, <em class="filename">.s</em>, and <em class="filename">.mod</em> files. But what if the source is not
          found after searching all possible rules? In this case, <em class="command">make</em> will search the rules again, this
          time assuming that the matching source file should be considered as
          a new target for updating. By performing this search recursively,
          <em class="command">make</em> can find a "chain" of rules
          that allows updating a target. We saw this in our <em class="filename">lexer.o</em> example. <em class="command">make</em> was able to update the <em class="filename">lexer.o</em> target from <em class="filename">lexer.l</em> even though the intermediate
          <em class="filename">.c</em> file was missing by invoking
          the <em class="filename">.l</em> to <em class="filename">.c</em> rule, then the <em class="filename">.c</em> to <em class="filename">.o</em> rule.</p><p><em class="command">这里显示了make</em>可以从其数据库自动生成的更令人印象深刻的序列之一。首先，我们通过创建一个空的<em class="command">yacc</em>源文件并使用<em class="command">ci</em>向 RCS 注册来设置我们的实验
          （也就是说，我们需要一个版本控制的<em class="command">yacc</em>源文件）：</p><p>One of the more impressive sequences that <em class="command">make</em> can produce automatically from its
          database is shown here. First, we setup our experiment by creating
          an empty <em class="command">yacc</em> source file and
          registering with RCS using <em class="command">ci</em>
          (that is, we want a version-controlled <em class="command">yacc</em> source file):</p><a id="OEBPS/ch02s05.html.I_2_tt69"></a><pre class="programlisting">$$<strong class="userinput"><code>touch foo.y</code></strong>
​<strong class="userinput"><code>ci foo.y</code></strong>
foo.y,v &lt;-- foo.y
。
初步修订：1.1
完毕</pre><pre class="programlisting">$<strong class="userinput"><code>touch foo.y</code></strong>
$ <strong class="userinput"><code>ci foo.y</code></strong>
foo.y,v  &lt;--  foo.y
.
initial revision: 1.1
done</pre><p>现在，我们询问<em class="command">make</em>如何创建可执行文件<em class="filename">foo</em>。<code class="option">—just-print</code>(或
          <code class="option">-n</code>) 选项告诉make<em class="command">报告</em>它将执行哪些操作，而无需实际运行它们。请注意，我们没有
          <em class="filename">makefile</em>，也没有“源”代码，只有一个 RCS 文件：</p><p>Now, we ask <em class="command">make</em> how it
          would create the executable <em class="filename">foo</em>. The <code class="option">—just-print</code> (or
          <code class="option">-n</code>) option tells <em class="command">make</em> to report what actions it would
          perform without actually running them. Notice that we have no
          <em class="filename">makefile</em> and no "source" code,
          only an RCS file:</p><a id="OEBPS/ch02s05.html.I_2_tt70"></a><pre class="programlisting">$<strong class="userinput"><code>make -n foo</code></strong>
co foo.y,v foo.y
foo.y,v --&gt; foo.y
修订版1.1
完毕
野牛 -y foo.y
mv -f y.tab.c foo.c
gcc -c -o foo.o foo.c
gcc foo.o -o foo
rm foo.c foo.o foo.y</pre><pre class="programlisting">$<strong class="userinput"><code>make -n foo</code></strong>
co  foo.y,v foo.y
foo.y,v  --&gt;  foo.y
revision 1.1
done
bison -y  foo.y
mv -f y.tab.c foo.c
gcc    -c -o foo.o foo.c
gcc   foo.o   -o foo
rm foo.c foo.o foo.y</pre><p>遵循隐式规则和先决条件链，
           <em class="command">make</em>确定它可以创建可执行文件<em class="filename">foo</em>，如果它具有目标文件<em class="filename">foo.o</em>。如果它有 C 源文件<em class="filename">foo.c</em> ，它可以创建<em class="filename">foo.o</em>。如果它有 yacc 源文件<em class="filename">foo.y</em> ，它可以创建<em class="filename">foo.c</em>。最后，它意识到可以通过从它实际拥有的RCS 文件<em class="filename">foo.y,v</em>
          中检出该文件来创建<em class="filename">foo.y</em> 。一旦
          <em class="command">make</em>制定了这个计划，它就会通过用<em class="command">co</em>检查<em class="filename">foo.y</em>，用<em class="command">bison将其转换为</em><em class="filename">foo.c</em>，用<em class="command">gcc将其编译为</em><em class="filename">foo.o ，并用</em><em class="command">gcc</em>将其再次链接形成<em class="filename">foo</em>来执行它。所有这些都来自隐式规则数据库。很酷。<em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em></p><p>Following the chain of implicit rules and prerequisites,
          <em class="command">make</em> determined it could create
          the executable, <em class="filename">foo</em>, if it had
          the object file <em class="filename">foo.o</em>. It could
          create <em class="filename">foo.o</em> if it had the C
          source file <em class="filename">foo.c</em>. It could
          create <em class="filename">foo.c</em> if it had the yacc
          source file <em class="filename">foo.y</em>. Finally, it
          realized it could create <em class="filename">foo.y</em>
          by checking out the file from the RCS file <em class="filename">foo.y,v</em>, which it actually has. Once
          <em class="command">make</em> has formulated this plan, it
          executes it by checking out <em class="filename">foo.y</em> with <em class="command">co</em>, transforming it into <em class="filename">foo.c</em> with <em class="command">bison</em>, compiling it into <em class="filename">foo.o</em> with <em class="command">gcc</em>, and linking it to form <em class="filename">foo</em> again with <em class="command">gcc</em>. All this from the implicit rules
          database. Pretty cool.</p><p>生成的文件<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-970" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-971" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-972" class="indexterm"></a>通过链接规则称为
          <em class="firstterm">中间文件，并由</em><em class="command">make</em>特殊处理。首先，由于中间文件不会出现在目标中（否则它们就不会是中间文件），因此<em class="command">make</em>永远不会简单地更新中间文件。其次，因为<em class="command">make</em>本身会创建中间文件作为更新目标的副作用，所以<em class="command">make</em>将在退出之前删除中间文件。您可以在示例的最后一行看到这一点。</p><p>The files generated <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>by chaining rules are called
          <em class="firstterm">intermediate</em> files and are treated specially
          by <em class="command">make</em>. First, since
          intermediate files do not occur in targets (otherwise they would not
          be intermediate), <em class="command">make</em> will never
          simply update an intermediate file. Second, because <em class="command">make</em> creates intermediate files itself as
          a side effect of updating a target, <em class="command">make</em> will delete the intermediates before
          exiting. You can see this in the last line of the example.</p><p>隐式规则数据库包含大量规则，即使非常大的项目也很少使用其中的大部分规则。因为它包含如此广泛的种类，所以 make 可能会以意想不到的方式使用您没有预料到的规则。作为预防措施，一些大型项目选择完全放弃隐含规则，转而采用自己手工制定的规则。您可以使用
          <code class="literal">--no-builtin-rules</code>(或<code class="literal">-r</code>) 选项轻松完成此操作。 （即使在最大的项目中，我也从未使用过此选项。）如果您使用此选项，您可能还需要考虑使用<code class="literal">--no-builtin-variables</code>(或
          <code class="literal">-R</code>)。</p><p>The implicit rules database contains a lot of rules and even
          very large projects rarely use most of it. Because it contains such
          a wide variety, rules you didn't expect to fire may be used by make
          in unexpected ways. As a preventative measure, some large projects
          choose to discard the implicit rules entirely in favor of their own
          hand-crafted rules. You can do this easily with the
          <code class="literal">--no-builtin-rules</code> (or <code class="literal">-r</code>)
          option. (I have never had to use this option even on the largest
          projects.) If you use this option, you may also want to consider
          using <code class="literal">--no-builtin-variables</code> (or
          <code class="literal">-R</code>). </p></div><div class="sect2" title="规则结构"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s05.html.make3-CHP-2-SECT-5.2"></a>规则结构</h2><h2 class="title"><a></a>Rule Structure</h2></div></div></div><p>内置规则有标准<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-973" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-974" class="indexterm"></a>旨在使它们易于定制的结构。让我们简单回顾一下结构，然后讨论定制。这是（现在熟悉的）更新规则<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-975" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-976" class="indexterm"></a>来自其 C 源代码的目标文件：</p><p>The built-in rules have a standard <a class="indexterm"></a> <a class="indexterm"></a>structure intended to make them easily customizable.
          Let's go over the structure briefly then talk about customization.
          Here is the (by now familiar) rule for updating an <a class="indexterm"></a> <a class="indexterm"></a>object file from its C source:</p><a id="OEBPS/ch02s05.html.I_2_tt71"></a><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">%.o: %.c
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>该规则的定制是完全受控的
          <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-977" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-978" class="indexterm"></a>通过它使用的变量集。我们在这里看到两个变量，但<code class="literal">COMPILE.c</code>特别是根据其他几个变量定义的：</p><p>The customization of this rule is controlled entirely
          <a class="indexterm"></a> <a class="indexterm"></a>by the set of variables it uses. We see two variables
          here, but <code class="literal">COMPILE.c</code> in particular
          is defined in terms of several other variables:</p><a id="OEBPS/ch02s05.html.I_2_tt72"></a><pre class="programlisting">编译.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CC = 海湾合作委员会
输出选项 = -o $@</pre><pre class="programlisting">COMPILE.c = $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CC = gcc
OUTPUT_OPTION = -o $@</pre><p>C 编译器本身可以通过改变变量的值来改变<code class="literal">CC</code>。其他变量用于设置编译选项 ( <code class="literal">CFLAGS</code>)、预处理器选项 ( <code class="literal">CPPFLAGS</code>) 和特定于体系结构的选项 ( <code class="literal">TARGET_ARCH</code>)。</p><p>The C compiler itself can be changed by altering the value of
          the <code class="literal">CC</code> variable. The other
          variables are used for setting compilation options (<code class="literal">CFLAGS</code>), preprocessor options (<code class="literal">CPPFLAGS</code>), and architecture-specific
          options (<code class="literal">TARGET_ARCH</code>).</p><p>内置规则中的变量<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-979" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-980" class="indexterm"></a>旨在使自定义规则尽可能容易。因此，在 makefile 中设置这些变量时务必要非常<em class="filename">小心</em>。如果您以幼稚的方式设置这些变量，则会破坏最终用户自定义它们的能力。例如，在<em class="filename">makefile</em>中给出此分配：</p><p>The variables in a built-in rule <a class="indexterm"></a> <a class="indexterm"></a>are intended to make customizing the rule as easy as
          possible. For that reason, it is important to be very careful when
          setting these variables in your <em class="filename">makefile</em>. If you set these variables in a
          naive way, you destroy the end user's ability to customize them. For
          instance, given this assignment in a <em class="filename">makefile</em>:</p><a id="OEBPS/ch02s05.html.I_2_tt73"></a><pre class="programlisting">CPPFLAGS = -I 项目/包含</pre><pre class="programlisting">CPPFLAGS = -I project/include</pre><p>如果用户想要将 CPP 定义添加到命令行，他们通常会调用<em class="command">make</em> 
          ，如下所示：</p><p>If the user wanted to add a CPP define to the command line,
          they would normally invoke <em class="command">make</em>
          like:</p><a id="OEBPS/ch02s05.html.I_2_tt74"></a><pre class="programlisting">$ 使 CPPFLAGS=-DDEBUG</pre><pre class="programlisting">$ make CPPFLAGS=-DDEBUG</pre><p>但这样做时，他们会意外地删除
          <code class="option">-I</code>（大概）编译所需的选项。在命令行上设置的变量会覆盖对该变量的所有其他分配。 （有关命令行分配的更多详细信息，请参阅<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>中的<a class="link" href="#OEBPS/ch03s06.html" title="变量从何而来">3.6 节</a>）。因此，在<em class="filename">makefile</em>中设置不当会“破坏”大多数用户希望使用的自定义功能。不要使用简单的赋值，而是考虑重新定义编译变量以包含您自己的变量：<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><code class="literal">CPPFLAGS</code><em class="filename"></em></p><p>But in so doing they would accidentally remove the
          <code class="option">-I</code> option that is (presumably) required for
          compiling. Variables set on the command line override all other
          assignments to the variable. (See the <a class="link" href="#OEBPS/ch03s06.html" title="Where Variables Come From">Section 3.6</a> in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a> for more details on
          command-line assignments). So, setting <code class="literal">CPPFLAGS</code> inappropriately in the <em class="filename">makefile</em> "broke" a customization feature
          that most users would expect to work. Instead of using simple
          assignment, consider redefining the compilation variable to include
          your own variables:</p><a id="OEBPS/ch02s05.html.I_2_tt75"></a><pre class="programlisting">COMPILE.c = $(CC) $(CFLAGS) $(INCLUDES) $(CPPFLAGS) $(TARGET_ARCH) -c
包括 = -I 项目/包括</pre><pre class="programlisting">COMPILE.c = $(CC) $(CFLAGS) $(INCLUDES) $(CPPFLAGS) $(TARGET_ARCH) -c
INCLUDES = -I project/include</pre><p>或者您可以使用追加式赋值，这将在<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章的</a><a class="link" href="#OEBPS/ch03s02.html.make3-CHP-3-SECT-2.1" title="其他类型的作业">3.2.1 节</a>中
          讨论。<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a></p><p>Or you can use append-style assignment, which is discussed in
          the <a class="link" href="#OEBPS/ch03s02.html.make3-CHP-3-SECT-2.1" title="Other Types of Assignment">Section 3.2.1</a> in
          <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>.</p></div><div class="sect2" title="源代码控制的隐式规则"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s05.html.make3-CHP-2-SECT-5.3"></a>源代码控制的隐式规则</h2><h2 class="title"><a></a>Implicit Rules for Source Control</h2></div></div></div><p><em class="command">让</em>知道<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-981" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-982" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-983" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-984" class="indexterm"></a>两个源代码控制系统 RCS 和 SCCS，并支持它们与内置隐式规则的使用。不幸的是，源代码控制和现代软件工程的最先进水平似乎已经落后于<em class="command">make</em>。我从未在<em class="command">make</em>中发现源代码控制支持的用途，也没有看到它在其他生产软件中使用。我不建议使用此功能。有许多的原因。</p><p><em class="command">make</em> knows about <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>two source code control systems, RCS and SCCS, and
          supports their use with built-in implicit rules. Unfortunately, it
          seems the state of the art in source code control and modern
          software engineering have left <em class="command">make</em> behind. I've never found a use for
          the source control support in <em class="command">make</em>, nor have I seen it used in other
          production software. I do not recommend the use of this feature.
          There are a number of reasons for this.</p><p><em class="command">首先， make</em> 、RCS 和 SCCS支持的源代码控制工具虽然在当时是有价值且受人尊敬的工具，但在很大程度上已经被<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-985" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-986" class="indexterm"></a>被 CVS、并发版本系统或专有工具取代。事实上，CVS 使用 RCS 在内部管理各个文件。然而，当一个项目跨越多个目录或多个开发人员时，直接使用 RCS 被证明是一个相当大的问题。特别是 CVS 的实施是为了填补 RCS 在这些领域的功能空白。<em class="command">make</em>从未添加对 CVS 的支持，这可能是一件好事。<sup>[ <a id="OEBPS/ch02s05.html.make3-CHP-2-FNOTE-2" href="#OEBPS/ch02s05.html.ftn.make3-CHP-2-FNOTE-2" class="footnote">2</a> ]</sup></p><p>First, the source control tools supported by <em class="command">make</em>, RCS and SCCS, although valuable and
          venerable tools in their day, have largely been <a class="indexterm"></a> <a class="indexterm"></a>supplanted by CVS, the Concurrent Version System, or
          proprietary tools. In fact, CVS uses RCS to manage individual files
          internally. However, using RCS directly proved to be a considerable
          problem when a project spanned more than one directory or more than
          one developer. CVS, in particular, was implemented to fill the gaps
          in RCS's functionality in precisely these areas. Support for CVS has
          never been added to <em class="command">make</em>, which
          is probably a good thing.<sup>[<a href="#OEBPS/ch02s05.html.ftn.make3-CHP-2-FNOTE-2" class="footnote">2</a>]</sup></p><p>现在人们普遍认识到软件的生命周期变得复杂。应用程序很少能顺利地从一个版本转移到下一个版本。更典型的是，应用程序的一个或多个不同版本正在现场使用（并且需要错误修复支持），而一个或多个版本正在积极开发中。 CVS 提供了强大的功能来帮助管理软件的这些并行版本。但这也意味着开发人员必须非常了解她正在处理的代码的特定版本。让
          <em class="filename">makefile</em>在编译期间自动签出源代码会引发以下问题：正在签出什么源代码以及新签出的源代码是否与开发人员工作目录中已存在的源代码兼容。在许多生产环境中，开发人员在一天内开发同一应用程序的三个或更多不同版本。如果没有软件悄悄地为您更新源代码树，控制这种复杂性就已经够困难的了。</p><p>It is now well recognized that the life cycle of software
          becomes complex. Applications rarely move smoothly from one release
          to the next. More typically, one or more distinct releases of an
          application are being used in the field (and require bug fix
          support), while one or more versions are in active development. CVS
          provides powerful features to help manage these parallel versions of
          the software. But it also means that a developer must be very aware
          of the specific version of the code she is working on. Having the
          <em class="filename">makefile</em> automatically check
          out source during a compilation begs the question of what source is
          being checked out and whether the newly checked out source is
          compatible with the source already existing in the developer's
          working directories. In many production environments, developers are
          working on three or more distinct versions of the same application
          in a single day. Keeping this complexity in check is hard enough
          without having software quietly updating your source tree for
          you.</p><p>此外，CVS 更强大的功能之一是它允许访问远程存储库。在大多数生产环境中，CVS 存储库（受控文件的数据库）并不位于开发人员自己的计算机上，而是位于服务器上。尽管现在网络访问速度相当快（特别是在局域网上），但通过探测网络服务器来搜索源文件并不是一个好<em class="command">主意</em>。性能影响将是灾难性的。</p><p>Also, one of the more powerful features of CVS is that it
          allows access to remote repositories. In most production
          environments, the CVS repository (the database of controlled files)
          is not located on the developer's own machine, but on a server.
          Although network access is now quite fast (particularly on a local
          area network) it is not a good idea to have <em class="command">make</em> probing the network server in search
          of source files. The performance impact would be disastrous.</p><p>因此，尽管可以使用内置的隐式规则或多或少干净地与 RCS 和 SCCS 接口，但没有规则可以访问 CVS 来收集源文件或<em class="filename">makefile</em>。我也不认为这样做有多大意义。另一方面，在<em class="filename">makefile</em>中使用 CVS 是相当合理的。例如，确保正确签入当前源、正确管理版本号信息或测试结果正确。这些是<em class="filename">makefile</em>作者对 CVS 的使用，而不是 CVS 与<em class="command">make</em>集成的问题。</p><p>So, although it is possible to use the built-in implicit rules
          to interface more or less cleanly with RCS and SCCS, there are no
          rules to access CVS for gathering source files or <em class="filename">makefile</em>. Nor do I think it makes much
          sense to do so. On the other hand, it is quite reasonable to use CVS
          in <em class="filename">makefile</em>s. For instance, to
          ensure that the current source is properly checked in, that the
          release number information is managed properly, or that test results
          are correct. These are uses of CVS by <em class="filename">makefile</em> authors rather than issues of
          CVS integration with <em class="command">make</em>.</p></div><div class="sect2" title="一个简单的帮助命令"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s05.html.make3-CHP-2-SECT-5.4"></a>一个简单的帮助命令</h2><h2 class="title"><a></a>A Simple Help Command</h2></div></div></div><p>大型<em class="filename">makefile</em>可以有很多<a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-987" class="indexterm"></a> <a id="OEBPS/ch02s05.html.make3-CHP-2-ITERM-988" class="indexterm"></a>用户难以记住的目标。减少此问题的一种方法是使默认目标成为简短的帮助命令。然而，手动维护帮助文本始终是一个问题。为了避免这种情况，您可以直接从<em class="command">make</em>的规则数据库收集可用命令。以下目标将显示可用<em class="command">make</em>目标的排序四列列表
          ：</p><p>Large <em class="filename">makefile</em>s can have
          many <a class="indexterm"></a> <a class="indexterm"></a>targets that are difficult for users to remember. One
          way to reduce this problem is to make the default target a brief
          help command. However, maintaining the help text by hand is always a
          problem. To avoid this, you can gather the available commands
          directly from <em class="command">make</em>'s rules
          database. The following target will present a sorted four column
          listing of the available <em class="command">make</em>
          targets:</p><a id="OEBPS/ch02s05.html.I_2_tt76"></a><pre class="programlisting"># help - 默认目标
.PHONY：帮助
帮助：
        @$(MAKE) --print-data-base --question no-such-target | @$(MAKE) --print-data-base --question no-such-target |
        $(GREP) -v -e '^no-such-target' -e '^makefile' | $(GREP) -v -e '^no-such-target' -e '^makefile' |
        $(AWK) '/^[^.%][-A-Za-z0-9_]*:/
               { 打印 substr($$1, 1, 长度($$1)-1) }' |
        $（排序）|
        $(PR) --省略分页 --width=80 --columns=4</pre><pre class="programlisting"># help - The default goal
.PHONY: help
help:
        @$(MAKE) --print-data-base --question no-such-target |
        $(GREP) -v -e '^no-such-target' -e '^makefile' |
        $(AWK) '/^[^.%][-A-Za-z0-9_]*:/
               { print substr($$1, 1, length($$1)-1) }' |
        $(SORT) |
        $(PR) --omit-pagination --width=80 --columns=4</pre><p>命令脚本由单个管道组成。使用该命令转储
          make
          <em class="command">规则</em><code class="option">--print-data-base</code>数据库。指定 no-such-target 的目标（而不是默认目标）可确保递归运行 makefile 不会触发无限递归。该
          <code class="literal">grep</code>命令过滤掉伪造的目标和 makefile 本身（通常在数据库转储中显示）。使用该<code class="option">—question</code>选项可防止<em class="command">make</em>运行任何实际命令。然后数据库通过一个简单的<em class="command">awk</em>过滤器，该过滤器抓取表示不以百分比或句点（分别为模式规则和后缀规则）开头的目标的每一行，并丢弃该行上的额外信息。最后，目标列表被排序并打印在一个简单的四列列表中。</p><p>The command script consists of a single pipeline. The
          <em class="command">make</em> rule database is dumped using the
          <code class="option">--print-data-base</code> command. Specifying a target of
          no-such-target (instead of the default target) ensures that running
          the makefile recursively does not trigger infinite recursion. The
          <code class="literal">grep</code> command filters out the bogus target and the
          makefile itself (which appears as a rule in the database dump).
          Using the <code class="option">—question</code> option prevents <em class="command">make</em> from running any actual commands. The
          database is then passed through a simple <em class="command">awk</em> filter that grabs every line
          representing a target that does not begin with percent or period
          (pattern rules and suffix rules, respectively) and discards extra
          information on the line. Finally, the target list is sorted and
          printed in a simple four-column listing.</p><p>同一命令的另一种方法（我的第一次尝试）是在<em class="filename">makefile本身上使用</em><em class="command">awk</em>命令。这需要对包含的<em class="filename">makefile</em>进行特殊处理（在<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>的<a class="link" href="#OEBPS/ch03s07.html.make3-CHP-3-SECT-7.1" title="包含指令">3.7.1 节</a>中介绍），并且根本无法处理生成的规则。这里提供的版本通过允许<em class="command">make</em>处理这些元素并报告结果规则集来自动处理所有这些。<em class="filename"></em><em class="filename"></em><a class="link" href="#OEBPS/ch03s07.html.make3-CHP-3-SECT-7.1" title="包含指令"></a><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><em class="command"></em></p><p>Another approach to the same command (my first attempt), used
          the <em class="command">awk</em> command on the <em class="filename">makefile</em> itself. This required special
          handling for included <em class="filename">makefile</em>s
          (covered in <a class="link" href="#OEBPS/ch03s07.html.make3-CHP-3-SECT-7.1" title="The include Directive">Section
          3.7.1</a> in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>) and
          could not handle generated rules at all. The version presented here
          handles all that automatically by allowing <em class="command">make</em> to process these elements and report
          the resulting rule set.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch02s05.html.ftn.make3-CHP-2-FNOTE-2" href="#OEBPS/ch02s05.html.make3-CHP-2-FNOTE-2" class="para">2</a> ]</sup>反过来，CVS 正在被更新的工具所取代。虽然 Subversion ( <a class="ulink" href="http://subversion.tigris.org/">http://subversion.tigris.org</a> )是目前最普遍的源代码控制系统，但它看起来将成为新浪潮。</p><p><sup>[<a href="#OEBPS/ch02s05.html.make3-CHP-2-FNOTE-2" class="para">2</a>] </sup>CVS is, in turn, becoming supplanted by newer tools. While
              it is currently the most ubiquitous source control system,
              subversion (<a class="ulink" href="http://subversion.tigris.org">http://subversion.tigris.org</a>)
              looks to be the new wave.</p></div></div></div></div></div>
<div id="OEBPS/ch02s06.html"><div>
<div class="sect1" title="特殊目标"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s06.html.make3-CHP-2-SECT-6"></a>特殊目标</h1><h1 class="title"><a></a>Special Targets</h1></div></div></div><p>特殊<em class="firstterm">目标</em>是内置的假目标<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-989" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-990" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-991" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-992" class="indexterm"></a>target 用于更改<em class="command">make</em>的默认行为。例如，
        <code class="literal">.PHONY</code>我们已经看到的一个特殊目标，声明其先决条件并不引用实际文件，并且应始终被视为已过时。该
        <code class="literal">.PHONY</code>目标是您将看到的最常见的特殊目标，但也有其他目标。</p><p>A <em class="firstterm">special target</em> is a built-in
        phony<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> target used to change <em class="command">make</em>'s default behavior. For instance,
        <code class="literal">.PHONY</code>, a special target, which
        we've already seen, declares that its prerequisite does not refer to
        an actual file and should always be considered out of date. The
        <code class="literal">.PHONY</code> target is the most common
        special target you will see, but there are others as well.</p><p>这些特殊目标遵循普通目标的语法，即<em class="replaceable"><code>target</code></em>:
         <em class="replaceable"><code>prerequisite</code></em>，但
        <em class="replaceable"><code>target</code></em>不是文件，甚至不是普通的虚假目标。它们实际上更像是修改<em class="command">make</em>内部算法的指令。</p><p>These special targets follow the syntax of normal targets, that
        is <em class="replaceable"><code>target</code></em>:
        <em class="replaceable"><code>prerequisite</code></em>, but the
        <em class="replaceable"><code>target</code></em> is not a file or even a normal
        phony. They are really more like directives for modifying <em class="command">make</em>'s internal algorithms.</p><p>有十二个特殊目标。它们分为三类：正如我们刚才所说，许多用于
        在更新目标时更改<em class="command">make的行为，另一组仅充当全局标志来</em><em class="command">生成</em>和忽略其目标，最后
        <code class="literal">.SUFFIXES</code>在指定旧目标时使用特殊目标 -制定的后缀规则（在本章前面的<a class="link" href="#OEBPS/ch02s04.html.make3-CHP-2-SECT-4.3" title="后缀规则">2.4.3 节中讨论）。</a></p><p>There are twelve special targets. They fall into three
        categories: as we've just said many are used to alter the behavior of
        <em class="command">make</em> when updating a target,
        another set act simply as global flags to <em class="command">make</em> and ignore their targets, finally the
        <code class="literal">.SUFFIXES</code> special target is used
        when specifying old-fashioned suffix rules (discussed in the <a class="link" href="#OEBPS/ch02s04.html.make3-CHP-2-SECT-4.3" title="Suffix Rules">Section 2.4.3</a> earlier in this
        chapter).</p><p>最有用的目标<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-993" class="indexterm"></a>修饰符（除了<code class="literal">.PHONY</code>）有：</p><p>The most useful target<a class="indexterm"></a> modifiers (aside from <code class="literal">.PHONY</code>) are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">.INTERMEDIATE</code></span></dt><dt><span class="term"><code class="literal">.INTERMEDIATE</code></span></dt><dd><p>这样做的先决条件<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-995" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-996" class="indexterm"></a>特殊目标<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-997" class="indexterm"></a>被视为中间文件。如果<em class="command">make在更新另一个目标时创建该文件，则当</em><em class="command">make</em>退出时该文件将被自动删除
              。如果<em class="command">make</em>
              考虑更新文件时该文件已经存在，则不会删除该文件。</p></dd><dd><p>Prerequisites of this <a class="indexterm"></a> <a class="indexterm"></a>special target <a class="indexterm"></a>are treated as intermediate files. If <em class="command">make</em> creates the file while updating
              another target, the file will be deleted automatically when
              <em class="command">make</em> exits. If the file
              already exists when <em class="command">make</em>
              considers updating the file, the file will not be
              deleted.</p></dd><dt><span class="term">&nbsp;</span></dt><dt><span class="term">&nbsp;</span></dt><dd><p>这在构建自定义规则链时非常有用。例如，大多数 Java 工具都接受类似 Windows 的文件列表。创建规则来构建文件列表并将其输出文件标记为中间文件允许<em class="command">make</em>清理许多临时文件。</p></dd><dd><p>This can be very useful when building custom rule chains.
              For instance, most Java tools accept Windows-like file lists.
              Creating rules to build the file lists and marking their output
              files as intermediate allows <em class="command">make</em> to clean up many temporary
              files.</p></dd><dt><span class="term"><code class="literal">.SECONDARY</code></span></dt><dt><span class="term"><code class="literal">.SECONDARY</code></span></dt><dd><p>这样做的先决条件<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-999" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1000" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001" class="indexterm"></a>特殊目标被视为中间文件，但永远不会自动删除。最常见的用途
              <code class="literal">.SECONDARY</code>是标记存储在<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1002" class="indexterm"></a>图书馆。通常，这些目标文件一旦添加到存档中就会被删除。有时，在开发过程中保留这些目标文件会更方便，但仍使用<em class="command">make</em>
              支持来更新存档。</p></dd><dd><p>Prerequisites of this <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>special target are treated as intermediate files
              but are never automatically deleted. The most common use of
              <code class="literal">.SECONDARY</code> is to mark object
              files stored in <a class="indexterm"></a>libraries. Normally these object files will be
              deleted as soon as they are added to an archive. Sometimes it is
              more convenient during development to keep these object files,
              but still use the <em class="command">make</em>
              support for updating archives.</p></dd><dt><span class="term"><code class="literal">.PRECIOUS</code></span></dt><dt><span class="term"><code class="literal">.PRECIOUS</code></span></dt><dd><p>当<em class="command">make</em>中断时<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1004" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005" class="indexterm"></a><em class="command">在执行期间，如果自make</em>启动以来文件被修改，它可能会删除正在更新的目标文件。这样<em class="command">make</em>就不会在构建树中留下部分构建的（可能已损坏的）文件。有时您不希望出现这种行为，特别是当文件很大并且创建的计算成本很高时。如果您将文件标记为珍贵，则即使中断， <em class="command">make</em>也永远不会删除该文件。</p></dd><dd><p>When <em class="command">make</em> is
              interrupted <a class="indexterm"></a> <a class="indexterm"></a>during execution, it may delete the target file it
              is updating if the file was modified since <em class="command">make</em> started. This is so <em class="command">make</em> doesn't leave a partially
              constructed (possibly corrupt) file laying around in the build
              tree. There are times when you don't want this behavior,
              particularly if the file is large and computationally expensive
              to create. If you mark the file as precious, <em class="command">make</em> will never delete the file if
              interrupted.</p></dd><dt><span class="term">&nbsp;</span></dt><dt><span class="term">&nbsp;</span></dt><dd><p>使用的<code class="literal">.PRECIOUS</code>情况相对较少，但当需要时它通常可以成为救星。请注意，如果规则的命令生成错误，<em class="command">make</em>将不会执行自动删除。仅当被信号中断时它才会这样做。</p></dd><dd><p>Use of <code class="literal">.PRECIOUS</code> is
              relatively rare, but when it is needed it is often a life saver.
              Note that <em class="command">make</em> will not
              perform an automatic delete if the commands of a rule generate
              an error. It does so only when interrupted by a signal.</p></dd><dt><span class="term"><code class="literal">.DELETE_ON_ERROR</code></span></dt><dt><span class="term"><code class="literal">.DELETE_ON_ERROR</code></span></dt><dd><p>这有点像<a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007" class="indexterm"></a> <a id="OEBPS/ch02s06.html.make3-CHP-2-ITERM-1008" class="indexterm"></a>的反面<code class="literal">.PRECIOUS</code>。将目标标记为
              <code class="literal">.DELETE_ON_ERROR</code>表示
              如果与规则关联的任何命令生成错误，则<em class="command">make</em>
              <span class="emphasis"><em>应</em></span><em class="command">删除该目标。 make</em>通常仅在被信号中断时才删除目标。</p></dd><dd><p>This is sort of the <a class="indexterm"></a> <a class="indexterm"></a>opposite of <code class="literal">.PRECIOUS</code>. Marking a target as
              <code class="literal">.DELETE_ON_ERROR</code> says that
              <em class="command">make</em>
              <span class="emphasis"><em>should</em></span> delete the target if any of the
              commands associated with the rule generates an error. <em class="command">make</em> normally only deletes the target
              if it is interrupted by a signal.</p></dd></dl></div><p>其他特殊目标将在其用途更相关时进行介绍。我们将<code class="literal">.EXPORT_ALL_VARIABLES</code>在<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章中讨论并在</a><a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能">第 10 章</a>中讨论与并行执行相关的目标。</p><p>The other special targets will be covered later when their use
        is more relevant. We'll discuss <code class="literal">.EXPORT_ALL_VARIABLES</code> in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a> and the targets relating to
        parallel execution in <a class="link" href="#OEBPS/ch10.html" title="Chapter&nbsp;10.&nbsp;Improving the Performance of make">Chapter
        10</a>.</p></div></div></div>
<div id="OEBPS/ch02s07.html"><div>
<div class="sect1" title="自动依赖生成"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s07.html.make3-CHP-2-SECT-7"></a>自动依赖生成</h1><h1 class="title"><a></a>Automatic Dependency Generation</h1></div></div></div><p>当我们重构我们的单词时<a id="OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009" class="indexterm"></a>计算程序使用头文件的数量时，一个棘手的小问题悄然而至。我们手动将目标文件和 C 头文件之间的依赖关系添加到<em class="filename">makefile</em>中。在这种情况下很容易做到，但在正常程序（不是玩具示例）中，这可能很乏味且容易出错。事实上，在大多数程序中这几乎是不可能的，因为大多数头文件都包含其他头文件，形成复杂的树。例如，在我的系统上，单个头文件<em class="filename">stdio.h</em>（C 中最常引用的头文件）扩展为包含 15 个其他头文件。手动解决这些关系是一项无望的任务。但未能重新编译文件可能会导致数小时的调试麻烦，或更糟糕的是，生成的程序中会出现错误。那么我们该怎么办？</p><p>When we refactored our word <a class="indexterm"></a>counting program to use header files, a thorny little
        problem snuck up on us. We added the dependency between the object
        files and the C header files to the <em class="filename">makefile</em> by hand. It was easy to do in this
        case, but in normal programs (not toy examples) this can be tedious
        and error-prone. In fact, in most programs it is virtually impossible
        because most header files include other header files forming a complex
        tree. For instance, on my system, the single header file <em class="filename">stdio.h</em> (the most commonly referenced
        header file in C) expands to include 15 other header files. Resolving
        these relationships by hand is a hopeless task. But failing to
        recompile files can lead to hours of debugging headaches or worse,
        bugs in the resulting program. So what do we do?</p><p>嗯，计算机非常擅长搜索和模式匹配。让我们使用一个程序来识别文件之间的关系，甚至可以让该程序以<em class="filename">makefile</em>语法写出这些依赖关系
        。您可能已经猜到，这样的程序已经存在——至少对于 C/C++ 来说是这样。<em class="command">gcc</em>和许多其他 C/C++ 编译器有一个选项可以读取源代码并编写<em class="filename">makefile</em>依赖项。例如，以下是我找到<em class="filename">stdio.h</em>依赖项的方法：</p><p>Well, computers are pretty good at searching and pattern
        matching. Let's use a program to identify the relationships between
        files and maybe even have this program write out these dependencies in
        <em class="filename">makefile</em> syntax. As you have
        probably guessed, such a program already exists—at least for C/C++.
        There is a option to <em class="command">gcc</em> and many
        other C/C++ compilers that will read the source and write <em class="filename">makefile</em> dependencies. For instance, here
        is how I found the dependencies for <em class="filename">stdio.h</em>:</p><a id="OEBPS/ch02s07.html.I_2_tt77"></a><pre class="programlisting">$$<strong class="userinput"><code>echo "#include &lt;stdio.h&gt;" &gt; stdio.c</code></strong>
​<strong class="userinput"><code>gcc -M stdio.c</code></strong>
stdio.o：stdio.c /usr/include/stdio.h /usr/include/_ansi.h \
  /usr/include/newlib.h /usr/include/sys/config.h \
  /usr/include/machine/ieeefp.h /usr/include/cygwin/config.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stddef.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stdarg.h \
  /usr/include/sys/reent.h /usr/include/sys/_types.h \
  /usr/include/sys/types.h /usr/include/machine/types.h \
  /usr/include/sys/features.h /usr/include/cygwin/types.h \
  /usr/include/sys/sysmacros.h /usr/include/stdint.h \
  /usr/include/sys/stdio.h</pre><pre class="programlisting">$<strong class="userinput"><code>echo "#include &lt;stdio.h&gt;" &gt; stdio.c</code></strong>
$ <strong class="userinput"><code>gcc -M stdio.c</code></strong>
stdio.o: stdio.c /usr/include/stdio.h /usr/include/_ansi.h \
  /usr/include/newlib.h /usr/include/sys/config.h \
  /usr/include/machine/ieeefp.h /usr/include/cygwin/config.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stddef.h \
  /usr/lib/gcc-lib/i686-pc-cygwin/3.2/include/stdarg.h \
  /usr/include/sys/reent.h /usr/include/sys/_types.h \
  /usr/include/sys/types.h /usr/include/machine/types.h \
  /usr/include/sys/features.h /usr/include/cygwin/types.h \
  /usr/include/sys/sysmacros.h /usr/include/stdint.h \
  /usr/include/sys/stdio.h</pre><p>“美好的。”我听到你哭了，“现在我需要运行<code class="literal">gcc</code>并使用编辑器将结果粘贴<code class="literal">-M</code>到我的<em class="filename">makefile</em>中。多痛苦啊。”如果这就是全部答案，那你就是对的。有两种传统方法可以将自动生成的依赖项包含到<em class="filename">makefile</em>中。第一个也是最古老的方法是添加一行，例如：</p><p>"Fine." I hear you cry, "Now I need to run <code class="literal">gcc</code> and use an editor to paste the results
        of <code class="literal">-M</code> into my <em class="filename">makefile</em>s. What a pain." And you'd be right
        if this was the whole answer. There are two traditional methods for
        including automatically generated dependencies into <em class="filename">makefile</em>s. The first and oldest is to add a
        line such as:</p><a id="OEBPS/ch02s07.html.I_2_tt78"></a><pre class="programlisting"># 自动生成依赖项 - 请勿编辑</pre><pre class="programlisting"># Automatically generated dependencies follow - Do Not Edit</pre><p><em class="filename">到makefile</em>的末尾
        ，然后编写 shell 脚本来更新这些生成的行。这当然比手动更新它们要好，但也非常难看。第二种方法是在<em class="command">make</em><code class="literal">include</code>程序中添加指令。到目前为止，大多数版本的
        <em class="command">make</em>都有该指令，<acronym class="acronym">GNU </acronym><em class="command">make</em>肯定也有。<em class="command"></em><em class="command"></em><code class="literal">include</code><acronym class="acronym"></acronym>
        <em class="command"></em></p><p>to the end of the <em class="filename">makefile</em>
        and then write a shell script to update these generated lines. This is
        certainly better than updating them by hand, but it's also very ugly.
        The second method is to add an <code class="literal">include</code> directive to the <em class="command">make</em> program. By now most versions of
        <em class="command">make</em> have the <code class="literal">include</code> directive and <acronym class="acronym">GNU</acronym>
        <em class="command">make</em> most certainly does.</p><p>因此，技巧是编写一个<em class="filename">makefile</em>目标，其操作使用选项对所有源
        运行<em class="command">gcc</em><code class="option">-M</code>，将结果保存在依赖文件中，然后重新运行<em class="command">make</em>，将生成的依赖文件包含在<em class="filename">makefile</em>中，以便它可以触发更新我们需要。在<acronym class="acronym">GNU </acronym> <em class="command">make</em>之前，这正是所做的事情，规则如下：</p><p>So, the trick is to write a <em class="filename">makefile</em> target whose action runs <em class="command">gcc</em> over all your source with the
        <code class="option">-M</code> option, saves the results in a dependency file,
        and then re-runs <em class="command">make</em> including the
        generated dependency file in the <em class="filename">makefile</em> so it can trigger the updates we
        need. Before <acronym class="acronym">GNU</acronym> <em class="command">make</em>, this is exactly what was done and the
        rule looked like:</p><a id="OEBPS/ch02s07.html.I_2_tt79"></a><pre class="programlisting">依赖：count_words.c lexer.c counter.c
        $(CC) -M $(CPPFLAGS) $^ &gt; $@

包括依赖</pre><pre class="programlisting">depend: count_words.c lexer.c counter.c
        $(CC) -M $(CPPFLAGS) $^ &gt; $@

include depend</pre><p>在运行<em class="command">make</em>构建程序之前，您首先需要执行<em class="command">make dependent</em>来生成依赖项。就目前而言，这很好，但人们通常会在源中添加或删除依赖项，而不重新生成<em class="filename">依赖</em>文件。然后源代码就不会被重新编译，整个混乱又开始了。</p><p>Before running <em class="command">make</em> to build
        the program, you would first execute <em class="command">make
        depend</em> to generate the dependencies. This was good as far as
        it went, but often people would add or remove dependencies from their
        source without regenerating the <em class="filename">depend</em> file. Then source wouldn't get
        recompiled and the whole mess started again.</p><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>
        通过一个很酷的功能和一个简单的算法解决了最后一个棘手的问题。首先，算法。如果我们将每个源文件的依赖项生成到其自己的依赖项文件中，例如，带有<em class="filename">.d</em>后缀，并将<em class="filename">.d</em>文件本身作为目标添加到此依赖项规则中，那么<em class="command">make</em>可以知道<em class="filename">.d</em>需要更新（以及目标文件）当源文件更改时：</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
        solved this last niggling problem with a cool feature and a simple
        algorithm. First, the algorithm. If we generated each source file's
        dependencies into its own dependency file with, say, a <em class="filename">.d</em> suffix and added the <em class="filename">.d</em> file itself as a target to this
        dependency rule, then <em class="command">make</em> could
        know that the <em class="filename">.d</em> needed to be
        updated (along with the object file) when the source file
        changed:</p><a id="OEBPS/ch02s07.html.I_2_tt80"></a><pre class="programlisting">counter.o counter.d: src/counter.c include/counter.h include/lexer.h</pre><pre class="programlisting">counter.o counter.d: src/counter.c include/counter.h include/lexer.h</pre><p>生成此规则可以使用模式规则和（相当丑陋的）命令脚本来完成（这直接取自
        <acronym class="acronym">GNU </acronym> <em class="command">make</em>
        手册）：<sup>[ <a id="OEBPS/ch02s07.html.make3-CHP-2-FNOTE-3" href="#OEBPS/ch02s07.html.ftn.make3-CHP-2-FNOTE-3" class="footnote">3</a> ]</sup></p><p>Generating this rule can be accomplished with a pattern rule and
        a (fairly ugly) command script (this is taken directly from the
        <acronym class="acronym">GNU</acronym> <em class="command">make</em>
        manual):<sup>[<a href="#OEBPS/ch02s07.html.ftn.make3-CHP-2-FNOTE-3" class="footnote">3</a>]</sup></p><a id="OEBPS/ch02s07.html.I_2_tt81"></a><pre class="programlisting">%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
        rm -f $@.$$$$</pre><pre class="programlisting">%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$;                  \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
        rm -f $@.$$$$</pre><p>现在，我们来看看这个很酷的功能。<em class="command">make</em>会将指令中指定的任何文件
        <code class="literal">include</code>视为要更新的目标。因此，当我们提到要包含的<em class="filename">.d文件时， </em><em class="command">make将在读取</em><em class="filename">makefile</em>时自动尝试创建这些文件。这是我们的<em class="filename">makefile</em>，添加了自动依赖项生成：</p><p>Now, for the cool feature. <em class="command">make</em> will treat any file named in an
        <code class="literal">include</code> directive as a target to be
        updated. So, when we mention the <em class="filename">.d</em> files we want to include, <em class="command">make</em> will automatically try to create these
        files as it reads the <em class="filename">makefile</em>.
        Here is our <em class="filename">makefile</em> with the
        addition of automatic dependency generation:</p><a id="OEBPS/ch02s07.html.I_2_tt82"></a><pre class="programlisting">VPATH = src 包含
CPPFLAGS = -我包括

来源= count_words.c \
           词法分析器.c \
           计数器.c

count_words: counter.o lexer.o -lfl
count_words.o：计数器.h
counter.o: counter.h lexer.h
词法分析器.o: 词法分析器.h

包括 $(subst .c,.d,$(来源))

%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
        rm -f $@.$$$$</pre><pre class="programlisting">VPATH    = src include
CPPFLAGS = -I include

SOURCES  = count_words.c \
           lexer.c       \
           counter.c

count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h

include $(subst .c,.d,$(SOURCES))

%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$;                      \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@;     \
        rm -f $@.$$$$</pre><p>该<code class="literal">include</code>指令应始终放置在手写依赖项之后，以便默认目标不会被某些依赖项文件劫持。该<code class="literal">include</code>指令采用文件列表（其名称可以包含通配符）。这里我们使用<em class="command">make</em>函数<code class="function">subst</code>，将源文件列表转换为依赖文件名列表。 （我们将在<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>的<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1" title="字符串函数">4.2.1 节</a><code class="function">subst</code>中详细讨论。）现在，只需注意此用法将中每个单词中的
        字符串<em class="filename">.c</em>替换为
        <em class="filename">.d</em>。<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1" title="字符串函数"></a><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a><em class="filename"></em><em class="filename"></em><code class="literal">$(SOURCES)</code></p><p>The <code class="literal">include</code> directive should
        always be placed after the hand-written dependencies so that the
        default goal is not hijacked by some dependency file. The <code class="literal">include</code> directive takes a list of files
        (whose names can include wildcards). Here we use a <em class="command">make</em> function, <code class="function">subst</code>, to transform the list of source
        files into a list of dependency filenames. (We'll discuss <code class="function">subst</code> in detail in <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1" title="String Functions">Section 4.2.1</a> in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>.) For now, just note that this
        use replaces the string <em class="filename">.c</em> with
        <em class="filename">.d</em> in each of the words in
        <code class="literal">$(SOURCES)</code>.</p><p>当我们
        使用该选项运行此<em class="filename">makefile</em><code class="option">—just-print</code>时，我们得到：</p><p>When we run this <em class="filename">makefile</em>
        with the <code class="option">—just-print</code> option, we get:</p><a id="OEBPS/ch02s07.html.I_2_tt83"></a><pre class="programlisting">$<strong class="userinput"><code>make --just-print</code></strong>
Makefile:13: count_words.d: 没有这样的文件或目录
Makefile:13: lexer.d: 没有这样的文件或目录
Makefile:13: counter.d: 没有这样的文件或目录
gcc -M -I include src/counter.c &gt; counter.d.$$; \
sed 's,\(counter\)\.o[ :]*,\1.o counter.d : ,g' &lt; counter.d.$$ &gt;
计数器.d; \
rm -f counter.d.$$
flex -t src/lexer.l &gt; lexer.c
gcc -M -I 包括 lexer.c &gt; lexer.d.$$; \
sed 's,\(lexer\)\.o[ :]*,\1.o lexer.d : ,g' &lt; lexer.d.$$ &gt; lexer.d;   
\
rm -f 词法分析器.d.$$
gcc -M -I include src/count_words.c &gt; count_words.d.$$;         
\
sed 's,\(count_words\)\.o[ :]*,\1.o count_words.d : ,g' &lt; count_words.d。
$$
count_words.d； \
rm -f count_words.d.$$
rm 词法分析器.c
gcc -I include -c -o count_words.o src/count_words.c
gcc -I include -c -o counter.o src/counter.c
gcc -I include -c -o lexer.o lexer.c
gcc count_words.o counter.o lexer.o /lib/libfl.a -o count_words</pre><pre class="programlisting">$<strong class="userinput"><code>make --just-print</code></strong>
Makefile:13: count_words.d: No such file or directory
Makefile:13: lexer.d: No such file or directory
Makefile:13: counter.d: No such file or directory
gcc -M -I include src/counter.c &gt; counter.d.$$;         \
sed 's,\(counter\)\.o[ :]*,\1.o counter.d : ,g' &lt; counter.d.$$ &gt; 
counter.d; \
rm -f counter.d.$$
flex -t src/lexer.l &gt; lexer.c
gcc -M -I include lexer.c &gt; lexer.d.$$;         \
sed 's,\(lexer\)\.o[ :]*,\1.o lexer.d : ,g' &lt; lexer.d.$$ &gt; lexer.d;   
\
rm -f lexer.d.$$
gcc -M -I include src/count_words.c &gt; count_words.d.$$;         
\
sed 's,\(count_words\)\.o[ :]*,\1.o count_words.d : ,g' &lt; count_words.d.
$$ 
count_words.d;   \
rm -f count_words.d.$$
rm lexer.c
gcc -I include -c -o count_words.o src/count_words.c
gcc -I include -c -o counter.o src/counter.c
gcc -I include -c -o lexer.o lexer.c
gcc  count_words.o counter.o lexer.o /lib/libfl.a  -o count_words</pre><p><em class="command">起初， make</em>的响应
        有点令人震惊——它看起来像一条<em class="command">make</em>错误消息。但不用担心，这只是一个警告。<em class="command">make</em>查找包含文件但没有找到它们，因此它会<code class="literal">No such file or directory</code>在搜索规则来创建这些文件之前发出警告。可以通过在<code class="literal">include</code>
        指令前添加连字符 ( )来抑制此警告<code class="literal">-</code>。警告后面的行显示<em class="command">make</em>使用选项调用<em class="command">gcc</em><code class="option">-M</code>，然后运行<em class="command">​​sed</em>命令。请注意，<em class="command">make</em>必须调用
        <em class="command">flex</em>来创建<em class="filename">lexer.c</em> ，然后在开始满足默认目标之前删除临时
        <em class="filename">lexer.c 。</em></p><p>At first the response by <em class="command">make</em>
        is a little alarming—it looks like a <em class="command">make</em> error message. But not to worry, this
        is just a warning. <em class="command">make</em> looks for
        the include files and doesn't find them, so it issues the <code class="literal">No such file or directory</code> warning before
        searching for a rule to create these files. This warning can be
        suppressed by preceding the <code class="literal">include</code>
        directive with a hyphen (<code class="literal">-</code>). The
        lines following the warnings show <em class="command">make</em> invoking <em class="command">gcc</em> with the <code class="option">-M</code> option,
        then running the <em class="command">sed</em> command.
        Notice that <em class="command">make</em> must invoke
        <em class="command">flex</em> to create <em class="filename">lexer.c</em>, then it deletes the temporary
        <em class="filename">lexer.c</em> before beginning to
        satisfy the default goal.</p><p>这让您体验一下自动依赖关系生成。还有很多东西要说，例如如何生成其他语言的依赖项或构建树布局。我们将在本书的第二部分中更深入地讨论这个主题。</p><p>This gives you a taste of automatic dependency generation.
        There's lots more to say, such as how do you generate dependencies for
        other languages or build tree layouts. We'll return to this topic in
        more depth in Part II of this book.</p><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch02s07.html.ftn.make3-CHP-2-FNOTE-3" href="#OEBPS/ch02s07.html.make3-CHP-2-FNOTE-3" class="para">3</a> ]</sup>这是一个令人印象深刻的小命令脚本，但我认为它需要一些解释。首先，我们使用 C 编译器来
            <code class="option">-M</code>创建一个包含该目标依赖项的临时文件。临时文件名是从目标 中创建的，<code class="literal">$@</code>并添加了唯一的数字后缀<code class="literal">$$$$</code>.在 shell 中，该变量
            <code class="literal">$$</code>返回当前运行的 shell 的进程号。由于进程号是唯一的，因此会产生唯一的文件名。然后，我们使用<em class="command">sed将</em><em class="filename">.d</em>文件作为目标添加到规则中。<em class="command">sed</em>表达式
            由搜索部分<code class="literal">\($*\)\.o[ :]*</code>和替换部分 :组成<code class="literal">\1.o $@
            </code>，以逗号分隔。搜索表达式以目标词干 开始，<code class="literal">$*</code>括在正则表达式 (RE) 组 中，<code class="literal">\(\)</code>后跟文件后缀
            <code class="literal">\.o</code>.在目标文件名之后，有零个或多个空格或冒号，<code class="literal">[ :]*</code>.替换部分通过引用第一个 RE 组并附加后缀 来恢复原始目标，<code class="literal">\1.o</code>然后添加依赖文件目标<code class="literal">$@</code>.</p><p><sup>[<a href="#OEBPS/ch02s07.html.make3-CHP-2-FNOTE-3" class="para">3</a>] </sup>This is an impressive little command script, but I think it
            requires some explanation. First, we use the C compiler with the
            <code class="option">-M</code> option to create a temporary file containing
            the dependencies for this target. The temporary filename is
            created from the target, <code class="literal">$@</code>,
            with a unique numeric suffix added, <code class="literal">$$$$</code>. In the shell, the variable
            <code class="literal">$$</code> returns the process number
            of the currently running shell. Since process numbers are unique,
            this produces a unique filename. We then use <em class="command">sed</em> to add the <em class="filename">.d</em> file as a target to the rule. The
            <em class="command">sed</em> expression consists of a
            search part, <code class="literal">\($*\)\.o[ :]*</code>,
            and a replacement part, <code class="literal">\1.o $@
            </code>:, separated by commas. The search expression begins
            with the target stem, <code class="literal">$*</code>,
            enclosed in a regular expression (RE) group, <code class="literal">\(\)</code>, followed by the file suffix,
            <code class="literal">\.o</code>. After the target filename,
            there come zero or more spaces or colons, <code class="literal">[ :]*</code>. The replacement portion restores
            the original target by referencing the first RE group and
            appending the suffix, <code class="literal">\1.o</code>,
            then adding the dependency file target, <code class="literal">$@</code>.</p></div></div></div></div></div>
<div id="OEBPS/ch02s08.html"><div>
<div class="sect1" title="管理图书馆"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch02s08.html.make3-CHP-2-SECT-8"></a>管理图书馆</h1><h1 class="title"><a></a>Managing Libraries</h1></div></div></div><p>档案<em class="firstterm">库</em>，通常<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1010" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1011" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1012" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1013" class="indexterm"></a>简称为库或存档，是一种特殊类型的文件，包含称为<em class="firstterm">members的</em>其他文件。归档用于将相关对象文件分组为更易于管理的单元。例如，C 标准库<em class="filename">libc.a</em>包含低级 C 函数。库非常常见，因此<em class="command">make</em>
        对创建、维护和引用它们有特殊支持。档案是使用<em class="command">ar</em>程序创建和修改的。</p><p>An <em class="firstterm">archive</em> library, usually <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>called simply a library or archive, is a special type of
        file containing other files called <em class="firstterm">members</em>.
        Archives are used to group related object files into more manageable
        units. For example, the C standard library <em class="filename">libc.a</em> contains low-level C functions.
        Libraries are very common so <em class="command">make</em>
        has special support for creating, maintaining, and referencing them.
        Archives are created and modified with the <em class="command">ar</em> program.</p><p>让我们看一个例子。我们可以通过将可重用部分重构为可重用库来修改我们的字数统计程序。我们的库将包含两个文件<em class="filename">counter.o</em>和<em class="filename">lexer.o</em>。 ar命令<em class="command">​</em><a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1014" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1015" class="indexterm"></a>创建这个库是：</p><p>Let's look at an example. We can modify our word counting
        program by refactoring the reusable parts into a reusable library. Our
        library will consist of the two files <em class="filename">counter.o</em> and <em class="filename">lexer.o</em>. The <em class="command">ar</em> command to<a class="indexterm"></a> <a class="indexterm"></a> create this library is:</p><a id="OEBPS/ch02s08.html.I_2_tt84"></a><pre class="programlisting">$<strong class="userinput"><code>ar rv libcounter.a counter.o lexer.o</code></strong>
a - 计数器.o
a - 词法分析器.o</pre><pre class="programlisting">$<strong class="userinput"><code>ar rv libcounter.a counter.o lexer.o</code></strong>
a - counter.o
a - lexer.o</pre><p>这些选项<code class="option">rv</code>表明我们想要
        用列出的目标文件<span class="emphasis"><em>替换</em></span>存档的成员，并且<em class="command">ar</em>应该
        <span class="emphasis"><em>详细</em></span>地回显其操作。即使存档不存在，我们也可以使用替换选项。选项后面的第一个参数是存档名称，后跟目标文件列表。 （如果存档不存在但<acronym class="acronym">GNU </acronym><em class="command">ar</em>不存在，
        某些版本的<em class="command">ar</em>
        还需要“c”选项来<span class="emphasis"><em>创建</em></span><em class="command">。） ar</em>命令后面的两行是其详细输出，指示已添加目标文件。<acronym class="acronym"></acronym> <em class="command"></em><em class="command"></em></p><p>The options <code class="option">rv</code> indicate that we want to
        <span class="emphasis"><em>r</em></span>eplace members of the archive with the object
        files listed and that <em class="command">ar</em> should
        <span class="emphasis"><em>v</em></span>erbosely echo its actions. We can use the
        replace option even though the archive doesn't exist. The first
        argument after the options is the archive name followed by a list of
        object files. (Some versions of <em class="command">ar</em>
        also require the "c" option, for <span class="emphasis"><em>c</em></span>reate, if the
        archive does not exist but <acronym class="acronym">GNU</acronym> <em class="command">ar</em> does not.) The two lines following the
        <em class="command">ar</em> command are its verbose output
        indicating the object files were added.</p><p><em class="command">使用ar</em>的替换选项允许我们增量创建或更新存档：</p><p>Using the replace option to <em class="command">ar</em> allows us to create or update an archive
        incrementally:</p><a id="OEBPS/ch02s08.html.I_2_tt85"></a><pre class="programlisting">$<strong class="userinput"><code>ar rv libcounter.a counter.o</code></strong>
r - 计数器.o
$ <strong class="userinput"><code>ar rv libcounter.a lexer.o</code></strong>
r - lexer.o</pre><pre class="programlisting">$<strong class="userinput"><code>ar rv libcounter.a counter.o</code></strong>
r - counter.o
$ <strong class="userinput"><code>ar rv libcounter.a lexer.o</code></strong>
r - lexer.o</pre><p>这里<em class="command">ar</em>用“r”回显每个操作，表示文件已在存档中被替换。</p><p>Here <em class="command">ar</em> echoed each action
        with "r" to indicate the file was replaced in the archive.</p><p>可以通过多种方式将库链接到可执行文件。最直接的方法是简单地在命令行上列出库文件。编译器或链接器将使用文件后缀来确定命令行上特定文件的类型并执行正确的操作©：</p><p>A library can be linked into an executable in several ways. The
        most straightforward way is to simply list the library file on the
        command line. The compiler or linker will use the file suffix to
        determine the type of a particular file on the command line and do the
        Right Thing©:</p><a id="OEBPS/ch02s08.html.I_2_tt86"></a><pre class="programlisting">cc count_words.o libcounter.a /lib/libfl.a -o count_words</pre><pre class="programlisting">cc count_words.o libcounter.a /lib/libfl.a -o count_words</pre><p>这里<em class="command">cc会将</em><em class="filename">libcounter.a</em>和
        <em class="filename">/lib/libfl.a</em>这两个文件识别为库，并在它们中搜索未定义的符号。在命令行上引用库的另一种方法是使用以下<code class="option">-l</code>
        选项：</p><p>Here <em class="command">cc</em> will recognize the
        two files <em class="filename">libcounter.a</em> and
        <em class="filename">/lib/libfl.a</em> as libraries and
        search them for undefined symbols. The other way to reference
        libraries on the command line is with the <code class="option">-l</code>
        option:</p><a id="OEBPS/ch02s08.html.I_2_tt87"></a><pre class="programlisting">cc count_words.o -lcounter -lfl -o count_words</pre><pre class="programlisting">cc count_words.o -lcounter -lfl -o count_words</pre><p>如您所见，使用此选项可以省略库文件名的前缀和后缀。该<code class="option">-l</code>选项使命令行更加紧凑且更易于阅读，但它具有更有用的功能。当<em class="command">cc</em>看到该
        <code class="option">-l</code>选项时，它会在系统的标准库目录中<span class="emphasis"><em>搜索</em></span>该库。这使程序员不必知道库的精确位置，并使命令行更加可移植。此外，在支持共享库（Unix 系统上扩展名为<em class="filename">.so</em>的库）的系统上，链接器将首先搜索共享库，然后再搜索存档库。这使得程序可以从共享库中受益，而无需专门要求它们。这是<acronym class="acronym">GNU</acronym>链接器/编译器的默认行为
        。较旧的链接器/编译器可能无法执行此优化。</p><p>As you can see, with this option you omit the prefix and suffix
        of the library filename. The <code class="option">-l</code> option makes the
        command line more compact and easier to read, but it has a far more
        useful function. When <em class="command">cc</em> sees the
        <code class="option">-l</code> option it <span class="emphasis"><em>searches</em></span> for the
        library in the system's standard library directories. This relieves
        the programmer from having to know the precise location of a library
        and makes the command line more portable. Also, on systems that
        support shared libraries (libraries with the extension <em class="filename">.so</em> on Unix systems), the linker will
        search for a shared library first, before searching for an archive
        library. This allows programs to benefit from shared libraries without
        specifically requiring them. This is the default behavior of
        <acronym class="acronym">GNU</acronym>'s linker/compiler. Older linker/compilers may
        not perform this optimization.</p><p><code class="option">-L</code>可以通过添加指示要搜索的目录以及搜索顺序的选项来更改编译器使用的搜索路径
        。这些目录添加在系统库之前，用于<code class="option">-l</code>命令行上的所有选项。事实上，最后一个示例无法链接，因为当前目录不在<em class="command">cc</em>的库搜索路径中。我们可以通过添加当前目录来修复此错误，如下所示：</p><p>The search path used by the compiler can be changed by adding
        <code class="option">-L</code> options indicating the directories to search and
        in what order. These directories are added before the system libraries
        and are used for all <code class="option">-l</code> options on the command line.
        In fact, the last example fails to link because the current directory
        is not in <em class="command">cc</em>'s library search path.
        We can fix this error by adding the current directory like
        this:</p><a id="OEBPS/ch02s08.html.I_2_tt88"></a><pre class="programlisting">抄送 count_words.o -L。 -lcounter -lfl -o 字数</pre><pre class="programlisting">cc count_words.o -L. -lcounter -lfl -o count_words</pre><p>库给构建程序的过程增加了一些复杂性。如何才能<em class="command">帮助</em>简化情况？<acronym class="acronym">GNU </acronym> <em class="command">make</em>包含支持库的创建及其在链接程序中的使用的特殊功能。让我们看看它们是如何工作的。</p><p>Libraries add a bit of complication to the process of building a
        program. How can <em class="command">make</em> help to
        simplify the situation? <acronym class="acronym">GNU</acronym> <em class="command">make</em> includes special features to support
        both the creation of libraries and their use in linking programs.
        Let's see how they work.</p><div class="sect2" title="创建和更新库"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s08.html.make3-CHP-2-SECT-8.1"></a>创建和更新库</h2><h2 class="title"><a></a>Creating and Updating Libraries</h2></div></div></div><p>在<em class="filename">makefile</em>中，库文件是<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1016" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1017" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1018" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1019" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1020" class="indexterm"></a>就像任何其他文件一样用其名称指定。创建我们的库的一个简单规则是：</p><p>Within a <em class="filename">makefile</em>, a
          library file is <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>specified with its name just like any other file. A
          simple rule to create our library is:</p><a id="OEBPS/ch02s08.html.I_2_tt89"></a><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(AR) $(ARFLAGS) $@ $^</pre><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(AR) $(ARFLAGS) $@ $^</pre><p><em class="command">这使用ar</em>程序的内置定义和中的<code class="literal">AR</code>标准选项
          。归档输出文件自动设置在 中，先决条件在 中设置
          。<code class="option">rv</code><code class="literal">ARFLAGS</code><code class="literal">$@</code><code class="literal">$^</code></p><p>This uses the built-in definition for the <em class="command">ar</em> program in <code class="literal">AR</code> and the standard options
          <code class="option">rv</code> in <code class="literal">ARFLAGS</code>.
          The archive output file is automatically set in <code class="literal">$@</code> and the prerequisites are set in
          <code class="literal">$^</code>.</p><p>现在，如果您将<em class="filename">libcounter.a作为</em><em class="filename">count_words</em> 的先决条件，<em class="command">那么 make</em>将在链接可执行文件之前更新我们的库。不过，请注意一点小刺激。存档的所有成员都会被替换，即使它们没有被修改。这是浪费时间，我们可以做得更好：</p><p>Now, if you make <em class="filename">libcounter.a</em> a prerequisite of <em class="filename">count_words</em> <em class="command">make</em> will update our library before
          linking the executable. Notice one small irritation, however. All
          members of the archive are replaced even if they have not been
          modified. This is a waste of time and we can do better:</p><a id="OEBPS/ch02s08.html.I_2_tt90"></a><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(AR) $(ARFLAGS) $@ $?</pre><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(AR) $(ARFLAGS) $@ $?</pre><p>如果您使用<code class="literal">$?</code>而不是
          <code class="literal">$^</code>，<em class="command">make</em>将仅将那些比目标文件更新的对象文件传递给<em class="command">ar</em>。</p><p>If you use <code class="literal">$?</code> instead of
          <code class="literal">$^</code>, <em class="command">make</em> will pass only those objects files
          that are newer than the target to <em class="command">ar</em>.</p><p>我们还能做得更好吗？也许，但也许不是。<em class="command">make</em>支持更新存档中的单个文件，为每个目标文件成员执行一个<em class="command">ar</em>命令，但在我们深入研究这些细节之前，关于这种构建库的风格有几点值得注意。<em class="command">make</em>的主要目标之一是通过仅更新那些过时的文件来有效地使用处理器。不幸的是，为每个过时成员调用一次<em class="command">ar</em>的方式很快就会陷入困境。如果存档包含超过几十个文件，则为每次更新调用<em class="command">ar</em>的费用
          开始超过使用我们即将介绍的语法的“优雅”因素。通过使用上面的简单方法并在显式规则中调用<em class="command">ar ，我们可以对所有文件执行一次</em><em class="command">ar</em>
          并节省许多 fork/exec 调用。此外，在许多系统上使用<code class="option">r</code>to <em class="command">ar</em>效率非常低。在我的 1.9 GHz Pentium 4 上，从头开始构建一个大型存档（包含 14,216 个成员，总计 55 MB）需要 4 分 24 秒。但是，在生成的存档上使用<em class="command">a r</em>更新单个目标文件需要 28 秒。因此，如果我需要替换超过 10 个文件（总共 14,216 个文件！），从头开始构建存档会更快。在这种情况下，使用自动变量对所有已修改的目标文件执行一次存档更新可能更为谨慎<code class="literal">$?</code>
          。对于较小的库和更快的处理器，没有任何性能原因会更喜欢上面的简单方法而不是下面更优雅的方法。在这些情况下，使用下面的特殊库支持是一个很好的方法。</p><p>Can we do better still? Maybe, but maybe not. <em class="command">make</em> has support for updating individual
          files within an archive, executing one <em class="command">ar</em> command for each object file member,
          but before we go delving into those details there are several points
          worth noting about this style of building libraries. One of the
          primary goals of <em class="command">make</em> is to use
          the processor efficiently by updating only those files that are out
          of date. Unfortunately, the style of invoking <em class="command">ar</em> once for each out-of-date member
          quickly bogs down. If the archive contains more than a few dozen
          files, the expense of invoking <em class="command">ar</em>
          for each update begins to outweigh the "elegance" factor of using
          the syntax we are about to introduce. By using the simple method
          above and invoking <em class="command">ar</em> in an
          explicit rule, we can execute <em class="command">ar</em>
          once for all files and save ourselves many fork/exec calls. In
          addition, on many systems using the <code class="option">r</code> to <em class="command">ar</em> is very inefficient. On my 1.9 GHz
          Pentium 4, building a large archive from scratch (with 14,216
          members totaling 55 MB) takes 4 minutes 24 seconds. However,
          updating a single object file with <em class="command">ar
          r</em> on the resulting archive takes 28 seconds. So building
          the archive from scratch is faster if I need to replace more than 10
          files (out of 14,216!). In such situations it is probably more
          prudent to perform a single update of the archive with all modified
          object files using the <code class="literal">$?</code>
          automatic variable. For smaller libraries and faster processors
          there is no performance reason to prefer the simple approach above
          to the more elegant one below. In those situations, using the
          special library support that follows is a fine approach.</p><p>在<acronym class="acronym">GNU </acronym> <em class="command">make</em>中，可以使用以下符号引用存档的成员：</p><p>In <acronym class="acronym">GNU</acronym> <em class="command">make</em>, a member of an archive can be
          referenced using the notation:</p><a id="OEBPS/ch02s08.html.I_2_tt91"></a><pre class="programlisting">libgraphics.a(bitblt.o): bitblt.o
        $(AR) $(ARFLAGS) $@ $&lt;</pre><pre class="programlisting">libgraphics.a(bitblt.o): bitblt.o
        $(AR) $(ARFLAGS) $@ $&lt;</pre><p>这里库名称是<em class="filename">libgraphics.a</em>，成员名称是
          <em class="filename">bitblt.o</em>（用于<span class="emphasis"><em>位块传输</em></span>）。语法<em class="filename">lib</em>
          <em class="replaceable"><code>name</code></em> .a <code class="literal">(</code>
          <em class="replaceable"><code>module</code></em>.o<code class="literal">)</code>指的是库中包含的模块。此目标的先决条件只是目标文件本身，并且该命令将目标文件添加到存档中。<code class="literal">$&lt;</code>命令中使用自动变量仅获取第一个先决条件。事实上，有一个内置的模式规则可以做到这一点。</p><p>Here the library name is <em class="filename">libgraphics.a</em> and the member name is
          <em class="filename">bitblt.o</em> (for <span class="emphasis"><em>bit
          block transfer</em></span>). The syntax <em class="filename">lib</em>
          <em class="replaceable"><code>name</code></em>.a<code class="literal">(</code>
          <em class="replaceable"><code>module</code></em>.o<code class="literal">)</code> refers to the module contained within
          the library. The prerequisite for this target is simply the object
          file itself and the command adds the object file to the archive. The
          automatic variable <code class="literal">$&lt;</code> is used
          in the command to get only the first prerequisite. In fact, there is
          a built-in pattern rule that does exactly this.</p><p>当我们把这些放在一起时，我们的<em class="filename">makefile</em>看起来像这样：</p><p>When we put this all together, our <em class="filename">makefile</em> looks like this:</p><a id="OEBPS/ch02s08.html.I_2_tt92"></a><pre class="programlisting">VPATH = src 包含
CPPFLAGS = -我包括

count_words：libcounter.a /lib/libfl.a

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)

libcounter.a(lexer.o): lexer.o
        $(AR) $(ARFLAGS) $@ $&lt;

libcounter.a(counter.o): 计数器.o
        $(AR) $(ARFLAGS) $@ $&lt;

count_words.o：计数器.h
counter.o: counter.h lexer.h
词法分析器.o: 词法分析器.h</pre><pre class="programlisting">VPATH    = src include
CPPFLAGS = -I include

count_words: libcounter.a /lib/libfl.a

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)

libcounter.a(lexer.o): lexer.o
        $(AR) $(ARFLAGS) $@ $&lt;

libcounter.a(counter.o): counter.o
        $(AR) $(ARFLAGS) $@ $&lt;

count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h</pre><p>执行时，<em class="command">make</em>
          会产生以下输出：</p><p>When executed, <em class="command">make</em>
          produces this output:</p><a id="OEBPS/ch02s08.html.I_2_tt93"></a><pre class="programlisting">$ 制作
gcc -I include -c -o count_words.o src/count_words.c
flex -t src/lexer.l&gt; lexer.c
gcc -I include -c -o lexer.o lexer.c
ar rv libcounter.a lexer.o
ar：创建 libcounter.a
a - 词法分析器.o
gcc -I include -c -o counter.o src/counter.c
ar rv libcounter.a counter.o
a - 计数器.o
gcc count_words.o libcounter.a /lib/libfl.a -o count_words
rm 词法分析器.c</pre><pre class="programlisting">$ make
gcc  -I include  -c -o count_words.o src/count_words.c
flex  -t src/lexer.l&gt; lexer.c
gcc  -I include  -c -o lexer.o lexer.c
ar rv libcounter.a lexer.o
ar: creating libcounter.a
a - lexer.o
gcc  -I include  -c -o counter.o src/counter.c
ar rv libcounter.a counter.o
a - counter.o
gcc   count_words.o libcounter.a /lib/libfl.a   -o count_words
rm lexer.c</pre><p>注意存档更新规则。<code class="literal">$@</code>即使 makefile 中的目标<em class="filename">是</em>libcounter.a <em class="filename">(lexer.o)</em> ，自动变量
          也会扩展为库名称。</p><p>Notice the archive updating rule. The automatic variable
          <code class="literal">$@</code> is expanded to the library
          name even though the target in the <em class="filename">makefile</em> is <em class="filename">libcounter.a(lexer.o)</em>.</p><p>最后，应该提到的是，存档库包含其所包含符号的索引。
          当新模块添加到存档时，较新的存档程序（例如<acronym class="acronym">GNU </acronym> <em class="command">ar）</em>会自动管理此索引。然而，许多旧版本的<em class="command">ar</em>却没有。要创建或更新存档的索引，需要使用另一个程序<em class="command">ranlib</em> 。在这些系统上，用于更新档案的内置隐式规则是不够的。对于这些系统，规则如下：</p><p>Finally, it should be mentioned that an archive library
          contains an index of the symbols it contains. Newer archive programs
          such as <acronym class="acronym">GNU</acronym> <em class="command">ar</em>
          manage this index automatically when a new module is added to the
          archive. However, many older versions of <em class="command">ar</em> do not. To create or update the index
          of an archive another program <em class="command">ranlib</em> is used. On these systems, the
          built-in implicit rule for updating archives is insufficient. For
          these systems, a rule such as:</p><a id="OEBPS/ch02s08.html.I_2_tt94"></a><pre class="programlisting">libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
        $(RANLIB) $@</pre><pre class="programlisting">libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
        $(RANLIB) $@</pre><p>必须使用。或者，如果您选择对大型档案使用替代方法：</p><p>must be used. Or if you choose to use the alternate approach
          for large archives:</p><a id="OEBPS/ch02s08.html.I_2_tt95"></a><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(RM) $@
        $(AR) $(ARFLGS) $@ $^
        $(RANLIB) $@</pre><pre class="programlisting">libcounter.a: counter.o lexer.o
        $(RM) $@
        $(AR) $(ARFLGS) $@ $^
        $(RANLIB) $@</pre><p>当然，这种用于管理存档成员的语法也可以与内置的隐式规则一起使用。
           <acronym class="acronym">GNU </acronym> <em class="command">make</em>带有一个用于更新存档的内置规则。当我们使用这个规则时，我们的<em class="filename">makefile</em>变成：</p><p>Of course, this syntax for managing the members of an archive
          can be used with the built-in implicit rules as well.
          <acronym class="acronym">GNU</acronym> <em class="command">make</em> comes
          with a built-in rule for updating an archive. When we use this rule,
          our <em class="filename">makefile</em> becomes:</p><a id="OEBPS/ch02s08.html.I_2_tt96"></a><pre class="programlisting">VPATH = src 包含
CPPFLAGS = -我包括

count_words：libcounter.a -lfl
libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
count_words.o：计数器.h
counter.o: counter.h lexer.h
词法分析器.o: 词法分析器.h</pre><pre class="programlisting">VPATH    = src include
CPPFLAGS = -I include

count_words: libcounter.a -lfl
libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h</pre></div><div class="sect2" title="使用库作为先决条件"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s08.html.make3-CHP-2-SECT-8.2"></a>使用库作为先决条件</h2><h2 class="title"><a></a>Using Libraries as Prerequisites</h2></div></div></div><p>当库显示为<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1021" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1022" class="indexterm"></a>如果满足先决条件，则可以使用标准文件名或语法来引用它们<code class="option">-l</code>。当使用文件名语法时：</p><p>When libraries appear as <a class="indexterm"></a> <a class="indexterm"></a>prerequisites, they can be referenced using either a
          standard filename or with the <code class="option">-l</code> syntax. When
          filename syntax is used:</p><a id="OEBPS/ch02s08.html.I_2_tt97"></a><pre class="programlisting">xpong：$（对象）/lib/X11/libX11.a/lib/X11/libXaw.a
        $(链接)$^-o $@</pre><pre class="programlisting">xpong: $(OBJECTS) /lib/X11/libX11.a /lib/X11/libXaw.a
        $(LINK) $^ -o $@</pre><p>链接器将简单地读取命令行上列出的库文件并正常处理它们。使用该语法时<code class="option">-l</code>
          ，先决条件根本不是正确的文件：</p><p>the linker will simply read the library files listed on the
          command line and process them normally. When the <code class="option">-l</code>
          syntax is used, the prerequisites aren't proper files at all:</p><a id="OEBPS/ch02s08.html.I_2_tt98"></a><pre class="programlisting">xpong：$（对象）-lX11 -lXaw
        $(链接)$^-o $@</pre><pre class="programlisting">xpong: $(OBJECTS) -lX11 -lXaw
        $(LINK) $^ -o $@</pre><p><code class="option">-l</code>当在先决条件中使用
          该形式时， <em class="command">make</em>将搜索库（首选共享库）并将其值作为绝对路径替换到<code class="literal">$^</code>和
          <code class="literal">$?</code>变量中。第二种形式的一大优点是，即使系统的链接器无法执行这些职责，它也允许您使用搜索和共享库首选项功能。另一个优点是您可以自定义<em class="command">make</em>的搜索路径，以便它可以找到您的应用程序的库以及系统库。在这种情况下，第一种形式将忽略共享库并使用存档库，因为这是在链接行上指定的。在第二种形式中，<em class="command">make</em>知道共享库是首选，并且将首先搜索<em class="filename">X11</em>的共享版本，然后再选择存档版本。用于根据格式识别库的模式
          <code class="option">-l</code>存储在其他库文件名格式中<code class="literal">.LIBPATTERNS</code>，并且可以针对其他库文件名格式进行定制。</p><p>When the <code class="option">-l</code> form is used in a prerequisite,
          <em class="command">make</em> will search for the library
          (preferring a shared library) and substitute its value, as an
          absolute path, into the <code class="literal">$^</code> and
          <code class="literal">$?</code> variables. One great advantage
          of the second form is that it allows you to use the search and
          shared library preference feature even when the system's linker
          cannot perform these duties. Another advantage is that you can
          customize <em class="command">make</em>'s search path so
          it can find your application's libraries as well as system
          libraries. In this case, the first form would ignore the shared
          library and use the archive library since that is what was specified
          on the link line. In the second form, <em class="command">make</em> knows that shared libraries are
          preferred and will search first for a shared version of <em class="filename">X11</em> before settling for the archive
          version. The pattern for recognizing libraries from the
          <code class="option">-l</code> format is stored in <code class="literal">.LIBPATTERNS</code> and can be customized for
          other library filename formats.</p><p>不幸的是，有一个小皱纹。如果<em class="filename">makefile</em>指定了库文件目标，则它无法<code class="option">-l</code>在先决条件中使用该文件的选项。例如，以下<em class="filename">makefile</em>：</p><p>Unfortunately, there is a small wrinkle. If a <em class="filename">makefile</em> specifies a library file target,
          it cannot use the <code class="option">-l</code> option for that file in a
          prerequisite. For instance, the following <em class="filename">makefile</em>:</p><a id="OEBPS/ch02s08.html.I_2_tt99"></a><pre class="programlisting">count_words: count_words.o -lcounter -lfl
        $(CC) $^ -o $@

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)</pre><pre class="programlisting">count_words: count_words.o -lcounter -lfl
        $(CC) $^ -o $@

libcounter.a: libcounter.a(lexer.o) libcounter.a(counter.o)</pre><p>失败并出现错误：</p><p>fails with the error:</p><a id="OEBPS/ch02s08.html.I_2_tt100"></a><pre class="programlisting">没有规则来创建“count_words”所需的目标“-lcounter”</pre><pre class="programlisting">No rule to make target `-lcounter', needed by `count_words'</pre><p>出现此错误的原因似乎是<em class="command">make</em>没有扩展
          <code class="option">-lcounter</code>到<em class="filename">libcounter.a</em>并搜索目标，而是直接进行库搜索。因此，对于在<em class="filename">makefile</em>中构建的库，必须使用文件名形式。</p><p>It appears that this error occurs because <em class="command">make</em> does not expand
          <code class="option">-lcounter</code> to <em class="filename">libcounter.a</em> and search for a target, but
          instead does a straight library search. So for libraries built
          within the <em class="filename">makefile</em>, the
          filename form must be used.</p><p>让复杂的程序无错误地链接可能有点像魔术。链接器将按照库在命令行上列出的顺序搜索库。因此，如果library
          <em class="replaceable"><code>A</code></em>包含未定义的符号，例如
          <code class="function">open</code>在library中定义的<em class="replaceable"><code>B</code></em>，则链接命令行必须列<em class="replaceable"><code>A</code></em>在前面
          <em class="replaceable"><code>B</code></em>（即<em class="replaceable"><code>A</code></em>
          requires <em class="replaceable"><code>B</code></em>）。否则，当链接器读取<em class="replaceable"><code>A</code></em>并看到未定义的符号
          时<code class="function">open</code>，再返回到就为时已晚了<em class="replaceable"><code>B</code></em>。链接器永远不会返回。正如您所看到的，命令行上库的顺序至关重要。</p><p>Getting complex programs to link without error can be somewhat
          of a black art. The linker will search libraries in the order in
          which they are listed on the command line. So if library
          <em class="replaceable"><code>A</code></em> includes an undefined symbol, say
          <code class="function">open</code>, that is defined in
          library <em class="replaceable"><code>B</code></em>, the link command line must
          list <em class="replaceable"><code>A</code></em> before
          <em class="replaceable"><code>B</code></em> (that is, <em class="replaceable"><code>A</code></em>
          requires <em class="replaceable"><code>B</code></em>). Otherwise, when the linker
          reads <em class="replaceable"><code>A</code></em> and sees the undefined symbol
          <code class="function">open</code>, it's too late to go back
          to <em class="replaceable"><code>B</code></em>. The linker doesn't ever go back. As
          you can see, the order of libraries on the command line is of
          fundamental importance.</p><p>当a的先决条件<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1024" class="indexterm"></a>目标保存在<code class="literal">$^</code>和<code class="literal">$?</code>变量中，它们的顺序被保留。因此，如上一个示例中所示，使用<code class="literal">$^</code>与先决条件列表相同的顺序扩展为相同的文件。即使先决条件分散在多个规则中也是如此。在这种情况下，每个规则的先决条件都会按照出现的顺序附加到目标先决条件列表中。</p><p>When the prerequisites of a <a class="indexterm"></a> <a class="indexterm"></a>target are saved in the <code class="literal">$^</code> and <code class="literal">$?</code> variables, their order is preserved. So
          using <code class="literal">$^</code> as in the previous
          example expands to the same files in the same order as the
          prerequisites list. This is true even when the prerequisites are
          split across multiple rules. In that case, the prerequisites of each
          rule are appended to the target prerequisite list in the order they
          are seen.</p><p>一个密切相关的问题是库之间的相互引用，通常称为<em class="firstterm">循环引用</em>或<em class="firstterm">循环</em>。认为<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1025" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1026" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1027" class="indexterm"></a>进行了更改，库
          <em class="replaceable"><code>B</code></em>现在引用库中定义的符号<em class="replaceable"><code>A</code></em>。我们知道
          <em class="replaceable"><code>A</code></em>必须先来
          <em class="replaceable"><code>B</code></em>，但现在<em class="replaceable"><code>B</code></em>
          必须先来<em class="replaceable"><code>A</code></em>。嗯，有问题。解决办法是<em class="replaceable"><code>A</code></em>在之前和<span class="emphasis"><em>之后</em></span> 都引用<em class="replaceable"><code>B</code></em>：
           <code class="option">-l</code> <em class="replaceable"><code>A</code></em>- <code class="literal">l</code> <em class="replaceable"><code>B</code></em>- <code class="literal">l</code> <em class="replaceable"><code>A</code></em>。在大型、复杂的程序中，库通常需要以这种方式重复，有时甚至两次以上。</p><p>A closely related problem is mutual reference between
          libraries, often referred to as <em class="firstterm">circular
          references</em> or <em class="firstterm">circularities</em>.
          Suppose <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>a change is made and library
          <em class="replaceable"><code>B</code></em> now references a symbol defined in
          library <em class="replaceable"><code>A</code></em>. We know
          <em class="replaceable"><code>A</code></em> must come before
          <em class="replaceable"><code>B</code></em>, but now <em class="replaceable"><code>B</code></em>
          must come before <em class="replaceable"><code>A</code></em>. Hmm, a problem. The
          solution is to reference <em class="replaceable"><code>A</code></em> both before
          and <span class="emphasis"><em>after</em></span> <em class="replaceable"><code>B</code></em>:
          <code class="option">-l</code> <em class="replaceable"><code>A</code></em> -<code class="literal">l</code> <em class="replaceable"><code>B</code></em> -<code class="literal">l</code> <em class="replaceable"><code>A</code></em>. In large,
          complex programs, libraries often need to be repeated in this way,
          sometimes more than twice.</p><p>这种情况给<em class="command">make</em>带来了一个小问题，因为自动变量通常会丢弃重复项。例如，假设我们需要重复一个库先决条件来满足库循环性：</p><p>This situation poses a minor problem for <em class="command">make</em> because the automatic variables
          normally discard duplicates. For example, suppose we need to repeat
          a library prerequisite to satisfy a library circularity:</p><a id="OEBPS/ch02s08.html.I_2_tt101"></a><pre class="programlisting">xpong: xpong.o libui.a libdynamics.a libui.a -lX11
        $(CC) $^ -o $@</pre><pre class="programlisting">xpong: xpong.o libui.a libdynamics.a libui.a -lX11
        $(CC) $^ -o $@</pre><p>该先决条件列表将被处理为以下链接命令：</p><p>This prerequisite list will be processed into the following
          link command:</p><a id="OEBPS/ch02s08.html.I_2_tt102"></a><pre class="programlisting">gcc xpong.o libui.a libdynamics.a /usr/lib/X11R6/libX11.a -o xpong</pre><pre class="programlisting">gcc xpong.o libui.a libdynamics.a /usr/lib/X11R6/libX11.a -o xpong</pre><p>哎呀。为了克服这种行为，可以在<em class="command">make</em><code class="literal">$^</code>中使用附加变量
          。该变量与 相同，只是保留了重复的先决条件。使用：<em class="command"></em><code class="literal">$+</code><code class="literal">$^</code><code class="literal">$+</code></p><p>Oops. To overcome this behavior of <code class="literal">$^</code> an additional variable is available in
          <em class="command">make</em>, <code class="literal">$+</code>. This variable is identical to <code class="literal">$^</code> with the exception that duplicate
          prerequisites are preserved. Using <code class="literal">$+</code>:</p><a id="OEBPS/ch02s08.html.I_2_tt103"></a><pre class="programlisting">xpong: xpong.o libui.a libdynamics.a libui.a -lX11
        $(CC) $+ -o $@</pre><pre class="programlisting">xpong: xpong.o libui.a libdynamics.a libui.a -lX11
        $(CC) $+ -o $@</pre><p>该先决条件列表将被处理为以下链接命令：</p><p>This prerequisite list will be processed into the following
          link command:</p><a id="OEBPS/ch02s08.html.I_2_tt104"></a><pre class="programlisting">gcc xpong.o libui.a libdynamics.a libui.a /usr/lib/X11R6/libX11.a -o xpong</pre><pre class="programlisting">gcc xpong.o libui.a libdynamics.a libui.a /usr/lib/X11R6/libX11.a -o xpong</pre></div><div class="sect2" title="双冒号规则"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch02s08.html.make3-CHP-2-SECT-8.3"></a>双冒号规则</h2><h2 class="title"><a></a>Double-Colon Rules</h2></div></div></div><p>双冒号规则是<a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1028" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1029" class="indexterm"></a> <a id="OEBPS/ch02s08.html.make3-CHP-2-ITERM-1030" class="indexterm"></a>模糊的功能，允许使用不同的命令更新相同的目标，具体取决于哪组先决条件比目标新。通常，当目标出现多次时，所有先决条件都会附加到一长串列表中，只有一个命令脚本来执行更新。然而，使用双冒号规则时，每次出现的目标都被视为完全独立的实体并单独处理。这意味着对于特定目标，所有规则必须属于同一类型，要么都是双冒号规则，要么都是单冒号规则。</p><p>Double-colon rules are an <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>obscure feature that allows the same target to be
          updated with different commands depending on which set of
          prerequisites are newer than the target. Normally, when a target
          appears more than once all the prerequisites are appended in a long
          list with only one command script to perform the update. With
          double-colon rules, however, each occurrence of the target is
          considered a completely separate entity and is handled individually.
          This means that for a particular target, all the rules must be of
          the same type, either they are all double-colon rules or all
          single-colon rules.</p><p>此功能的现实、有用的示例很难获得（这就是为什么它是一个晦涩的功能），但这里有一个人为的示例：</p><p>Realistic, useful examples of this feature are difficult to
          come by (which is why it is an obscure feature), but here is an
          artificial example:</p><a id="OEBPS/ch02s08.html.I_2_tt105"></a><pre class="programlisting">文件列表:: 生成列表脚本
        chmod +x $&lt;
        生成列表脚本 $(files) &gt; 文件列表

文件列表:: $(文件)
        生成列表脚本 $(files) &gt; 文件列表</pre><pre class="programlisting">file-list:: generate-list-script
        chmod +x $&lt;
        generate-list-script $(files) &gt; file-list

file-list:: $(files)
        generate-list-script $(files) &gt; file-list</pre><p>我们可以通过两种方式重新生成<em class="filename">文件列表</em>目标。如果生成脚本已更新，我们使脚本可执行，然后运行它。如果源文件已更改，我们只需运行脚本即可。虽然有点牵强，但这可以让您了解如何使用该功能。</p><p>We can regenerate the <em class="filename">file-list</em> target two ways. If the
          generating script has been updated, we make the script executable,
          then run it. If the source files have changed, we simply run the
          script. Although a bit far-fetched, this gives you a feel for how
          the feature might be used.</p><p><em class="command">我们已经介绍了make</em>规则的大部分功能，以及变量和命令，这就是<em class="command">make</em>的本质。我们主要关注这些功能的具体语法和行为，而没有过多讨论如何在更复杂的情况下应用它们。这就是<a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题">第二部分</a>的主题
          。现在，我们将继续讨论变量，然后是命令。</p><p>We've covered most of the features of <em class="command">make</em> rules and, along with variables and
          commands, this is the essence of <em class="command">make</em>. We've focused largely on the
          specific syntax and behavior of the features without going much into
          how to apply them in more complex situations. That is the subject of
          <a class="link" href="#OEBPS/pt02.html" title="Part&nbsp;II.&nbsp;Advanced and Specialized Topics">Part II</a>. For now, we will
          continue our discussion with variables and then commands.</p></div></div></div></div>
<div id="OEBPS/ch03.html"><div>
<div class="chapter" title="第 3 章变量和宏"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03.html.make3-CHP-3"></a>第 3 章变量和宏</h1><h1 class="title"><a></a>Chapter&nbsp;3.&nbsp;Variables and Macros</h1></div></div></div><p>我们研究<em class="filename">makefile</em>变量已经有一段时间了，并且已经看到了许多如何在内置规则和用户定义规则中使用它们的示例。但我们所看到的例子仅仅触及了表面。变量和宏变得更加复杂，
       <acronym class="acronym">GNU</acronym> 更加
      <em class="command">重视</em><a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1031" class="indexterm"></a>其不可思议的力量。</p><p>We've been looking at <em class="filename">makefile</em> variables for a while now and we've
      seen many examples of how they're used in both the built-in and
      user-defined rules. But the examples we've seen have only scratched the
      surface. Variables and macros get much more complicated and give
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> much of
      <a class="indexterm"></a>its incredible power.</p><p>在我们进一步讨论之前，了解
      <em class="command">make</em>是两种语言合二为一是很重要的。第一种语言描述由目标和先决条件组成的依赖关系图。 （该语言已在<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>中介绍过。）第二种语言是用于执行文本替换的宏语言。您可能熟悉的其他宏语言包括 C 预处理器、<em class="command">m4</em>、TEX 和宏汇编器。与其他宏语言一样，<em class="command">make</em>允许您为较长的字符序列定义速记术语并在程序中使用该速记术语。宏处理器将识别您的速记术语并将其替换为其扩展形式。虽然很容易将<em class="filename">makefile</em>
      变量视为传统编程语言变量，但宏“变量”和“传统”变量之间存在区别。宏变量“就地”扩展以生成文本字符串，然后可以进一步扩展该文本字符串。随着我们的继续，这种区别将变得更加清晰。</p><p>Before we go any further, it is important to understand that
      <em class="command">make</em> is sort of two languages in one.
      The first language describes dependency graphs consisting of targets and
      prerequisites. (This language was covered in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>.) The second language is a macro
      language for performing textual substitution. Other macro languages you
      may be familiar with are the C preprocessor, <em class="command">m4</em>, TEX, and macro assemblers. Like these
      other macro languages, <em class="command">make</em> allows
      you to define a shorthand term for a longer sequence of characters and
      use the shorthand in your program. The macro processor will recognize
      your shorthand terms and replace them with their expanded form. Although
      it is easy to think of <em class="filename">makefile</em>
      variables as traditional programming language variables, there is a
      distinction between a macro "variable" and a "traditional" variable. A
      macro variable is expanded "in place" to yield a text string that may
      then be expanded further. This distinction will become more clear as we
      proceed.</p><p>变量名可以包含<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1032" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1033" class="indexterm"></a>几乎所有字符，包括大多数标点符号。即使有空格也是允许的，但如果你重视你的理智，你应该避免它们。变量名中实际上不允许使用的字符只有:、# 和 =。</p><p>A variable name can contain <a class="indexterm"></a> <a class="indexterm"></a>almost any characters including most punctuation. Even
      spaces are allowed, but if you value your sanity you should avoid them.
      The only characters actually disallowed in a variable name are :, #, and
      =.</p><p>变量是<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1034" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1035" class="indexterm"></a>区分大小写，因此<code class="literal">cc</code>
      和<code class="literal">CC</code>引用不同的变量。要获取变量的值，请将变量名称括在 中<code class="literal">$( )</code>。作为一种特殊情况，单字母变量名可以省略<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1036" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1037" class="indexterm"></a>括号并简单地使用<code class="literal">$</code> <em class="replaceable"><code>letter</code></em>.这就是自动变量可以不写括号的原因。作为一般规则，您应该使用括号形式并避免使用单字母变量名称。</p><p>Variables are <a class="indexterm"></a> <a class="indexterm"></a>case-sensitive, so <code class="literal">cc</code>
      and <code class="literal">CC</code> refer to different variables.
      To get the value of a variable, enclose the variable name in <code class="literal">$( )</code>. As a special case, single-letter
      variable names can omit the <a class="indexterm"></a> <a class="indexterm"></a>parentheses and simply use <code class="literal">$</code> <em class="replaceable"><code>letter</code></em>. This is
      why the automatic variables can be written without the parentheses. As a
      general rule you should use the parenthetical form and avoid single
      letter variable names.</p><p>变量也可以使用curly来扩展<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1038" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1039" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1040" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1041" class="indexterm"></a>中的大括号<code class="literal">${CC}</code>，您会经常看到这种形式，特别是在较旧的<em class="filename">makefile</em>中。使用其中一种很少比另一种更有优势，因此只需选择一种并坚持使用即可。有些人使用花括号进行变量引用，使用括号进行函数调用，类似于 shell 使用它们的方式。大多数现代
      <em class="filename">makefile</em>使用括号，这也是我们在本书中将使用的内容。</p><p>Variables can also be expanded using curly <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>braces as in <code class="literal">${CC}</code> and
      you will often see this form, particularly in older <em class="filename">makefile</em>s. There is seldom an advantage to
      using one over the other, so just pick one and stick with it. Some
      people use curly braces for variable reference and parentheses for
      function call, similar to the way the shell uses them. Most modern
      <em class="filename">makefile</em>s use parentheses and
      that's what we'll use throughout this book.</p><p>代表用户常量的变量<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1042" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1043" class="indexterm"></a>可能想在命令行或环境中进行自定义，按照约定全部用大写字母书写。单词之间用下划线分隔。仅出现在<em class="filename">makefile</em>中的变量全部小写，单词之间用下划线分隔。最后，在本书中，变量中的用户定义函数<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1044" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1045" class="indexterm"></a> <a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1046" class="indexterm"></a>宏使用小写单词，并用破折号分隔。其他命名约定将在出现的地方进行解释。 （以下示例使用了我们尚未讨论的功能。我使用它们来说明变量命名约定，现在不要太关心右侧。）</p><p>Variables representing constants a user <a class="indexterm"></a> <a class="indexterm"></a>might want to customize on the command line or in the
      environment are written in all uppercase, by convention. Words are
      separated by underscores. Variables that appear only in the <em class="filename">makefile</em> are all lowercase with words
      separated by underscores. Finally, in this book, user-defined functions
      in variables <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>and macros use lowercase words separated by dashes. Other
      naming conventions will be explained where they occur. (The following
      example uses features we haven't discussed yet. I'm using them to
      illustrate the variable naming conventions, don't be too concerned about
      the righthand side for now.)</p><a id="OEBPS/ch03.html.I_3_tt106"></a><pre class="programlisting"># 一些简单的常量。
CC := 海湾合作委员会
MKDIR := mkdir -p

# 内部变量。
来源= *.c
对象 = $(subst .c,.o,$(来源))

# 一个或两个函数。
也许-make-dir = $(如果$(通配符$1),,$(MKDIR) $1)
断言-not-null = $(if $1,,$(错误非法空值。))</pre><pre class="programlisting"># Some simple constants.
CC    := gcc
MKDIR := mkdir -p

# Internal variables.
sources = *.c
objects = $(subst .c,.o,$(sources))

# A function or two.
maybe-make-dir  = $(if $(wildcard $1),,$(MKDIR) $1)
assert-not-null = $(if $1,,$(error Illegal null value.))</pre><p>变量的值包括<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1047" class="indexterm"></a>赋值符号右侧的所有单词，前导空格被修剪。尾随空格不会被修剪。这有时会导致问题，例如，如果变量中包含尾随空格并随后在命令脚本中使用：</p><p>The value of a variable consists of <a class="indexterm"></a>all the words to the right of the assignment symbol with
      leading space trimmed. Trailing spaces are not trimmed. This can
      occasionally cause trouble, for instance, if the trailing whitespace is
      included in the variable and subsequently used in a command
      script:</p><a id="OEBPS/ch03.html.I_3_tt107"></a><pre class="programlisting">LIBRARY = libio.a # LIBRARY 有一个尾随空格。
缺失文件：
        触摸$(图书馆)
        ls -l | grep '$(库)'</pre><pre class="programlisting">LIBRARY = libio.a # LIBRARY has a trailing space.
missing_file:
        touch $(LIBRARY)
        ls -l | grep '$(LIBRARY)'</pre><p>变量赋值包含一个尾随空格，该空格通过注释变得更加明显（但尾随空格也可以在没有尾随注释的情况下出现）。当这个<em class="filename">makefile</em>运行时，我们得到：</p><p>The variable assignment contains a trailing space that is made
      more apparent by the comment (but a trailing space can also be present
      without a trailing comment). When this <em class="filename">makefile</em> is run, we get:</p><a id="OEBPS/ch03.html.I_3_tt108"></a><pre class="programlisting">$ 制作
触摸libio.a
ls -l | grep 'libio.a'
make: *** [missing_file] 错误 1</pre><pre class="programlisting">$ make
touch libio.a 
ls -l | grep 'libio.a '
make: *** [missing_file] Error 1</pre><p>糟糕，<em class="command">grep</em>搜索字符串还包含尾随空格，无法在<em class="command">ls</em>的输出中找到该文件。稍后我们将更详细地讨论空白问题。现在，让我们更仔细地看看变量。</p><p>Oops, the <em class="command">grep</em> search string
      also included the trailing space and failed to find the file in <em class="command">ls</em>'s output. We'll discuss whitespace issues
      in more detail later. For now, let's look more closely at
      variables.</p><div class="sect1" title="变量的用途"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03.html.make3-CHP-3-SECT-1"></a>变量的用途</h1><h1 class="title"><a></a>What Variables Are Used For</h1></div></div></div><p>一般来说，使用<a id="OEBPS/ch03.html.make3-CHP-3-ITERM-1048" class="indexterm"></a>代表外部程序的变量。这使得<em class="filename">makefile</em>的用户可以更轻松地使<em class="filename">makefile</em>适应其特定环境。例如，系统上
        通常有多个版本的<em class="command">awk ： </em><em class="command">awk</em>、<em class="command">nawk</em>、<em class="command">gawk</em>。通过创建变量来保存<em class="command">awk</em><code class="literal">AWK</code>程序的名称，可以让其他用户更轻松地使用<em class="filename">makefile</em>。此外，如果您的环境中存在安全问题，最好的做法是使用绝对路径访问外部程序，以避免用户路径出现问题。如果系统程序的特洛伊木马版本已安装在用户路径中的某个位置，绝对路径还可以减少出现问题的可能性。当然，绝对路径也使得<em class="filename">makefile</em>不易移植到其他系统。您自己的要求应该指导您的选择。<em class="command"></em><em class="filename"></em><em class="filename"></em></p><p>In general it is a good idea to use <a class="indexterm"></a>variables to represent external programs. This allows
        users of the <em class="filename">makefile</em> to more
        easily adapt the <em class="filename">makefile</em> to
        their specific environment. For instance, there are often several
        versions of <em class="command">awk</em> on a system:
        <em class="command">awk</em>, <em class="command">nawk</em>, <em class="command">gawk</em>. By creating a variable, <code class="literal">AWK</code>, to hold the name of the <em class="command">awk</em> program you make it easier for other
        users of your <em class="filename">makefile</em>. Also, if
        security is an issue in your environment, a good practice is to access
        external programs with absolute paths to avoid problems with user's
        paths. Absolute paths also reduce the likelihood of issues if trojan
        horse versions of system programs have been installed somewhere in a
        user's path. Of course, absolute paths also make <em class="filename">makefile</em>s less portable to other systems.
        Your own requirements should guide your choice.</p><p>虽然变量的第一次使用应该是保存简单的常量，但它们也可以存储用户定义的命令序列，例如：<sup>[ <a id="OEBPS/ch03.html.make3-CHP-3-FNOTE-1" href="#OEBPS/ch03.html.ftn.make3-CHP-3-FNOTE-1" class="footnote">1</a> ]</sup></p><p>Though your first use of variables should be to hold simple
        constants, they can also store user-defined command sequences such
        as:<sup>[<a href="#OEBPS/ch03.html.ftn.make3-CHP-3-FNOTE-1" class="footnote">1</a>]</sup></p><a id="OEBPS/ch03.html.I_3_tt109"></a><pre class="programlisting">DF=DF
AWK = awk
自由空间 := $(DF) 。 | $(AWK) 'NR == 2 { 打印 $$4 }'</pre><pre class="programlisting">DF  = df
AWK = awk
free-space := $(DF) . | $(AWK) 'NR =  = 2 { print $$4 }'</pre><p>用于报告可用磁盘空间。正如我们将看到的，变量用于这些目的以及更多目的。</p><p>for reporting on free disk space. Variables are used for both
        these purposes and more, as we will see.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch03.html.ftn.make3-CHP-3-FNOTE-1" href="#OEBPS/ch03.html.make3-CHP-3-FNOTE-1" class="para">1</a> ] </sup><em class="command">df</em>命令返回每个已安装文件系统的列表以及文件系统容量和使用情况的统计信息。通过参数，它可以打印指定文件系统的统计信息。输出的第一行是列标题的列表。此输出由<em class="command">awk</em>读取，它检查第二行并忽略所有其他行。<em class="command">df</em>输出的第四列是块中的剩余可用空间。</p><p><sup>[<a href="#OEBPS/ch03.html.make3-CHP-3-FNOTE-1" class="para">1</a>] </sup>The <em class="command">df</em> command returns a
            list of each mounted filesystem and statistics on the filesystem's
            capacity and usage. With an argument, it prints statistics for the
            specified filesystem. The first line of the output is a list of
            column titles. This output is read by <em class="command">awk</em> which examines the second line and
            ignores all others. Column four of <em class="command">df</em>'s output is the remaining free space
            in blocks.</p></div></div></div></div></div>
<div id="OEBPS/ch03s02.html"><div>
<div class="sect1" title="变量类型"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s02.html.make3-CHP-3-SECT-2"></a>变量类型</h1><h1 class="title"><a></a>Variable Types</h1></div></div></div><p>有两种类型<a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1050" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1052" class="indexterm"></a><em class="command">make</em>中的变量：简单扩展变量和递归扩展变量。使用赋值运算符定义<em class="firstterm">简单扩展</em>变量
        （或简单变量）<code class="literal">:=</code>：</p><p>There are two types of <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>variables in <em class="command">make</em>:
        simply expanded variables and recursively expanded variables. A
        <em class="firstterm">simply expanded</em> variable (or a simple variable)
        is defined using the <code class="literal">:=</code> assignment
        operator:</p><a id="OEBPS/ch03s02.html.I_3_tt110"></a><pre class="programlisting">MAKE_DEPEND := $(CC) -M</pre><pre class="programlisting">MAKE_DEPEND := $(CC) -M</pre><p>它被称为“简单扩展”，因为它的右侧在从<em class="filename">makefile</em>读取该行后立即扩展。右侧的任何<em class="command">make</em>变量引用都会展开，并将生成的文本保存为变量的值。此行为与大多数编程和脚本语言相同。例如，该变量的正常扩展将产生：</p><p>It is called "simply expanded" because its righthand side is
        expanded immediately upon reading the line from the <em class="filename">makefile</em>. Any <em class="command">make</em> variable references in the righthand
        side are expanded and the resulting text saved as the value of the
        variable. This behavior is identical to most programming and scripting
        languages. For instance, the normal expansion of this variable would
        yield:</p><a id="OEBPS/ch03s02.html.I_3_tt111"></a><pre class="programlisting">海湾合作委员会-M</pre><pre class="programlisting">gcc -M</pre><p>但是，如果<code class="literal">CC</code>尚未设置上述内容，则上述赋值的值为：</p><p>However, if <code class="literal">CC</code> above had not
        yet been set, then the value of the above assignment would be:</p><a id="OEBPS/ch03s02.html.I_3_tt112"></a><pre class="programlisting">&lt;空格&gt;-M</pre><pre class="programlisting">&lt;space&gt;-M</pre><p><code class="literal">$(CC)</code>扩展为其值（不包含字符），然后折叠为空。变量没有定义并不是错误。事实上，这是非常有用的。大多数隐式命令都包含未定义的变量，这些变量充当用户自定义的占位符。如果用户不自定义变量，它就会崩溃。现在注意前导空格。首先由<em class="command">make</em>解析右侧以生成字符串<code class="literal">$(CC) -M</code>。当变量引用折叠为空时，<em class="command">make</em>不会重新扫描该值并修剪空白。空白保持原样。</p><p><code class="literal">$(CC)</code> is expanded to its
        value (which contains no characters), and collapses to nothing. It is
        not an error for a variable to have no definition. In fact, this is
        extremely useful. Most of the implicit commands include undefined
        variables that serve as place holders for user customizations. If the
        user does not customize a variable it collapses to nothing. Now notice
        the leading space. The righthand side is first parsed by <em class="command">make</em> to yield the string <code class="literal">$(CC) -M</code>. When the variable reference is
        collapsed to nothing, <em class="command">make</em> does not
        rescan the value and trim blanks. The blanks are left intact.</p><p>第二种类型的变量称为递归扩展变量。<em class="firstterm">递归扩展</em>变量（或递归变量）是使用<code class="literal">=</code>赋值运算符定义的：</p><p>The second type of variable is called a recursively expanded
        variable. A <em class="firstterm">recursively expanded</em> variable (or a
        recursive variable) is defined using the <code class="literal">=</code> assignment operator:</p><a id="OEBPS/ch03s02.html.I_3_tt113"></a><pre class="programlisting">MAKE_DEPEND = $(CC) -M</pre><pre class="programlisting">MAKE_DEPEND = $(CC) -M</pre><p><em class="command">它被称为“递归扩展”，因为它的右侧只是被make</em>吸收并存储为变量的值，而不以任何方式评估或扩展它。相反，扩展是在
        <span class="emphasis"><em>使用</em></span>变量时执行的。该变量的更好术语可能是
        <span class="emphasis"><em>延迟扩展</em></span>变量，因为评估被推迟到实际使用时。这种扩展方式的一个令人惊讶的效果是赋值可以“乱序”执行：</p><p>It is called "recursively expanded" because its righthand side
        is simply slurped up by <em class="command">make</em> and
        stored as the value of the variable without evaluating or expanding it
        in any way. Instead, the expansion is performed when the variable is
        <span class="emphasis"><em>used</em></span>. A better term for this variable might be
        <span class="emphasis"><em>lazily expanded</em></span> variable, since the evaluation is
        deferred until it is actually used. One surprising effect of this
        style of expansion is that assignments can be performed "out of
        order":</p><a id="OEBPS/ch03s02.html.I_3_tt114"></a><pre class="programlisting">MAKE_DEPEND = $(CC) -M
...
＃ 一段时间之后
CC = 海湾合作委员会</pre><pre class="programlisting">MAKE_DEPEND = $(CC) -M
...
# Some time later
CC = gcc</pre><p><code class="literal">MAKE_DEPEND</code>
        这里命令脚本中的值是<em class="command">gcc -M，</em>
        即使在分配<code class="literal">CC</code>时未定义
        。<code class="literal">MAKE_DEPEND</code></p><p>Here the value of <code class="literal">MAKE_DEPEND</code>
        within a command script is <em class="command">gcc -M</em>
        even though <code class="literal">CC</code> was undefined when
        <code class="literal">MAKE_DEPEND</code> was assigned.</p><p>事实上，递归变量实际上不仅仅是一个惰性赋值（至少不是一个普通的惰性赋值）。每次使用递归变量时，都会重新评估其右侧。对于像上面这样的简单常量定义的变量
        <code class="literal">MAKE_DEPEND</code>，这种区别是没有意义的，因为右侧的所有变量也是简单常量。但想象一下，如果右侧的变量代表程序的执行，例如<em class="command">date</em>。每次扩展递归变量时，都会执行<em class="command">日期</em>程序，并且每个变量扩展将具有不同的值（假设它们至少相隔一秒执行）。有时这非常有用。其他时候也很烦人！</p><p>In fact, recursive variables aren't really just a lazy
        assignment (at least not a normal lazy assignment). Each time the
        recursive variable is used, its righthand side is re-evaluated. For
        variables that are defined in terms of simple constants such as
        <code class="literal">MAKE_DEPEND</code> above, this distinction
        is pointless since all the variables on the righthand side are also
        simple constants. But imagine if a variable in the righthand side
        represented the execution of a program, say <em class="command">date</em>. Each time the recursive variable was
        expanded the <em class="command">date</em> program would be
        executed and each variable expansion would have a different value
        (assuming they were executed at least one second apart). At times this
        is very useful. At other times it is very annoying!</p><div class="sect2" title="其他类型的作业"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch03s02.html.make3-CHP-3-SECT-2.1"></a>其他类型的作业</h2><h2 class="title"><a></a>Other Types of Assignment</h2></div></div></div><p>从前面的示例中，我们看到了两种类型的赋值：
          <code class="literal">=</code>用于创建递归变量和<code class="literal">:=</code>用于创建简单变量。<em class="command">make</em>还提供了另外两个赋值运算符。</p><p>From previous examples we've seen two types of assignment:
          <code class="literal">=</code> for creating recursive
          variables and <code class="literal">:=</code> for creating
          simple variables. There are two other assignment operators provided
          by <em class="command">make</em>.</p><p>运营<code class="literal">?=</code>商是
          <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1053" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1055" class="indexterm"></a>称为<em class="firstterm">条件变量赋值运算符</em>。这实在是太绕口了，所以我们称之为条件赋值。仅当变量尚无值时，该运算符才会执行请求的变量赋值。</p><p>The <code class="literal">?=</code> operator is
          <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>called the <em class="firstterm">conditional variable assignment
          operator</em>. That's quite a mouth-full so we'll just call
          it conditional assignment. This operator will perform the requested
          variable assignment only if the variable does not yet have a
          value.</p><a id="OEBPS/ch03s02.html.I_3_tt115"></a><pre class="programlisting"># 将所有生成的文件放入目录$(PROJECT_DIR)/out中。
OUTPUT_DIR ?= $(PROJECT_DIR)/out</pre><pre class="programlisting"># Put all generated files in the directory $(PROJECT_DIR)/out.
OUTPUT_DIR ?= $(PROJECT_DIR)/out</pre><p>这里我们设置输出目录变量 ，<code class="literal">OUTPUT_DIR</code>仅当它之前没有设置过时。此功能与环境变量可以很好地交互。我们将在本章后面的<a class="link" href="#OEBPS/ch03s06.html" title="变量从何而来">3.6 节</a>中讨论这个问题。</p><p>Here we set the output directory variable, <code class="literal">OUTPUT_DIR</code>, only if it hasn't been set
          earlier. This feature interacts nicely with environment variables.
          We'll discuss this in <a class="link" href="#OEBPS/ch03s06.html" title="Where Variables Come From">Section
          3.6</a> later in this chapter.</p><p>另一个赋值运算符，<code class="literal">+=</code> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1057" class="indexterm"></a> <a id="OEBPS/ch03s02.html.make3-CHP-3-ITERM-1058" class="indexterm"></a>，通常称为
          <em class="firstterm">追加</em>。顾名思义，该运算符将文本附加到变量中。这可能看起来不起眼，但在使用递归变量时这是一个重要的特性。具体来说，赋值右侧的值将附加到变量中<span class="emphasis"><em>，而不更改变量中的原始值</em></span>。 “有什么大不了的，append 不就是这么做的吗？”我听到你说。是的，但是等等，这有点棘手。</p><p>The other assignment operator, <code class="literal">+=</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>, is usually referred to as
          <em class="firstterm">append</em>. As its name suggests, this operator
          appends text to a variable. This may seem unremarkable, but it is an
          important feature when recursive variables are used. Specifically,
          values on the righthand side of the assignment are appended to the
          variable <span class="emphasis"><em>without changing the original values in the
          variable</em></span>. "Big deal, isn't that what append always does?"
          I hear you say. Yes, but hold on, this is a little tricky.</p><p>附加到一个简单的变量是非常明显的。该<code class="literal">+=</code>运算符可以这样实现：</p><p>Appending to a simple variable is pretty obvious. The <code class="literal">+=</code> operator might be implemented like
          this:</p><a id="OEBPS/ch03s02.html.I_3_tt116"></a><pre class="programlisting">简单 := $(简单) 新东西</pre><pre class="programlisting">simple := $(simple) new stuff</pre><p>由于简单变量中的值已经进行了扩展，<em class="command">因此 make</em>可以扩展
          <code class="literal">$(simple)</code>、追加文本并完成赋值。但递归变量会带来问题。不允许像下面这样的实现。</p><p>Since the value in the simple variable has already undergone
          expansion, <em class="command">make</em> can expand
          <code class="literal">$(simple)</code>, append the text, and
          finish the assignment. But recursive variables pose a problem. An
          implementation like the following isn't allowed.</p><a id="OEBPS/ch03s02.html.I_3_tt117"></a><pre class="programlisting">递归 = $(递归) 新东西</pre><pre class="programlisting">recursive = $(recursive) new stuff</pre><p><em class="command">这是一个错误，因为make</em>没有好的方法来处理它。如果<em class="command">make</em><code class="literal">recursive</code>存储了plus的当前定义
          <code class="literal">new stuff</code>，<em class="command">则 make</em>无法在运行时再次扩展它。此外，尝试扩展包含对其自身的引用的递归变量会产生无限循环。</p><p>This is an error because there's no good way for <em class="command">make</em> to handle it. If <em class="command">make</em> stores the current definition of
          <code class="literal">recursive</code> plus <code class="literal">new stuff</code>, <em class="command">make</em> can't expand it again at runtime.
          Furthermore, attempting to expand a recursive variable containing a
          reference to itself yields an infinite loop.</p><a id="OEBPS/ch03s02.html.I_3_tt118"></a><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
makefile:2: *** 递归变量“recursive”引用自身（最终）。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
makefile:2: *** Recursive variable `recursive' references itself (eventually).  Stop.</pre><p>因此，<code class="literal">+=</code>专门实现了允许将文本添加到递归变量并执行正确的操作©。该运算符对于以增量方式将值收集到变量中特别有用。</p><p>So, <code class="literal">+=</code> was implemented
          specifically to allow adding text to a recursive variable and does
          the Right Thing©. This operator is particularly useful for
          collecting values into a variable incrementally.</p></div></div></div></div>
<div id="OEBPS/ch03s03.html"><div>
<div class="sect1" title="宏"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s03.html.make3-CHP-3-SECT-3"></a>宏</h1><h1 class="title"><a></a>Macros</h1></div></div></div><p>变量适合<a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1059" class="indexterm"></a>将值存储为单行文本，但是如果我们有一个多行值（例如我们想要在多个位置执行的命令脚本）怎么办？例如，可以使用以下命令序列
        从 Java 类文件创建 Java 归档文件（或<em class="firstterm">jar ）：</em></p><p>Variables are fine for <a class="indexterm"></a>storing values as a single line of text, but what if we
        have a multiline value such as a command script we would like to
        execute in several places? For instance, the following sequence of
        commands might be used to create a Java archive (or
        <em class="firstterm">jar</em>) from Java class files:</p><a id="OEBPS/ch03s03.html.I_3_tt119"></a><pre class="programlisting">回声正在创建$@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) &amp;&amp; $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(清单)
$(RM) $(TMP_JAR_DIR)</pre><pre class="programlisting">echo Creating $@...
$(RM) $(TMP_JAR_DIR)
$(MKDIR) $(TMP_JAR_DIR)
$(CP) -r $^ $(TMP_JAR_DIR)
cd $(TMP_JAR_DIR) &amp;&amp; $(JAR) $(JARFLAGS) $@ .
$(JAR) -ufm $@ $(MANIFEST)
$(RM) $(TMP_JAR_DIR)</pre><p>在这样的长序列的开头，我喜欢打印一条简短的消息。它可以使阅读<em class="command">make</em>的输出变得更加容易。收到消息后，我们将类文件收集到一个干净的临时目录中。因此，我们删除临时<span class="emphasis"><em>jar</em></span>目录，以防旧的 jar 目录被遗弃，<sup>[ <a id="OEBPS/ch03s03.html.make3-CHP-3-FNOTE-2" href="#OEBPS/ch03s03.html.ftn.make3-CHP-3-FNOTE-2" class="footnote">2</a> ]</sup>然后我们创建一个新的临时目录。接下来，我们将必备文件（及其所有子目录）复制到临时目录中。然后我们切换到临时目录并使用目标文件名创建 jar。我们将清单文件添加到 jar 中，最后进行清理。显然，我们不想在<em class="filename">makefile</em>中重复这一系列命令，因为这将成为将来的维护问题。我们可能会考虑将所有这些命令打包到一个递归变量中，但是当<em class="command">make</em>回显命令行时，维护起来很困难并且难以阅读（整个序列作为一大行文本回显）。</p><p>At the beginning of long sequences such as this, I like to print
        a brief message. It can make reading <em class="command">make</em>'s output much easier. After the
        message, we collect our class files into a clean temporary directory.
        So we delete the temporary <span class="emphasis"><em>jar</em></span> directory in case
        an old one is left lying about,<sup>[<a href="#OEBPS/ch03s03.html.ftn.make3-CHP-3-FNOTE-2" class="footnote">2</a>]</sup> then we create a fresh temporary directory. Next we copy
        our prerequisite files (and all their subdirectories) into the
        temporary directory. Then we switch to our temporary directory and
        create the jar with the target filename. We add the manifest file to
        the jar and finally clean up. Clearly, we do not want to duplicate
        this sequence of commands in our <em class="filename">makefile</em> since that would be a maintenance
        problem in the future. We might consider packing all these commands
        into a recursive variable, but that is ugly to maintain and difficult
        to read when <em class="command">make</em> echoes the
        command line (the whole sequence is echoed as one enormous line of
        text).</p><p>相反，我们可以使用<a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1060" class="indexterm"></a>由指令创建的
        <em class="command">GNU make</em> “<acronym class="acronym">固定</acronym> 序列” 。 “固定序列”这个术语有点尴尬，所以我们将其称为
        <em class="firstterm">宏</em>。宏只是定义的另一种方式
        <em class="command"></em><code class="literal">define</code><em class="firstterm"></em><a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061" class="indexterm"></a><em class="command">make</em>中的一个变量，以及一个可以包含嵌入换行符的变量！ GNU <em class="command">make</em>手册似乎可以互换使用
        <acronym class="acronym">变量</acronym>
        <span class="emphasis"><em>和</em></span>宏<span class="emphasis"><em>这</em></span>两个词
        。在本书中，我们将专门使用
        <span class="emphasis"><em>“宏”</em></span>一词来表示使用指令定义的变量，并且
        仅在使用赋值时才<span class="emphasis"><em>使用变量。</em></span><em class="command"></em><span class="emphasis"><em></em></span><span class="emphasis"><em></em></span><span class="emphasis"><em></em></span><code class="literal">define</code><span class="emphasis"><em></em></span></p><p>Instead, we can use <a class="indexterm"></a>a <acronym class="acronym">GNU</acronym> <em class="command">make</em> "canned sequence" as created by the
        <code class="literal">define</code> directive. The term "canned
        sequence" is a bit awkward, so we'll call this a
        <em class="firstterm">macro</em>. A macro is just another way of defining
        <a class="indexterm"></a>a variable in <em class="command">make</em>,
        and one that can contain embedded newlines! The <acronym class="acronym">GNU</acronym>
        <em class="command">make</em> manual seems to use the words
        <span class="emphasis"><em>variable</em></span> and <span class="emphasis"><em>macro</em></span>
        interchangeably. In this book, we'll use the word
        <span class="emphasis"><em>macro</em></span> specifically to mean variables defined
        using the <code class="literal">define</code> directive and
        <span class="emphasis"><em>variable</em></span> only when assignment is used.</p><a id="OEBPS/ch03s03.html.I_3_tt120"></a><pre class="programlisting">定义创建jar
 @echo 创建$@...
 $(RM) $(TMP_JAR_DIR)
 $(MKDIR) $(TMP_JAR_DIR)
 $(CP) -r $^ $(TMP_JAR_DIR)
 cd $(TMP_JAR_DIR) &amp;&amp; $(JAR) $(JARFLAGS) $@ .
 $(JAR) -ufm $@ $(清单)
 $(RM) $(TMP_JAR_DIR)
恩德夫</pre><pre class="programlisting">define create-jar
 @echo Creating $@...
 $(RM) $(TMP_JAR_DIR)
 $(MKDIR) $(TMP_JAR_DIR)
 $(CP) -r $^ $(TMP_JAR_DIR)
 cd $(TMP_JAR_DIR) &amp;&amp; $(JAR) $(JARFLAGS) $@ .
 $(JAR) -ufm $@ $(MANIFEST)
 $(RM) $(TMP_JAR_DIR)
endef</pre><p>该<code class="literal">define</code>指令
        <a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1062" class="indexterm"></a> <a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1063" class="indexterm"></a> <a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1064" class="indexterm"></a>后面跟着宏名称和换行符。宏的主体包括直到<a id="OEBPS/ch03s03.html.make3-CHP-3-ITERM-1065" class="indexterm"></a>关键字<code class="literal">endef</code>，必须单独出现在一行上。用创建的宏的<code class="literal">define</code>扩展方式与任何其他变量非常相似，不同之处在于当它在命令脚本的上下文中使用时，宏的每一行前面都有一个制表符。一个使用示例是：</p><p>The <code class="literal">define</code> directive
        <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>is followed by the macro name and a newline. The body of
        the macro includes all the text up to <a class="indexterm"></a>the <code class="literal">endef</code> keyword,
        which must appear on a line by itself. A macro created with <code class="literal">define</code> is expanded pretty much like any
        other variable, except that when it is used in the context of a
        command script, each line of the macro has a tab prepended to the
        line. An example use is:</p><a id="OEBPS/ch03s03.html.I_3_tt121"></a><pre class="programlisting">$(UI_JAR): $(UI_CLASSES)
        $(创建jar)</pre><pre class="programlisting">$(UI_JAR): $(UI_CLASSES)
        $(create-jar)</pre><p><em class="command">请注意，我们在echo</em><code class="literal">@</code>命令
        前面添加了一个字符
        。执行命令时，<em class="command">make</em>不会回显以字符为前缀的命令行。因此，当我们运行<em class="command">make</em>时，它​​不会打印<em class="command">echo</em>命令，而只会打印该命令的输出。如果
        在宏中使用前缀，则前缀字符适用于使用它的各个行。但是，如果在宏引用上使用前缀字符，则整个宏体将被隐藏：<em class="command"></em><code class="literal">@</code><em class="command"></em><em class="command"></em><em class="command"></em><code class="literal">@</code></p><p>Notice we've added an <code class="literal">@</code>
        character in front of our <em class="command">echo</em>
        command. Command lines prefixed with an <code class="literal">@</code> character are not echoed by <em class="command">make</em> when the command is executed. When we
        run <em class="command">make</em>, therefore, it doesn't
        print the <em class="command">echo</em> command, just the
        output of that command. If the <code class="literal">@</code>
        prefix is used within a macro, the prefix character applies to the
        individual lines on which it is used. However, if the prefix character
        is used on the macro reference, the entire macro body is
        hidden:</p><a id="OEBPS/ch03s03.html.I_3_tt122"></a><pre class="programlisting">$(UI_JAR): $(UI_CLASSES)
        @$(创建jar)</pre><pre class="programlisting">$(UI_JAR): $(UI_CLASSES)
        @$(create-jar)</pre><p>这仅显示：</p><p>This displays only:</p><a id="OEBPS/ch03s03.html.I_3_tt123"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
正在创建 ui.jar...</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Creating ui.jar...</pre><p><a class="link" href="#OEBPS/ch05.html" title="第 5 章命令">第 5 章第</a>5.1.2<a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1.2" title="命令修饰符">节</a><code class="literal">@</code>更详细地介绍了的使用。<a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1.2" title="命令修饰符"></a><a class="link" href="#OEBPS/ch05.html" title="第 5 章命令"></a></p><p>The use of <code class="literal">@</code> is covered in
        more detail in the <a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1.2" title="Command Modifiers">Section
        5.1.2</a> in <a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">Chapter 5</a>.</p><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch03s03.html.ftn.make3-CHP-3-FNOTE-2" href="#OEBPS/ch03s03.html.make3-CHP-3-FNOTE-2" class="para">2</a> ]</sup>为了获得最佳效果，<code class="literal">RM</code>应将变量定义为保存
            <em class="command">rm -rf</em>。事实上，它的默认值是<em class="command">rm -f</em>，更安全，但不太有用。此外，<code class="literal">MKDIR</code>
            应定义为<em class="command">mkdir -p</em>等。</p><p><sup>[<a href="#OEBPS/ch03s03.html.make3-CHP-3-FNOTE-2" class="para">2</a>] </sup>For best effect here, the <code class="literal">RM</code> variable should be defined to hold
            <em class="command">rm -rf</em>. In fact, its default
            value is <em class="command">rm -f</em>, safer but not
            quite as useful. Further, <code class="literal">MKDIR</code>
            should be defined as <em class="command">mkdir -p</em>,
            and so on.</p></div></div></div></div></div>
<div id="OEBPS/ch03s04.html"><div>
<div class="sect1" title="当变量展开时"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s04.html.make3-CHP-3-SECT-4"></a>当变量展开时</h1><h1 class="title"><a></a>When Variables Are Expanded</h1></div></div></div><p>在前面的章节中，我们<a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1067" class="indexterm"></a>开始领略变量扩展的一些微妙之处。结果在很大程度上取决于先前定义的内容和位置。即使<em class="command">make</em>未能发现任何错误，您也可能很容易得到您不想要的结果。那么变量扩展的规则是什么呢？这到底是如何运作的？</p><p>In the previous sections, we <a class="indexterm"></a> <a class="indexterm"></a>began to get a taste of some of the subtleties of
        variable expansion. Results depend a lot on what was previously
        defined, and where. You could easily get results you don't want, even
        if <em class="command">make</em> fails to find any error. So
        what are the rules for expanding variables? How does this really
        work?</p><p>当<em class="command">make</em>运行时，它分两个阶段执行其工作。在第一阶段，<em class="command">make</em>读取<em class="filename">makefile</em>和任何包含的<em class="filename">makefile</em>。此时，变量和规则被加载到<em class="command">make</em>的内部数据库中，并创建依赖图。在第二阶段，<em class="command">make</em>分析依赖图并确定需要更新的目标，然后执行命令脚本来执行所需的更新。</p><p>When <em class="command">make</em> runs, it performs
        its job in two phases. In the first phase, <em class="command">make</em> reads the <em class="filename">makefile</em> and any included <em class="filename">makefile</em>s. At this time, variables and
        rules are loaded into <em class="command">make</em>'s
        internal database and the dependency graph is created. In the second
        phase, <em class="command">make</em> analyzes the dependency
        graph and determines the targets that need to be updated, then
        executes command scripts to perform the required updates.</p><p><em class="command">当make</em><code class="literal">define</code>处理递归变量或指令时，变量或宏主体中的行将被存储，包括不扩展的换行符。宏定义的最后一个换行符不存储为宏的一部分。否则，当宏展开时，<em class="command">make</em>将读取额外的换行符。<em class="command"></em><em class="command"></em></p><p>When a recursive variable or <code class="literal">define</code> directive is processed by <em class="command">make</em>, the lines in the variable or body of
        the macro are stored, including the newlines without being expanded.
        The very last newline of a macro definition is not stored as part of
        the macro. Otherwise, when the macro was expanded an extra newline
        would be read by <em class="command">make</em>.</p><p>当宏展开时，<a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1068" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1069" class="indexterm"></a>然后立即扫描扩展的文本以获取进一步的宏或变量引用，并递归地扩展这些文本，依此类推。如果宏在操作上下文中展开，则宏的每一行都会插入一个前导制表符。</p><p>When a macro is expanded, the <a class="indexterm"></a> <a class="indexterm"></a>expanded text is then immediately scanned for further
        macro or variable references and those are expanded and so on,
        recursively. If the macro is expanded in the context of an action,
        each line of the macro is inserted with a leading tab
        character.</p><p>总而言之，以下是扩展<em class="filename">makefile</em>元素的规则
        ：</p><p>To summarize, here are the rules for when elements of a
        <em class="filename">makefile</em> are expanded:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><em class="command">对于变量赋值，当make</em>在第一阶段读取该行时，赋值的左侧总是立即展开。</p></li><li class="listitem"><p>For variable assignments, the lefthand side of the
            assignment is always expanded immediately when <em class="command">make</em> reads the line during its first
            phase.</p></li><li class="listitem"><p><code class="literal">=</code>
            和的右侧<code class="literal">?=</code>被推迟到第二阶段使用。</p></li><li class="listitem"><p>The righthand side of <code class="literal">=</code>
            and <code class="literal">?=</code> are deferred until they
            are used in the second phase.</p></li><li class="listitem"><p>的右侧<code class="literal">:=</code>
            立即展开。</p></li><li class="listitem"><p>The righthand side of <code class="literal">:=</code>
            is expanded immediately.</p></li><li class="listitem"><p><code class="literal">+=</code>
            如果左侧最初定义为简单变量，则右侧会立即扩展。否则，其评估将被推迟。</p></li><li class="listitem"><p>The righthand side of <code class="literal">+=</code>
            is expanded immediately if the lefthand side was originally
            defined as a simple variable. Otherwise, its evaluation is
            deferred.</p></li><li class="listitem"><p>对于宏定义（使用 的宏定义<code class="literal">define</code>），宏变量名称会立即展开，而宏的主体会延迟到使用为止。</p></li><li class="listitem"><p>For macro definitions (those using <code class="literal">define</code>), the macro variable name is
            immediately expanded and the body of the macro is deferred until
            used.</p></li><li class="listitem"><p>对于规则，目标和先决条件总是立即扩展，而命令总是延迟。</p></li><li class="listitem"><p>For rules, the targets and prerequisites are always
            immediately expanded while the commands are always
            deferred.</p></li></ul></div><p><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>总结了变量扩展时会发生什么。</p><p><a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a> summarizes what
        occurs when variables are expanded.</p><div class="table"><a id="OEBPS/ch03s04.html.make3-CHP-3-TABLE-1"></a><p class="title">表 3-1。立即和延迟扩展的规则</p><p class="title">Table&nbsp;3-1.&nbsp;Rules for immediate and deferred expansion</p><div class="table-contents"><table summary="Rules for immediate and deferred expansion" style="border-collapse:collapse;border-top:0.5pt solid;border-bottom:0.5pt solid;border-left:0.5pt solid;border-right:0.5pt solid"><colgroup><col><col><col></colgroup><thead><tr><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>定义</p><p>Definition</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>扩展一个</p><p>Expansion of a</p></th><th style="border-bottom:0.5pt solid"><p>b 的扩展</p><p>Expansion of b</p></th></tr></thead><tbody><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><a id="OEBPS/ch03s04.html.I_3_tt124"></a><pre class="programlisting"><span class="emphasis"><em>a</em></span> =<span class="emphasis"><em> b</em></span></pre><pre class="programlisting"><span class="emphasis"><em>a</em></span> = <span class="emphasis"><em>b</em></span></pre></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>即时</p><p>Immediate</p></td><td style="border-bottom:0.5pt solid"><p>延期</p><p>Deferred</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><a id="OEBPS/ch03s04.html.I_3_tt125"></a><pre class="programlisting"><span class="emphasis"><em>a</em></span> ? =<span class="emphasis"><em> b</em></span></pre><pre class="programlisting"><span class="emphasis"><em>a</em></span> ?= <span class="emphasis"><em>b</em></span></pre></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>即时</p><p>Immediate</p></td><td style="border-bottom:0.5pt solid"><p>延期</p><p>Deferred</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><a id="OEBPS/ch03s04.html.I_3_tt126"></a><pre class="programlisting"><span class="emphasis"><em>一个</em></span>：=<span class="emphasis"><em>乙</em></span></pre><pre class="programlisting"><span class="emphasis"><em>a</em></span> := <span class="emphasis"><em>b</em></span></pre></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>即时</p><p>Immediate</p></td><td style="border-bottom:0.5pt solid"><p>即时</p><p>Immediate</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><a id="OEBPS/ch03s04.html.I_3_tt127"></a><pre class="programlisting"><span class="emphasis"><em>a</em></span> +=<span class="emphasis"><em> b</em></span></pre><pre class="programlisting"><span class="emphasis"><em>a</em></span> += <span class="emphasis"><em>b</em></span></pre></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>即时</p><p>Immediate</p></td><td style="border-bottom:0.5pt solid"><p>延期或立即</p><p>Deferred or immediate</p></td></tr><tr><td style="border-right:0.5pt solid"><a id="OEBPS/ch03s04.html.I_3_tt128"></a><pre class="programlisting">定义<span class="emphasis"><em>ab</em></span>。 。 。 
 <span class="emphasis"><em>b</em></span> . 。 。 
 <span class="emphasis"><em>b</em></span> . 。 。
恩德夫</pre><pre class="programlisting">define<span class="emphasis"><em>ab</em></span> . . . 
<span class="emphasis"><em>b</em></span> . . . 
<span class="emphasis"><em>b</em></span> . . . 
endef</pre></td><td style="border-right:0.5pt solid"><p>即时</p><p>Immediate</p></td><td style=""><p>延期</p><p>Deferred</p></td></tr></tbody></table></div></div><p>作为一般规则，始终定义变量和<a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1070" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1071" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1073" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1074" class="indexterm"></a> <a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1075" class="indexterm"></a>在使用宏之前。特别是，需要在使用目标或先决条件中使用的变量之前对其进行定义。</p><p>As a general rule, always define variables and <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>macros before they are used. In particular, it is
        required that a variable used in a target or prerequisite be defined
        before its use.</p><p>一个例子会让这一切变得更清楚。假设我们重新实现我们的<code class="function">free-space</code>宏。我们将一次浏览该示例的一部分，然后最后将它们全部放在一起。</p><p>An example will make all this clearer. Suppose we reimplement
        our <code class="function">free-space</code> macro. We'll go
        over the example a piece at a time, then put them all together at the
        end.</p><a id="OEBPS/ch03s04.html.I_3_tt129"></a><pre class="programlisting">BIN := /usr/bin
PRINTF := $(BIN)/printf
DF := $(BIN)/df
AWK := $(BIN)/awk</pre><pre class="programlisting">BIN    := /usr/bin
PRINTF := $(BIN)/printf
DF     := $(BIN)/df
AWK    := $(BIN)/awk</pre><p>我们定义三个变量来保存我们在宏中使用的程序的名称。为了避免代码重复，我们将<em class="filename">bin</em>目录分解
        为第四个变量。读取四个变量定义并立即展开它们的右侧，因为它们是简单变量。因为<code class="literal">BIN</code>是在其他之前定义的，所以它的值可以插入到它们的值中<a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1076" class="indexterm"></a>价值观。</p><p>We define three variables to hold the names of the programs we
        use in our macro. To avoid code duplication we factor out the
        <em class="filename">bin</em> directory into a fourth
        variable. The four variable definitions are read and their righthand
        sides are immediately expanded because they are simple variables.
        Because <code class="literal">BIN</code> is defined before the
        others, its value can be plugged into their <a class="indexterm"></a>values.</p><p>接下来，我们定义<code class="function">free-space</code>宏。</p><p>Next, we define the <code class="function">free-space</code> macro.</p><a id="OEBPS/ch03s04.html.I_3_tt130"></a><pre class="programlisting">定义自由空间
  $(PRINTF)“可用磁盘空间”
  $(DF) 。 | $(AWK) 'NR == 2 { 打印 $$4 }'
恩德夫</pre><pre class="programlisting">define free-space
  $(PRINTF) "Free disk space "
  $(DF) . | $(AWK) 'NR =  = 2 { print $$4 }'
endef</pre><p>该<code class="literal">define</code>指令后面跟着一个立即展开的变量名。在这种情况下，不需要扩展。宏的主体在未展开的情况下被读取和存储。</p><p>The <code class="literal">define</code> directive is
        followed by a variable name that is immediately expanded. In this
        case, no expansion is necessary. The body of the macro is read and
        stored unexpanded.</p><p>最后，我们在规则中使用我们的宏。</p><p>Finally, we use our macro in a rule.</p><a id="OEBPS/ch03s04.html.I_3_tt131"></a><pre class="programlisting">输出目录：= /tmp

$(OUTPUT_DIR)/very_big_file:
        $（可用空间）</pre><pre class="programlisting">OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
        $(free-space)</pre><p>读取<em class="filename">$(OUTPUT_DIR)/very_big_file</em>时，目标和先决条件中使用的任何变量都会立即展开。此处，<code class="literal">$(OUTPUT_DIR)</code>扩展为<em class="filename">/tmp</em>以形成
        <em class="filename">/tmp/very_big_file</em>目标。接下来，读取该目标的命令脚本。命令行由前导制表符识别并读取和存储，但不扩展。</p><p>When <em class="filename">$(OUTPUT_DIR)/very_big_file</em> is read, any
        variables used in the targets and prerequisites are immediately
        expanded. Here, <code class="literal">$(OUTPUT_DIR)</code> is
        expanded to <em class="filename">/tmp</em> to form the
        <em class="filename">/tmp/very_big_file</em> target. Next,
        the command script for this target is read. Command lines are
        recognized by the leading tab character and are read and stored, but
        not expanded.</p><p>这是整个示例<em class="filename">makefile</em>。文件中元素的顺序已被故意打乱，以说明<em class="command">make</em>的评估算法。</p><p>Here is the entire example <em class="filename">makefile</em>. The order of elements in the file
        has been scrambled intentionally to illustrate <em class="command">make</em>'s evaluation algorithm.</p><a id="OEBPS/ch03s04.html.I_3_tt132"></a><pre class="programlisting">输出目录：= /tmp

$(OUTPUT_DIR)/very_big_file:
        $（可用空间）

定义自由空间
  $(PRINTF)“可用磁盘空间”
  $(DF) 。 | $(AWK) 'NR == 2 { 打印 $$4 }'
恩德夫

BIN := /usr/bin
PRINTF := $(BIN)/printf
DF := $(BIN)/df
AWK := $(BIN)/awk</pre><pre class="programlisting">OUTPUT_DIR := /tmp

$(OUTPUT_DIR)/very_big_file:
        $(free-space)

define free-space
  $(PRINTF) "Free disk space "
  $(DF) . | $(AWK) 'NR =  = 2 { print $$4 }'
endef

BIN    := /usr/bin
PRINTF := $(BIN)/printf
DF     := $(BIN)/df
AWK    := $(BIN)/awk</pre><p><em class="filename">请注意，虽然makefile</em>中的行顺序看起来是向后的，但它执行得很好。这是递归变量的令人惊讶的效果之一。它可能非常有用，但同时又令人困惑。该<em class="filename">makefile</em>起作用的原因是命令脚本和宏主体的扩展被推迟到实际使用时。因此，它们出现的相对顺序对于<em class="filename">makefile</em>的执行并不重要。</p><p>Notice that although the order of lines in the <em class="filename">makefile</em> seems backward, it executes just
        fine. This is one of the surprising effects of recursive variables. It
        can be immensely useful and confusing at the same time. The reason
        this <em class="filename">makefile</em> works is that
        expansion of the command script and the body of the macro are deferred
        until they are actually used. Therefore, the relative order in which
        they occur is immaterial to the execution of the <em class="filename">makefile</em>.</p><p>在处理的第二阶段，读取<em class="filename">makefile后， </em><em class="command">make</em>识别目标，执行依赖性分析，并执行每个规则的操作。这里唯一的目标<code class="literal">$(OUTPUT_DIR)/very_big_file</code>没有任何先决条件，因此<em class="command">make</em>将简单地执行操作（假设该文件不存在）。命令是
        <code class="function">$(free-space)</code>。所以<em class="command">make</em>扩展了它，就好像程序员已经写了：</p><p>In the second phase of processing, after the <em class="filename">makefile</em> is read, <em class="command">make</em> identifies the targets, performs
        dependency analysis, and executes the actions for each rule. Here the
        only target, <code class="literal">$(OUTPUT_DIR)/very_big_file</code>, has no
        prerequisites, so <em class="command">make</em> will simply
        execute the actions (assuming the file doesn't exist). The command is
        <code class="function">$(free-space)</code>. So <em class="command">make</em> expands this as if the programmer had
        written:</p><a id="OEBPS/ch03s04.html.I_3_tt133"></a><pre class="programlisting">/tmp/very_big_file:
        /usr/bin/printf “可用磁盘空间”
        /usr/bin/df 。 | /usr/bin/awk 'NR == 2 { 打印 $$4 }'</pre><pre class="programlisting">/tmp/very_big_file:
        /usr/bin/printf "Free disk space "
        /usr/bin/df . | /usr/bin/awk 'NR =  = 2 { print $$4 }'</pre><p>一旦所有变量都展开，它就开始执行<a id="OEBPS/ch03s04.html.make3-CHP-3-ITERM-1077" class="indexterm"></a>一次命令一个。</p><p>Once all variables are expanded, it begins executing <a class="indexterm"></a>commands one at a time.</p><p>让我们看看 makefile 中顺序很重要的两个部分。如前所述，目标<em class="filename">​​$(OUTPUT_DIR)/very_big_file</em>立即展开。如果变量的定义<code class="literal">OUTPUT_DIR</code>遵​​循规则，则目标的扩展将产生<em class="filename">/very_big_file</em>。可能不是用户想要的。同样，如果 的定义<code class="literal">BIN</code>已移至 后<code class="literal">AWK</code>，则这三个变量将扩展为<em class="filename">/printf</em>、<em class="filename">/df</em>和<em class="filename">/awk ，</em>因为使用<code class="literal">:=</code>会导致立即评估赋值的右侧。然而，在这种情况下，我们可以通过更改为，使它们成为递归变量来避免<code class="literal">PRINTF</code>、
        <code class="literal">DF</code>和的问题。<code class="literal">AWK</code><code class="literal">:=</code><code class="literal">=</code></p><p>Let's look at the two parts of the makefile where the order is
        important. As explained earlier, the target <em class="filename">$(OUTPUT_DIR)/very_big_file</em> is expanded
        immediately. If the definition of the variable <code class="literal">OUTPUT_DIR</code> had followed the rule, the
        expansion of the target would have yielded <em class="filename">/very_big_file</em>. Probably not what the user
        wanted. Similarly, if the definition of <code class="literal">BIN</code> had been moved after <code class="literal">AWK</code>, those three variables would have
        expanded to <em class="filename">/printf</em>, <em class="filename">/df</em>, and <em class="filename">/awk</em> because the use of <code class="literal">:=</code> causes immediate evaluation of the
        righthand side of the assignment. However, in this case, we could
        avoid the problem for <code class="literal">PRINTF</code>,
        <code class="literal">DF</code>, and <code class="literal">AWK</code> by changing <code class="literal">:=</code> to <code class="literal">=</code>,
        making them recursive variables.</p><p>最后一个细节。请注意，更改<code class="literal">OUTPUT_DIR</code>和的递归变量的定义
        <code class="literal">BIN</code>不会改变先前排序问题的影响。重要的问题是，当<em class="filename">$(OUTPUT_DIR)/very_big_file</em><code class="literal">PRINTF</code>以及、<code class="literal">DF</code>、 和的右侧<code class="literal">AWK</code>展开时，它们的展开会立即发生，因此它们引用的变量必须已经定义。</p><p>One last detail. Notice that changing the definitions of
        <code class="literal">OUTPUT_DIR</code> and <code class="literal">BIN</code> to recursive variables would not change
        the effect of the previous ordering problems. The important issue is
        that when <em class="filename">$(OUTPUT_DIR)/very_big_file</em> and the
        righthand sides of <code class="literal">PRINTF</code>, <code class="literal">DF</code>, and <code class="literal">AWK</code> are expanded, their expansion happens
        immediately, so the variables they refer to must be already
        defined.</p></div></div></div>
<div id="OEBPS/ch03s05.html"><div>
<div class="sect1" title="特定于目标和模式的变量"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s05.html.make3-CHP-3-SECT-5"></a>特定于目标和模式的变量</h1><h1 class="title"><a></a>Target- and Pattern-Specific Variables</h1></div></div></div><p>变量通常有<a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1078" class="indexterm"></a> <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1079" class="indexterm"></a> <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080" class="indexterm"></a> <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081" class="indexterm"></a>执行 makefile 期间只有一个<em class="filename">值</em>。这是由<em class="filename">makefile</em>处理的两阶段性质保证的。在第一阶段，读取<em class="filename">makefile</em>，分配和扩展变量，并构建依赖关系图。在第二阶段，分析并遍历依赖图。因此，当命令脚本执行时，所有变量处理已经完成。但是假设我们只想为单个规则或模式重新定义变量。</p><p>Variables usually have <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>only one value during the execution of a <em class="filename">makefile</em>. This is ensured by the two-phase
        nature of <em class="filename">makefile</em> processing. In
        phase one, the <em class="filename">makefile</em> is read,
        variables are assigned and expanded, and the dependency graph is
        built. In phase two, the dependency graph is analyzed and traversed.
        So when command scripts are being executed, all variable processing
        has already completed. But suppose we wanted to redefine a variable
        for just a single rule or pattern.</p><p>在此示例中，我们正在编译的特定文件需要一个额外的命令行选项 ，<code class="literal">-DUSE_NEW_MALLOC=1</code>该选项不应提供给其他编译：</p><p>In this example, the particular file we are compiling needs an
        extra command-line option, <code class="literal">-DUSE_NEW_MALLOC=1</code>, that should not be
        provided to other compiles:</p><a id="OEBPS/ch03s05.html.I_3_tt134"></a><pre class="programlisting">gui.o：gui.h
        $(COMPILE.c) -DUSE_NEW_MALLOC=1 $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">gui.o: gui.h
        $(COMPILE.c) -DUSE_NEW_MALLOC=1 $(OUTPUT_OPTION) $&lt;</pre><p>在这里，我们通过复制编译命令脚本并添加新的必需选项来解决问题。这种方法在几个方面都不能令人满意。首先，我们复制代码。如果规则发生变化或者我们选择用自定义模式规则替换内置规则，则需要更新此代码，而我们可能会忘记。其次，如果许多文件需要特殊处理，则粘贴此代码的任务很快就会变得非常乏味且容易出错（想象一下一百个这样的文件）。</p><p>Here, we've solved the problem by duplicating the compilation
        command script and adding the new required option. This approach is
        unsatisfactory in several respects. First, we are duplicating code. If
        the rule ever changes or if we choose to replace the built-in rule
        with a custom pattern rule, this code would need to be updated and we
        might forget. Second, if many files require special treatment, the
        task of pasting in this code will quickly become very tedious and
        error-prone (imagine a hundred files like this).</p><p>为了解决这个问题和其他问题，<em class="command">make</em>提供了<em class="firstterm">特定于目标的变量</em>。这些是附加到目标的变量定义，仅在处理该目标及其任何先决条件期间有效。我们可以使用此功能重写之前的示例，如下所示：</p><p>To address this issue and others, <em class="command">make</em> provides <em class="firstterm">target-specific
        variables</em>. These are variable definitions attached to a
        target that are valid only during the processing of that target and
        any of its prerequisites. We can rewrite our previous example using
        this feature like this:</p><a id="OEBPS/ch03s05.html.I_3_tt135"></a><pre class="programlisting">gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o：gui.h
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>变量<code class="literal">CPPFLAGS</code>
        <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1082" class="indexterm"></a> <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083" class="indexterm"></a>内置于默认的 C 编译规则中，旨在包含 C 预处理器的选项。通过使用<code class="literal">+=</code>赋值的形式，我们将新选项附加到任何已经存在的现有值上。现在可以完全删除编译命令脚本：</p><p>The variable <code class="literal">CPPFLAGS</code>
        <a class="indexterm"></a> <a class="indexterm"></a> is built in to the default C compilation rule and is
        meant to contain options for the C preprocessor. By using the <code class="literal">+=</code> form of assignment, we append our new
        option to any existing value already present. Now the compile command
        script can be removed entirely:</p><a id="OEBPS/ch03s05.html.I_3_tt136"></a><pre class="programlisting">gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o：gui.h</pre><pre class="programlisting">gui.o: CPPFLAGS += -DUSE_NEW_MALLOC=1
gui.o: gui.h</pre><p>在处理<em class="filename">gui.o</em>目标时，除了其原始内容之外，<code class="literal">CPPFLAGS</code>还将包含
        的值。<code class="option">-DUSE_NEW_MALLOC=1</code>当<em class="filename">gui.o</em>目标完成时，<code class="literal">CPPFLAGS</code>将恢复到其原始值。当<em class="filename">gui.o</em>目标完成时，<code class="literal">CPPFLAGS</code>将恢复到其原始值。特定于模式的变量类似，只是它们在模式规则中指定（请参见第 21 页）。</p><p>While the <em class="filename">gui.o</em> target is
        being processed, the value of <code class="literal">CPPFLAGS</code> will contain
        <code class="option">-DUSE_NEW_MALLOC=1</code> in addition to its original
        contents. When the <em class="filename">gui.o</em> target
        is finished, <code class="literal">CPPFLAGS</code> will revert
        to its original value. When the <em class="filename">gui.o</em> target is
        finished, <code class="literal">CPPFLAGS</code> will revert to its original
        value. Pattern-specific variables are similar, only they are specified
        in a pattern rule (see page 21).</p><p>一般语法为<a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1084" class="indexterm"></a> <a id="OEBPS/ch03s05.html.make3-CHP-3-ITERM-1085" class="indexterm"></a>目标特定变量是：</p><p>The general syntax for <a class="indexterm"></a> <a class="indexterm"></a>target-specific variables is:</p><a id="OEBPS/ch03s05.html.I_3_tt137"></a><pre class="programlisting"><em class="replaceable"><code>target</code></em>……：……：……：……：<em class="replaceable"><code>variable = value</code></em>
               <em class="replaceable"><code>target</code></em><em class="replaceable"><code>variable := value</code></em>
               <em class="replaceable"><code>target</code></em><em class="replaceable"><code>variable += value</code></em>
               <em class="replaceable"><code>target</code></em><em class="replaceable"><code>variable ?= value</code></em></pre><pre class="programlisting"><em class="replaceable"><code>target</code></em>...: <em class="replaceable"><code>variable = value</code></em>
               <em class="replaceable"><code>target</code></em>...: <em class="replaceable"><code>variable := value</code></em>
               <em class="replaceable"><code>target</code></em>...: <em class="replaceable"><code>variable += value</code></em>
               <em class="replaceable"><code>target</code></em>...: <em class="replaceable"><code>variable ?= value</code></em></pre><p>正如您所看到的，所有各种形式的赋值对于特定于目标的变量都有效。该变量在赋值之前不需要存在。</p><p>As you can see, all the various forms of assignment are valid
        for a target-specific variable. The variable does not need to exist
        before the assignment.</p><p>此外，直到目标处理开始后才真正执行变量赋值。因此，赋值的右侧本身可以是另一个特定于目标的变量中设置的值。该变量在处理所有先决条件期间也有效。</p><p>Furthermore, the variable assignment is not actually performed
        until the processing of the target begins. So the righthand side of
        the assignment can itself be a value set in another target-specific
        variable. The variable is valid during the processing of all
        prerequisites as well.</p></div></div></div>
<div id="OEBPS/ch03s06.html"><div>
<div class="sect1" title="变量从何而来"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s06.html.make3-CHP-3-SECT-6"></a>变量从何而来</h1><h1 class="title"><a></a>Where Variables Come From</h1></div></div></div><p>到目前为止，大多数变量已经在我们自己的
        <em class="filename">makefile</em>中显式定义，但变量可以有更复杂的<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086" class="indexterm"></a> <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1087" class="indexterm"></a>祖先。例如，我们已经看到可以在<em class="command">make</em>命令行上定义变量。事实上，<em class="command">make</em>变量可以来自以下来源：</p><p>So far, most variables have been defined explicitly in our own
        <em class="filename">makefile</em>s, but variables can have
        a more complex <a class="indexterm"></a> <a class="indexterm"></a>ancestry. For instance, we have seen that variables can
        be defined on the <em class="command">make</em> command
        line. In fact, <em class="command">make</em> variables can
        come from these sources:</p><div class="variablelist"><dl><dt><span class="term">文件</span></dt><dt><span class="term">File</span></dt><dd><p>当然，变量可以是<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1088" class="indexterm"></a><em class="filename">在makefile或</em><em class="filename">makefile</em>包含的文件
              中定义（我们将
              <code class="literal">include</code>很快介绍该指令）。</p></dd><dd><p>Of course, variables can be <a class="indexterm"></a>defined in the <em class="filename">makefile</em> or a file included by the
              <em class="filename">makefile</em> (we'll cover the
              <code class="literal">include</code> directive
              shortly).</p></dd><dt><span class="term">命令行</span></dt><dt><span class="term">Command line</span></dt><dd><p>变量可以被定义或重新定义<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1089" class="indexterm"></a>直接从<em class="command">make</em>命令行：</p><a id="OEBPS/ch03s06.html.I_3_tt138"></a><pre class="programlisting">$ make CFLAGS=-g CPPFLAGS='-DBSD -DDEBUG'</pre><p>包含 an 的命令行参数<code class="literal">=</code>是变量赋值。命令行上的每个变量分配必须是单个 shell 参数。如果变量的值（或者天堂禁止变量本身）包含空格，则参数必须用引号括起来，或者必须对空格进行转义。</p><p>命令行上的变量赋值会覆盖环境中的任何值以及
              <em class="filename">makefile</em>中的任何赋值。命令行赋值可以分别使用<code class="literal">:=</code>或来设置简单变量或递归变量<code class="literal">=</code>。可以使用该<code class="function">override</code>指令来允许使用<em class="filename">makefile</em>分配而不是命令行分配。</p><a id="OEBPS/ch03s06.html.I_3_tt139"></a><pre class="programlisting"># 使用big-endian对象，否则程序崩溃！
覆盖 LDFLAGS = -EB</pre><p>当然，只有在最紧急的情况下才应该忽略用户的显式分配请求（除非您只是想激怒用户）。</p></dd><dd><p>Variables can be defined or redefined <a class="indexterm"></a>directly from the <em class="command">make</em> command line:</p><a></a><pre class="programlisting">$ make CFLAGS=-g CPPFLAGS='-DBSD -DDEBUG'</pre><p>A command-line argument containing an <code class="literal">=</code> is a variable assignment. Each
              variable assignment on the command line must be a single shell
              argument. If the value of the variable (or heaven forbid, the
              variable itself) contains spaces, the argument must be
              surrounded by quotes or the spaces must be escaped.</p><p>An assignment of a variable on the command line overrides
              any value from the environment and any assignment in the
              <em class="filename">makefile</em>. Command-line
              assignments can set either simple or recursive variables by
              using <code class="literal">:=</code> or <code class="literal">=</code>, respectively. It is possible using
              the <code class="function">override</code> directive to
              allow a <em class="filename">makefile</em> assignment
              to be used instead of a command-line assignment.</p><a></a><pre class="programlisting"># Use big-endian objects or the program crashes!
override LDFLAGS = -EB</pre><p>Of course, you should ignore a user's explicit assignment
              request only under the most urgent circumstances (unless you
              just want to irritate your users).</p></dd><dt><span class="term">环境</span></dt><dt><span class="term">Environment</span></dt><dd><p>您的所有变量<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1090" class="indexterm"></a><em class="command">make</em>启动时环境会自动定义为<em class="command">make</em>变量。这些变量的优先级非常低，因此<em class="filename">makefile</em>或命令行参数中的赋值将覆盖环境变量的值。您可以使用(或) 命令行选项使环境变量覆盖<em class="filename">makefile</em>变量
              。<em class="command"></em><em class="filename"></em><em class="filename"></em><code class="option">—environment-overrides</code><code class="option">-e</code></p><p>当递归调用<em class="command">make时，父</em><em class="command">make</em>中的一些变量将通过环境传递给子<em class="command">make</em>。默认情况下，只有那些最初来自环境的变量会导出到子环境中，但是可以使用以下指令将任何变量导出到环境中<code class="function">export</code>：</p><a id="OEBPS/ch03s06.html.I_3_tt140"></a><pre class="programlisting">导出 CLASSPATH := $(HOME)/classes:$(PROJECT)/classes
贝壳 = -x
出口贝类</pre><p>您可以使所有变量<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1091" class="indexterm"></a> <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092" class="indexterm"></a>导出为：</p><a id="OEBPS/ch03s06.html.I_3_tt141"></a><pre class="programlisting">出口</pre><p>请注意，<em class="command">make</em>甚至会导出那些名称包含无效 shell 变量字符的变量。例如：</p><a id="OEBPS/ch03s06.html.I_3_tt142"></a><pre class="programlisting">导出 make 中的有效变量 = 整洁！
显示变量：
        环境| grep '^有效-'
        valid_variable_in_shell=很好
        shell 中的无效变量=抱歉


$ 制作
环境| grep '^有效-'
valid-variable-in-make=整洁！
valid_variable_in_shell=很好
shell 中的无效变量=抱歉
/bin/sh: 第 1 行：shell 中的无效变量=抱歉：找不到命令
make: *** [显示变量] 错误 127</pre><p>通过导出创建了“无效”shell 变量
              <code class="literal">valid-variable-in-make</code>。该变量无法通过正常的 shell 语法访问，只能通过诸如在环境中运行<em class="command">grep</em>之类的技巧来访问。然而，该变量可以被任何有效且可访问的子<em class="command">品牌</em>继承。我们将在<a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题">第二部分介绍“递归” </a><em class="command">make</em>的使用。<a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题"></a></p><p>您还可以阻止将环境变量导出到子流程：</p><a id="OEBPS/ch03s06.html.I_3_tt143"></a><pre class="programlisting">取消导出显示</pre><p>和指令<code class="function">mp_export</code>的
              <code class="function">mp_unexport</code>工作方式与<em class="command">mp_sh</em>命令
              <code class="function">mp_export</code>和<code class="function">mp_unset</code>
              工作方式相同。</p><p>条件赋值<a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1093" class="indexterm"></a> <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1094" class="indexterm"></a>运算符与环境变量的交互非常好。假设您在<em class="filename">makefile</em>中设置了默认输出目录，但您希望用户能够轻松覆盖默认值。条件赋值非常适合这种情况：</p><a id="OEBPS/ch03s06.html.I_3_tt144"></a><pre class="programlisting"># 假设输出目录为$(PROJECT_DIR)/out。
OUTPUT_DIR ?= $(PROJECT_DIR)/out</pre><p><code class="literal">OUTPUT_DIR</code>这里仅当从未设置过时才执行分配。我们可以通过更详细地获得几乎相同的效果：</p><a id="OEBPS/ch03s06.html.I_3_tt145"></a><pre class="programlisting">ifndef 输出目录
  # 假设输出目录为$(PROJECT_DIR)/out。
  OUTPUT_DIR = $(PROJECT_DIR)/输出
万一</pre><p>不同之处在于，如果变量已以任何方式设置（甚至设置为空值），条件赋值运算符将跳过赋值，而 and<code class="literal">ifdef</code>运算<code class="literal">ifndef</code>符则测试非空值。因此，<code class="literal">OUTPUT_DIR=</code>被认为是由条件运算符设置的，但不是由 定义的
              <code class="literal">ifdef</code>。</p><p>需要注意的是，过度使用环境变量会使<em class="filename">makefile</em>的可移植性大大降低，因为其他用户不太可能拥有相同的环境变量集。事实上，正是因为这个原因，我很少使用这个功能。</p></dd><dd><p>All the variables from your <a class="indexterm"></a>environment are automatically defined as <em class="command">make</em> variables when <em class="command">make</em> starts. These variables have very
              low precedence, so assignments within the <em class="filename">makefile</em> or command-line arguments
              will override the value of an environment variable. You can
              cause environment variables to override <em class="filename">makefile</em> variables using the
              <code class="option">—environment-overrides</code> (or <code class="option">-e</code>)
              command-line option.</p><p>When <em class="command">make</em> is invoked
              recursively, some variables from the parent <em class="command">make</em> are passed through the
              environment to the child <em class="command">make</em>. By default, only those variables
              that originally came from the environment are exported to the
              child's environment, but any variable can be exported to the
              environment by using the <code class="function">export</code> directive:</p><a></a><pre class="programlisting">export CLASSPATH := $(HOME)/classes:$(PROJECT)/classes
SHELLOPTS = -x
export SHELLOPTS</pre><p>You can cause all variables to <a class="indexterm"></a> <a class="indexterm"></a>be exported with:</p><a></a><pre class="programlisting">export</pre><p>Note that <em class="command">make</em> will
              export even those variables whose names contain invalid shell
              variable characters. For example:</p><a></a><pre class="programlisting">export valid-variable-in-make = Neat!
show-vars:
        env | grep '^valid-'
        valid_variable_in_shell=Great
        invalid-variable-in-shell=Sorry


$ make
env | grep '^valid-'
valid-variable-in-make=Neat!
valid_variable_in_shell=Great
invalid-variable-in-shell=Sorry
/bin/sh: line 1: invalid-variable-in-shell=Sorry: command not found
make: *** [show-vars] Error 127</pre><p>An "invalid" shell variable was created by exporting
              <code class="literal">valid-variable-in-make</code>. This
              variable is not accessible through normal shell syntax, only
              through trickery such as running <em class="command">grep</em> over the environment.
              Nevertheless, this variable is inherited by any sub-<em class="command">make</em> where it is valid and accessible.
              We will cover use of "recursive" <em class="command">make</em> in <a class="link" href="#OEBPS/pt02.html" title="Part&nbsp;II.&nbsp;Advanced and Specialized Topics">Part II</a>.</p><p>You can also prevent an environment variable from being
              exported to the sub-process:</p><a></a><pre class="programlisting">unexport DISPLAY</pre><p>The <code class="function">mp_export</code> and
              <code class="function">mp_unexport</code> directives work
              the same way the <em class="command">mp_sh</em> commands
              <code class="function">mp_export</code> and <code class="function">mp_unset</code>
              work. </p><p>The conditional assignment <a class="indexterm"></a> <a class="indexterm"></a>operator interacts very nicely with environment
              variables. Suppose you have a default output directory set in
              your <em class="filename">makefile</em>, but you want
              users to be able to override the default easily. Conditional
              assignment is perfect for this situation:</p><a></a><pre class="programlisting"># Assume the output directory $(PROJECT_DIR)/out.
OUTPUT_DIR ?= $(PROJECT_DIR)/out</pre><p>Here the assignment is performed only if <code class="literal">OUTPUT_DIR</code> has never been set. We can
              get nearly the same effect more verbosely with:</p><a></a><pre class="programlisting">ifndef OUTPUT_DIR
  # Assume the output directory $(PROJECT_DIR)/out.
  OUTPUT_DIR = $(PROJECT_DIR)/out
endif</pre><p>The difference is that the conditional assignment operator
              will skip the assignment if the variable has been set in any
              way, even to the empty value, while the <code class="literal">ifdef</code> and <code class="literal">ifndef</code> operators test for a nonempty
              value. Thus, <code class="literal">OUTPUT_DIR=</code> is
              considered set by the conditional operator but not defined by
              <code class="literal">ifdef</code>.</p><p>It is important to note that excessive use of environment
              variables makes your <em class="filename">makefile</em>s much less portable, since
              other users are not likely to have the same set of environment
              variables. In fact, I rarely use this feature for precisely that
              reason.</p></dd><dt><span class="term">自动的</span></dt><dt><span class="term">Automatic</span></dt><dd><p>最后，<em class="command">make</em>创建
              <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1095" class="indexterm"></a> <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096" class="indexterm"></a>在执行规则的命令脚本之前立即使用自动变量。</p></dd><dd><p>Finally, <em class="command">make</em> creates
              <a class="indexterm"></a> <a class="indexterm"></a>automatic variables immediately before executing
              the command script of a rule.</p></dd></dl></div><p>传统上，环境变量用于帮助管理开发人员计算机之间的差异。例如，常见的是
        <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1097" class="indexterm"></a> <a id="OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098" class="indexterm"></a>根据 makefile 中引用的环境变量创建开发环境（源代码、编译的输出树和工具<em class="filename">）</em>。 makefile
        将引用每棵树的根的一个环境变量<em class="filename">。</em>如果源文件树是从变量<code class="literal">PROJECT_SRC</code>、二进制输出文件
        <code class="literal">PROJECT_BIN</code>和库引用的
        <code class="literal">PROJECT_LIB</code>，那么开发人员可以自由地将这些树放置在适当的位置。</p><p>Traditionally, environment variables are used to help manage the
        differences between developer machines. For instance, it is common
        <a class="indexterm"></a> <a class="indexterm"></a>to create a development environment (source code,
        compiled output tree, and tools) based on environment variables
        referenced in the <em class="filename">makefile</em>. The
        <em class="filename">makefile</em> would refer to one
        environment variable for the root of each tree. If the source file
        tree is referenced from a variable <code class="literal">PROJECT_SRC</code>, binary output files from
        <code class="literal">PROJECT_BIN</code>, and libraries from
        <code class="literal">PROJECT_LIB</code>, then developers are
        free to place these trees wherever is appropriate.</p><p>当未设置这些“根”变量时，此方法（以及通常使用环境变量）会出现潜在问题。一种解决方案是使用赋值形式在<em class="filename">makefile</em>中提供默认值
        ：<code class="literal">?=</code></p><p>A potential problem with this approach (and with the use of
        environment variables in general) occurs when these "root" variables
        are not set. One solution is to provide default values in the
        <em class="filename">makefile</em> using the <code class="literal">?=</code> form of assignment:</p><a id="OEBPS/ch03s06.html.I_3_tt146"></a><pre class="programlisting">PROJECT_SRC ?= /dev/$(USER)/src
PROJECT_BIN ?= $(patsubst %/src,%/bin,$(PROJECT_SRC))
PROJECT_LIB ?= /net/server/project/lib</pre><pre class="programlisting">PROJECT_SRC ?= /dev/$(USER)/src
PROJECT_BIN ?= $(patsubst %/src,%/bin,$(PROJECT_SRC))
PROJECT_LIB ?= /net/server/project/lib</pre><p>通过使用这些变量访问项目组件，您可以创建适应不同机器布局的开发环境。 （我们将在<a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题">第二部分</a>中看到更全面的示例。）但是，请注意过度依赖环境变量。一般来说，<em class="filename">makefile</em>应该能够在开发人员环境的最低支持下运行，因此请务必提供合理的默认值并检查关键组件是否存在。</p><p>By using these variables to access project components, you can
        create a development environment that is adaptable to varying machine
        layouts. (We will see more comprehensive examples of this in <a class="link" href="#OEBPS/pt02.html" title="Part&nbsp;II.&nbsp;Advanced and Specialized Topics">Part II</a>.) Beware of overreliance on
        environment variables, however. Generally, a <em class="filename">makefile</em> should be able to run with a
        minimum of support from the developer's environment so be sure to
        provide reasonable defaults and check for the existence of critical
        components.</p></div></div></div>
<div id="OEBPS/ch03s07.html"><div>
<div class="sect1" title="有条件并包括处理"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s07.html.make3-CHP-3-SECT-7"></a>有条件并包括处理</h1><h1 class="title"><a></a>Conditional and include Processing</h1></div></div></div><p><em class="filename">makefile</em>的某些部分可以省略<a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1099" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1100" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1101" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1102" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1103" class="indexterm"></a><em class="firstterm">或在使用条件处理</em>指令读取
        <em class="filename">makefile</em>时选择。控制选择的条件可以有多种形式，例如“已定义”或“等于”。例如：<em class="firstterm"></em></p><p>Parts of a <em class="filename">makefile</em> can be
        omitted <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>or selected while the <em class="filename">makefile</em> is being read using
        <em class="firstterm">conditional processing</em> directives. The
        condition that controls the selection can have several forms such as
        "is defined" or "is equal to." For example:</p><a id="OEBPS/ch03s07.html.I_3_tt147"></a><pre class="programlisting"># COMSPEC 仅在 Windows 上定义。
ifdef 计算机规范
  路径_SEP := ;
  EXE_EXT := .exe
别的
  路径_SEP := :
  EXE_EXT :=
万一</pre><pre class="programlisting"># COMSPEC is defined only on Windows.
ifdef COMSPEC
  PATH_SEP := ;
  EXE_EXT  := .exe
else
  PATH_SEP := :
  EXE_EXT  :=
endif</pre><p><code class="literal">COMSPEC</code>如果定义了变量，则选择条件的第一个分支
        。</p><p>This selects the first branch of the conditional if the variable
        <code class="literal">COMSPEC</code> is defined.</p><p>条件语句的基本语法<a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1104" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1105" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1106" class="indexterm"></a>指令是：</p><p>The basic syntax of the conditional<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> directive is:</p><a id="OEBPS/ch03s07.html.I_3_tt148"></a><pre class="programlisting"><em class="replaceable"><code>if-condition</code></em>
               <em class="replaceable"><code>text if the condition is true</code></em>
万一</pre><pre class="programlisting"><em class="replaceable"><code>if-condition</code></em>
               <em class="replaceable"><code>text if the condition is true</code></em>
endif</pre><p>或者：</p><p>or:</p><a id="OEBPS/ch03s07.html.I_3_tt149"></a><pre class="programlisting"><em class="replaceable"><code>if-condition</code></em>
               <em class="replaceable"><code>text if the condition is true</code></em>
别的
  <em class="replaceable"><code>text if the condition is false</code></em>
万一</pre><pre class="programlisting"><em class="replaceable"><code>if-condition</code></em>
               <em class="replaceable"><code>text if the condition is true</code></em>
else
  <em class="replaceable"><code>text if the condition is false</code></em>
endif</pre><p>可以<em class="replaceable"><code>if-condition</code></em>是以下之一：</p><p>The <em class="replaceable"><code>if-condition</code></em> can be one
        of:</p><a id="OEBPS/ch03s07.html.I_3_tt150"></a><pre class="programlisting">ifdef <em class="replaceable"><code>variable-name</code></em>
ifndef <em class="replaceable"><code>variable-name</code></em>
ifeq   <em class="replaceable"><code>test</code></em>
ifneq<em class="replaceable"><code>test</code></em></pre><pre class="programlisting">ifdef<em class="replaceable"><code>variable-name</code></em>
ifndef <em class="replaceable"><code>variable-name</code></em>
ifeq  <em class="replaceable"><code>test</code></em>
ifneq <em class="replaceable"><code>test</code></em></pre><p>不应被/测试<em class="replaceable"><code>variable-name</code></em>包围。最后，
        可以表示为：<code class="literal">$( )</code><code class="literal">ifdef</code><code class="literal">ifndef</code><em class="replaceable"><code>test</code></em></p><p>The <em class="replaceable"><code>variable-name</code></em> should not be
        surrounded by <code class="literal">$( )</code> for the <code class="literal">ifdef</code>/<code class="literal">ifndef</code> test. Finally, the
        <em class="replaceable"><code>test</code></em> can be expressed as either of:</p><a id="OEBPS/ch03s07.html.I_3_tt151"></a><pre class="programlisting">” <em class="replaceable"><code>a</code></em>“” <em class="replaceable"><code>b</code></em>“
( <em class="replaceable"><code>a</code></em>, <em class="replaceable"><code>b</code></em>)</pre><pre class="programlisting">"<em class="replaceable"><code>a</code></em>" "<em class="replaceable"><code>b</code></em>"
(<em class="replaceable"><code>a</code></em>,<em class="replaceable"><code>b</code></em>)</pre><p>其中单引号或双引号可以互换使用（但您使用的引号必须匹配）。</p><p>in which single or double quotes can be used interchangeably
        (but the quotes you use must match).</p><p><em class="filename">条件处理指令可以在宏定义和命令脚本中以及makefile</em>的顶层使用
        ：</p><p>The conditional processing directives can be used within macro
        definitions and command scripts as well as at the top level of
        <em class="filename">makefile</em>s:</p><a id="OEBPS/ch03s07.html.I_3_tt152"></a><pre class="programlisting">libGui.a: $(gui_objects)
        $(AR) $(ARFLAGS) $@ $&lt;
    ifdef RANLIB
        $(RANLIB) $@
    万一</pre><pre class="programlisting">libGui.a: $(gui_objects)
        $(AR) $(ARFLAGS) $@ $&lt;
    ifdef RANLIB
        $(RANLIB) $@
    endif</pre><p>我喜欢缩进条件语句，但粗心的缩进可能会导致错误。在前面的行中，条件指令缩进四个空格，而包含的命令有一个前导制表符。如果包含的命令不以制表符开头，则<em class="command">make</em>不会将它们识别为命令。如果条件指令有一个前导选项卡，它们将被错误地识别为命令并传递到子 shell。</p><p>I like to indent my conditionals, but careless indentation can
        lead to errors. In the preceding lines, the conditional directives are
        indented four spaces while the enclosed commands have a leading tab.
        If the enclosed commands didn't begin with a tab, they would not be
        recognized as commands by <em class="command">make</em>. If
        the conditional directives had a leading tab, they would be
        misidentified as commands and passed to the subshell.</p><p>和条件<code class="literal">ifeq</code>句<code class="literal">ifneq</code><a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1107" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1108" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1109" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1110" class="indexterm"></a>测试他们的参数是否相等。条件处理中的空白可能很难处理。例如，当使用测试的括号形式时，逗号后面的空格将被忽略，但所有其他空格都很重要：</p><p>The <code class="literal">ifeq</code> and <code class="literal">ifneq</code> conditionals <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>test if their arguments are equal or not equal.
        Whitespace in conditional processing can be tricky to handle. For
        instance, when using the parenthesis form of the test, whitespace
        after the comma is ignored, but all other whitespace is
        significant:</p><a id="OEBPS/ch03s07.html.I_3_tt153"></a><pre class="programlisting">ifeq (a, a)
  # 这些是相等的
万一

ifeq ( b, b )
  # 这些不相等 - ' b' != 'b '
万一</pre><pre class="programlisting">ifeq (a, a)
  # These are equal
endif

ifeq ( b, b )
  # These are not equal - ' b' != 'b '
endif</pre><p>就我个人而言，我坚持引用的平等形式：</p><p>Personally, I stick with the quoted forms of equality:</p><a id="OEBPS/ch03s07.html.I_3_tt154"></a><pre class="programlisting">ifeq “一” “一”
  # 这些是相等的
万一

ifeq 'b' 'b'
  # 这些也是
万一</pre><pre class="programlisting">ifeq "a" "a"
  # These are equal
endif

ifeq 'b' 'b'
  # So are these
endif</pre><p>即便如此，变量扩展中经常会包含意外的空格。这可能会导致问题<a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1111" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1112" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1113" class="indexterm"></a>因为比较包括所有字符。要创建更健壮的<em class="filename">makefile</em>，请使用以下
        <code class="function">strip</code>函数：</p><p>Even so, it often occurs that a variable expansion contains
        unexpected whitespace. This can cause problems <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>since the comparison includes all characters. To create
        more robust <em class="filename">makefile</em>s, use the
        <code class="function">strip</code> function:</p><a id="OEBPS/ch03s07.html.I_3_tt155"></a><pre class="programlisting">ifeq "$(strip $(OPTIONS))" "-d"
  编译标志 += -DDEBUG
万一</pre><pre class="programlisting">ifeq "$(strip $(OPTIONS))" "-d"
  COMPILATION_FLAGS += -DDEBUG
endif</pre><div class="sect2" title="包含指令"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch03s07.html.make3-CHP-3-SECT-7.1"></a>包含指令</h2><h2 class="title"><a></a>The include Directive</h2></div></div></div><p>我们首先看到的是<code class="literal">include</code>
          <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1114" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1115" class="indexterm"></a>指令<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>第<a class="link" href="#OEBPS/ch02s07.html" title="自动依赖生成">2.7 节</a>。现在让我们更详细地讨论一下。</p><p>We first saw the <code class="literal">include</code>
          <a class="indexterm"></a> <a class="indexterm"></a>directive in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter
          2</a>, in <a class="link" href="#OEBPS/ch02s07.html" title="Automatic Dependency Generation">Section 2.7</a>.
          Now let's go over it in more detail.</p><p><em class="filename">生成文件</em>可以包含其他文件。最常见的做法是将通用<em class="command">make</em>定义放入<em class="command">make</em>头文件中或包含自动生成的依赖关系信息。该<code class="literal">include</code>指令的使用方式如下：</p><p>A <em class="filename">makefile</em> can include
          other files. This is most commonly done to place common <em class="command">make</em> definitions in a <em class="command">make</em> header file or to include
          automatically generated dependency information. The <code class="literal">include</code> directive is used like
          this:</p><a id="OEBPS/ch03s07.html.I_3_tt156"></a><pre class="programlisting">包括定义.mk</pre><pre class="programlisting">include definitions.mk</pre><p>该指令可以给定任意数量的文件和 shell 通配符，并且也允许使用<em class="command">make变量。</em></p><p>The directive can be given any number of files and shell
          wildcards and <em class="command">make</em> variables are
          also allowed.</p></div><div class="sect2" title="包含和依赖关系"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch03s07.html.make3-CHP-3-SECT-7.2"></a>包含和依赖关系</h2><h2 class="title"><a></a>include and Dependencies</h2></div></div></div><p>当<em class="command">遇到</em>一个
          <code class="literal">include</code> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1116" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1117" class="indexterm"></a> <a id="OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118" class="indexterm"></a>指令，它扩展通配符和变量引用，然后尝试读取包含文件。如果该文件存在，我们将正常继续。但是，如果该文件不存在，<em class="command">make会报告该问题并继续读取</em><em class="filename">makefile</em>的其余部分。当所有读取完成后，
           <em class="command">make</em>在规则数据库中查找任何规则来更新包含文件。如果找到匹配项，
           <em class="command">make</em>将遵循更新目标的正常过程。如果任何包含文件被规则更新，则<em class="command">make</em>会清除其内部数据库并重新读取整个<em class="filename">makefile</em>。如果在完成读取、更新和重读过程后，仍然有
          <code class="literal">include</code>指令因丢失文件而失败，<em class="command">则 make</em>
          将终止并显示错误状态。</p><p>When <em class="command">make</em> encounters an
          <code class="literal">include</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> directive, it expands the wildcards and variable
          references, then tries to read the include file. If the file exists,
          we continue normally. If the file does not exist, however, <em class="command">make</em> reports the problem and continues
          reading the rest of the <em class="filename">makefile</em>. When all reading is complete,
          <em class="command">make</em> looks in the rules database
          for any rule to update the include files. If a match is found,
          <em class="command">make</em> follows the normal process
          for updating a target. If any of the include files is updated by a
          rule, <em class="command">make</em> then clears its
          internal database and rereads the entire <em class="filename">makefile</em>. If, after completing the
          process of reading, updating, and rereading, there are still
          <code class="literal">include</code> directives that have
          failed due to missing files, <em class="command">make</em>
          terminates with an error status.</p><p>我们可以通过以下两个文件的示例来查看此过程的实际情况。我们使用<code class="function">warning</code>
          内置函数从<em class="command">make</em>打印一条简单的消息。 （这个函数和其他函数将在<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>中详细介绍。）这是<em class="filename">makefile</em>：</p><p>We can see this process in action with the following two-file
          example. We use the <code class="function">warning</code>
          built-in function to print a simple message from <em class="command">make</em>. (This and other functions are
          covered in detail in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>.)
          Here is the <em class="filename">makefile</em>:</p><a id="OEBPS/ch03s07.html.I_3_tt157"></a><pre class="programlisting"># 简单的 makefile 包括生成的文件。
包括 foo.mk
$(警告已完成包括)

foo.mk: 酒吧.mk
        m4 --define=FILENAME=$@ bar.mk &gt; $@</pre><pre class="programlisting"># Simple makefile including a generated file.
include foo.mk
$(warning Finished include)

foo.mk: bar.mk
        m4 --define=FILENAME=$@ bar.mk &gt; $@</pre><p>这是<em class="filename">bar.mk</em>，包含文件的源代码：</p><p>and here is <em class="filename">bar.mk</em>, the
          source for the included file:</p><a id="OEBPS/ch03s07.html.I_3_tt158"></a><pre class="programlisting"># bar.mk - 当我被阅读时报告。
$(警告读取文件名)</pre><pre class="programlisting"># bar.mk - Report when I am being read.
$(warning Reading FILENAME)</pre><p>运行时，我们看到：</p><p>When run, we see:</p><a id="OEBPS/ch03s07.html.I_3_tt159"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Makefile:2: foo.mk: 没有这样的文件或目录
Makefile:3: 完成包含
m4 --define=FILENAME=foo.mk bar.mk &gt; foo.mk
foo.mk:2: 读取 foo.mk
Makefile:3: 完成包含
make: `foo.mk' 是最新的。</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Makefile:2: foo.mk: No such file or directory
Makefile:3: Finished include
m4 --define=FILENAME=foo.mk bar.mk &gt; foo.mk
foo.mk:2: Reading foo.mk
Makefile:3: Finished include
make: `foo.mk' is up to date.</pre><p>第一行显示<em class="command">make</em>找不到包含文件，但第二行显示<em class="command">make</em>不断读取并执行<em class="filename">makefile</em>。完成读取后，
           <em class="command">make</em>发现创建包含文件<em class="filename">foo.mk 的</em>规则，并执行此操作。然后<em class="command">make</em>再次开始整个过程​​，这次读取包含文件不会遇到任何困难。</p><p>The first line shows that <em class="command">make</em> cannot find the include file, but the
          second line shows that <em class="command">make</em> keeps
          reading and executing the <em class="filename">makefile</em>. After completing the read,
          <em class="command">make</em> discovers a rule to create
          the include file, <em class="filename">foo.mk</em>, and
          it does so. Then <em class="command">make</em> starts the
          whole process again, this time without encountering any difficulty
          reading the include file.</p><p>现在是时候提及<em class="command">make</em>还将把<em class="filename">makefile</em>本身视为可能的目标。读取整个<em class="filename">makefile后， </em><em class="command">make</em>将查找规则来重新生成当前正在执行的<em class="filename">makefile</em>。如果找到，<em class="command">make</em>将处理该规则，然后检查<em class="filename">makefile</em>是否已更新。如果是这样，<em class="command">make</em>将清除其内部状态并重新读取<em class="filename">makefile</em>，重新执行整个分析。这是一个基于这种行为的无限循环的愚蠢示例：</p><p>Now is a good time to mention that <em class="command">make</em> will also treat the <em class="filename">makefile</em> itself as a possible target.
          After the entire <em class="filename">makefile</em> has
          been read, <em class="command">make</em> will look for a
          rule to remake the currently executing <em class="filename">makefile</em>. If it finds one, <em class="command">make</em> will process the rule, then check if
          the <em class="filename">makefile</em> has been updated.
          If so, <em class="command">make</em> will clear its
          internal state and reread the <em class="filename">makefile</em>, performing the whole analysis
          over again. Here is a silly example of an infinite loop based on
          this behavior:</p><a id="OEBPS/ch03s07.html.I_3_tt160"></a><pre class="programlisting">.PHONY：假人
makefile：虚拟
        触摸$@</pre><pre class="programlisting">.PHONY: dummy
makefile: dummy
        touch $@</pre><p>当<em class="command">make</em>执行此
          <em class="filename">makefile</em>时，它​​发现
          <em class="filename">makefile</em>已过期（因为<code class="literal">.PHONY</code>目标
          <em class="filename">dummy</em>已过期），因此它执行<em class="command">touch命令，该命令更新</em><em class="filename">makefile</em>的时间戳。然后<em class="command">make</em>重新读取该文件，发现<em class="filename">makefile</em>已经过期。 。 。 。反正你懂这个意思。</p><p>When <em class="command">make</em> executes this
          <em class="filename">makefile</em>, it sees that the
          <em class="filename">makefile</em> is out of date
          (because the <code class="literal">.PHONY</code> target,
          <em class="filename">dummy</em>, is out of date) so it
          executes the <em class="command">touch</em> command, which
          updates the timestamp of the <em class="filename">makefile</em>. Then <em class="command">make</em> rereads the file and discovers that
          the <em class="filename">makefile</em> is out of date. .
          . . Well, you get the idea.</p><p><em class="command">make</em>在哪里查找包含的文件？显然，如果 的参数<code class="literal">include</code>是绝对文件引用，
          <em class="command">则 make</em>读取该文件。如果文件引用是相对的，则<em class="command">make</em>首先查找其当前工作目录。如果<em class="command">make</em>找不到该文件，它将继续搜索您使用<code class="option">—include-dir</code>(或
          <code class="option">-I</code>) 选项在命令行上指定的任何目录。之后，<em class="command">make</em>搜索类似于以下的已编译搜索路径：<em class="filename">/usr/local/include</em>、
           <em class="filename">/usr/gnu/include</em>、<em class="filename">/usr/include</em>。由于<em class="command">make 的</em>编译方式不同，该路径可能会略有不同。</p><p>Where does <em class="command">make</em> look for
          included files? Clearly, if the argument to <code class="literal">include</code> is an absolute file reference,
          <em class="command">make</em> reads that file. If the file
          reference is relative, <em class="command">make</em> first
          looks in its current working directory. If <em class="command">make</em> cannot find the file, it then
          proceeds to search through any directories you have specified on the
          command line using the <code class="option">—include-dir</code> (or
          <code class="option">-I</code>) option. After that, <em class="command">make</em> searches a compiled search path
          similar to: <em class="filename">/usr/local/include</em>,
          <em class="filename">/usr/gnu/include</em>, <em class="filename">/usr/include</em>. There may be slight
          variations of this path due to the way <em class="command">make</em> was compiled.</p><p>如果<em class="command">make</em>找不到包含文件并且无法使用规则创建它，<em class="command">则 make</em>将退出并出现错误。如果您希望
          <em class="command">make</em>忽略它无法加载的包含文件，请在<code class="literal">include</code>指令中添加一个前导破折号：</p><p>If <em class="command">make</em> cannot find the
          include file and it cannot create it using a rule, <em class="command">make</em> exits with an error. If you want
          <em class="command">make</em> to ignore include files it
          cannot load, add a leading dash to the <code class="literal">include</code> directive:</p><a id="OEBPS/ch03s07.html.I_3_tt161"></a><pre class="programlisting">-包括我可能不存在.mk</pre><pre class="programlisting">-include i-may-not-exist.mk</pre><p>为了与其他<em class="command">make</em>兼容，该词<code class="literal">sinclude</code>是 的别名<code class="literal">-include</code>。</p><p>For compatibility with other <em class="command">make</em>s, the word <code class="literal">sinclude</code> is an alias for <code class="literal">-include</code>.</p><p>值得注意的是，在 makefile 中的第一个目标之前使用 include 指令可能会更改默认目标。也就是说，如果包含文件包含任何目标，那么第一个目标将成为 makefile 的默认目标。只需将所需的默认目标放在包含之前即可避免这种情况（即使没有先决条件或目标）：</p><p>It is worth noting that using an include directive before the
          first target in a makefile might change the default goal. That is,
          if the include file contains any targets at all the first of those
          targets will become the default goal for the makefile. This can be
          avoided by simply placing the desired default goal before the
          include (even without prerequisites or targets): </p><a id="OEBPS/ch03s07.html.I_programlisting3_d1e7699"></a><pre class="programlisting"># 确保全部是默认目标。
全部：
包括支持.mk
# 现在我们已经定义了变量，完成 all 目标。
全部：$（程序）</pre><pre class="programlisting"># Ensure all is the default goal.
all:
include support.mk
# Now that we have our variables defined, complete the all target.
all: $(programs)</pre></div></div></div></div>
<div id="OEBPS/ch03s08.html"><div>
<div class="sect1" title="标准 make 变量"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch03s08.html.make3-CHP-3-SECT-8"></a>标准 make 变量</h1><h1 class="title"><a></a>Standard make Variables</h1></div></div></div><p>除了自动变量之外，<em class="command">make</em>还维护一些揭示其自身状态的变量以及用于定制内置规则的变量：</p><p>In addition to automatic variables, <em class="command">make</em> maintains variables revealing bits and
        pieces of its own state as well as variables for customizing built-in
        rules:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">MAKE_VERSION</code> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1119" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120" class="indexterm"></a></span></dt><dt><span class="term"><code class="literal">MAKE_VERSION</code> <a class="indexterm"></a> <a class="indexterm"></a></span></dt><dd><p>这是版本<a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1122" class="indexterm"></a><acronym class="acronym">GNU </acronym> <em class="command">make</em>的数量。在撰写本文时，其值为<code class="literal">3.80</code>，CVS 存储库中的值为<code class="literal">3.81rc1</code>。</p><p>之前版本的<em class="command">make</em> 3.79.1 不支持
              <code class="function">eval</code>和<code class="function">value</code>函数（以及其他更改），但它仍然很常见。因此，当我编写需要这些功能的<em class="filename">makefile</em>时，我使用此变量来测试我正在运行的<em class="command">make</em>版本。我们将在<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>的<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4" title="流量控制">4.2.4 节</a>中看到一个例子。<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a></p></dd><dd><p>This is the version <a class="indexterm"></a> <a class="indexterm"></a>number of <acronym class="acronym">GNU</acronym> <em class="command">make</em>. At the time of this writing, its
              value is <code class="literal">3.80</code>, and the value
              in the CVS repository is <code class="literal">3.81rc1</code>.</p><p>The previous version of <em class="command">make</em>, 3.79.1, did not support the
              <code class="function">eval</code> and <code class="function">value</code> functions (among other changes)
              and it is still very common. So when I write <em class="filename">makefile</em>s that require these
              features, I use this variable to test the version of <em class="command">make</em> I'm running. We'll see an example
              of that in <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4" title="Flow Control">Section
              4.2.4</a> in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter
              4</a>.</p></dd><dt><span class="term"><code class="literal">CURDIR</code> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1123" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124" class="indexterm"></a></span></dt><dt><span class="term"><code class="literal">CURDIR</code> <a class="indexterm"></a> <a class="indexterm"></a></span></dt><dd><p>该变量包含当前<a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1125" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1127" class="indexterm"></a><em class="command">执行make</em>进程的工作目录 (cwd) 。这将与执行<em class="command">make</em>程序的目录相同（并且与 shell 变量相同
              <code class="literal">PWD</code>），除非
              使用<code class="option">—directory</code>( ) 选项。<code class="option">-C</code>该<code class="option">—directory</code>选项指示<em class="command">make</em>在搜索任何<em class="filename">makefile</em>之前更改到不同的目录。该选项的完整形式是<code class="option">—directory=</code>
              <em class="replaceable"><code>directory-name</code></em>or <code class="option">-C
              </code> <em class="replaceable"><code>directory-name</code></em>。如果
              <code class="option">—directory</code>使用，<code class="literal">CURDIR</code>将包含 的目录参数<code class="option">—include-dir</code>。</p><p>我通常在编码时
              从<em class="command">emacs调用</em><em class="command">make</em> 。例如，我当前的项目是用 Java 编写的，并
              在顶级目录（不一定是包含代码的目录）中使用单个<em class="filename">makefile</em> 。在这种情况下，使用该选项允许我从源树中的任何目录调用<em class="command">make并仍然访问</em><em class="filename">makefile</em>。在<em class="filename">makefile</em>中，所有路径都相对于<em class="filename">makefile</em>目录。有时需要绝对路径，并且可以使用.<em class="command"></em><em class="filename"></em><code class="option">—directory</code><em class="command"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><code class="literal">CURDIR</code></p></dd><dd><p>This variable contains the current <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>working directory (cwd) of the executing <em class="command">make</em> process. This will be the same
              directory the <em class="command">make</em> program
              was executed from (and it will be the same as the shell variable
              <code class="literal">PWD</code>), unless the
              <code class="option">—directory</code> (<code class="option">-C</code>) option is
              used. The <code class="option">—directory</code> option instructs <em class="command">make</em> to change to a different
              directory before searching for any <em class="filename">makefile</em>. The complete form of the
              option is <code class="option">—directory=</code>
              <em class="replaceable"><code>directory-name</code></em> or <code class="option">-C
              </code> <em class="replaceable"><code>directory-name</code></em>. If
              <code class="option">—directory</code> is used, <code class="literal">CURDIR</code> will contain the directory
              argument to <code class="option">—include-dir</code>.</p><p>I typically invoke <em class="command">make</em>
              from <em class="command">emacs</em> while coding. For
              instance, my current project is in Java and uses a single
              <em class="filename">makefile</em> in a top-level
              directory (not necessarily the directory containing the code).
              In this case, using the <code class="option">—directory</code> option
              allows me to invoke <em class="command">make</em> from
              any directory in the source tree and still access the <em class="filename">makefile</em>. Within the <em class="filename">makefile</em>, all paths are relative to
              the <em class="filename">makefile</em> directory.
              Absolute paths are occasionally required and these are accessed
              using <code class="literal">CURDIR</code>.</p></dd><dt><span class="term"><code class="literal">MAKEFILE_LIST</code> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1128" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129" class="indexterm"></a></span></dt><dt><span class="term"><code class="literal">MAKEFILE_LIST</code> <a class="indexterm"></a> <a class="indexterm"></a></span></dt><dd><p>该变量包含<a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1130" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131" class="indexterm"></a><em class="command">make</em>已读取的每个文件的列表，包括默认
              <em class="filename">makefile</em>和在命令行或通过指令指定的<em class="filename">makefile</em><code class="literal">include</code> 
              。在读取每个文件之前，名称会附加到<code class="literal">MAKEFILE_LIST</code>
              变量中。因此，<em class="filename">makefile</em>始终可以通过检查列表的最后一个单词来确定自己的名称。</p></dd><dd><p>This variable contains <a class="indexterm"></a> <a class="indexterm"></a>a list of each file <em class="command">make</em> has read including the default
              <em class="filename">makefile</em> and <em class="filename">makefile</em>s specified on the command
              line or through <code class="literal">include</code>
              directives. Just before each file is read, the name is appended
              to the <code class="literal">MAKEFILE_LIST</code>
              variable. So a <em class="filename">makefile</em> can
              always determine its own name by examining the last word of the
              list.</p></dd><dt><span class="term"><code class="literal">MAKECMDGOALS</code> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1132" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133" class="indexterm"></a></span></dt><dt><span class="term"><code class="literal">MAKECMDGOALS</code> <a class="indexterm"></a> <a class="indexterm"></a></span></dt><dd><p>变量<code class="literal">MAKECMDGOALS</code>
              ​<a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1135" class="indexterm"></a><em class="command">包含在命令行上指定的当前执行make</em>的所有目标的列表。它不包括命令行选项或变量分配。例如：</p><a id="OEBPS/ch03s08.html.I_3_tt162"></a><pre class="programlisting">$ make -f- FOO=bar -k goal &lt;&lt;&lt; '目标:;# $(MAKECMDGOALS)'
＃ 目标</pre><p>该示例使用“技巧”告诉<em class="command">make</em>使用
              (或)选项从<em class="filename">标准输入</em>读取<em class="filename">makefile</em>。使用<em class="command">bash</em>的<em class="firstterm">此处字符串</em>“&lt;&lt;&lt;”语法从命令行字符串重定向<em class="filename">标准</em>输入。 <sup>[ </sup><sup><a id="OEBPS/ch03s08.html.make3-CHP-3-FNOTE-3" href="#OEBPS/ch03s08.html.ftn.make3-CHP-3-FNOTE-3" class="footnote">3</a></sup><sup> ]</sup> makefile
              本身包含默认目标，而命令脚本则在同一行给出<em class="filename">，</em>用分号分隔目标和命令。命令脚本包含一行：<em class="filename"></em><code class="option">-f-</code><code class="option">—file</code><em class="filename"></em><em class="command"></em><em class="firstterm"></em><sup><a id="OEBPS/ch03s08.html.make3-CHP-3-FNOTE-3" href="#OEBPS/ch03s08.html.ftn.make3-CHP-3-FNOTE-3" class="footnote"></a></sup><em class="filename"></em><code class="literal">goal</code></p><a id="OEBPS/ch03s08.html.I_3_tt163"></a><pre class="programlisting"># $(MAKECMD目标)</pre><p><code class="literal">MAKECMDGOALS</code>通常在目标需要特殊处理时使用。主要的例子是“干净”目标。当调用“clean”时，
               <em class="command">make</em>不应执行通常触发的依赖文件生成<code class="literal">include</code>（在第<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">2 章的</a><a class="link" href="#OEBPS/ch02s07.html" title="自动依赖生成">2.7 节</a>中讨论）。为了防止这种使用
              ，并且：<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a><code class="literal">ifneq</code><code class="literal">MAKECMDGOALS</code></p><a id="OEBPS/ch03s08.html.I_3_tt164"></a><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "干净"
  -包括 $(subst .xml,.d,$(xml_src))
万一</pre></dd><dd><p>The <code class="literal">MAKECMDGOALS</code>
              variable <a class="indexterm"></a> <a class="indexterm"></a>contains a list of all the targets specified on
              the command line for the current execution of <em class="command">make</em>. It does not include command-line
              options or variable assignments. For instance:</p><a></a><pre class="programlisting">$ make -f- FOO=bar -k goal &lt;&lt;&lt; 'goal:;# $(MAKECMDGOALS)'
# goal</pre><p>The example uses the "trick" of telling <em class="command">make</em> to read the <em class="filename">makefile</em> from the <em class="filename">stdin</em> with the <code class="option">-f-</code>
              (or <code class="option">—file</code>) option. The <em class="filename">stdin</em> is redirected from a
              command-line string using <em class="command">bash</em>'s <em class="firstterm">here
              string</em>, "&lt;&lt;&lt;", syntax.<sup>[<a href="#OEBPS/ch03s08.html.ftn.make3-CHP-3-FNOTE-3" class="footnote">3</a>]</sup> The <em class="filename">makefile</em>
              itself consists of the default goal <code class="literal">goal</code>, while the command script is
              given on the same line by separating the target from the command
              with a semicolon. The command script contains the single
              line:</p><a></a><pre class="programlisting"># $(MAKECMDGOALS)</pre><p><code class="literal">MAKECMDGOALS</code> is
              typically used when a target requires special handling. The
              primary example is the "clean" target. When invoking "clean,"
              <em class="command">make</em> should not perform the
              usual dependency file generation triggered by <code class="literal">include</code> (discussed in <a class="link" href="#OEBPS/ch02s07.html" title="Automatic Dependency Generation">Section 2.7</a> in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>). To prevent this use
              <code class="literal">ifneq</code> and <code class="literal">MAKECMDGOALS</code>:</p><a></a><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "clean"
  -include $(subst .xml,.d,$(xml_src))
endif</pre></dd><dt><span class="term"><code class="literal">.VARIABLES</code> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1136" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137" class="indexterm"></a></span></dt><dt><span class="term"><code class="literal">.VARIABLES</code> <a class="indexterm"></a> <a class="indexterm"></a></span></dt><dd><p>这包含一个列表<a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1138" class="indexterm"></a> <a id="OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139" class="indexterm"></a><em class="filename">到目前为止读取的makefile</em>中定义的所有变量的名称
              ，特定于目标的变量除外。该变量是只读的，对其进行的任何赋值都将被忽略。</p><a id="OEBPS/ch03s08.html.I_3_tt165"></a><pre class="programlisting">列表：
        @echo "$(.VARIABLES)" | tr ' ' '\015' | grep MAKEF
$ 制作
制作标志
MAKEFILE_列表
生成文件</pre></dd><dd><p>This contains a list <a class="indexterm"></a> <a class="indexterm"></a>of the names of all the variables defined in
              <em class="filename">makefile</em>s read so far, with
              the exception of target-specific variables. The variable is
              read-only and any assignment to it is ignored.</p><a></a><pre class="programlisting">list:
        @echo "$(.VARIABLES)" | tr ' ' '\015' | grep MAKEF
$ make
MAKEFLAGS
MAKEFILE_LIST
MAKEFILES</pre></dd></dl></div><p>正如您所看到的，变量还用于自定义<em class="command">make</em>内置的隐式规则。 C/C++ 的规则是所有编程语言中这些变量所采用的典型形式。<a class="link" href="#OEBPS/ch03s08.html.make3-CHP-3-FIG-1" title="图 3-1。 C/C++ 编译的变量">图 3-1</a>显示了控制从一种文件类型到另一种文件类型的转换的变量。</p><p>As you've seen, variables are also used to customize the
        implicit rules built in to <em class="command">make</em>.
        The rules for C/C++ are typical of the form these variables take for
        all programming languages. <a class="link" href="#OEBPS/ch03s08.html.make3-CHP-3-FIG-1" title="Figure&nbsp;3-1.&nbsp;Variables for C/C++ compilation">Figure
        3-1</a> shows the variables controlling translation from one file
        type to another.</p><div class="figure"><a id="OEBPS/ch03s08.html.make3-CHP-3-FIG-1"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch03s08.html.I_3_tt166"></a><img src="data:image/png;base64,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" height="256" alt="C/C++ 编译的变量"></div></div><p class="title">图 3-1。 C/C++ 编译的变量</p><p class="title">Figure&nbsp;3-1.&nbsp;Variables for C/C++ compilation</p></div><p>变量具有基本形式：
         <em class="replaceable"><code>ACTION</code></em>。<em class="replaceable"><code>suffix</code></em>。用于创建目标文件、
        创建可执行文件或<em class="replaceable"><code>ACTION</code></em>“特殊”操作、、分别
        用于运行 C 预处理器<em class="command">yacc</em>或<em class="command">lex</em>。指示
        源文件类型。<code class="literal">COMPILE</code><code class="literal">LINK</code><code class="literal">PREPROCESS</code><code class="literal">YACC</code><code class="literal">LEX</code><em class="command"></em><em class="command"></em><em class="replaceable"><code>suffix</code></em></p><p>The variables have the basic form:
        <em class="replaceable"><code>ACTION</code></em>.<em class="replaceable"><code>suffix</code></em>.
        The <em class="replaceable"><code>ACTION</code></em> is <code class="literal">COMPILE</code> for creating an object file,
        <code class="literal">LINK</code> for creating an executable, or
        the "special" operations <code class="literal">PREPROCESS</code>, <code class="literal">YACC</code>, <code class="literal">LEX</code>
        for running the C preprocessor, <em class="command">yacc</em>, or <em class="command">lex</em>, respectively. The
        <em class="replaceable"><code>suffix</code></em> indicates the source file
        type.</p><p>例如，C++ 中通过这些变量的标准“路径”使用两个规则。首先，将 C++ 源文件编译为目标文件。然后将目标文件链接到可执行文件中。</p><p>The standard "path" through these variables for, say, C++, uses
        two rules. First, compile C++ source files to object files. Then link
        the object files into an executable.</p><a id="OEBPS/ch03s08.html.I_3_tt167"></a><pre class="programlisting">%.o: %.C
        $(COMPILE.C) $(OUTPUT_OPTION) $&lt;

%：%.o
        $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><pre class="programlisting">%.o: %.C
        $(COMPILE.C) $(OUTPUT_OPTION) $&lt;

%: %.o
        $(LINK.o) $^ $(LOADLIBES) $(LDLIBS) -o $@</pre><p>第一条规则使用这些变量定义：</p><p>The first rule uses these variable definitions:</p><a id="OEBPS/ch03s08.html.I_3_tt168"></a><pre class="programlisting">编译.C = $(编译.cc)
COMPILE.cc = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CXX = g++
输出选项 = -o $@</pre><pre class="programlisting">COMPILE.C     = $(COMPILE.cc)
COMPILE.cc    = $(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c
CXX           = g++
OUTPUT_OPTION = -o $@</pre><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>
        支持后缀<em class="filename">.C</em>或<em class="filename">.cc</em>来表示 C++ 源文件。该
        <code class="literal">CXX</code>变量指示要使用的 C++ 编译器，默认为<em class="command">g++</em>。变量<code class="literal">CXXFLAGS</code>、<code class="literal">CPPFLAGS</code>和<code class="literal">TARGET_ARCH</code>没有默认值。它们旨在供最终用户用来自定义构建过程。这三个变量分别保存 C++ 编译器标志、C 预处理器标志和特定于体系结构的编译选项。包含<code class="literal">OUTPUT_OPTION</code>输出文件选项。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
        supports either of the suffixes <em class="filename">.C</em> or <em class="filename">.cc</em> for denoting C++ source files. The
        <code class="literal">CXX</code> variable indicates the C++
        compiler to use and defaults to <em class="command">g++</em>. The variables <code class="literal">CXXFLAGS</code>, <code class="literal">CPPFLAGS</code>, and <code class="literal">TARGET_ARCH</code> have no default value. They are
        intended for use by end-users to customize the build process. The
        three variables hold the C++ compiler flags, C preprocessor flags, and
        architecture-specific compilation options, respectively. The <code class="literal">OUTPUT_OPTION</code> contains the output file
        option.</p><p>链接规则有点简单：</p><p>The linking rule is a bit simpler:</p><a id="OEBPS/ch03s08.html.I_3_tt169"></a><pre class="programlisting">LINK.o = $(CC) $(LDFLAGS) $(TARGET_ARCH)
CC = 海湾合作委员会</pre><pre class="programlisting">LINK.o = $(CC) $(LDFLAGS) $(TARGET_ARCH)
CC     = gcc</pre><p>该规则使用 C 编译器将目标文件组合成可执行文件。 C 编译器的默认值是<em class="command">gcc</em>。<code class="literal">LDFLAGS</code>并且<code class="literal">TARGET_ARCH</code>没有默认值。该
        <code class="literal">LDFLAGS</code>变量保存用于链接的选项，例如<code class="option">-L</code>标志。和<code class="literal">LOADLIBES</code>变量<code class="literal">LDLIBS</code>包含要链接的库列表。包含两个变量主要是为了可移植性。</p><p>This rule uses the C compiler to combine object files into an
        executable. The default for the C compiler is <em class="command">gcc</em>. <code class="literal">LDFLAGS</code> and <code class="literal">TARGET_ARCH</code> have no default value. The
        <code class="literal">LDFLAGS</code> variable holds options for
        linking such as <code class="option">-L</code> flags. The <code class="literal">LOADLIBES</code> and <code class="literal">LDLIBS</code> variables contain lists of libraries
        to link against. Two variables are included mostly for
        portability.</p><p><em class="command">这是对make</em>变量的快速浏览。还有更多，但这让您了解变量如何与规则集成。另一组变量与 TEX 相关并且有它自己的一组规则。递归<em class="command">make</em>是变量支持的另一个功能。我们将在<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>讨论这个主题。</p><p>This was a quick tour through the <em class="command">make</em> variables. There are more, but this
        gives you the flavor of how variables are integrated with rules.
        Another group of variables deals with TEX and has its own set of
        rules. Recursive <em class="command">make</em> is another
        feature supported by variables. We'll discuss this topic in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>.</p><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch03s08.html.ftn.make3-CHP-3-FNOTE-3" href="#OEBPS/ch03s08.html.make3-CHP-3-FNOTE-3" class="para">3</a> ]</sup>对于那些想要在另一个 shell 中运行此类示例的人，请使用：</p><p><sup>[<a href="#OEBPS/ch03s08.html.make3-CHP-3-FNOTE-3" class="para">3</a>] </sup>For those of you who want to run this type of example
                  in another shell, use:</p></div></div></div></div></div>
<div id="OEBPS/ch04.html"><div>
<div class="chapter" title="第 4 章函数"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch04.html.make3-CHP-4"></a>第 4 章函数</h1><h1 class="title"><a></a>Chapter&nbsp;4.&nbsp;Functions</h1></div></div></div><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>
      支持内置函数和用户定义函数。函数调用看起来很像变量引用，但包含一个或多个用逗号分隔的参数。大多数内置函数都会扩展为某个值，然后将其分配给变量或传递给子 shell。用户定义的函数存储在变量或宏中，并期望调用者传递一个或多个参数。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
      supports both built-in and user-defined functions. A function invocation
      looks much like a variable reference, but includes one or more
      parameters separated by commas. Most built-in functions expand to some
      value that is then assigned to a variable or passed to a subshell. A
      user-defined function is stored in a variable or macro and expects one
      or more parameters to be passed by the caller.</p><div class="sect1" title="用户定义函数"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch04.html.make3-CHP-4-SECT-1"></a>用户定义函数</h1><h1 class="title"><a></a>User-Defined Functions</h1></div></div></div><p>将命令序列存储在<a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1140" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1141" class="indexterm"></a>变量打开了广泛应用的大门。例如，这是一个很好的小宏来终止进程：<sup>[ <a id="OEBPS/ch04.html.make3-CHP-4-FNOTE-1" href="#OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-1" class="footnote">1</a> ]</sup></p><p>Storing command sequences in<a class="indexterm"></a> <a class="indexterm"></a> variables opens the door to a wide range of
        applications. For instance, here's a nice little macro to kill a
        process:<sup>[<a href="#OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-1" class="footnote">1</a>]</sup></p><a id="OEBPS/ch04.html.I_4_tt170"></a><pre class="programlisting">AWK := awk
杀死 := 杀死

# $(kill-acroread)
定义kill-acroread
  @ ps -W | \
  $(AWK) '开始 { FieldWIDTHS = "9 47 100" } \
          /AcroRd32/ { \
                       打印“杀死”$$3； \
                       系统(“$(KILL)-f”$$1)\
                     }'
恩德夫</pre><pre class="programlisting">AWK  := awk
KILL := kill

# $(kill-acroread)
define kill-acroread
  @ ps -W |                                           \
  $(AWK) 'BEGIN      { FIELDWIDTHS = "9 47 100" }     \
          /AcroRd32/ {                                \
                       print "Killing " $$3;          \
                       system( "$(KILL) -f " $$1 )    \
                     }'
endef</pre><p>（这个宏是这样写的<a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1142" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1143" class="indexterm"></a>明确使用 Cygwin 工具，<sup>[ <a id="OEBPS/ch04.html.make3-CHP-4-FNOTE-2" href="#OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-2" class="footnote">2</a> ]因此我们搜索的程序名称以及</sup><em class="command">ps</em>和<em class="command">kill</em>的选项
        不是标准 Unix。）为了终止进程，我们将<em class="command">ps</em>的输出通过管道传输到
        <em class="command">awk</em>。 awk脚本通过 Windows 程序名称查找 Acrobat Reader，并在该进程正在运行时终止该进程<em class="command">。</em>我们使用该<code class="literal">FIELDWIDTHS</code>功能将程序名称及其所有参数视为单个字段。即使其中包含嵌入的空格，这也会正确打印完整的程序名称和参数。<em class="command">awk</em>中的字段引用被写为<code class="literal">$1</code>,等。
        如果我们不以某种方式引用它们，<code class="literal">$2</code>它们将被视为<em class="command">make</em>变量。我们可以告诉<em class="command">make</em>将<code class="literal">$</code> <em class="replaceable"><code>n</code></em>引用传递给
        <em class="command">awk，</em><code class="literal">$</code>
        <em class="replaceable"><code>n</code></em>而不是通过使用额外的美元符号 转义美元符号来扩展它本身<code class="literal">$$</code> <em class="replaceable"><code>n</code></em>。<em class="command">make</em>将看到双美元符号，将其折叠为单个美元符号并将其传递给子 shell。</p><p>(This macro was written <a class="indexterm"></a> <a class="indexterm"></a>explicitly to use the Cygwin tools,<sup>[<a href="#OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-2" class="footnote">2</a>]</sup> so the program name we search for and the options to
        <em class="command">ps</em> and <em class="command">kill</em> are not standard Unix.) To kill a
        process we pipe the output of <em class="command">ps</em> to
        <em class="command">awk</em>. The <em class="command">awk</em> script looks for the Acrobat Reader by
        its Windows program name and kills the process if it is running. We
        use the <code class="literal">FIELDWIDTHS</code> feature to
        treat the program name and all its arguments as a single field. This
        correctly prints the complete program name and arguments even when it
        contains embedded blanks. Field references in <em class="command">awk</em> are written as <code class="literal">$1</code>, <code class="literal">$2</code>,
        etc. These would be treated as <em class="command">make</em>
        variables if we did not quote them in some way. We can tell <em class="command">make</em> to pass the <code class="literal">$</code> <em class="replaceable"><code>n</code></em> reference to
        <em class="command">awk</em> instead of expanding it itself
        by escaping the dollar sign in <code class="literal">$</code>
        <em class="replaceable"><code>n</code></em> with an additional dollar sign, <code class="literal">$$</code> <em class="replaceable"><code>n</code></em>. <em class="command">make</em> will see the double dollar sign,
        collapse it to a single dollar sign and pass it to the
        subshell.</p><p>不错的宏观。如果我们想经常使用该指令，则<code class="literal">define</code>
        可以避免重复代码。但它并不完美。如果我们想终止 Acrobat Reader 以外的进程怎么办？我们是否必须定义另一个宏并复制脚本？不！</p><p>Nice macro. And the <code class="literal">define</code>
        directive saves us from duplicating the code if we want to use it
        often. But it isn't perfect. What if we want to kill processes other
        than the Acrobat Reader? Do we have to define another macro and
        duplicate the script? No!</p><p>可以传递变量和宏<a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1145" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1146" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1147" class="indexterm"></a>参数，以便每个扩展都可以不同。宏的参数在宏定义体内用 、 等引用<code class="literal">$1</code>。<code class="literal">$2</code>要参数化我们的<code class="function">kill-acroread</code>函数，我们只需要添加一个搜索参数：</p><p>Variables and macros can be passed <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>arguments so that each expansion can be different. The
        parameters of the macro are referenced within the body of the macro
        definition with <code class="literal">$1</code>, <code class="literal">$2</code>, etc. To parameterize our <code class="function">kill-acroread</code> function, we only need to add
        a search parameter:</p><a id="OEBPS/ch04.html.I_4_tt171"></a><pre class="programlisting">AWK := awk
杀死 := 杀死
KILL_FLAGS := -f
PS := PS
PS_FLAGS := -W
PS_FIELDS := "9 47 100"

# $(调用kill-program,awk-pattern)
定义终止程序
  @ $(PS) $(PS_FLAGS) | \
  $(AWK) '开始 { FieldWIDTHS = $(PS_FIELDS) } \
          /$1/ { \
                  打印“杀死”$$3； \
                  系统(“$(KILL)$(KILL_FLAGS)”$$1)\
                }'
恩德夫</pre><pre class="programlisting">AWK        := awk
KILL       := kill
KILL_FLAGS := -f
PS         := ps
PS_FLAGS   := -W
PS_FIELDS  := "9 47 100"

# $(call kill-program,awk-pattern)
define kill-program
  @ $(PS) $(PS_FLAGS) |                                  \
  $(AWK) 'BEGIN { FIELDWIDTHS = $(PS_FIELDS) }           \
          /$1/  {                                        \
                  print "Killing " $$3;                  \
                  system( "$(KILL) $(KILL_FLAGS) " $$1 ) \
                }'
endef</pre><p>我们已将<em class="command">awk</em>搜索模式替换<code class="literal">/AcroRd32/</code>为参数引用<code class="literal">$1</code>。请注意宏参数<code class="literal">$1</code>和<em class="command">awk</em>字段引用之间的细微区别<code class="literal">$$1</code>。记住哪个程序是变量引用的预期接收者非常重要。只要我们改进该函数，我们也会对其进行适当的重命名，并用变量替换特定于 Cygwin 的硬编码值。现在我们有一个相当可移植的宏来终止进程。</p><p>We've replaced the <em class="command">awk</em> search
        pattern, <code class="literal">/AcroRd32/</code>, with a
        parameter reference, <code class="literal">$1</code>. Note the
        subtle distinction between the macro parameter, <code class="literal">$1</code>, and the <em class="command">awk</em> field reference, <code class="literal">$$1</code>. It is very important to remember which
        program is the intended recipient for a variable reference. As long as
        we're improving the function, we have also renamed it appropriately
        and replaced the Cygwin-specific, hardcoded values with variables. Now
        we have a reasonably portable macro for terminating processes.</p><p>让我们看看它的实际效果：</p><p>So let's see it in action:</p><a id="OEBPS/ch04.html.I_4_tt172"></a><pre class="programlisting">FOP := org.apache.fop.apps.Fop
FOP_FLAGS := -q
FOP_OUTPUT := &gt; /dev/null
%.pdf: %.fo
        $(调用终止程序,AcroRd32)
        $(JAVA) $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)</pre><pre class="programlisting">FOP        := org.apache.fop.apps.Fop
FOP_FLAGS  := -q
FOP_OUTPUT := &gt; /dev/null
%.pdf: %.fo
        $(call kill-program,AcroRd32)
        $(JAVA) $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)</pre><p>此模式规则会终止<span class="emphasis"><em>Acrobat</em></span>
        进程（如果正在运行），然后通过调用处理器 ( <a class="ulink" href="http://xml.apache.org/fop">http://xml.apache.org/fop ) 将</a><em class="filename">fo</em>（格式化对象）文件转换为
        <em class="filename">pdf</em>文件。扩展变量或宏的语法是：<code class="literal">Fop</code><a class="ulink" href="http://xml.apache.org/fop"></a></p><p>This pattern rule kills the <span class="emphasis"><em>Acrobat</em></span>
        process, if one is running, and then converts an <em class="filename">fo</em> (Formatting Objects) file into a
        <em class="filename">pdf</em> file by invoking the <code class="literal">Fop</code> processor (<a class="ulink" href="http://xml.apache.org/fop">http://xml.apache.org/fop</a>). The syntax for expanding a
        variable or macro is:</p><a id="OEBPS/ch04.html.I_4_tt173"></a><pre class="programlisting">$(调用宏名称[, 参数<sub>1</sub> . . . ])</pre><pre class="programlisting">$(call macro-name[, param<sub>1</sub> . . . ])</pre><p><code class="function">call</code>是一个内置<em class="command">make</em>函数，它扩展其第一个参数并用给出的其余参数替换出现的 、 等<code class="literal">$1</code>。<code class="literal">$2</code>（事实上​​，从控制转移的意义上来说，它根本没有真正“调用”它的宏参数，而是执行一种特殊类型的宏扩展。） 是
        <code class="option">macro-name</code>任何宏或变量的名称（请记住，宏是只是允许嵌入换行符的变量）。宏或变量值甚至不必包含
        引用，但使用起来根本<code class="literal">$</code> <em class="replaceable"><code>n</code></em>
        没有多大意义。<code class="function">call</code>宏后面的参数<code class="option">macro-name</code>用逗号分隔。</p><p><code class="function">call</code> is a built-in <em class="command">make</em> function that expands its first
        argument and replaces occurrences of <code class="literal">$1</code>, <code class="literal">$2</code>,
        etc., with the remaining arguments it is given. (In fact, it doesn't
        really "call" its macro argument at all in the sense of transfer of
        control, rather it performs a special kind of macro expansion.) The
        <code class="option">macro-name</code> is the name of any macro or variable
        (remember that macros are just variables where embedded newlines are
        allowed). The macro or variable value doesn't even have to contain a
        <code class="literal">$</code> <em class="replaceable"><code>n</code></em>
        reference, but then there isn't much point in using <code class="function">call</code> at all. Arguments to the macro
        following <code class="option">macro-name</code> are separated by commas.</p><p>请注意，第一个参数<code class="function">call</code>是未扩展的变量名称（即，它不以美元符号开头）。这是相当不寻常的。只有另外一个内置函数<code class="function">origin</code>接受未扩展的变量。如果将第一个参数 括<code class="literal">call</code>在美元符号和括号中，则该参数将扩展为变量，并将其值传递给<code class="literal">call</code>。</p><p>Notice that the first argument to <code class="function">call</code> is an unexpanded variable name (that
        is, it does not begin with a dollar sign). That is fairly unusual.
        Only one other built-in function, <code class="function">origin</code>, accepts unexpanded variables. If
        you enclose the first argument to <code class="literal">call</code> in a dollar sign and parentheses, that
        argument is expanded as a variable and its value is passed to <code class="literal">call</code>.</p><p>使用 进行参数检查的方式很少
        <code class="function">call</code>。可以向 赋予任意数量的参数<code class="function">call</code>。如果宏引用参数<code class="literal">$</code>
        <em class="replaceable"><code>n</code></em>并且实例中没有相应的参数<code class="function">call</code>，则该变量将崩溃为空。如果实例中的参数多于<code class="function">call</code>引用<code class="literal">$</code> <em class="replaceable"><code>n</code></em>，则宏中永远不会扩展额外的参数。</p><p>There is very little in the way of argument checking with
        <code class="function">call</code>. Any number of arguments can
        be given to <code class="function">call</code>. If a macro
        references a parameter <code class="literal">$</code>
        <em class="replaceable"><code>n</code></em> and there is no corresponding argument in
        the <code class="function">call</code> instance, the variable
        collapses to nothing. If there are more arguments in the <code class="function">call</code> instance than there are <code class="literal">$</code> <em class="replaceable"><code>n</code></em> references,
        the extra arguments are never expanded in the macro.</p><p>如果您从另一个宏调用一个宏，您应该注意到<em class="command">make</em> 
        3.80 中的一种有点奇怪的行为。该<code class="function">call</code>函数将参数定义为
        扩展期间的正常<em class="command">make</em>变量。所以如果一个宏
        <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1148" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1149" class="indexterm"></a>调用另一个，父宏的参数可能在子宏的扩展中可见：</p><p>If you invoke one macro from another, you should be aware of a
        somewhat strange behavior in <em class="command">make</em>
        3.80. The <code class="function">call</code> function defines
        the arguments as normal <em class="command">make</em>
        variables for the duration of the expansion. So if one macro
        <a class="indexterm"></a> <a class="indexterm"></a>invokes another, it is possible that the parent's
        arguments will be visible in the child macro's expansion:</p><a id="OEBPS/ch04.html.I_4_tt174"></a><pre class="programlisting">定义父级
  echo "parent 有两个参数: $1, $2"
  $（呼叫孩子，$1）
恩德夫

定义孩子
  echo "子进程有一个参数：$1"
  echo "但是子进程也可以看到父进程的第二个参数：$2!"
恩德夫

范围界定问题：
        @$（调用父级，一，二）</pre><pre class="programlisting">define parent
  echo "parent has two parameters: $1, $2"
  $(call child,$1)
endef

define child
  echo "child has one parameter: $1"
  echo "but child can also see parent's second parameter: $2!"
endef

scoping_issue:
        @$(call parent,one,two)</pre><p>运行时，我们看到宏实现有一个<a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1150" class="indexterm"></a> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1151" class="indexterm"></a>范围界定问题。</p><p>When run, we see that the macro implementation has a <a class="indexterm"></a> <a class="indexterm"></a>scoping issue.</p><a id="OEBPS/ch04.html.I_4_tt175"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Parent 有两个参数：一、二
child 有一个参数：一
但孩子也可以看到父母的第二个参数：二！</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
parent has two parameters: one, two
child has one parameter: one
but child can also see parent's second parameter: two!</pre><p>这个问题已在 3.81 中得到解决，因此<code class="literal">$2</code>会<code class="function">child</code>崩溃。</p><p>This has been resolved in 3.81 so that <code class="literal">$2</code> in <code class="function">child</code> collapses to nothing.</p><p>在本书的其余部分中，我们将花费更多的时间来讨论用户定义的函数，但在此之前我们需要更多的背景知识
        <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1152" class="indexterm"></a>
        <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1153" class="indexterm"></a>我们可以进入真正有趣的事情！</p><p>We'll spend a lot more time with user-defined functions
        throughout the rest of the book, but we need more background before
        <a class="indexterm"></a>
        <a class="indexterm"></a>we
        can get into the really fun stuff!</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-1" href="#OEBPS/ch04.html.make3-CHP-4-FNOTE-1" class="para">1</a> ]</sup> “为什么要在 makefile 中执行此操作<em class="filename">？</em> ”你问。那么，在 Windows 上，打开文件会锁定该文件，防止其他进程写入。当我写这本书时，<em class="filename">PDF</em>文件经常被 Acrobat Reader 锁定并阻止我的<em class="filename">makefile</em>更新<em class="filename">PDF</em>。因此，我将此命令添加到多个目标，以在尝试更新锁定文件之前终止 Acrobat Reader。</p><p><sup>[<a href="#OEBPS/ch04.html.make3-CHP-4-FNOTE-1" class="para">1</a>] </sup>"Why would you want to do this in a <em class="filename">makefile</em>?" you ask. Well, on Windows,
            opening a file locks it against writing by other processes. While
            I was writing this book, the <em class="filename">PDF</em> file would often be locked by the
            Acrobat Reader and prevent my <em class="filename">makefile</em> from updating the <em class="filename">PDF</em>. So I added this command to several
            targets to terminate Acrobat Reader before attempting to update
            the locked file.</p></div><div class="footnote"><p><sup>[ <a id="OEBPS/ch04.html.ftn.make3-CHP-4-FNOTE-2" href="#OEBPS/ch04.html.make3-CHP-4-FNOTE-2" class="para">2</a> ]</sup>西格<span class="emphasis"><em>温</em></span> <a id="OEBPS/ch04.html.make3-CHP-4-ITERM-1144" class="indexterm"></a><acronym class="acronym">工具是许多标准GNU</acronym>和 Linux 程序到 Windows的端口
            。它包括编译器套件、X11R6、<em class="command">ssh</em>甚至<em class="command">inetd</em>。该端口依赖于一个兼容性库，该库根据 Win32 API 函数实现 Unix 系统调用。这是一项令人难以置信的工程壮举，我强烈推荐它。从<a class="ulink" href="http://www.cygwin.com/">http://www.cygwin.com</a>下载。</p><p><sup>[<a href="#OEBPS/ch04.html.make3-CHP-4-FNOTE-2" class="para">2</a>] </sup>The <span class="emphasis"><em>Cygwin</em></span> <a class="indexterm"></a> tools are a port of many of the standard
            <acronym class="acronym">GNU</acronym> and Linux programs to Windows. It includes
            the compiler suite, X11R6, <em class="command">ssh</em>,
            and even <em class="command">inetd</em>. The port relies
            on a compatibility library that implements Unix system calls in
            terms of Win32 API functions. It is an incredible feat of
            engineering and I highly recommend it. Download it from <a class="ulink" href="http://www.cygwin.com">http://www.cygwin.com</a>.</p></div></div></div></div></div>
<div id="OEBPS/ch04s02.html"><div>
<div class="sect1" title="内置功能"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2"></a>内置功能</h1><h1 class="title"><a></a>Built-in Functions</h1></div></div></div><p>一旦你开始上路<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1154" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1155" class="indexterm"></a>使用<em class="command">make</em>
        变量不仅仅是简单的常量，您会发现您想要以越来越复杂的方式操作变量及其内容。好吧，你可以。<acronym class="acronym">GNU </acronym> <em class="command">make</em>有几十个内置函数用于处理变量及其内容。这些函数分为几大类：字符串操作、文件名操作、流控制、用户定义函数和一些（重要的）杂项函数。</p><p>Once you start down the road <a class="indexterm"></a> <a class="indexterm"></a>of using <em class="command">make</em>
        variables for more than just simple constants you'll find that you
        want to manipulate the variables and their contents in more and more
        complex ways. Well, you can. <acronym class="acronym">GNU</acronym> <em class="command">make</em> has a couple dozen built-in functions
        for working with variables and their contents. The functions fall into
        several broad categories: string manipulation, filename manipulation,
        flow control, user-defined functions, and some (important)
        miscellaneous functions.</p><p>但首先，多了解一点<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1156" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1157" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158" class="indexterm"></a>函数语法。所有函数的形式如下：</p><p>But first, a little more about <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>function syntax. All functions have the form:</p><a id="OEBPS/ch04s02.html.I_4_tt176"></a><pre class="programlisting">$(函数名 arg <sub>1</sub> [, arg <sub>n</sub> ])</pre><pre class="programlisting">$(function-name arg<sub>1</sub>[, arg<sub>n</sub>])</pre><p>后面<code class="literal">$(</code>是内置函数名称，然后是函数的参数。第一个参数中的前导空格被修剪掉，但所有后续参数都包含任何前导（当然还有嵌入的和后面的）空格。</p><p>The <code class="literal">$(</code> is followed by
        built-in function name and then followed by the arguments to the
        function. Leading whitespace is trimmed from the first argument, but
        all subsequent arguments include any leading (and, of course, embedded
        and following) whitespace.</p><p>函数参数以逗号分隔，因此具有一个参数的函数不使用逗号，具有两个参数的函数使用一个逗号，等等。许多函数接受单个参数，将其视为空格分隔的单词列表。对于这些函数，单词之间的空格被视为单单词分隔符，否则将被忽略。</p><p>Function arguments are separated by commas, so a function with
        one argument uses no commas, a function with two arguments uses one
        comma, etc. Many functions accept a single argument, treating it as a
        list of space-separated words. For these functions, the whitespace
        between words is treated as a single-word separator and is otherwise
        ignored.</p><p>我喜欢<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1159" class="indexterm"></a>空白。它使代码更具可读性并且更易于维护。所以我会在任何可以“逃脱”的地方使用空白。然而，有时，参数列表或变量定义中的空格可能会干扰代码的正常运行。发生这种情况时，您别无选择，只能删除有问题的空白。我们已经在本章前面看到过一个示例，其中尾随空格被意外插入到<em class="command">grep</em>命令的搜索模式中。当我们继续提供更多示例时，我们将指出出现空白问题的位置。</p><p>I like <a class="indexterm"></a>whitespace. It makes the code more readable and easier
        to maintain. So I'll be using whitespace wherever I can "get away"
        with it. Sometimes, however, the whitespace in an argument list or
        variable definition can interfere with the proper functioning of the
        code. When this happens, you have little choice but to remove the
        problematic whitespace. We already saw one example earlier in the
        chapter where trailing whitespace was accidentally inserted into the
        search pattern of a <em class="command">grep</em> command.
        As we proceed with more examples, we'll point out where whitespace
        issues arise.</p><p>许多<em class="command">make</em>函数接受
        <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1160" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1162" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1163" class="indexterm"></a> <em class="firstterm">模式</em>作为参数。该模式使用与模式规则中使用的模式相同的语法（请参阅<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>中的
        <a class="link" href="#OEBPS/ch02s04.html" title="模式规则">2.4 节</a>）。模式包含具有前导或尾随字符（或两者）的单个模式。该
        字符代表零个或多个任何类型的字符。要匹配目标字符串，模式必须匹配整个字符串，而不仅仅是字符串中的字符子集。我们很快就会用一个例子来说明这一点。该字符在模式中是可选的，并且通常在适当的时候被省略。<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a><code class="literal">%</code><code class="literal">%</code><code class="literal">%</code></p><p>Many <em class="command">make</em> functions accept a
        <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <em class="firstterm">pattern</em> as an argument. This
        pattern uses the same syntax as the patterns used in pattern rules
        (see the <a class="link" href="#OEBPS/ch02s04.html" title="Pattern Rules">Section 2.4</a> in
        <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>). A pattern contains a
        single <code class="literal">%</code> with leading or trailing
        characters (or both). The <code class="literal">%</code>
        character represents zero or more characters of any kind. To match a
        target string, the pattern must match the entire string, not just a
        subset of characters within the string. We'll illustrate this with an
        example shortly. The <code class="literal">%</code> character is
        optional in a pattern and is commonly omitted when appropriate.</p><div class="sect2" title="字符串函数"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1"></a>字符串函数</h2><h2 class="title"><a></a>String Functions</h2></div></div></div><p>大多数<em class="command">make</em>的内置函数<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1164" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1166" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1167" class="indexterm"></a>以一种或另一种形式操作文本，但某些函数在字符串操作方面特别强大，这些将在这里讨论。</p><p>Most of <em class="command">make</em>'s built-in
          functions <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>manipulate text in one form or another, but certain
          functions are particularly strong at string manipulation, and these
          will be discussed here.</p><p><em class="command">make</em>中常见的字符串操作是从列表中选择一组文件。这就是<em class="command">grep</em>在 shell 脚本中的典型用途。在<em class="command">make</em>中，我们有<code class="function">filter</code>、<code class="function">filter-out</code>、 和<code class="function">findstring</code>函数。</p><p>A common string operation in <em class="command">make</em> is to select a set of files from a
          list. This is what <em class="command">grep</em> is
          typically used for in shell scripts. In <em class="command">make</em> we have the <code class="function">filter</code>, <code class="function">filter-out</code>, and <code class="function">findstring</code> functions.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(filter</code>
              <code class="option">pattern</code> <code class="literal">. .
              </code>。 ,<code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(filter</code>
              <code class="option">pattern</code> <code class="literal">. .
              </code>. ,<code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>该<code class="function">filter</code>函数处理<code class="option">text</code> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1168" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1169" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1170" class="indexterm"></a>作为空格分隔的单词序列并返回匹配的单词的列表
                <code class="option">pattern</code>。例如，要构建用户界面代码的存档，我们可能只想选择<em class="filename">ui</em>
                子目录中的目标文件。在以下示例中，我们从文件名列表中提取以<em class="filename">ui/开头并以</em><em class="filename">.o</em>结尾的文件名。该
                <code class="literal">%</code>字符与之间任意数量的字符匹配：</p><a id="OEBPS/ch04s02.html.I_4_tt177"></a><pre class="programlisting">$(ui_library): $(过滤器 ui/%.o,$(objects))
        $(AR) $(ARFLAGS) $@ $^</pre><p>也可以<code class="function">filter</code>接受多个
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1171" class="indexterm"></a>图案，用空格分隔。如上所述，模式必须与整个单词匹配才能将单词包含在输出列表中。因此，例如：</p><a id="OEBPS/ch04s02.html.I_4_tt178"></a><pre class="programlisting">话 := 他 母鸡 其他%
得到：
        @echo 他匹配：$(filter he, $(words))
        @echo %he 匹配：$(filter %he, $(words))
        @echo he% 匹配：$(filter he%, $(words))
        @echo %he% 匹配：$(filter %he%, $(words))</pre><p>执行时，<em class="filename">makefile</em>会生成输出：</p><a id="OEBPS/ch04s02.html.I_4_tt179"></a><pre class="programlisting">$ 制作
他匹配： 他
%他匹配：他
he% 匹配： he hen
%he% 匹配：%</pre><p>正如您所看到的，第一个模式仅匹配单词
                <code class="literal">he</code>，因为该模式必须匹配整个单词，而不仅仅是单词的一部分。其他模式匹配加上包含在正确位置<code class="literal">he</code>的单词。<code class="literal">he</code></p><p>一个模式只能包含一个<code class="literal">%</code>。如果<code class="literal">%</code>模式中包含其他字符，则除第一个字符外的所有字符都将被视为文字字符。</p><p><code class="function">filter</code>无法匹配单词中的子字符串或接受多个通配符可能看起来很奇怪。您会发现有时会非常怀念此功能。但是，您可以使用循环和条件测试来实现类似的东西。稍后我们会向您展示如何操作。</p></dd><dd><p>The <code class="function">filter</code> function
                treats <code class="option">text</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>as a sequence of space separated words and
                returns a list of those words matching
                <code class="option">pattern</code>. For instance, to build an archive of
                user-interface code, we might want to select only the object
                files in the <em class="filename">ui</em>
                subdirectory. In the following example, we extract the
                filenames starting with <em class="filename">ui/</em> and ending in <em class="filename">.o</em> from a list of filenames. The
                <code class="literal">%</code> character matches any
                number of characters in between:</p><a></a><pre class="programlisting">$(ui_library): $(filter ui/%.o,$(objects))
        $(AR) $(ARFLAGS) $@ $^</pre><p>It is also possible for <code class="function">filter</code> to accept multiple
                <a class="indexterm"></a>patterns, separated by spaces. As noted above,
                the pattern must match an entire word for the word to be
                included in the output list. So, for instance:</p><a></a><pre class="programlisting">words := he the hen other the%
get-the:
        @echo he matches: $(filter he, $(words))
        @echo %he matches: $(filter %he, $(words))
        @echo he% matches: $(filter he%, $(words))
        @echo %he% matches: $(filter %he%, $(words))</pre><p>When executed the <em class="filename">makefile</em> generates the
                output:</p><a></a><pre class="programlisting">$ make
he matches: he
%he matches: he the
he% matches: he hen
%he% matches: the%</pre><p>As you can see, the first pattern matches only the word
                <code class="literal">he</code>, because the pattern
                must match the entire word, not just a part of it. The other
                patterns match <code class="literal">he</code> plus
                words that contain <code class="literal">he</code> in
                the right position.</p><p>A pattern can contain only one <code class="literal">%</code>. If additional <code class="literal">%</code> characters are included in the
                pattern, all but the first are treated as literal
                characters.</p><p>It may seem odd that <code class="function">filter</code> cannot match substrings
                within words or accept more than one wildcard character. You
                will find times when this functionality is sorely missed.
                However, you can implement something similar using looping and
                conditional testing. We'll show you how later.</p></dd><dt><span class="term"><code class="literal">$(filter-out</code>
              <code class="option">pattern</code> <code class="literal">. .
              </code>。 ,<code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(filter-out</code>
              <code class="option">pattern</code> <code class="literal">. .
              </code>. ,<code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这<code class="function">filter-out</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1172" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1173" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1174" class="indexterm"></a>函数的作用与 相反<code class="function">filter</code>，选择与模式不匹配的每个单词。这里我们选择所有不是 C 头文件的文件。</p><a id="OEBPS/ch04s02.html.I_4_tt180"></a><pre class="programlisting">all_source := count_words.c counter.c lexer.l counter.h lexer.h
to_compile := $(过滤出%.h, $(all_source))</pre></dd><dd><p>The <code class="function">filter-out</code>
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>function does the opposite of <code class="function">filter</code>, selecting every word that
                does not match the pattern. Here we select all files that are
                not C headers.</p><a></a><pre class="programlisting">all_source := count_words.c counter.c lexer.l counter.h lexer.h
to_compile := $(filter-out %.h, $(all_source))</pre></dd><dt><span class="term"><code class="literal">$(findstring</code>
              <code class="option">string</code>,<code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(findstring</code>
              <code class="option">string</code>,<code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这个功能<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1175" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1176" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1177" class="indexterm"></a>寻找<code class="option">string</code>在
                <code class="option">text</code>.如果找到该字符串，则该函数返回<code class="option">string</code>；否则，它不会返回任何内容。</p><p>乍一看，这个函数可能看起来像我们想象的子字符串搜索<em class="command">grep</em><code class="function">filter</code>函数，但事实并非如此。首先，也是最重要的，此函数仅返回搜索字符串，而不返回它找到的包含搜索字符串的单词。其次，搜索字符串不能包含通配符（换句话说，<code class="literal">%</code>搜索字符串中的字符按字面匹配）。</p><p><code class="function">if</code>该函数主要与后面讨论的函数结合使用
                。然而，我发现在一种情况下
                <code class="function">findstring</code>它本身很有用。</p><p>假设您有多个具有并行结构的树，例如参考源、沙箱源、调试二进制文件和优化二进制文件。您希望能够从当前目录找出您所在的树（没有根目录的当前相对路径）。下面是一些确定这一点的框架代码：</p><a id="OEBPS/ch04s02.html.I_4_tt181"></a><pre class="programlisting">查找树：
        # 密码 = $(密码)
        # $(findstring /test/book/admin,$(PWD))
        # $(findstring /test/book/bin,$(PWD))
        # $(findstring /test/book/dblite_0.5,$(PWD))
        # $(findstring /test/book/examples,$(PWD))
        # $(findstring /test/book/out,$(PWD))
        # $(findstring /test/book/text,$(PWD))</pre><p>（每行都以制表符和 shell 注释字符开头，因此每一行都像其他命令一样在自己的子 shell 中“执行”。Bourne Again Shell、<em class="command">bash</em>和许多其他类似 Bourne 的 shell 会忽略这些行。这是一个更打印出简单<em class="command">make</em>结构的扩展比键入更方便，您可以使用更便携的 : shell 操作符实现几乎相同的效果，但是 : 操作符执行重定向，因此，包含
                创建文件<em class="filename">word 的</em><code class="literal">@echo</code>命令行会产生副作用。 .) 运行时，它会产生：<code class="literal">&gt; word</code><em class="filename"></em></p><a id="OEBPS/ch04s02.html.I_4_tt182"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
# PWD = /test/book/out/ch03-findstring-1
#
#
#
#
＃/测试/书/出
#</pre><p>正如您所看到的，每次测试都会<code class="literal">$(PWD)</code>返回 null，直到我们测试父目录。然后返回父目录本身。如图所示，该代码仅作为 的演示
                <code class="function">findstring</code>。这可用于编写返回当前树的根目录的函数。</p></dd><dd><p>This function <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>looks for <code class="option">string</code> in
                <code class="option">text</code>. If the string is found, the function
                returns <code class="option">string</code>; otherwise, it returns
                nothing.</p><p>At first, this function might seem like the substring
                searching <em class="command">grep</em> function we
                thought <code class="function">filter</code> might be,
                but not so. First, and most important, this function returns
                just the search string, not the word it finds that contains
                the search string. Second, the search string cannot contain
                wildcard characters (putting it another way, <code class="literal">%</code> characters in the search string
                are matched literally).</p><p>This function is mostly useful in conjunction with the
                <code class="function">if</code> function discussed
                later. There is, however, one situation where I've found
                <code class="function">findstring</code> to be useful
                in its own right.</p><p>Suppose you have several trees with parallel structure
                such as reference source, sandbox source, debugging binary,
                and optimized binary. You'd like to be able to find out which
                tree you are in from your current directory (without the
                current relative path from the root). Here is some skeleton
                code to determine this:</p><a></a><pre class="programlisting">find-tree:
        # PWD = $(PWD)
        # $(findstring /test/book/admin,$(PWD))
        # $(findstring /test/book/bin,$(PWD))
        # $(findstring /test/book/dblite_0.5,$(PWD))
        # $(findstring /test/book/examples,$(PWD))
        # $(findstring /test/book/out,$(PWD))
        # $(findstring /test/book/text,$(PWD))</pre><p>(Each line begins with a tab and a shell comment
                character so each is "executed" in its own subshell just like
                other commands. The Bourne Again Shell, <em class="command">bash</em>, and many other Bourne-like
                shells simply ignore these lines. This is a more convenient
                way to print out the expansion of simple <em class="command">make</em> constructs than typing <code class="literal">@echo</code>. You can achieve almost the
                same effect using the more portable : shell operator, but the
                : operator performs redirections. Thus, a command line
                containing <code class="literal">&gt; word</code>
                creates the file <em class="filename">word</em> as
                a side effect.) When run, it produces:</p><a></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
# PWD = /test/book/out/ch03-findstring-1
# 
# 
# 
# 
# /test/book/out
#</pre><p>As you can see, each test against <code class="literal">$(PWD)</code> returns null until we test
                our parent directory. Then the parent directory itself is
                returned. As shown, the code is merely as a demonstration of
                <code class="function">findstring</code>. This can be
                used to write a function returning the current tree's root
                directory.</p></dd></dl></div><p>有两个搜索和<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1178" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1179" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1180" class="indexterm"></a>替换函数：</p><p>There are two search and <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>replace functions:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(subst</code>
              <code class="option">search-string</code>, <code class="option">replace-string</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(subst</code>
              <code class="option">search-string</code>,<code class="option">replace-string</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dd><p>这是一个简单的、<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1181" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1182" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1183" class="indexterm"></a>非通配符，搜索和替换。它最常见的用途之一是将文件名列表中的一个后缀替换为另一个后缀：</p><a id="OEBPS/ch04s02.html.I_4_tt183"></a><pre class="programlisting">来源 := count_words.c counter.c lexer.c
对象 := $(subst .c,.o,$(来源))</pre><p>这会将中任何位置出现的所有“ <em class="filename">.c</em> ”替换为“ <em class="filename">.o</em><code class="literal">$(sources)</code> ” ，或者更一般地说，将搜索字符串的所有出现替换为替换字符串。</p><p>此示例是一个常见的说明，说明空格在函数调用参数中的重要性。请注意，逗号后面没有空格。如果我们改为这样写：</p><a id="OEBPS/ch04s02.html.I_4_tt184"></a><pre class="programlisting">来源 := count_words.c counter.c lexer.c
对象 := $(subst .c, .o, $(源))</pre><p>（注意每个逗号后面的空格）， 的值
                <code class="literal">$(objects)</code>将是：</p><a id="OEBPS/ch04s02.html.I_4_tt185"></a><pre class="programlisting">count_words .o 计数器 .o 词法分析器 .o</pre><p>根本不是我们想要的。问题在于参数之前的空格<code class="literal">.o</code>是替换文本的一部分，并被插入到输出字符串中。之前的空格没问题，因为第一个参数之前的所有空格都被<em class="command">make</em><code class="literal">.c</code>去掉了。事实上，前面的空格
                也可能是良性的，因为很可能被用作简单的命令行参数，其中前导空格不是问题。但是，我永远不会在函数调用中的逗号后混合不同的间距，即使它产生正确的结果：<em class="command"></em><code class="literal">$(sources)</code><code class="literal">$(objects)</code></p><a id="OEBPS/ch04s02.html.I_4_tt186"></a><pre class="programlisting"># 是的，这个调用中的间距太微妙了。
对象 := $(subst .c,.o, $(源))</pre><p>请注意，它<code class="function">subst</code>
                不理解文件名或文件后缀，只理解字符串。如果我的源文件之一包含<code class="literal">.c</code>内部，那么它也将被替换。例如，文件名<em class="filename">car.cdr.c</em>将转换为
                <em class="filename">car.odr.o</em>。可能不是我们想要的。</p><p><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">在第 2 章</a>
                的<a class="link" href="#OEBPS/ch02s07.html" title="自动依赖生成">2.7 节</a>中，我们讨论了依赖项生成。该部分的
                最后一个示例<em class="filename">makefile</em>使用如下：<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a><em class="filename"></em><code class="function">subst</code></p><a id="OEBPS/ch04s02.html.I_4_tt187"></a><pre class="programlisting">VPATH = src 包含
CPPFLAGS = -我包括
来源= count_words.c \
           词法分析器.c \
           计数器.c
count_words: counter.o lexer.o -lfl
count_words.o：计数器.h
counter.o: counter.h lexer.h
词法分析器.o: 词法分析器.h
包括 $(subst .c,.d,$(来源))
%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$; \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@; \
        rm -f $@.$$$$</pre><p>该<code class="function">subst</code>函数用于将源文件列表转换为依赖文件列表。由于依赖项文件作为 的参数出现
                ，因此它们被视为先决条件并使用该规则<code class="literal">include</code>进行更新。<code class="literal">%.d</code></p></dd><dd><p>This is a simple, <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>nonwildcard, search and replace. One of its most
                common uses is to replace one suffix with another in a list of
                filenames:</p><a></a><pre class="programlisting">sources := count_words.c counter.c lexer.c
objects := $(subst .c,.o,$(sources))</pre><p>This replaces all occurrences of "<em class="filename">.c</em>" with "<em class="filename">.o</em>" anywhere in <code class="literal">$(sources)</code>, or, more generally, all
                occurrences of the search string with the replacement
                string.</p><p>This example is a commonly found illustration of where
                spaces are significant in function call arguments. Note that
                there are no spaces after the commas. If we had instead
                written:</p><a></a><pre class="programlisting">sources := count_words.c counter.c lexer.c
objects := $(subst .c, .o, $(sources))</pre><p>(notice the space after each comma), the value of
                <code class="literal">$(objects)</code> would have
                been:</p><a></a><pre class="programlisting">count_words .o counter .o lexer .o</pre><p>Not at all what we want. The problem is that the space
                before the <code class="literal">.o</code> argument is
                part of the replacement text and was inserted into the output
                string. The space before the <code class="literal">.c</code> is fine because all whitespace
                before the first argument is stripped off by <em class="command">make</em>. In fact, the space before
                <code class="literal">$(sources)</code> is probably
                benign as well since <code class="literal">$(objects)</code> will most likely be used
                as a simple command-line argument where leading spaces aren't
                a problem. However, I would never mix different spacing after
                commas in a function call even if it yields the correct
                results:</p><a></a><pre class="programlisting"># Yech, the spacing in this call is too subtle.
objects := $(subst .c,.o, $(source))</pre><p>Note that <code class="function">subst</code>
                doesn't understand filenames or file suffixes, just strings of
                characters. If one of my source files contains a <code class="literal">.c</code> internally, that too will be
                substituted. For instance, the filename <em class="filename">car.cdr.c</em> would be transformed into
                <em class="filename">car.odr.o</em>. Probably not
                what we want.</p><p>In <a class="link" href="#OEBPS/ch02s07.html" title="Automatic Dependency Generation">Section 2.7</a>
                in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>, we talked
                about dependency generation. The last example <em class="filename">makefile</em> of that section used
                <code class="function">subst</code> like this:</p><a></a><pre class="programlisting">VPATH    = src include
CPPFLAGS = -I include
SOURCES  = count_words.c \
           lexer.c       \
           counter.c
count_words: counter.o lexer.o -lfl
count_words.o: counter.h
counter.o: counter.h lexer.h
lexer.o: lexer.h
include $(subst .c,.d,$(SOURCES))
%.d: %.c
        $(CC) -M $(CPPFLAGS) $&lt; &gt; $@.$$$$;                      \
        sed 's,\($*\)\.o[ :]*,\1.o $@ : ,g' &lt; $@.$$$$ &gt; $@;     \
        rm -f $@.$$$$</pre><p>The <code class="function">subst</code> function
                is used to transform the source file list into a dependency
                file list. Since the dependency files appear as an argument to
                <code class="literal">include</code>, they are
                considered prerequisites and are updated using the <code class="literal">%.d</code> rule.</p></dd><dt><span class="term"><code class="literal">$(patsubst</code>
              <code class="option">search-pattern</code>, <code class="option">replace-pattern</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(patsubst</code>
              <code class="option">search-pattern</code>,<code class="option">replace-pattern</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dd><p>这是搜索和替换的通配符版本。像往常一样，该模式可以包含单个<code class="literal">%</code>.百分之一在
                <code class="option">replace-pattern</code> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1184" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1185" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1186" class="indexterm"></a>与匹配的文本一起扩展。重要的是要记住 必须<code class="option">search-pattern</code>
                匹配 的整个值<code class="option">text</code>。例如，以下命令将删除 中的尾部斜杠
                <code class="option">text</code>，而不是删除 中的每个斜杠
                <code class="option">text</code>：</p><a id="OEBPS/ch04s02.html.I_4_tt188"></a><pre class="programlisting">条尾斜杠 = $(patsubst %/,%,$(目录路径))</pre><p><em class="firstterm">替代参考</em>是
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1187" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1188" class="indexterm"></a>执行相同替换的便携式方式。替换引用的语法是：</p><a id="OEBPS/ch04s02.html.I_4_tt189"></a><pre class="programlisting">$( <em class="replaceable"><code>variable</code></em>: <em class="replaceable"><code>search</code></em>= <em class="replaceable"><code>replace</code></em>)</pre><p>文本<em class="replaceable"><code>search</code></em>可以是一个简单的字符串；在这种情况下，<em class="replaceable"><code>replace</code></em>每当字符串出现在单词末尾时，该字符串就会被替换
                。也就是说，只要后面跟着空格或变量值的末尾。另外，
                <em class="replaceable"><code>search</code></em>可以包含<code class="literal">%</code>代表通配符的a；在这种情况下，搜索和替换遵循 的规则
                <code class="function">patsubst</code>。我发现与
                <code class="function">patsubst</code>.</p><p>正如我们所见，变量通常包含单词列表。以下是从列表中选择单词、计算列表长度等的函数。与所有<em class="command">make</em>函数一样，单词之间用<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1189" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1190" class="indexterm"></a>空白。</p></dd><dd><p>This is the wildcard version of search and replace. As
                usual, the pattern can contain a single <code class="literal">%</code>. A percent in the
                <code class="option">replace-pattern</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> is expanded with the matching text. It is
                important to remember that the <code class="option">search-pattern</code>
                must match the entire value of <code class="option">text</code>. For
                instance, the following will delete a trailing slash in
                <code class="option">text</code>, not every slash in
                <code class="option">text</code>:</p><a></a><pre class="programlisting">strip-trailing-slash = $(patsubst %/,%,$(directory-path))</pre><p><em class="firstterm">Substitution references</em> are a
                <a class="indexterm"></a> <a class="indexterm"></a>portable way of performing the same
                substitution. The syntax of a substitution reference
                is:</p><a></a><pre class="programlisting">$(<em class="replaceable"><code>variable</code></em>:<em class="replaceable"><code>search</code></em>=<em class="replaceable"><code>replace</code></em>)</pre><p>The <em class="replaceable"><code>search</code></em> text can be a
                simple string; in which case, the string is replaced with
                <em class="replaceable"><code>replace</code></em> whenever it occurs at the
                end of a word. That is, whenever it is followed by whitespace
                or the end of the variable value. In addition,
                <em class="replaceable"><code>search</code></em> can contain a <code class="literal">%</code> representing a wildcard character;
                in which case, the search and replace follow the rules of
                <code class="function">patsubst</code>. I find this
                syntax to be obscure and difficult to read in comparison to
                <code class="function">patsubst</code>.</p><p>As we've seen, variables often contain lists of words.
                Here are functions to select words from a list, count the
                length of a list, etc. As with all <em class="command">make</em> functions, words are separated
                by <a class="indexterm"></a> <a class="indexterm"></a>whitespace.</p></dd><dt><span class="term"><code class="literal">$(words</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(words</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这将返回数量<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1191" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1192" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1193" class="indexterm"></a>中的话<code class="option">text</code>。</p><a id="OEBPS/ch04s02.html.I_4_tt190"></a><pre class="programlisting">CURRENT_PATH := $(替换 /, ,$(HOME))
字：
        @echo 我的主路径有 $(words $(CURRENT_PATH)) 目录。</pre><p>这个函数有很多用途，我们很快就会看到，但我们需要介绍更多函数才能有效地使用它。</p></dd><dd><p>This returns the number of <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>words in <code class="option">text</code>.</p><a></a><pre class="programlisting">CURRENT_PATH := $(subst /, ,$(HOME))
words:
        @echo My HOME path has $(words $(CURRENT_PATH)) directories.</pre><p>This function has many uses, as we'll see shortly, but
                we need to cover a few more functions to use it
                effectively.</p></dd><dt><span class="term"><code class="literal">$(word</code>
              <code class="option">n</code>,<code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(word</code>
              <code class="option">n</code>,<code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这将返回中的<sup>第 th 个</sup>单词。第一个字的编号为 1。如果
                大于 中的字数，则该函数的值为空。<em class="replaceable"><code>n</code></em>
                <sup></sup><code class="option">text</code><em class="replaceable"><code>n</code></em><code class="option">text</code></p><a id="OEBPS/ch04s02.html.I_4_tt191"></a><pre class="programlisting">版本列表 := $(subst ., ,$(MAKE_VERSION))
次要版本 := $(单词 2, $(version_list))</pre><p>该变量<code class="literal">MAKE_VERSION</code>是内置变量。 （参见<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>
                第<a class="link" href="#OEBPS/ch03s08.html" title="标准 make 变量">3.8 节</a>。）<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a></p><p>您始终可以通过以下方式获取列表中的最后一个单词：</p><a id="OEBPS/ch04s02.html.I_4_tt192"></a><pre class="programlisting">当前 := $(单词 $(单词 $(MAKEFILE_LIST)), $(MAKEFILE_LIST))</pre><p>这将返回最近读取的
                <em class="filename">makefile</em>的名称。</p></dd><dd><p>This returns the <em class="replaceable"><code>n</code></em>
                <sup>th</sup> word in <code class="option">text</code>.
                The first word is numbered 1. If <em class="replaceable"><code>n</code></em>
                is larger than the number of words in <code class="option">text</code>,
                the value of the function is empty.</p><a></a><pre class="programlisting">version_list  := $(subst ., ,$(MAKE_VERSION))
minor_version := $(word 2, $(version_list))</pre><p>The variable <code class="literal">MAKE_VERSION</code> is a built-in variable.
                (See the <a class="link" href="#OEBPS/ch03s08.html" title="Standard make Variables">Section 3.8</a>
                in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>.)</p><p>You can always get the last word in a list with:</p><a></a><pre class="programlisting">current := $(word $(words $(MAKEFILE_LIST)), $(MAKEFILE_LIST))</pre><p>This returns the name of the most recently read
                <em class="filename">makefile</em>.</p></dd><dt><span class="term"><code class="literal">$(firstword</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(firstword</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这将返回<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1194" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1195" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1196" class="indexterm"></a>中的第一个词<code class="option">text</code>。这相当于<code class="function">$(word 1,</code>
                <code class="option">text</code>）。</p><a id="OEBPS/ch04s02.html.I_4_tt193"></a><pre class="programlisting">版本列表 := $(subst ., ,$(MAKE_VERSION))
主要版本 := $(第一个单词 $(version_list))</pre></dd><dd><p>This returns the<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> first word in <code class="option">text</code>. This is
                equivalent to <code class="function">$(word 1,</code>
                <code class="option">text</code>).</p><a></a><pre class="programlisting">version_list := $(subst ., ,$(MAKE_VERSION))
major_version := $(firstword $(version_list))</pre></dd><dt><span class="term"><code class="literal">$(wordlist</code>
              <code class="option">start</code>, <code class="option">end</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(wordlist</code>
              <code class="option">start</code>,<code class="option">end</code>,<code class="option">text</code>
              <code class="literal">)</code></span></dt><dd><p>这将返回<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1197" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1198" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1199" class="indexterm"></a><code class="option">text</code>从
                <code class="option">start</code>到中的单词<code class="option">end</code>，包含在内。与该<code class="function">word</code>函数一样，第一个字的编号为 1。如果<code class="option">start</code>大于字数，则该值为空。如果
                <code class="option">start</code>大于<code class="option">end</code>，则该值为空。如果<code class="option">end</code>大于单词数，则<code class="option">start</code>返回从 开始的所有单词。</p><a id="OEBPS/ch04s02.html.I_4_tt194"></a><pre class="programlisting"># $(call uid_gid, 用户名)
uid_gid = $(单词列表 3, 4, \
            $(替换:,,\
              $(shell grep "^$1:" /etc/passwd)))</pre></dd><dd><p>This returns the <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>words in <code class="option">text</code> from
                <code class="option">start</code> to <code class="option">end</code>, inclusive. As
                with the <code class="function">word</code> function,
                the first word is numbered 1. If <code class="option">start</code> is
                greater than the number of words, the value is empty. If
                <code class="option">start</code> is greater than <code class="option">end</code>,
                the value is empty. If <code class="option">end</code> is greater than
                the number of words, all words from <code class="option">start</code> on
                are returned.</p><a></a><pre class="programlisting"># $(call uid_gid, user-name)
uid_gid = $(wordlist 3, 4, \
            $(subst :, ,   \
              $(shell grep "^$1:" /etc/passwd)))</pre></dd></dl></div></div><div class="sect2" title="重要的杂项功能"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.2"></a>重要的杂项功能</h2><h2 class="title"><a></a>Important Miscellaneous Functions</h2></div></div></div><p>在我们介绍管理文件名的函数之前，让我们先介绍两个非常有用的函数：<code class="function">sort</code>和<code class="function">shell</code>。</p><p>Before we push on to functions for managing filenames, let's
          introduce two very useful functions: <code class="function">sort</code> and <code class="function">shell</code>.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(sort</code>
              <code class="option">list</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(sort</code>
              <code class="option">list</code> <code class="literal">)</code></span></dt><dd><p>功能<code class="function">sort</code>​
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1200" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1201" class="indexterm"></a>对它的<code class="option">list</code>参数进行排序并删除重复项。结果列表包含按字典顺序排列的所有唯一单词，每个单词由一个空格分隔。此外，<code class="function">sort</code>
                去除前导和尾随空白。</p><a id="OEBPS/ch04s02.html.I_4_tt195"></a><pre class="programlisting">$ make -f- &lt;&lt;&lt; 'x:;@echo =$(sort dbsdt )='
=bdst=</pre><p><code class="function">sort</code>当然，该函数是直接由<em class="command">make</em>实现的，因此它不支持程序的任何选项<code class="literal">sort</code>
                。该函数对其参数进行操作，通常是变量或另一个<em class="command">make</em>函数的返回值。</p></dd><dd><p>The <code class="function">sort</code> function
                <a class="indexterm"></a> <a class="indexterm"></a>sorts its <code class="option">list</code> argument and
                removes duplicates. The resulting list contains all the unique
                words in lexicographic order, each separated by a single
                space. In addition, <code class="function">sort</code>
                strips leading and trailing blanks.</p><a></a><pre class="programlisting">$ make -f- &lt;&lt;&lt; 'x:;@echo =$(sort    d  b s   d      t   )='
=b d s t=</pre><p>The <code class="function">sort</code> function
                is, of course, implemented directly by <em class="command">make</em>, so it does not support any of
                the options of the <code class="literal">sort</code>
                program. The function operates on its argument, typically a
                variable or the return value of another <em class="command">make</em> function.</p></dd><dt><span class="term"><code class="literal">$(shell</code>
              <code class="option">command</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(shell</code>
              <code class="option">command</code> <code class="literal">)</code></span></dt><dd><p>该<code class="function">shell</code>函数接受<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1202" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1203" class="indexterm"></a>扩展的单个参数（像所有参数一样）并传递给子 shell 执行。然后读取命令的标准输出并将其作为函数的值返回。输出中的换行符序列被折叠为单个空格。任何尾随换行符都会被删除。不返回标准错误，也不返回任何程序退出状态。</p><a id="OEBPS/ch04s02.html.I_4_tt196"></a><pre class="programlisting">stdout := $(shell 回显正常消息)
stderr := $(shell 回显错误消息 1&gt;&amp;2)
外壳值：
        # $(标准输出)
        # $(标准错误)</pre><p>正如您所看到的，发送到<em class="filename">stderr</em>的消息照常发送到终端，因此不包含在函数的输出中<code class="function">shell</code>：</p><a id="OEBPS/ch04s02.html.I_4_tt197"></a><pre class="programlisting">$ 制作
错误信息
# 正常消息
#</pre><p>这是创建一组目录的循环：</p><a id="OEBPS/ch04s02.html.I_4_tt198"></a><pre class="programlisting">REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS); \
             做 \
               [[ -d $$d ]] || mkdir -p $$d; \
             完毕）</pre><p>通常，
                如果在执行任何命令脚本之前能够保证基本的输出目录存在，则<em class="filename">makefile更容易实现。该变量通过使用</em><em class="command">bash</em> shell“for”循环创建必要的目录，
                以确保一组目录存在。双方括号是<em class="command">bash测试语法，与</em><em class="command">测试</em>程序类似
                ，只是不执行分词和路径名扩展。因此，如果变量包含带有嵌入空格的文件名，测试仍然可以正常工作（并且不带引号）。通过将此<em class="command">make变量赋值放在</em><em class="filename">makefile 的</em>早期，我们确保它在命令脚本或其他变量使用输出目录之前执行。的实际值<code class="literal">_MKDIRS</code>是无关紧要的，<code class="literal">_MKDIRS</code>它本身永远不会被使用。</p></dd><dd><p>The <code class="function">shell</code> function
                accepts <a class="indexterm"></a> <a class="indexterm"></a>a single argument that is expanded (like all
                arguments) and passed to a subshell for execution. The
                standard output of the command is then read and returned as
                the value of the function. Sequences of newlines in the output
                are collapsed to a single space. Any trailing newline is
                deleted. The standard error is not returned, nor is any
                program exit status.</p><a></a><pre class="programlisting">stdout := $(shell echo normal message)
stderr := $(shell echo error message 1&gt;&amp;2)
shell-value:
        # $(stdout)
        # $(stderr)</pre><p>As you can see, messages to <em class="filename">stderr</em> are sent to the terminal as
                usual and so are not included in the output of the <code class="function">shell</code> function:</p><a></a><pre class="programlisting">$ make
error message
# normal message
#</pre><p>Here is a loop to create a set of directories:</p><a></a><pre class="programlisting">REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS); \
             do                               \
               [[ -d $$d ]] || mkdir -p $$d;  \
             done)</pre><p>Often, a <em class="filename">makefile</em>
                is easier to implement if essential output directories can be
                guaranteed to exist before any command scripts are executed.
                This variable creates the necessary directories by using a
                <em class="command">bash</em> shell "for" loop to
                ensure that a set of directories exists. The double square
                brackets are <em class="command">bash</em> test
                syntax similar to the <em class="command">test</em>
                program except that word splitting and pathname expansion are
                not performed. Therefore if the variable contains a filename
                with embedded spaces, the test still works correctly (and
                without quoting). By placing this <em class="command">make</em> variable assignment early in
                the <em class="filename">makefile</em>, we ensure
                it is executed before command scripts or other variables use
                the output directories. The actual value of <code class="literal">_MKDIRS</code> is irrelevant and <code class="literal">_MKDIRS</code> itself would never be
                used.</p></dd></dl></div><p><code class="function">shell</code>既然可以使用该功能<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1204" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1206" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1207" class="indexterm"></a>要调用任何外部程序，您应该小心如何使用它。特别是，您应该考虑简单变量和递归变量之间的区别。</p><p>Since the <code class="function">shell</code> function
          can be used <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>to invoke any external program, you should be careful
          how you use it. In particular, you should consider the distinction
          between simple variables and recursive variables.</p><a id="OEBPS/ch04s02.html.I_4_tt199"></a><pre class="programlisting">START_TIME := $(外壳日期)
CURRENT_TIME = $(外壳日期)</pre><pre class="programlisting">START_TIME   := $(shell date)
CURRENT_TIME =  $(shell date)</pre><p>当定义该变量时，该<code class="literal">START_TIME</code>变量会导致<em class="command">日期</em>命令执行一次。每次在<em class="filename">makefile</em>中使用该变量时，该<code class="literal">CURRENT_TIME</code>变量都会重新执行
          <em class="command">date</em>。<em class="filename"></em></p><p>The <code class="literal">START_TIME</code> variable
          causes the <em class="command">date</em> command to
          execute once when the variable is defined. The <code class="literal">CURRENT_TIME</code> variable will reexecute
          <em class="command">date</em> each time the variable is
          used in the <em class="filename">makefile</em>.</p><p>我们的工具箱现在已经足够编写一些相当有趣的函数了。这是一个用于测试值是否包含重复项的函数：</p><p>Our toolbox is now full enough to write some fairly
          interesting functions. Here is a function for testing whether a
          value contains duplicates:</p><a id="OEBPS/ch04s02.html.I_4_tt200"></a><pre class="programlisting"># $(调用有重复项，单词列表)
有重复项 = $(过滤器 \
                   $(单词$1) \
                   $(单词$(排序$1)))</pre><pre class="programlisting"># $(call has-duplicates, word-list)
has-duplicates = $(filter               \
                   $(words $1)          \
                   $(words $(sort $1)))</pre><p>我们计算列表和唯一列表中的单词，然后“比较”这两个数字。没有任何<em class="command">make</em>函数可以理解数字，只能理解字符串。要比较两个数字，我们必须将它们作为字符串进行比较。最简单的方法是使用<code class="function">filter</code>.我们在另一个数字中搜索一个数字。如果存在重复项，该<code class="function">has-duplicates</code>函数将为非空。</p><p>We count the words in the list and the unique list, then
          "compare" the two numbers. There are no <em class="command">make</em> functions that understand numbers,
          only strings. To compare two numbers, we must compare them as
          strings. The easiest way to do that is with <code class="function">filter</code>. We search for one number in the
          other number. The <code class="function">has-duplicates</code> function will be non-null
          if there are duplicates.</p><p>这是生成文件名的简单方法<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1208" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1209" class="indexterm"></a>带时间戳：</p><p>Here is a simple way to generate a filename <a class="indexterm"></a> <a class="indexterm"></a>with a timestamp:</p><a id="OEBPS/ch04s02.html.I_4_tt201"></a><pre class="programlisting">RELEASE_TAR := mpwm-$(shell 日期 +%F).tar.gz</pre><pre class="programlisting">RELEASE_TAR := mpwm-$(shell date +%F).tar.gz</pre><p>这会产生：</p><p>This produces:</p><a id="OEBPS/ch04s02.html.I_4_tt202"></a><pre class="programlisting">mpwm-2003-11-11.tar.gz</pre><pre class="programlisting">mpwm-2003-11-11.tar.gz</pre><p>我们可以生成相同的文件名并让<em class="command">date</em>完成更多工作：</p><p>We could produce the same filename and have <em class="command">date</em> do more of the work with:</p><a id="OEBPS/ch04s02.html.I_4_tt203"></a><pre class="programlisting">RELEASE_TAR := $(shell 日期 +mpwm-%F.tar.gz)</pre><pre class="programlisting">RELEASE_TAR := $(shell date +mpwm-%F.tar.gz)</pre><p>可以使用下一个函数来转换<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1210" class="indexterm"></a>相对路径（可能来自<em class="filename">com</em>目录）到完全限定的 Java 类名：</p><p>The next function can be used to convert <a class="indexterm"></a>relative paths (possibly from a <em class="filename">com</em> directory) into a fully qualified
          Java class name:</p><a id="OEBPS/ch04s02.html.I_4_tt204"></a><pre class="programlisting"># $(调用文件到类名，文件名)
文件到类名 := $(subst /,.,$(patsubst %.java,%,$1))</pre><pre class="programlisting"># $(call file-to-class-name, file-name)
file-to-class-name := $(subst /,.,$(patsubst %.java,%,$1))</pre><p><code class="function">subst</code>这种特殊的模式也可以用两个来完成：</p><p>This particular pattern can be accomplished with two <code class="function">subst</code>s as well:</p><a id="OEBPS/ch04s02.html.I_4_tt205"></a><pre class="programlisting"># $(调用文件到类名，文件名)
文件到类名 := $(subst /,.,$(subst .java,,$1))</pre><pre class="programlisting"># $(call file-to-class-name, file-name)
file-to-class-name := $(subst /,.,$(subst .java,,$1))</pre><p>然后我们可以使用这个函数来调用 Java 类，如下所示：</p><p>We can then use this function to invoke the Java class like
          this:</p><a id="OEBPS/ch04s02.html.I_4_tt206"></a><pre class="programlisting">CALIBRATE_ELEVATOR := com/wonka/CalibrateElevator.java
校准：
        $(JAVA) $(调用文件到类名,$(CALIBRATE_ELEVATOR))</pre><pre class="programlisting">CALIBRATE_ELEVATOR := com/wonka/CalibrateElevator.java
calibrate:
        $(JAVA) $(call file-to-class-name,$(CALIBRATE_ELEVATOR))</pre><p><code class="literal">$(sources)</code>如果上面有更多的父目录组件<code class="literal">com</code>，可以通过将目录树的根作为第一个参数传递，使用以下函数删除它们：<sup>[ <a id="OEBPS/ch04s02.html.make3-CHP-4-FNOTE-3" href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-3" class="footnote">3</a> ]</sup></p><p>If there are more parent directory components in <code class="literal">$(sources)</code> above <code class="literal">com</code>, they can be removed with the
          following function by passing the root of the directory tree as the
          first argument:<sup>[<a href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-3" class="footnote">3</a>]</sup></p><a id="OEBPS/ch04s02.html.I_4_tt207"></a><pre class="programlisting"># $(调用文件到类名、根目录、文件名)
文件到类名 := $(subst /,., \
                        $(subst .java,, \
                          $(替代$1/,,$2)))</pre><pre class="programlisting"># $(call file-to-class-name, root-dir, file-name)
file-to-class-name := $(subst /,.,          \
                        $(subst .java,,     \
                          $(subst $1/,,$2)))</pre><p>当阅读这样的函数时，通常最容易尝试从头到尾地理解它们。从最内部开始
          <code class="function">subst</code>，该函数删除 string <code class="literal">$1/</code>，然后删除字符串<em class="filename">.java</em>，最后将所有斜杠转换为句点。</p><p>When reading functions such as this, it is typically easiest
          to try to understand them inside out. Beginning at the inner-most
          <code class="function">subst</code>, the function removes the
          string <code class="literal">$1/</code>, then removes the
          string <em class="filename">.java</em>, and finally
          converts all slashes to periods.</p></div><div class="sect2" title="文件名函数"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.3"></a>文件名函数</h2><h2 class="title"><a></a>Filename Functions</h2></div></div></div><p><em class="filename">Makefile</em>编写者花费大量时间<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1211" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1212" class="indexterm"></a>处理文件。因此，有很多<em class="command">make</em>函数可以帮助完成这项任务也就不足为奇了。</p><p><em class="filename">Makefile</em> writers spend a
          lot of time <a class="indexterm"></a> <a class="indexterm"></a>handling files. So it isn't surprising there are a lot
          of <em class="command">make</em> functions to help with
          this task.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(wildcard</code>
              <code class="option">pattern</code> <code class="literal">. . .
              )</code></span></dt><dt><span class="term"><code class="literal">$(wildcard</code>
              <code class="option">pattern</code> <code class="literal">. . .
              )</code></span></dt><dd><p>通配符<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1213" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1214" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215" class="indexterm"></a><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a>在目标、先决条件和命令脚本的上下文中介绍了这些内容。但是，如果我们希望在另一个上下文中（例如变量定义）使用此功能怎么办？有了这个<code class="function">shell</code>函数，我们可以简单地使用子 shell 来扩展模式，但如果我们需要经常这样做，那会非常慢。相反，我们可以使用该<code class="function">wildcard</code>
                函数：</p><a id="OEBPS/ch04s02.html.I_4_tt208"></a><pre class="programlisting">来源 := $(通配符 *.c *.h)</pre><p>该<code class="function">wildcard</code>
                函数接受模式列表并对每个模式执行扩展。<sup>[ <a id="OEBPS/ch04s02.html.make3-CHP-4-FNOTE-4" href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-4" class="footnote">4</a> ]</sup>如果模式与任何文件都不匹配，则返回空字符串。与目标和先决条件中的通配符扩展一样，支持正常的 shell 通配符：<code class="literal">~</code>、<code class="literal">*</code>、<code class="literal">?</code>、<code class="literal">[...]</code>和<code class="literal">[^...]</code>。</p><p>的另一个用途<code class="function">wildcard</code>是测试条件中文件是否存在。当与<code class="function">if</code>函数（稍后描述）结合使用时，您经常会看到<code class="function">wildcard</code>参数根本不包含通配符的函数调用。例如，</p><a id="OEBPS/ch04s02.html.I_4_tt209"></a><pre class="programlisting">点-emacs-exists := $(通配符 ~/.emacs)</pre><p>如果用户的主目录不包含<em class="filename">.emacs</em>文件，将返回空字符串。</p></dd><dd><p>Wildcards <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>were covered in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>, in the context of
                targets, prerequisites, and command scripts. But what if we
                want this functionality in another context, say a variable
                definition? With the <code class="function">shell</code> function, we could simply use
                the subshell to expand the pattern, but that would be terribly
                slow if we needed to do this very often. Instead, we can use
                the <code class="function">wildcard</code>
                function:</p><a></a><pre class="programlisting">sources := $(wildcard *.c *.h)</pre><p>The <code class="function">wildcard</code>
                function accepts a list of patterns and performs expansion on
                each one.<sup>[<a href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-4" class="footnote">4</a>]</sup> If a pattern does not match any files, the empty
                string is returned. As with wildcard expansion in targets and
                prerequisites, the normal shell globbing characters are
                supported: <code class="literal">~</code>, <code class="literal">*</code>, <code class="literal">?</code>, <code class="literal">[...]</code>, and <code class="literal">[^...]</code>.</p><p>Another use of <code class="function">wildcard</code> is to test for the
                existence of a file in conditionals. When used in conjunction
                with the <code class="function">if</code> function
                (described shortly) you often see <code class="function">wildcard</code> function calls whose
                argument contains no wildcard characters at all. For
                instance,</p><a></a><pre class="programlisting">dot-emacs-exists := $(wildcard ~/.emacs)</pre><p>will return the empty string if the user's home
                directory does not contain a <em class="filename">.emacs</em> file.</p></dd><dt><span class="term"><code class="literal">$(dir</code>
              <code class="option">list</code> <code class="literal">. . .
              )</code></span></dt><dt><span class="term"><code class="literal">$(dir</code>
              <code class="option">list</code> <code class="literal">. . .
              )</code></span></dt><dd><p>这<code class="function">dir</code> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1217" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1218" class="indexterm"></a>函数返回 中每个单词的目录部分<code class="option">list</code>。以下是返回包含 C 文件的每个子目录的表达式：</p><a id="OEBPS/ch04s02.html.I_4_tt210"></a><pre class="programlisting">源目录 := $(排序 \
                 $(目录\
                   $(shell find .-name '*.c')))</pre><p>查找<em class="command">返回</em>所有源文件，然后该<code class="function">dir</code>函数剥离离开目录的文件部分，并且排序删除重复的目录。请注意，此变量定义使用一个简单变量，以避免每次使用该变量时重新执行查找<em class="command">（因为我们假设源文件在</em><em class="filename">makefile</em>执行期间不会自发出现和消失）。这是需要递归变量的函数实现：</p><a id="OEBPS/ch04s02.html.I_4_tt211"></a><pre class="programlisting"># $(调用源目录，目录列表)
源目录 = $(排序 \
                $(目录\
                  $(shell find $1 -name '*.c')))</pre><p>此版本接受以空格分隔的目录列表作为其第一个参数进行搜索。要<em class="command">查找的</em>第一个参数是要搜索的一个或多个目录。目录列表的末尾由第一个破折号参数识别。 （我几十年来都不知道的<em class="command">查找功能！）</em></p></dd><dd><p>The <code class="function">dir</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>function returns the directory portion of each
                word in <code class="option">list</code>. Here is an expression to return
                every subdirectory that contains C files:</p><a></a><pre class="programlisting">source-dirs := $(sort                          \
                 $(dir                         \
                   $(shell find . -name '*.c')))</pre><p>The <em class="command">find</em> returns all
                the source files, then the <code class="function">dir</code> function strips off the file
                portion leaving the directory, and the sort removes duplicate
                directories. Notice that this variable definition uses a
                simple variable to avoid reexecuting the <em class="command">find</em> each time the variable is used
                (since we assume source files will not spontaneously appear
                and disappear during the execution of the <em class="filename">makefile</em>). Here's a function
                implementation that requires a recursive variable:</p><a></a><pre class="programlisting"># $(call source-dirs, dir-list)
source-dirs = $(sort                             \
                $(dir                            \
                  $(shell find $1 -name '*.c')))</pre><p>This version accepts a space-separated directory list to
                search as its first parameter. The first arguments to <em class="command">find</em> are one or more directories to
                search. The end of the directory list is recognized by the
                first dash argument. (A <em class="command">find</em> feature I didn't know about for
                several decades!)</p></dd><dt><span class="term"><code class="literal">$(notdir</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dt><span class="term"><code class="literal">$(notdir</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dd><p>这<code class="function">notdir</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1220" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1221" class="indexterm"></a>函数返回文件路径的文件名部分。以下是从 Java 源文件返回 Java 类名的表达式：</p><a id="OEBPS/ch04s02.html.I_4_tt212"></a><pre class="programlisting"># $(调用 get-java-class-name, 文件名)
get-java-class-name = $(notdir $(subst .java,,$1))</pre><p>在许多情况下，<code class="function">dir</code>和<code class="function">notdir</code>可以一起使用来产生所需的输出。例如，假设必须在与其生成的输出文件相同的目录中执行自定义 shell 脚本。</p><a id="OEBPS/ch04s02.html.I_4_tt213"></a><pre class="programlisting">$(OUT)/myfile.out: $(SRC)/source1.in $(SRC)/source2.in
        cd $(目录$@); \
        生成 myfile $^ &gt; $(notdir $@)</pre><p><code class="literal">$@</code>代表目标的自动变量可以被分解以产生目标目录和文件作为单独的值。事实上，如果<code class="literal">OUT</code>是绝对路径，这里就没有必要使用该<code class="function">notdir</code>函数，但这样做会使输出更具可读性。</p><p>在命令脚本中，分解文件名的另一种方法是使用<code class="literal">$(@D)</code>
                和 ，如<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a><a class="link" href="#OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1" title="自动变量">2.2.1 节</a>中
                <code class="literal">$(@F)</code>所述
                。<a class="link" href="#OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1" title="自动变量"></a><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a></p></dd><dd><p>The <code class="function">notdir</code>
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> function returns the filename portion of a file
                path. Here is an expression to return the Java class name from
                a Java source file:</p><a></a><pre class="programlisting"># $(call get-java-class-name, file-name)
get-java-class-name = $(notdir $(subst .java,,$1))</pre><p>There are many instances where <code class="function">dir</code> and <code class="function">notdir</code> can be used together to
                produce the desired output. For instance, suppose a custom
                shell script must be executed in the same directory as the
                output file it generates.</p><a></a><pre class="programlisting">$(OUT)/myfile.out: $(SRC)/source1.in $(SRC)/source2.in
        cd $(dir $@); \
        generate-myfile $^ &gt; $(notdir $@)</pre><p>The automatic variable, <code class="literal">$@</code>, representing the target, can be
                decomposed to yield the target directory and file as separate
                values. In fact, if <code class="literal">OUT</code> is
                an absolute path, it isn't necessary to use the <code class="function">notdir</code> function here, but doing so
                will make the output more readable.</p><p>In command scripts, another way to decompose a filename
                is through the use of <code class="literal">$(@D)</code>
                and <code class="literal">$(@F)</code> as mentioned in
                <a class="link" href="#OEBPS/ch02s02.html.make3-CHP-2-SECT-2.1" title="Automatic Variables">Section 2.2.1</a> in
                <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>.</p></dd></dl></div><p>这里有添加和删除文件后缀等功能。</p><p>Here are functions for adding and removing file suffixes,
          etc.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(suffix</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dt><span class="term"><code class="literal">$(suffix</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dd><p>这<code class="function">suffix</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1223" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1224" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1225" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226" class="indexterm"></a>函数返回其参数中每个单词的后缀。这是一个测试列表中的所有单词是否具有相同后缀的函数：</p><a id="OEBPS/ch04s02.html.I_4_tt214"></a><pre class="programlisting"># $(调用相同后缀，文件列表)
相同后缀 = $(过滤器 1, $(单词 $(排序 $(后缀 $1))))</pre><p>该函数更常见的用法<code class="function">suffix</code>是在条件语句中与 结合使用<code class="function">findstring</code>。</p></dd><dd><p>The <code class="function">suffix</code>
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> function returns the suffix of each word in its
                argument. Here is a function to test whether all the words in
                a list have the same suffix:</p><a></a><pre class="programlisting"># $(call same-suffix, file-list)
same-suffix = $(filter 1, $(words $(sort $(suffix $1))))</pre><p>A more common use of the <code class="function">suffix</code> function is within
                conditionals in conjunction with <code class="function">findstring</code>.</p></dd><dt><span class="term"><code class="literal">$(basename</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dt><span class="term"><code class="literal">$(basename</code>
              <code class="option">name</code> <code class="literal">. . .
              )</code></span></dt><dd><p>功能<code class="function">basename</code>
                ​<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1227" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1229" class="indexterm"></a>是 的补集<code class="function">suffix</code>。它返回不带后缀的文件名。调用后任何引导路径组件都保持不变<code class="function">basename</code>。以下是用 重写的早期函数<code class="function">file-to-class-name</code>和函数：<code class="function">get-java-class-name</code><code class="function">basename</code></p><a id="OEBPS/ch04s02.html.I_4_tt215"></a><pre class="programlisting"># $(调用文件到类名、根目录、文件名)
文件到类名 := $(subst /,., \
                         $(基本名称\
                           $(替代$1/,,$2)))
# $(调用 get-java-class-name, 文件名)
get-java-class-name = $(notdir $(basename $1))</pre></dd><dd><p>The <code class="function">basename</code>
                function <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>is the complement of <code class="function">suffix</code>. It returns the filename
                without its suffix. Any leading path components remain intact
                after the <code class="function">basename</code> call.
                Here are the earlier <code class="function">file-to-class-name</code> and <code class="function">get-java-class-name</code> functions
                re-written with <code class="function">basename</code>:</p><a></a><pre class="programlisting"># $(call file-to-class-name, root-directory, file-name)
file-to-class-name  := $(subst /,.,          \
                         $(basename          \
                           $(subst $1/,,$2)))
# $(call get-java-class-name, file-name)
get-java-class-name =  $(notdir $(basename $1))</pre></dd><dt><span class="term"><code class="literal">$(addsuffix</code>
              <code class="option">suffix</code>,<code class="option">name</code> <code class="literal">. . . )</code></span></dt><dt><span class="term"><code class="literal">$(addsuffix</code>
              <code class="option">suffix</code>,<code class="option">name</code> <code class="literal">. . . )</code></span></dt><dd><p>功能<code class="function">addsuffix</code>
                ​<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1230" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1232" class="indexterm"></a>将给定<code class="option">suffix</code>文本附加到 中的每个单词<code class="option">name</code>。文本
                <code class="option">suffix</code>可以是任何内容。这是一个查找 中<code class="literal">PATH</code>与表达式匹配的所有文件的函数：</p><a id="OEBPS/ch04s02.html.I_4_tt216"></a><pre class="programlisting"># $(调用查找程序，过滤器模式)
查找程序 = $(过滤 $1, \
                 $(通配符\
                   $(添加后缀 /*, \
                     $(排序\
                       $(替换:,,\
                         $(subst::,:.:, \
                           $(patsubst :%,.:%, \
                             $(patsubst %:,%:.,$(路径)))))))))
寻找：
        @echo $(words $(调用 find-program, %))</pre><p>最里面的三个替换说明了 shell 语法中的特殊情况。空路径部分表示当前目录。为了规范化这种特殊语法，我们按顺序搜索空尾随路径组件、空前导路径组件和空内部路径组件。任何匹配的组件都替换为“.”。接下来，将路径分隔符替换为空格以创建单独的单词。该<code class="function">sort</code>函数用于去除重复的路径成分。然后将通配后缀<em class="filename">/*</em>附加到每个单词并<code class="function">wildcard</code>调用以扩展通配表达式。最后，通过 提取所需的模式<code class="function">filter</code>。</p><p>虽然这看起来是一个运行起来非常慢的函数（而且很可能在许多系统上），但在我的 1.9 GHz P4（具有 512 MB）上，该函数在 0.20 秒内执行并找到 4,335 个程序。通过将<code class="literal">$1</code>调用中的参数移至 ，可以提高此性能
                <code class="function">wildcard</code>。以下版本消除了对调用者参数的调用<code class="function">filter</code>并更改<code class="function">addsuffix</code>为使用调用者的参数。</p><a id="OEBPS/ch04s02.html.I_4_tt217"></a><pre class="programlisting"># $(调用查找程序,通配符模式)
查找程序 = $(通配符 \
                 $(添加后缀/$1,\
                   $(排序\
                     $(替换:,,\
                       $(subst::,:.:, \
                         $(patsubst :%,.:%, \
                           $(patsubst %:,%:.,$(路径))))))))
寻找：
        @echo $(words $(调用 find-program,*))</pre><p>该版本运行时间为 0.17 秒。它运行得更快，因为<code class="function">wildcard</code>不再返回每个文件只是为了让函数稍后使用<code class="function">filter</code>. <acronym class="acronym">GNU </acronym> <em class="command">make</em>手册中也有类似的例子。另请注意，第一个版本使用<code class="function">filter</code>-style 通配模式（<code class="literal">%</code>仅使用），而第二个版本使用<code class="function">wildcard</code>-style 通配模式（<code class="literal">~</code>、<code class="literal">*</code>、<code class="literal">?</code>、<code class="literal">[...]</code>和<code class="literal">[^...]</code>）。</p></dd><dd><p>The <code class="function">addsuffix</code>
                function <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>appends the given <code class="option">suffix</code> text
                to each word in <code class="option">name</code>. The
                <code class="option">suffix</code> text can be anything. Here is a
                function to find all the files in the <code class="literal">PATH</code> that match an
                expression:</p><a></a><pre class="programlisting"># $(call find-program, filter-pattern)
find-program = $(filter $1,                     \
                 $(wildcard                     \
                   $(addsuffix /*,              \
                     $(sort                     \
                       $(subst :, ,             \
                         $(subst ::,:.:,        \
                           $(patsubst :%,.:%,   \
                             $(patsubst %:,%:.,$(PATH)))))))))
find:
        @echo $(words $(call find-program, %))</pre><p>The inner-most three substitutions account for a special
                case in shell syntax. An empty path component is taken to mean
                the current directory. To normalize this special syntax we
                search for an empty trailing path component, an empty leading
                path component, and an empty interior path component, in that
                order. Any matching components are replaced with ".". Next,
                the path separator is replaced with a space to create separate
                words. The <code class="function">sort</code> function
                is used to remove repeated path components. Then the globbing
                suffix <em class="filename">/*</em> is appended to
                each word and <code class="function">wildcard</code> is
                invoked to expand the globbing expressions. Finally, the
                desired patterns are extracted by <code class="function">filter</code>.</p><p>Although this may seem like an extremely slow function
                to run (and it may well be on many systems), on my 1.9 GHz P4
                with 512 MB this function executes in 0.20 seconds and finds
                4,335 programs. This performance can be improved by moving the
                <code class="literal">$1</code> argument inside the call
                to <code class="function">wildcard</code>. The
                following version eliminates the call to <code class="function">filter</code> and changes <code class="function">addsuffix</code> to use the caller's
                argument.</p><a></a><pre class="programlisting"># $(call find-program,wildcard-pattern)
find-program = $(wildcard                       \
                 $(addsuffix /$1,               \
                   $(sort                       \
                     $(subst :, ,               \
                       $(subst ::,:.:,          \
                         $(patsubst :%,.:%,     \
                           $(patsubst %:,%:.,$(PATH))))))))
find:
        @echo $(words $(call find-program,*))</pre><p>This version runs in 0.17 seconds. It runs faster
                because <code class="function">wildcard</code> no
                longer returns every file only to make the function discard
                them later with <code class="function">filter</code>. A
                similar example occurs in the <acronym class="acronym">GNU</acronym> <em class="command">make</em> manual. Notice also that the
                first version uses <code class="function">filter</code>-style globbing patterns
                (using <code class="literal">%</code> only) while the
                second version uses <code class="function">wildcard</code>-style globbing patterns
                (<code class="literal">~</code>, <code class="literal">*</code>, <code class="literal">?</code>, <code class="literal">[...]</code>, and <code class="literal">[^...]</code>).</p></dd><dt><span class="term"><code class="literal">$(addprefix</code>
              <code class="option">prefix</code>,<code class="option">name</code> <code class="literal">. . . )</code></span></dt><dt><span class="term"><code class="literal">$(addprefix</code>
              <code class="option">prefix</code>,<code class="option">name</code> <code class="literal">. . . )</code></span></dt><dd><p>这<code class="function">addprefix</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1234" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1235" class="indexterm"></a>函数是 的补集<code class="function">addsuffix</code>。下面是一个测试一组文件是否存在且非空的表达式：</p><a id="OEBPS/ch04s02.html.I_4_tt218"></a><pre class="programlisting"># $(调用有效文件，文件列表)
有效文件=测试-s。 $(addprefix -a -s ,$1)</pre><p>此函数与前面的大多数示例不同，因为它旨在在命令脚本中执行。它使用 shell 的<em class="command">测试</em>程序和
                <code class="option">-s</code>选项（“如果文件存在且不为空则为 true”）来执行测试。由于<em class="command">测试</em>命令需要多个文件名之间有一个
                <code class="option">-a</code>（和）选项，
                因此在每个文件名之前<code class="function">addprefix</code>添加
                <code class="option">-a</code>。用于启动“与”链的第一个文件是点，它总是产生 true。</p></dd><dd><p>The <code class="function">addprefix</code>
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> function is the complement of <code class="function">addsuffix</code>. Here is an expression to
                test whether a set of files exists and is nonempty:</p><a></a><pre class="programlisting"># $(call valid-files, file-list)
valid-files = test -s . $(addprefix -a -s ,$1)</pre><p>This function is different from most of the previous
                examples in that it is intended to be executed in a command
                script. It uses the shell's <em class="command">test</em> program with the
                <code class="option">-s</code> option ("true if the file exists and is
                not empty") to perform the test. Since the <em class="command">test</em> command requires a
                <code class="option">-a</code> (and) option between multiple filenames,
                <code class="function">addprefix</code> prepends the
                <code class="option">-a</code> before each filename. The first file used
                to start the "and" chain is dot, which always yields
                true.</p></dd><dt><span class="term"><code class="literal">$(join</code>
              <code class="option">prefix-list</code>,<code class="option">suffix-list</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(join</code>
              <code class="option">prefix-list</code>,<code class="option">suffix-list</code>
              <code class="literal">)</code></span></dt><dd><p>这<code class="function">join</code> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1237" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1238" class="indexterm"></a><code class="function">dir</code>函数是和的补集<code class="function">notdir</code>。它接受两个列表，并将第一个元素 from
                <code class="option">prefix-list</code>与第一个元素 from
                连接起来<code class="option">suffix-list</code>，然后将第二个元素 from
                <code class="option">prefix-list</code>与第二个元素
                连接<code class="option">suffix-list</code>起来，依此类推。它可用于重建用<code class="function">dir</code>和分解的列表<code class="function">notdir</code>。</p></dd><dd><p>The <code class="function">join</code> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>function is the complement of <code class="function">dir</code> and <code class="function">notdir</code>. It accepts two lists and
                concatenates the first element from
                <code class="option">prefix-list</code> with the first element from
                <code class="option">suffix-list</code>, then the second element from
                <code class="option">prefix-list</code> with the second element from
                <code class="option">suffix-list</code> and so on. It can be used to
                reconstruct lists decomposed with <code class="function">dir</code> and <code class="function">notdir</code>.</p></dd></dl></div></div><div class="sect2" title="流量控制"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4"></a>流量控制</h2><h2 class="title"><a></a>Flow Control</h2></div></div></div><p>因为许多<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1239" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1240" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1241" class="indexterm"></a>到目前为止我们看到的函数都是为了在列表上执行操作而实现的，即使没有循环结构，它们也能很好地工作。但如果没有真正的循环运算符和某种条件处理，<em class="command">make</em>宏语言确实会非常有限。幸运的是，<em class="command">make</em>
          提供了这两种语言功能。我还在本节中加入了致命<code class="function">error</code>
          函数，这显然是一种非常极端的流量控制形式！</p><p>Because many of the <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>functions we have seen so far are implemented to
          perform their operations on lists, they work well even without a
          looping construct. But without a true looping operator and
          conditional processing of some kind the <em class="command">make</em> macro language would be very limited,
          indeed. Fortunately, <em class="command">make</em>
          provides both of these language features. I have also thrown into
          this section the fatal <code class="function">error</code>
          function, clearly a very extreme form of flow control!</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(if</code>
              <code class="option">condition</code>, <code class="option">then-part</code>,<code class="option">else-part</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(if</code>
              <code class="option">condition</code>,<code class="option">then-part</code>,<code class="option">else-part</code>
              <code class="literal">)</code></span></dt><dd><p>这<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1242" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1243" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1244" class="indexterm"></a> <code class="function">if</code>
                函数（不要与
                <a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>中讨论的条件指令<code class="literal">ifeq</code>、<code class="literal">ifneq</code>、<code class="literal">ifdef</code>和混淆）根据条件表达式的“值”选择两个宏扩展之一。如果其扩展包含任何字符（甚至空格），则为 true 。在这种情况下，被扩展。否则，如果 的扩展为空，则为 false，并且被扩展。<sup>[ </sup><sup><a id="OEBPS/ch04s02.html.make3-CHP-4-FNOTE-5" href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-5" class="footnote">5</a></sup><sup> ]</sup><code class="literal">ifndef</code><a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><code class="option">condition</code><code class="option">then-part</code><code class="option">condition</code><code class="option">else-part</code><sup><a id="OEBPS/ch04s02.html.make3-CHP-4-FNOTE-5" href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-5" class="footnote"></a></sup></p><p>这是测试 makefile 是否<em class="filename">在</em>Windows 上运行的简单方法。查找<code class="literal">COMSPEC</code>
                仅在 Windows 上定义的环境变量：</p><a id="OEBPS/ch04s02.html.I_4_tt219"></a><pre class="programlisting">PATH_SEP := $(如果 $(COMSPEC),;,:)</pre><p><em class="command">make</em><code class="option">condition</code>通过首先删除前导和尾随空格，然后扩展表达式来计算
                。如果扩展产生任何字符（包括空格），则表达式为 true。现在<code class="literal">PATH_SEP</code>包含在路径中使用的正确字符，无论<em class="filename">makefile</em>是在 Windows 还是 Unix 上运行。</p><p>在上一章中，我们提到如果您使用一些最新功能（例如），请检查<em class="command">make</em>的版本。和<code class="function">eval</code>函数经常一起使用来测试字符串的值：<code class="function">if</code><code class="function">filter</code></p><a id="OEBPS/ch04s02.html.I_4_tt220"></a><pre class="programlisting">$(如果$(过滤器$(MAKE_VERSION),3.80),,\
  $(错误此 makefile 需要 GNU make 版本 3.80。))</pre><p>现在，随着<em class="command">make</em>的后续版本发布，该表达式可以用更可接受的版本进行扩展：</p><a id="OEBPS/ch04s02.html.I_4_tt221"></a><pre class="programlisting">$(如果$(过滤器$(MAKE_VERSION),3.80 3.81 3.90 3.92),,\
  $(错误此 makefile 需要 GNU make 版本之一....))</pre><p>这种技术的缺点是当安装新版本的<em class="command">make</em>时必须更新代码。但这种情况并不经常发生。 （例如，自 2002 年 10 月以来，3.80 一直是发布版本。）上述测试可以
                作为顶级表达式添加到<em class="filename">makefile</em><code class="function">if</code>中，因为
                如果为 true，则崩溃为空，否则<code class="function">error</code>终止<em class="command">make</em>。</p></dd><dd><p>The<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <code class="function">if</code>
                function (not to be confused with the conditional directives
                <code class="literal">ifeq</code>, <code class="literal">ifneq</code>, <code class="literal">ifdef</code>, and <code class="literal">ifndef</code> discussed in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>) selects one of two
                macro expansions depending on the "value" of the conditional
                expression. The <code class="option">condition</code> is true if its
                expansion contains any characters (even space). In this case,
                the <code class="option">then-part</code> is expanded. Otherwise, if the
                expansion of <code class="option">condition</code> is empty, it is false
                and the <code class="option">else-part</code> is expanded.<sup>[<a href="#OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-5" class="footnote">5</a>]</sup></p><p>Here is an easy way to test whether the <em class="filename">makefile</em> is running on Windows.
                Look for the <code class="literal">COMSPEC</code>
                environment variable defined only on Windows:</p><a></a><pre class="programlisting">PATH_SEP := $(if $(COMSPEC),;,:)</pre><p><em class="command">make</em> evaluates the
                <code class="option">condition</code> by first removing leading and
                trailing whitespace, then expanding the expression. If the
                expansion yields any characters (including whitespace), the
                expression is true. Now <code class="literal">PATH_SEP</code> contains the proper
                character to use in paths, whether the <em class="filename">makefile</em> is running on Windows or
                Unix.</p><p>In the last chapter, we mentioned checking the version
                of <em class="command">make</em> if you use some of
                the newest features (like <code class="function">eval</code>). The <code class="function">if</code> and <code class="function">filter</code> functions are often used
                together to test the value of a string:</p><a></a><pre class="programlisting">$(if $(filter $(MAKE_VERSION),3.80),,\
  $(error This makefile requires GNU make version 3.80.))</pre><p>Now, as subsequent versions of <em class="command">make</em> are released, the expression
                can be extended with more acceptable versions:</p><a></a><pre class="programlisting">$(if $(filter $(MAKE_VERSION),3.80 3.81 3.90 3.92),,\
  $(error This makefile requires one of GNU make version ....))</pre><p>This technique has the disadvantage that the code must
                be updated when a new version of <em class="command">make</em> is installed. But that doesn't
                happen very often. (For instance, 3.80 has been the release
                version since October 2002.) The above test can be added to a
                <em class="filename">makefile</em> as a top-level
                expression since the <code class="function">if</code>
                collapses to nothing if true and <code class="function">error</code> terminates the <em class="command">make</em> otherwise.</p></dd><dt><span class="term"><code class="literal">$(error</code>
              <code class="option">text</code>）</span></dt><dt><span class="term"><code class="literal">$(error</code>
              <code class="option">text</code>)</span></dt><dd><p>功能<code class="function">error</code>​
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1245" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1246" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1247" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1248" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1249" class="indexterm"></a>用于打印致命错误消息。函数打印其消息后，<em class="command">make</em>以退出状态 2 终止。输出以当前
                <em class="filename">makefile</em>的名称、当前行号和消息文本为前缀。以下是<em class="command">make</em><code class="function">assert</code>
                的常见编程结构的实现：<em class="command"></em></p><a id="OEBPS/ch04s02.html.I_4_tt222"></a><pre class="programlisting"># $(调用断言,条件,消息)
定义断言
  $(如果 $1,,$(错误断言失败: $2))
恩德夫
# $(调用断言文件存在，通配符模式)
定义断言文件存在
  $(调用断言,$(通配符$1),$1不存在)
恩德夫
# $(调用断言非空，make-variable)
定义断言非空
  $(调用断言,$($1),变量“$1”为空)
恩德夫
错误退出：
        $(调用断言-not-null,NON_EXISTENT)</pre><p>第一个函数 ,<code class="function">assert</code>只是<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1250" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1251" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1252" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1253" class="indexterm"></a>测试其第一个参数，如果为空则打印用户的错误消息。第二个函数建立在第一个函数的基础上，并测试通配符模式是否生成现有文件。请注意，该参数可以包含任意数量的通配模式。</p><p>第三个函数是一个非常有用的断言
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1254" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255" class="indexterm"></a>依赖于<em class="firstterm">计算变量</em>。<em class="command">make</em>变量可以包含任何内容，包括另一个<em class="command">make</em>变量的名称。但是，如果一个变量包含另一个变量的名称，如何访问另一个变量的值呢？嗯，非常简单，只需将变量扩展两次：</p><a id="OEBPS/ch04s02.html.I_4_tt223"></a><pre class="programlisting">NO_SPACE_MSG := 设备上没有剩余空间。
NO_FILE_MSG := 未找到文件。
...;
STATUS_MSG := NO_SPACE_MSG
$(错误$($(STATUS_MSG)))</pre><p>为了保持简单，这个示例稍微做了一些设计，但这里<code class="literal">STATUS_MSG</code>通过存储错误消息变量名称来设置多个错误消息之一。当需要打印消息时，
                <code class="literal">STATUS_MSG</code>首先扩展以访问错误消息变量名称，<code class="literal">$(STATUS_MSG)</code>然后再次扩展以访问消息文本，<code class="literal">$($(STATUS_MSG)</code>）。在我们的<code class="function">assert-not-null</code>函数中，我们假设函数的参数是<em class="command">make</em>变量
                的<span class="emphasis"><em>名称</em></span>。我们首先扩展参数来访问变量名称，然后再次扩展) 来确定它是否有值。如果它为空，那么我们就可以在错误消息中使用变量名称。<em class="command"></em><code class="literal">$1</code><code class="literal">$($1</code><code class="literal">$1</code></p><a id="OEBPS/ch04s02.html.I_4_tt224"></a><pre class="programlisting">$ 制作
Makefile:14: *** 断言失败：变量“NON_EXISTENT”为空。停止。</pre><p>还有一个<code class="function">warning</code>函数（参见本章后面的<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.5" title="不太重要的杂项功能">4.2.5 节</a>）以与 相同的格式打印消息
                <code class="function">error</code>，但不终止<em class="command">make</em>。</p></dd><dd><p>The <code class="function">error</code> function
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>is used for printing fatal error messages. After
                the function prints its message, <em class="command">make</em> terminates with an exit status
                of 2. The output is prefixed with the name of the current
                <em class="filename">makefile</em>, the current
                line number, and the message text. Here is an implementation
                of the common <code class="function">assert</code>
                programming construct for <em class="command">make</em>:</p><a></a><pre class="programlisting"># $(call assert,condition,message)
define assert
  $(if $1,,$(error Assertion failed: $2))
endef
# $(call assert-file-exists,wildcard-pattern)
define assert-file-exists
  $(call assert,$(wildcard $1),$1 does not exist)
endef
# $(call assert-not-null,make-variable)
define assert-not-null
  $(call assert,$($1),The variable "$1" is null)
endef
error-exit:
        $(call assert-not-null,NON_EXISTENT)</pre><p>The first function, <code class="function">assert</code>, just <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>tests its first argument and prints the user's
                error message if it is empty. The second function builds on
                the first and tests that a wildcard pattern yields an existing
                file. Note that the argument can include any number of
                globbing patterns.</p><p>The third function is a very useful assert that
                <a class="indexterm"></a> <a class="indexterm"></a>relies on <em class="firstterm">computed
                variables</em>. A <em class="command">make</em> variable can contain anything,
                including the name of another <em class="command">make</em> variable. But if a variable
                contains the name of another variable how can you access the
                value of that other variable? Well, very simply by expanding
                the variable twice:</p><a></a><pre class="programlisting">NO_SPACE_MSG := No space left on device.
NO_FILE_MSG  := File not found.
...;
STATUS_MSG   := NO_SPACE_MSG
$(error $($(STATUS_MSG)))</pre><p>This example is slightly contrived to keep it simple,
                but here <code class="literal">STATUS_MSG</code> is set
                to one of several error messages by storing the error message
                variable name. When it comes time to print the message,
                <code class="literal">STATUS_MSG</code> is first
                expanded to access the error message variable name, <code class="literal">$(STATUS_MSG)</code>, then expanded again
                to access the message text, <code class="literal">$($(STATUS_MSG)</code>). In our <code class="function">assert-not-null</code> function we assume
                the argument to the function is the <span class="emphasis"><em>name</em></span>
                of a <em class="command">make</em> variable. We
                first expand the argument, <code class="literal">$1</code>, to access the variable name,
                then expand again, <code class="literal">$($1</code>),
                to determine if it has a value. If it is null, then we have
                the variable name right in <code class="literal">$1</code> to use in the error
                message.</p><a></a><pre class="programlisting">$ make
Makefile:14: *** Assertion failed: The variable "NON_EXISTENT" is null.  Stop.</pre><p>There is also a <code class="function">warning</code> function (see the <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.5" title="Less Important Miscellaneous Functions">Section 4.2.5</a> later in
                this chapter) that prints a message in the same format as
                <code class="function">error</code>, but does not
                terminate <em class="command">make</em>.</p></dd><dt><span class="term"><code class="literal">$(foreach</code>
              <code class="option">variable</code>, <code class="option">list</code>,<code class="option">body</code>
              <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(foreach</code>
              <code class="option">variable</code>,<code class="option">list</code>,<code class="option">body</code>
              <code class="literal">)</code></span></dt><dd><p>这<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1256" class="indexterm"></a> <code class="function">foreach</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1257" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1258" class="indexterm"></a>函数提供了一种方法<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1259" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1260" class="indexterm"></a>重复扩展文本，同时将不同的值替换到每个扩展中。请注意，这与使用不同参数重复执行函数不同（尽管它也可以做到这一点）。例如：</p><a id="OEBPS/ch04s02.html.I_4_tt225"></a><pre class="programlisting">字母 := $(对于每个字母,abcd,$(字母))
显示词：
        # 个字母有 $(单词 $(字母)) 个单词： '$(字母)'
$ 制作
# 个字母有 4 个单词：'abc d'</pre><p>执行此命令时<code class="function">foreach</code>
                ，它将循环控制变量 设定<code class="literal">letter</code>为 中的每个值，<code class="option">a b
                c d</code>并为每个值扩展循环体<code class="literal">$(letter)</code>一次。扩展的文本通过空格分隔每个扩展来累积。</p></dd><dd><p>The <a class="indexterm"></a> <code class="function">foreach</code>
                <a class="indexterm"></a> <a class="indexterm"></a> function provides a way to <a class="indexterm"></a> <a class="indexterm"></a>expand text repeatedly while substituting
                different values into each expansion. Notice that this is
                different from executing a function repeatedly with different
                arguments (although it can do that, too). For example:</p><a></a><pre class="programlisting">letters := $(foreach letter,a b c d,$(letter))
show-words:
        # letters has $(words $(letters)) words: '$(letters)'
$ make
# letters has 4 words: 'a b c d'</pre><p>When this <code class="function">foreach</code>
                is executed, it sets the loop control variable, <code class="literal">letter</code>, to each value in <code class="option">a b
                c d</code> and expands the body of the loop, <code class="literal">$(letter)</code>, once for each value. The
                expanded text is accumulated with a space separating each
                expansion.</p></dd></dl></div><p>这是一个测试是否设置了一组变量的函数：</p><p>Here is a function to test if a set of variables is
          set:</p><a id="OEBPS/ch04s02.html.I_4_tt226"></a><pre class="programlisting">VARIABLE_LIST := 源对象主页
$(foreach i,$(VARIABLE_LIST), \
  $(如果$($i),,\
    $(shell echo $i 没有值 &gt; /dev/stderr)))</pre><pre class="programlisting">VARIABLE_LIST := SOURCES OBJECTS HOME
$(foreach i,$(VARIABLE_LIST), \
  $(if $($i),,                \
    $(shell echo $i has no value &gt; /dev/stderr)))</pre><p>（函数中的伪文件<em class="filename">/dev/stderr</em><code class="function">shell</code>需要设置<code class="literal">SHELL</code>为<em class="command">bash</em>。）此循环<code class="literal">i</code>设置<code class="literal">VARIABLE_LIST</code>.第一个中的测试表达式<code class="literal">if</code>求值<code class="literal">$i</code>以获取变量名称，然后在计算表达式中再次求值<code class="literal">$($i)</code>以查看它是否为非空。如果表达式有值，则该<em class="replaceable"><code>then</code></em>部分不执行任何操作；否则，该<em class="replaceable"><code>else</code></em>部件将打印警告。请注意，如果我们省略 echo 的重定向，则命令的输出<code class="function">shell</code>
          将被替换到<em class="filename">makefile</em>中，从而产生语法错误。如图所示，整个<code class="function">foreach</code>循环扩展为空。</p><p>(The pseudo file <em class="filename">/dev/stderr</em> in the <code class="function">shell</code> function requires setting <code class="literal">SHELL</code> to <em class="command">bash</em>.) This loop sets <code class="literal">i</code> to each word of <code class="literal">VARIABLE_LIST</code>. The test expression inside
          the <code class="literal">if</code> first evaluates <code class="literal">$i</code> to get the variable name, then
          evaluates this again in a computed expression <code class="literal">$($i)</code> to see if it is non-null. If the
          expression has a value, the <em class="replaceable"><code>then</code></em> part
          does nothing; otherwise, the <em class="replaceable"><code>else</code></em> part
          prints a warning. Note that if we omit the redirection from the
          echo, the output of the <code class="function">shell</code>
          command will be substituted into the <em class="filename">makefile</em>, yielding a syntax error. As
          shown, the entire <code class="function">foreach</code> loop
          expands to nothing.</p><p>正如之前所承诺的，这里是一个从列表中收集包含子字符串的所有单词的函数：</p><p>As promised earlier, here is a function that gathers all the
          words that contain a substring from a list:</p><a id="OEBPS/ch04s02.html.I_4_tt227"></a><pre class="programlisting"># $(调用 grep 字符串、搜索字符串、单词列表)
定义 grep 字符串
$(条\
  $(foreach w, $2, \
    $(if $(findstring $1, $w), \
      $w)))
恩德夫
单词 := count_words.c counter.c lexer.l lexer.h counter.h
查词：
        @echo $(调用 grep-string,un,$(words))</pre><pre class="programlisting"># $(call grep-string, search-string, word-list)
define grep-string
$(strip                                         \
  $(foreach w, $2,                               \
    $(if $(findstring $1, $w),                   \
      $w)))
endef
words := count_words.c counter.c lexer.l lexer.h counter.h
find-words:
        @echo $(call grep-string,un,$(words))</pre><p>不幸的是，这个函数不接受模式，但它确实找到简单的子字符串：</p><p>Unfortunately, this function does not accept patterns, but it
          does find simple substrings:</p><a id="OEBPS/ch04s02.html.I_4_tt228"></a><pre class="programlisting">$ 制作
count_words.c counter.c counter.h</pre><pre class="programlisting">$ make
count_words.c counter.c counter.h</pre><div class="sect3" title="关于变量和括号的样式注释"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4.1"></a>关于变量和括号的样式注释</h3><h3 class="title"><a></a>Style note concerning variables and parentheses</h3></div></div></div><p>如前所述，括号<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1262" class="indexterm"></a>对于一个字符的<em class="command">make</em>变量来说不需要。例如，所有基本自动变量都是一个字符。即使在<acronym class="acronym">GNU </acronym> <em class="command">make</em>手册中，自动变量也普遍不带括号。然而，<em class="command">make</em>手册几乎对所有其他变量（甚至单个字符变量）都使用括号，并强烈敦促用户效仿。这突出了<em class="command">make</em>变量的特殊性质
            ，因为几乎所有其他具有“美元变量”的程序（例如 shell、<em class="command">perl</em>、<em class="command">awk</em>、<em class="command">yacc</em>等）都不需要括号。最常见的<em class="command">make</em>编程错误之一
            是忘记括号。以下是<code class="literal">foreach</code>包含错误的常见用法：</p><p>As noted earlier, parentheses<a class="indexterm"></a> <a class="indexterm"></a> are not required for <em class="command">make</em> variables of one character. For
            instance, all of the basic automatic variables are one character.
            Automatic variables are universally written without parentheses
            even in the <acronym class="acronym">GNU</acronym> <em class="command">make</em> manual. However, the <em class="command">make</em> manual uses parentheses for
            virtually all other variables, even single character variables,
            and strongly urges users to follow suit. This highlights the
            special nature of <em class="command">make</em>
            variables since almost all other programs that have "dollar
            variables" (such as shells, <em class="command">perl</em>, <em class="command">awk</em>, <em class="command">yacc</em>, etc.) don't require parentheses.
            One of the more common <em class="command">make</em>
            programming errors is forgetting parentheses. Here is a common use
            of <code class="literal">foreach</code> containing the
            error:</p><a id="OEBPS/ch04s02.html.I_4_tt229"></a><pre class="programlisting">包括_目录:= ...
包括 := $(foreach i,$INCLUDE_DIRS,-I $i)
# INCLUDES 现在的值为“-I NCLUDE_DIRS”</pre><pre class="programlisting">INCLUDE_DIRS := ...
INCLUDES := $(foreach i,$INCLUDE_DIRS,-I $i)
# INCLUDES now has the value "-I NCLUDE_DIRS"</pre><p>然而，我发现通过明智地使用单字符变量并省略不必要的括号，可以更容易地读取宏。例如，我认为
            <code class="function">has-duplicates</code>没有完整括号的函数更容易阅读：</p><p>However, I find that reading macros can be much easier
            through the judicious use of single-character variables and
            omitting unnecessary parentheses. For instance, I think the
            <code class="function">has-duplicates</code> function is
            easier to read without full parentheses:</p><a id="OEBPS/ch04s02.html.I_4_tt230"></a><pre class="programlisting"># $(调用有重复项，单词列表)
有重复项 = $(过滤器 \
                   $(单词$1) \
                   $(单词$(排序$1))))</pre><pre class="programlisting"># $(call has-duplicates, word-list)
has-duplicates = $(filter               \
                   $(words $1)          \
                   $(words $(sort $1))))</pre><p>相对：</p><p>versus:</p><a id="OEBPS/ch04s02.html.I_4_tt231"></a><pre class="programlisting"># $(调用有重复项，单词列表)
有重复项 = $(过滤器 \
                   $(单词$(1)) \
                   $(单词$(排序$(1)))))</pre><pre class="programlisting"># $(call has-duplicates, word-list)
has-duplicates = $(filter                 \
                   $(words $(1))          \
                   $(words $(sort $(1)))))</pre><p>然而，<code class="function">kill-program</code>使用完整的括号该函数可能更具可读性，因为它将有助于区分
            <em class="command">make</em>变量与 shell 变量或其他程序中使用的变量：</p><p>However, the <code class="function">kill-program</code> function might be more
            readable with full parentheses since it would help distinguish
            <em class="command">make</em> variables from shell
            variables or variables used in other programs:</p><a id="OEBPS/ch04s02.html.I_4_tt232"></a><pre class="programlisting">定义终止程序
  @ $(PS) $(PS_FLAGS) | \
  $(AWK) '开始 { FieldWIDTHS = $(PS_FIELDS) } \
          /$(1)/{ \
                  打印“杀死”$$3； \
                  系统(“$(KILL)$(KILLFLAGS)”$$1)\
                }'
恩德夫</pre><pre class="programlisting">define kill-program
  @ $(PS) $(PS_FLAGS) |                                 \
  $(AWK) 'BEGIN { FIELDWIDTHS = $(PS_FIELDS) }          \
          /$(1)/{                                       \
                  print "Killing " $$3;                 \
                  system( "$(KILL) $(KILLFLAGS) " $$1 ) \
                }'
endef</pre><p>搜索字符串包含宏的第一个参数
            <code class="literal">$(1)</code>。<code class="literal">$$3</code>并<code class="literal">$$1</code>引用<em class="command">awk</em>变量。</p><p>The search string contains the first parameter to the macro,
            <code class="literal">$(1)</code>. <code class="literal">$$3</code> and <code class="literal">$$1</code> refer to <em class="command">awk</em> variables.</p><p>我使用单字符变量，并且仅在看起来使代码更具可读性时才省略括号。我通常对宏的参数和
            <code class="function">foreach</code>循环中的控制变量执行此操作。您应该遵循适合您情况的风格。如果您对<em class="filename">makefile</em>的可维护性有任何疑问，请遵循<em class="command">make</em>手册的建议并使用完整的括号。请记住，<em class="command">make</em>
            程序就是为了缓解与维护软件相关的问题。如果您在编写<em class="filename">makefile</em>时牢记这一点
            ，那么您很可能会避免麻烦。</p><p>I use single-character variables and omit the parentheses
            only when it seems to make the code more readable. I typically do
            this for the parameters to macros and the control variable in
            <code class="function">foreach</code> loops. You should
            follow a style that suits your situation. If you have any doubts
            about the maintainability of your <em class="filename">makefile</em>s, follow the <em class="command">make</em> manual's suggestion and use full
            parentheses. Remember, the <em class="command">make</em>
            program is all about easing the problems associated with
            maintaining software. If you keep that in mind as you write your
            <em class="filename">makefile</em>s, you will most
            likely stay clear of trouble.</p></div></div><div class="sect2" title="不太重要的杂项功能"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s02.html.make3-CHP-4-SECT-2.5"></a>不太重要的杂项功能</h2><h2 class="title"><a></a>Less Important Miscellaneous Functions</h2></div></div></div><p>最后，我们有一些杂项（但重要）的字符串函数。虽然与<code class="function">foreach</code>或相比较小<code class="function">call</code>，但您会发现自己经常使用它们。</p><p>Finally, we have some miscellaneous (but important) string
          functions. Although minor in comparison with <code class="function">foreach</code> or <code class="function">call</code>, you'll find yourself using these
          very often.</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">$(strip</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(strip</code>
              <code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这<code class="function">strip</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1263" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1264" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1265" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1266" class="indexterm"></a>函数删除所有<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267" class="indexterm"></a><code class="option">text</code>将所有内部空白替换为单个空格的前导和尾随空白
                。此函数的常见用途是清理条件表达式中使用的变量。</p><p>我最常使用此函数从跨多行格式化的变量和宏定义中删除不需要的空格。但如果函数对前导空格敏感，则用 包裹函数参数<code class="literal">$1</code>、
                <code class="literal">$2</code>等也是一个好主意。通常，不了解<em class="command">make</em><code class="function">strip</code>微妙之处的程序员会在参数列表中的逗号后面添加一个空格
                。<em class="command"></em><code class="function">call</code></p></dd><dd><p>The <code class="function">strip</code>
                <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> function removes all <a class="indexterm"></a>leading and trailing whitespace from
                <code class="option">text</code> and replaces all internal whitespace
                with a single space. A common use for this function is to
                clean up variables used in conditional expressions.</p><p>I most often use this function to remove unwanted
                whitespace from variable and macro definitions I've formatted
                across multiple lines. But it can also be a good idea to wrap
                the function parameters <code class="literal">$1</code>,
                <code class="literal">$2</code>, etc., with <code class="function">strip</code> if the function is sensitive
                to leading blanks. Often programmers unaware of the subtleties
                of <em class="command">make</em> will add a space
                after commas in a <code class="function">call</code>
                argument list.</p></dd><dt><span class="term"><code class="literal">$(origin</code>
              <code class="option">variable</code> <code class="literal">)</code></span></dt><dt><span class="term"><code class="literal">$(origin</code>
              <code class="option">variable</code> <code class="literal">)</code></span></dt><dd><p>这<code class="function">origin</code>
                <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1268" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1269" class="indexterm"></a>函数返回一个字符串<a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270" class="indexterm"></a>描述变量的来源。这对于决定如何使用变量的值非常有用。例如，如果变量的值来自环境，您可能希望忽略它，但如果它是从命令行设置的，则不需要。对于更具体的示例，这里是一个新的断言函数，用于测试变量是否已定义：</p><a id="OEBPS/ch04s02.html.I_4_tt233"></a><pre class="programlisting"># $(调用断言定义，变量名)
定义断言定义
  $(调用断言，\
    $(过滤出未定义，$(原点$1))，\
    “$1”未定义）
恩德夫</pre><p>可能的返回值为<code class="function">origin</code>：</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">undefined</code></span></dt><dd><p>该变量从未被定义过。</p></dd><dt><span class="term"><code class="literal">default</code></span></dt><dd><p>该变量的定义来自<em class="command">make</em>的内置数据库。如果更改内置变量的值，则<code class="function">origin</code>返回最新定义的来源。</p></dd><dt><span class="term"><code class="literal">environment</code></span></dt><dd><p>变量的定义来自环境（并且该
                      <code class="option">—environment-overrides</code>选项
                      <span class="emphasis"><em>未</em></span>打开）。</p></dd><dt><span class="term"><code class="literal">environment
                    override</code></span></dt><dd><p>变量的定义来自环境（并且该
                      <code class="option">—environment-overrides</code>选项
                      <span class="emphasis"><em>已</em></span>打开）。</p></dd><dt><span class="term"><code class="literal">file</code></span></dt><dd><p>该变量的定义来自<em class="filename">makefile</em>。</p></dd><dt><span class="term"><code class="literal">command
                    line</code></span></dt><dd><p>变量的定义来自命令行。</p></dd><dt><span class="term"><code class="literal">override</code></span></dt><dd><p>变量的定义来自<code class="function">override</code>指令。</p></dd><dt><span class="term"><code class="literal">automatic</code></span></dt><dd><p><em class="command">该变量是make</em>定义的自动变量
                      。</p></dd><dt><span class="term"><code class="literal">$(warning</code>
                    <code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>这<code class="function">warning</code>
                      <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1271" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1272" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1273" class="indexterm"></a> <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1274" class="indexterm"></a>function 与 function 类似<code class="function">error</code>，只是它不会导致<em class="command">make</em>
                      退出。与函数一样，输出以当前<em class="filename">makefile</em><code class="function">error</code>的名称和当前行号为前缀，后跟消息文本。函数展开为空<em class="filename"></em><code class="function">warning</code><a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1275" class="indexterm"></a>
                      <a id="OEBPS/ch04s02.html.make3-CHP-4-ITERM-1276" class="indexterm"></a>字符串，因此它几乎可以在任何地方使用。</p><a id="OEBPS/ch04s02.html.I_4_tt234"></a><pre class="programlisting">$(if $(通配符 $(JAVAC)),, \
  $(警告java编译器变量，JAVAC($(JAVAC))，\
            未正确设置。））</pre></dd></dl></div></dd><dd><p>The <code class="function">origin</code>
                <a class="indexterm"></a> <a class="indexterm"></a> function returns a string <a class="indexterm"></a>describing the origin of a variable. This can be
                very useful in deciding how to use the value of a variable.
                For instance, you might want to ignore the value of a variable
                if it came from the environment, but not if it was set from
                the command line. For a more concrete example, here is a new
                assert function that tests if a variable is defined:</p><a></a><pre class="programlisting"># $(call assert-defined,variable-name)
define assert-defined
  $(call assert,                          \
    $(filter-out undefined,$(origin $1)), \
    '$1' is undefined)
endef</pre><p>The possible return values of <code class="function">origin</code> are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">undefined</code></span></dt><dd><p>The variable has never been defined.</p></dd><dt><span class="term"><code class="literal">default</code></span></dt><dd><p>The variable's definition came from <em class="command">make</em>'s built-in database. If
                      you alter the value of a built-in variable, <code class="function">origin</code> returns the origin of
                      the most recent definition.</p></dd><dt><span class="term"><code class="literal">environment</code></span></dt><dd><p>The variable's definition came from the
                      environment (and the
                      <code class="option">—environment-overrides</code> option is
                      <span class="emphasis"><em>not</em></span> turned on).</p></dd><dt><span class="term"><code class="literal">environment
                    override</code></span></dt><dd><p>The variable's definition came from the
                      environment (and the
                      <code class="option">—environment-overrides</code> option
                      <span class="emphasis"><em>is</em></span> turned on).</p></dd><dt><span class="term"><code class="literal">file</code></span></dt><dd><p>The variable's definition came from the <em class="filename">makefile</em>.</p></dd><dt><span class="term"><code class="literal">command
                    line</code></span></dt><dd><p>The variable's definition came from the command
                      line.</p></dd><dt><span class="term"><code class="literal">override</code></span></dt><dd><p>The variable's definition came from an <code class="function">override</code> directive.</p></dd><dt><span class="term"><code class="literal">automatic</code></span></dt><dd><p>The variable is an automatic variable defined by
                      <em class="command">make</em>.</p></dd><dt><span class="term"><code class="literal">$(warning</code>
                    <code class="option">text</code> <code class="literal">)</code></span></dt><dd><p>The <code class="function">warning</code>
                      <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> function is similar to the <code class="function">error</code> function except that it
                      does not cause <em class="command">make</em>
                      to exit. Like the <code class="function">error</code> function, the output is
                      prefixed with the name of the current <em class="filename">makefile</em> and the current line
                      number followed by the message text. The <code class="function">warning</code> function expands to
                      the empty <a class="indexterm"></a>
                      <a class="indexterm"></a>string so
                      it can be used almost anywhere.</p><a></a><pre class="programlisting">$(if $(wildcard $(JAVAC)),,                               \
  $(warning The java compiler variable, JAVAC ($(JAVAC)), \
            is not properly set.))</pre></dd></dl></div></dd></dl></div></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-3" href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-3" class="para">3</a> ]</sup>在 Java 中，建议所有类都在包含开发人员完整 Internet 域名的包中声明，相反。此外，目录结构通常反映包结构。因此，许多源代码树看起来像
              <em class="replaceable"><code>root-dir</code></em>/com/ <em class="replaceable"><code>company-name</code></em>/ <em class="replaceable"><code>dir</code></em>。</p><p><sup>[<a href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-3" class="para">3</a>] </sup>In Java, it is suggested that all classes be declared
              within a package containing the developer's complete Internet
              domain name, reversed. Also, the directory structure typically
              mirrors the package structure. Therefore, many source trees look
              like
              <em class="replaceable"><code>root-dir</code></em>/com/<em class="replaceable"><code>company-name</code></em>/<em class="replaceable"><code>dir</code></em>.</p></div><div class="footnote"><p><sup>[ <a id="OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-4" href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-4" class="para">4</a> ]</sup> make <em class="command">3.80</em>手册没有提到允许使用多种模式。</p><p><sup>[<a href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-4" class="para">4</a>] </sup>The <em class="command">make</em> 3.80
                    manual fails to mention that more than one pattern is
                    allowed.</p></div><div class="footnote"><p><sup>[ <a id="OEBPS/ch04s02.html.ftn.make3-CHP-4-FNOTE-5" href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-5" class="para">5</a> ]</sup>在<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第3章</a>中，我对宏语言和其他编程语言进行了区分。宏语言的工作原理是通过定义和扩展宏将源文本转换为输出文本。当我们了解该<code class="function">if</code>
                    函数的工作原理时，这种区别就会变得更加清晰。</p><p><sup>[<a href="#OEBPS/ch04s02.html.make3-CHP-4-FNOTE-5" class="para">5</a>] </sup>In <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>, I
                    made a distinction between macro languages and other
                    programming languages. Macro languages work by
                    transforming source text into output text through defining
                    and expanding macros. This distinction becomes clearer as
                    we see how the <code class="function">if</code>
                    function works.</p></div></div></div></div></div>
<div id="OEBPS/ch04s03.html"><div>
<div class="sect1" title="高级用户定义函数"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch04s03.html.make3-CHP-4-SECT-3"></a>高级用户定义函数</h1><h1 class="title"><a></a>Advanced User-Defined Functions</h1></div></div></div><p>我们会花很多时间<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278" class="indexterm"></a>编写宏函数。不幸的是， <em class="command">make</em>中没有太多帮助调试它们的功能。让我们首先尝试编写一个简单的调试跟踪函数来帮助我们解决问题。</p><p>We'll spend a lot of time <a class="indexterm"></a> <a class="indexterm"></a>writing macro functions. Unfortunately, there aren't
        many features in <em class="command">make</em> for helping
        to debug them. Let's begin by trying to write a simple debugging trace
        function to help us out.</p><p>正如我们所提到的，<code class="function">call</code>
        将把它的每个参数绑定到编号变量<code class="literal">$1</code>、<code class="literal">$2</code>等。可以向 赋予任意数量的参数<code class="function">call</code>。作为一种特殊情况，当前正在执行的函数的名称（即变量名称）可以通过 访问<code class="literal">$0</code>。利用这些信息，我们可以编写一对调试函数，通过宏扩展进行跟踪：</p><p>As we've mentioned, <code class="function">call</code>
        will bind each of its parameters to the numbered variables <code class="literal">$1</code>, <code class="literal">$2</code>,
        etc. Any number of arguments can be given to <code class="function">call</code>. As a special case, the name of the
        currently executing function (i.e., the variable name) is accessible
        through <code class="literal">$0</code>. Using this information,
        we can write a pair of debugging functions for tracing through macro
        expansion:</p><a id="OEBPS/ch04s03.html.I_4_tt235"></a><pre class="programlisting"># $(调试输入)
调试输入 = $(如果 $(debug_trace),\
                $(警告输入$0($(echo-args))))

# $(调试离开)
debug-leave = $(if $(debug_trace),$(警告离开 $0))

逗号 := ,
echo-args = $(subst ' ','$(逗号) ',\
                $(foreach a,1 2 3 4 5 6 7 8 9,'$($a)'))</pre><pre class="programlisting"># $(debug-enter)
debug-enter = $(if $(debug_trace),\
                $(warning Entering $0($(echo-args))))

# $(debug-leave)
debug-leave = $(if $(debug_trace),$(warning Leaving $0))

comma := ,
echo-args   = $(subst ' ','$(comma) ',\
                $(foreach a,1 2 3 4 5 6 7 8 9,'$($a)'))</pre><p>如果我们想观察函数<code class="function">a</code>和<code class="function">b</code>是如何被调用的，我们可以像这样使用这些跟踪函数：</p><p>If we want to watch how functions <code class="function">a</code> and <code class="function">b</code> are invoked, we can use these trace
        functions like this:</p><a id="OEBPS/ch04s03.html.I_4_tt236"></a><pre class="programlisting">调试跟踪 = 1

定义一个
  $(调试-输入)
  @echo $1 $2 $3
  $(调试离开)
恩德夫

定义b
  $(调试-输入)
  $(呼叫 a,$1,$2,hi)
  $(调试离开)
恩德夫

跟踪宏：
        $(调用 b,5,$(MAKE))</pre><pre class="programlisting">debug_trace = 1

define a
  $(debug-enter)
  @echo $1 $2 $3
  $(debug-leave)
endef

define b
  $(debug-enter)
  $(call a,$1,$2,hi)
  $(debug-leave)
endef

trace-macro:
        $(call b,5,$(MAKE))</pre><p>通过将<code class="function">debug-enter</code>和
        <code class="function">debug-leave</code>变量放置在
        <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1279" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1280" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282" class="indexterm"></a>函数的开始和结束，您可以跟踪自己函数的扩展。这些功能还远远不够完善。该<code class="function">echo-args</code>函数将仅回显前九个参数，更糟糕的是，它无法确定调用中实际参数的数量（当然，也不能<em class="command">make</em>！）。尽管如此，我已经用过<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1283" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1284" class="indexterm"></a>这些宏在我自己的调试中“按原样”。执行时，<em class="filename">makefile</em>会生成以下跟踪输出：</p><p>By placing <code class="function">debug-enter</code> and
        <code class="function">debug-leave</code> variables at the
        <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>start and end of your functions, you can trace the
        expansions of your own functions. These functions are far from
        perfect. The <code class="function">echo-args</code> function
        will echo only the first nine arguments and, worse, it cannot
        determine the number of actual arguments in the call (of course,
        neither can <em class="command">make</em>!). Nevertheless,
        I've used <a class="indexterm"></a> <a class="indexterm"></a>these macros "as is" in my own debugging. When executed,
        the <em class="filename">makefile</em> generates this trace
        output:</p><a id="OEBPS/ch04s03.html.I_4_tt237"></a><pre class="programlisting">$ 制作
makefile:14: 输入 b('5', 'make', '', '', '', '', '', '', '')
makefile:14: 输入 a( '5', 'make', 'hi', '', '', '', '', '', '')
makefile:14: 留下一个
makefile:14: 离开 b
5 打个招呼</pre><pre class="programlisting">$ make
makefile:14: Entering b( '5', 'make', '', '', '', '', '', '', '')
makefile:14: Entering a( '5', 'make', 'hi', '', '', '', '', '', '')
makefile:14: Leaving a
makefile:14: Leaving b
5 make hi</pre><p>正如一位朋友最近对我说的那样，“我以前从未想过<em class="command">将 make</em>作为一种编程语言。”
         <acronym class="acronym">GNU </acronym> <em class="command">make</em>不是你祖母的<em class="command">make</em>！</p><p>As a friend said to me recently, "I never thought of <em class="command">make</em> as a programming language before."
        <acronym class="acronym">GNU</acronym> <em class="command">make</em> isn't
        your grandmother's <em class="command">make</em>!</p><div class="sect2" title="评估和价值"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s03.html.make3-CHP-4-SECT-3.1"></a>评估和价值</h2><h2 class="title"><a></a>eval and value</h2></div></div></div><p>这<code class="function">eval</code> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1285" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1286" class="indexterm"></a>函数与其他内置函数完全不同。其目的是将文本直接提供给
          <em class="command">make</em>解析器。例如，</p><p>The <code class="function">eval</code> <a class="indexterm"></a> <a class="indexterm"></a> function is completely different from the rest of the
          built-in functions. Its purpose is to feed text directly to the
          <em class="command">make</em> parser. For instance,</p><a id="OEBPS/ch04s03.html.I_4_tt238"></a><pre class="programlisting">$(评估源:= foo.c bar.c)</pre><pre class="programlisting">$(eval sources := foo.c bar.c)</pre><p>首先扫描的参数<code class="function">eval</code>以查找变量并展开（就像所有函数的所有参数一样），然后对文本进行解析和评估，就好像它来自输入文件一样。这个例子非常简单，您可能想知道为什么要费心使用这个函数。让我们尝试一个更有趣的例子。假设您有一个<em class="filename">makefile</em>来编译十几个程序，并且您想为每个程序定义几个变量，例如<code class="literal">sources</code>、<code class="literal">headers</code>和<code class="literal">objects</code>。不要对每组变量一遍又一遍地重复这些变量分配：</p><p>The argument to <code class="function">eval</code> is
          first scanned for variables and expanded (as all arguments to all
          functions are), then the text is parsed and evaluated as if it had
          come from an input file. This example is so simple you might be
          wondering why you would bother with this function. Let's try a more
          interesting example. Suppose you have a <em class="filename">makefile</em> to compile a dozen programs and
          you want to define several variables for each program, say <code class="literal">sources</code>, <code class="literal">headers</code>, and <code class="literal">objects</code>. Instead of repeating these
          variable assignments over and over with each set of
          variables:</p><a id="OEBPS/ch04s03.html.I_4_tt239"></a><pre class="programlisting">ls_sources := ls.c glob.c
ls_headers := ls.h glob.h
ls_objects := ls.o glob.o
...</pre><pre class="programlisting">ls_sources := ls.c glob.c
ls_headers := ls.h glob.h
ls_objects := ls.o glob.o
...</pre><p>我们可能会尝试定义一个宏来完成这项工作：</p><p>We might try to define a macro to do the job:</p><a id="OEBPS/ch04s03.html.I_4_tt240"></a><pre class="programlisting"># $(调用程序变量、变量前缀、文件列表)
定义程序变量
  $1_sources = $(过滤器%.c,$2)
  $1_headers = $(过滤器%.h,$2)
  $1_objects = $(subst .c,.o,$(过滤器 %.c,$2))
恩德夫

$(调用程序变量, ls, ls.c ls.h glob.c glob.h)

显示变量：
        # $(ls_sources)
        # $(ls_headers)
        # $(ls_objects)</pre><pre class="programlisting"># $(call program-variables, variable-prefix, file-list)
define program-variables
  $1_sources = $(filter %.c,$2)
  $1_headers = $(filter %.h,$2)
  $1_objects = $(subst .c,.o,$(filter %.c,$2))
endef

$(call program-variables, ls, ls.c ls.h glob.c glob.h)

show-variables:
        # $(ls_sources)
        # $(ls_headers)
        # $(ls_objects)</pre><p>该<code class="function">program-variables</code>
          宏接受<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1287" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1288" class="indexterm"></a>两个参数：三个变量的前缀和一个文件列表，宏从中选择要在每个变量中设置的文件。但是，当我们尝试使用这个宏时，我们收到错误：</p><p>The <code class="function">program-variables</code>
          macro accepts<a class="indexterm"></a> <a class="indexterm"></a> two arguments: a prefix for the three variables and a
          file list from which the macro selects files to set in each
          variable. But, when we try to use this macro, we get the
          error:</p><a id="OEBPS/ch04s03.html.I_4_tt241"></a><pre class="programlisting">$ <strong class="userinput"><code>make</code></strong>
Makefile:7: *** 缺少分隔符。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
Makefile:7: *** missing separator.  Stop.</pre><p>由于<em class="command">make</em>解析器的工作方式，这不能按预期工作。扩展为多行的宏（在顶级解析级别）是非法的，会导致语法错误。在这种情况下，解析器认为该行是规则或命令脚本的一部分，但缺少分隔符标记。相当令人困惑的错误消息。该<code class="function">eval</code>函数的引入就是为了解决这个问题。如果我们将<code class="function">call</code>行更改为：</p><p>This doesn't work as expected because of the way the <em class="command">make</em> parser works. A macro (at the top
          parsing level) that expands to multiple lines is illegal and results
          in syntax errors. In this case, the parser believes this line is a
          rule or part of a command script but is missing a separator token.
          Quite a confusing error message. The <code class="function">eval</code> function was introduced to handle
          this issue. If we change our <code class="function">call</code> line to:</p><a id="OEBPS/ch04s03.html.I_4_tt242"></a><pre class="programlisting">$(eval $(调用程序变量, ls, ls.c ls.h glob.c glob.h))</pre><pre class="programlisting">$(eval $(call program-variables, ls, ls.c ls.h glob.c glob.h))</pre><p>我们得到了我们所期望的：</p><p>we get what we expect:</p><a id="OEBPS/ch04s03.html.I_4_tt243"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
# ls.c glob.c
# ls.h glob.h
# ls.o glob.o</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
# ls.c glob.c
# ls.h glob.h
# ls.o glob.o</pre><p>使用<code class="function">eval</code>解决了
          <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1289" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1290" class="indexterm"></a>解析问题，因为<code class="function">eval</code>处理多行宏扩展并且本身扩展为零行。</p><p>Using <code class="function">eval</code> resolves the
          <a class="indexterm"></a> <a class="indexterm"></a>parsing issue because <code class="function">eval</code> handles the multiline macro
          expansion and itself expands to zero lines.</p><p>现在我们有一个非常简洁地定义了三个变量的宏。请注意宏中的赋值如何从传递到函数的前缀和固定后缀
          <code class="literal">$1_sources</code>.组成变量名称。这些不是前面描述的精确计算的变量，但它们具有大致相同的风格。</p><p>Now we have a macro that defines three variables very
          concisely. Notice how the assignments in the macro compose variable
          names from a prefix passed in to the function and a fixed suffix,
          <code class="literal">$1_sources</code>. These aren't
          precisely computed variables as described previously, but they have
          much the same flavor.</p><p>继续这个例子，我们意识到我们还可以包括我们的
          <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1291" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1292" class="indexterm"></a>宏中的规则：</p><p>Continuing this example, we realize we can also include our
          <a class="indexterm"></a> <a class="indexterm"></a>rules in the macro:</p><a id="OEBPS/ch04s03.html.I_4_tt244"></a><pre class="programlisting"># $(调用程序变量,变量前缀,文件列表)
定义程序变量
  $1_sources = $(过滤器%.c,$2)
  $1_headers = $(过滤器%.h,$2)
  $1_objects = $(subst .c,.o,$(过滤器 %.c,$2))

  $($1_objects): $($1_headers)
恩德夫

ls: $(ls_objects)

$(eval $(调用程序变量,ls,ls.c ls.h glob.c glob.h))</pre><pre class="programlisting"># $(call program-variables,variable-prefix,file-list)
define program-variables
  $1_sources = $(filter %.c,$2)
  $1_headers = $(filter %.h,$2)
  $1_objects = $(subst .c,.o,$(filter %.c,$2))

  $($1_objects): $($1_headers)
endef

ls: $(ls_objects)

$(eval $(call program-variables,ls,ls.c ls.h glob.c glob.h))</pre><p>请注意这两个版本如何<code class="function">program-variables</code>说明函数参数中的空格问题。在以前的版本中，两个函数参数的简单使用不受参数前导空格的影响。也就是说，无论<code class="literal">$1</code>或中是否有任何前导空格，代码的行为都是相同的<code class="literal">$2</code>。然而，新版本引入了计算变量<code class="literal">$($1_objects)</code>和<code class="literal">$($1_headers)</code>。现在，向函数 ( <em class="command">ls</em> )的第一个参数添加前导空格会导致计算变量以前导空格开头，该变量会扩展为空，因为我们定义的变量都没有以前导空格开头。这可能是一个非常隐蔽的诊断问题。</p><p>Notice how these two versions of <code class="function">program-variables</code> illustrate a problem
          with spaces in function arguments. In the previous version, the
          simple uses of the two function parameters were immune to leading
          spaces on the arguments. That is, the code behaved the same
          regardless of any leading spaces in <code class="literal">$1</code> or <code class="literal">$2</code>. The new version, however, introduced
          the computed variables <code class="literal">$($1_objects)</code> and <code class="literal">$($1_headers)</code>. Now adding a leading space
          to the first argument to our function (<em class="command">ls</em>) causes the computed variable to begin
          with a leading space, which expands to nothing because no variable
          we've defined begins with a leading space. This can be quite an
          insidious problem to diagnose.</p><p>当我们运行这个<em class="filename">makefile</em>时，我们发现
          <em class="command">make</em>忽略了<em class="filename">.h</em>先决条件。为了诊断这个问题，我们通过运行<em class="command">make</em>
          及其选项来检查<em class="command">make</em>的内部数据库，我们看到一些奇怪的东西：<em class="command"></em><em class="command"></em><em class="command"></em><code class="option">—print-data-base</code></p><p>When we run this <em class="filename">makefile</em>, we discover that somehow the
          <em class="filename">.h</em> prerequisites are being
          ignored by <em class="command">make</em>. To diagnose this
          problem, we examine <em class="command">make</em>'s
          internal database by running <em class="command">make</em>
          with its <code class="option">—print-data-base</code> option and we see
          something strange:</p><a id="OEBPS/ch04s03.html.I_4_tt245"></a><pre class="programlisting">$<strong class="userinput"><code>make --print-database | grep ^ls</code></strong>
ls_headers = ls.h glob.h
ls_sources = ls.c glob.c
ls_objects = ls.o glob.o
ls.c:
ls.o: ls.c
ls: ls.o</pre><pre class="programlisting">$<strong class="userinput"><code>make --print-database | grep ^ls</code></strong>
ls_headers = ls.h glob.h
ls_sources = ls.c glob.c
ls_objects = ls.o glob.o
ls.c:
ls.o: ls.c
ls: ls.o</pre><p><em class="filename">ls.o</em>的
          <em class="filename">.h</em>先决条件缺失！使用计算变量的规则有问题。<em class="filename"></em></p><p>The <em class="filename">.h</em> prerequisites for
          <em class="filename">ls.o</em> are missing! There is
          something wrong with the rule using computed variables.</p><p>当<em class="command">make</em>解析
          <code class="function">eval</code>函数调用时，它首先扩展用户定义的函数<code class="function">program-variables</code>。宏的第一行扩展为：</p><p>When <em class="command">make</em> parses the
          <code class="function">eval</code> function call, it first
          expands the user-defined function, <code class="function">program-variables</code>. The first line of the
          macro expands to:</p><a id="OEBPS/ch04s03.html.I_4_tt246"></a><pre class="programlisting">ls_sources = ls.c glob.c</pre><pre class="programlisting">ls_sources = ls.c glob.c</pre><p>请注意，宏的每一行都会按预期立即展开。其他变量赋值的处理方式类似。然后我们得出规则：</p><p>Notice that each line of the macro is expanded immediately as
          expected. The other variable assignments are handled similarly. Then
          we get to the rule:</p><a id="OEBPS/ch04s03.html.I_4_tt247"></a><pre class="programlisting">$($1_objects): $($1_headers)</pre><pre class="programlisting">$($1_objects): $($1_headers)</pre><p>计算变量首先扩展其变量名：</p><p>The computed variables first have their variable name
          expanded:</p><a id="OEBPS/ch04s03.html.I_4_tt248"></a><pre class="programlisting">$(ls_objects): $(ls_headers)</pre><pre class="programlisting">$(ls_objects): $(ls_headers)</pre><p>然后执行外部变量扩展，产生：</p><p>Then the outer variable expansion is performed,
          yielding:</p><a id="OEBPS/ch04s03.html.I_4_tt249"></a><pre class="programlisting">：</pre><pre class="programlisting">:</pre><p>等待！我们的变量到哪里去了？答案是前面的三个赋值语句被 make 扩展但<span class="emphasis"><em>没有</em></span><em class="command">计算</em>。让我们继续看看它是如何工作的。一旦<code class="function">program-variables</code>扩展了
          对的调用， <em class="command">make</em>就会看到如下内容：</p><p>Wait! Where did our variables go? The answer is that the
          previous three assignment statements were expanded <span class="emphasis"><em>but not
          evaluated</em></span> by <em class="command">make</em>.
          Let's keep going to see how this works. Once the call to <code class="function">program-variables</code> has been expanded,
          <em class="command">make</em> sees something like:</p><a id="OEBPS/ch04s03.html.I_4_tt250"></a><pre class="programlisting">$(eval ls_sources = ls.c glob.c
ls_headers = ls.h glob.h
ls_objects = ls.o glob.o

:)</pre><pre class="programlisting">$(eval   ls_sources = ls.c glob.c
ls_headers = ls.h glob.h
ls_objects = ls.o glob.o

:)</pre><p>然后该<code class="function">eval</code>函数执行并定义三个变量。因此，答案是规则中的变量在实际定义之前就已被扩展。</p><p>The <code class="function">eval</code> function then
          executes and defines the three variables. So, the answer is that the
          variables in the rule are being expanded before they have actually
          been defined.</p><p>我们可以通过显式推迟计算变量的扩展直到定义了三个变量来解决这个问题。我们可以通过在计算变量前面引用美元符号来做到这一点：</p><p>We can resolve this problem by explicitly deferring the
          expansion of the computed variables until the three variables are
          defined. We can do this by quoting the dollar signs in front of the
          computed variables:</p><a id="OEBPS/ch04s03.html.I_4_tt251"></a><pre class="programlisting">$$($1_objects): $$($1_headers)</pre><pre class="programlisting">$$($1_objects): $$($1_headers)</pre><p>这次<em class="command">make</em>数据库显示了我们期望的先决条件：</p><p>This time the <em class="command">make</em> database
          shows the prerequisites we expect:</p><a id="OEBPS/ch04s03.html.I_4_tt252"></a><pre class="programlisting">$<strong class="userinput"><code>make -p | grep ^ls</code></strong>
ls_headers = ls.h glob.h
ls_sources = ls.c glob.c
ls_objects = ls.o glob.o
ls.c:
ls.o: ls.c ls.h glob.h
ls: ls.o</pre><pre class="programlisting">$<strong class="userinput"><code>make -p | grep ^ls</code></strong>
ls_headers = ls.h glob.h
ls_sources = ls.c glob.c
ls_objects = ls.o glob.o
ls.c:
ls.o: ls.c ls.h glob.h
ls: ls.o</pre><p>总而言之， 的参数<code class="function">eval</code>被扩展
          <span class="emphasis"><em>两次</em></span>：一次是当<em class="command">make</em>为 准备参数列表
          时<code class="function">eval</code>，另一次是 by
           <code class="function">eval</code>。</p><p>To summarize, the argument to <code class="function">eval</code> is expanded
          <span class="emphasis"><em>twice</em></span>: once when when <em class="command">make</em> prepares the argument list for
          <code class="function">eval</code>, and once again by
          <code class="function">eval</code>.</p><p>我们通过推迟计算变量的评估解决了最后一个问题。处理该问题的另一种方法是通过用以下内容包装每个变量来强制早期评估变量分配<code class="function">eval</code>：</p><p>We resolved the last problem by deferring evaluation of the
          computed variables. Another way of handling the problem is to force
          early evaluation of the variable assignments by wrapping each one
          with <code class="function">eval</code>:</p><a id="OEBPS/ch04s03.html.I_4_tt253"></a><pre class="programlisting"># $(调用程序变量,变量前缀,文件列表)
定义程序变量
  $(eval $1_sources = $(过滤器%.c,$2))
  $(eval $1_headers = $(过滤器%.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(过滤器 %.c,$2)))

  $($1_objects): $($1_headers)
恩德夫

ls: $(ls_objects)

$(eval $(调用程序变量,ls,ls.c ls.h glob.c glob.h))</pre><pre class="programlisting"># $(call program-variables,variable-prefix,file-list)
define program-variables
  $(eval $1_sources = $(filter %.c,$2))
  $(eval $1_headers = $(filter %.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(filter %.c,$2)))

  $($1_objects): $($1_headers)
endef

ls: $(ls_objects)

$(eval $(call program-variables,ls,ls.c ls.h glob.c glob.h))</pre><p>通过将变量赋值包装在它们自己的调用中，我们可以在宏展开时
          <code class="function">eval</code>使它们被<em class="command">make</em><code class="function">program-variables</code>内部化。然后它们就可以立即在宏中使用。</p><p>By wrapping the variable assignments in their own <code class="function">eval</code> calls, we cause them to be
          internalized by <em class="command">make</em> while the
          <code class="function">program-variables</code> macro is
          being expanded. They are then available for use within the macro
          immediately.</p><p>当我们增强<em class="filename">makefile</em>时，我们意识到我们还有另一个可以添加到宏中的规则。程序本身取决于它的对象。因此，为了完成我们的参数化<em class="filename">makefile</em>，我们添加一个顶级<em class="filename">all目标，并需要一个变量来保存我们的</em><em class="filename">makefile</em>
          可以管理的所有程序：</p><p>As we enhance our <em class="filename">makefile</em>, we realize we have another rule
          we can add to our macro. The program itself depends on its objects.
          So, to finish our parameterized <em class="filename">makefile</em>, we add a top-level <em class="filename">all</em> target and need a variable to hold
          all the programs our <em class="filename">makefile</em>
          can manage:</p><a id="OEBPS/ch04s03.html.I_4_tt254"></a><pre class="programlisting">#$(调用程序变量、变量前缀、文件列表)
定义程序变量
  $(eval $1_sources = $(过滤器%.c,$2))
  $(eval $1_headers = $(过滤器%.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(过滤器 %.c,$2)))

  节目 += $1

  $1: $($1_objects)

  $($1_objects): $($1_headers)
恩德夫

# 将所有目标放在这里，所以它是默认目标。
全部：

$(eval $(调用程序变量,ls,ls.c ls.h glob.c glob.h))
$(eval $(调用程序变量,cp,...))
$(eval $(调用程序变量,mv,...))
$(eval $(调用程序变量,ln,...))
$(eval $(调用程序变量,rm,...))

# 将程序先决条件放置在此处定义的位置。
全部：$（程序）</pre><pre class="programlisting">#$(call program-variables,variable-prefix,file-list)
define program-variables
  $(eval $1_sources = $(filter %.c,$2))
  $(eval $1_headers = $(filter %.h,$2))
  $(eval $1_objects = $(subst .c,.o,$(filter %.c,$2)))

  programs += $1

  $1: $($1_objects)

  $($1_objects): $($1_headers)
endef

# Place all target here, so it is the default goal.
all:

$(eval $(call program-variables,ls,ls.c ls.h glob.c glob.h))
$(eval $(call program-variables,cp,...))
$(eval $(call program-variables,mv,...))
$(eval $(call program-variables,ln,...))
$(eval $(call program-variables,rm,...))

# Place the programs prerequisite here where it is defined.
all: $(programs)</pre><p>注意目标的放置<code class="literal">all</code>及其先决条件。该
          <code class="literal">programs</code>变量直到五次<code class="literal">eval</code>
          调用之后才被正确定义，但我们希望将目标放在<span class="email"><a class="email" href="#OEBPS/mailto:makefile">makefile</a></span><code class="literal">all</code>中的第一个位置
          ，因此这是默认目标。我们可以通过先放置先决条件然后再添加先决条件来满足所有限制
          。<span class="email"><a class="email" href="#OEBPS/mailto:makefile"></a></span><code class="literal">all</code><code class="literal">all</code></p><p>Notice the placement of the <code class="literal">all</code> target and its prerequisite. The
          <code class="literal">programs</code> variable is not properly
          defined until after the five <code class="literal">eval</code>
          calls, but we would like to place the <code class="literal">all</code> target first in the
          <span class="email"><a class="email" href="#OEBPS/mailto:makefile">makefile</a></span> so <code class="literal">all</code> is
          the default goal. We can satisfy all our constrains by putting
          <code class="literal">all</code> first and adding the
          prerequisites later.</p><p>该<code class="function">program-variables</code>
          函数存在问题，因为某些变量评估得太早。<em class="command">make</em>实际上提供了一个
          <code class="function">value</code>函数来帮助解决这种情况。该函数返回其参数
          <span class="emphasis"><em>unexpanded</em></span><code class="function">value</code>
          的值。然后可以将该未扩展的值传递给处理。通过返回未扩展的值，我们可以避免必须在宏中引用某些变量引用的问题。<code class="option">variable</code><span class="emphasis"><em></em></span><code class="function">eval</code></p><p>The <code class="function">program-variables</code>
          function had problems because some variables were evaluated too
          early. <em class="command">make</em> actually offers a
          <code class="function">value</code> function to help address
          this situation. The <code class="function">value</code>
          function returns the value of its <code class="option">variable</code> argument
          <span class="emphasis"><em>unexpanded</em></span>. This unexpanded value can then be
          passed to <code class="function">eval</code> for processing.
          By returning an unexpanded value, we can avoid the problem of having
          to quote some of the variable references in our macros.</p><p>不幸的是，这个函数不能与宏一起使用<code class="function">program-variables</code>。那是因为
          <code class="function">value</code>是一个全有或全无的函数。如果使用，<code class="function">value</code>将不会扩展宏中的<span class="emphasis"><em>任何</em></span>变量。此外，<code class="function">value</code>不接受参数（如果接受，也不会对其执行任何操作），因此我们的程序名称和文件列表参数不会扩展。</p><p>Unfortunately, this function cannot be used with the <code class="function">program-variables</code> macro. That's because
          <code class="function">value</code> is an all-or-nothing
          function. If used, <code class="function">value</code> will
          not expand <span class="emphasis"><em>any</em></span> of the variables in the macro.
          Furthermore, <code class="function">value</code> doesn't
          accept parameters (and wouldn't do anything with them if it did) so
          our program name and file list parameters wouldn't be
          expanded.</p><p>由于这些限制，您<code class="function">value</code>在本书中不会经常看到它的使用。</p><p>Because of these limitations, you won't see <code class="function">value</code> used very often in this
          book.</p></div><div class="sect2" title="挂钩函数"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s03.html.make3-CHP-4-SECT-3.2"></a>挂钩函数</h2><h2 class="title"><a></a>Hooking Functions</h2></div></div></div><p>用户定义的函数只是<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1293" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1294" class="indexterm"></a>保存文本的变量。该<code class="function">call</code>函数将扩展变量文本中的 、 等引用（如果存在）<code class="literal">$1</code>。<code class="literal">$2</code>如果函数不包含任何这些变量引用，则<code class="function">call</code>不在乎。事实上，如果变量不包含任何文本，则<code class="function">call</code>不在乎。不会出现错误或警告。如果您碰巧拼错了函数名称，这可能会非常令人沮丧。但它也可能非常有用。</p><p>User-defined functions are just <a class="indexterm"></a> <a class="indexterm"></a>variables holding text. The <code class="function">call</code> function will expand <code class="literal">$1</code>, <code class="literal">$2</code>,
          etc. references in the variable text if they exist. If the function
          doesn't contain any of these variable references, <code class="function">call</code> doesn't care. In fact, if the
          variable doesn't contain any text, <code class="function">call</code> doesn't care. No error or warning
          occurs. This can be very frustrating if you happen to misspell a
          function name. But it can also be very useful.</p><p>函数都是关于可重用代码的。函数重用的次数越多，就越值得把它写好。通过向函数添加<span class="emphasis"><em>钩子</em></span>可以使函数更加可重用
          。钩子是一个函数引用<em class="firstterm">，</em>用户可以重新定义它以在标准操作期间执行自己的自定义任务。</p><p>Functions are all about reusable code. The more often you
          reuse a function, the more worthwhile it is to write it well.
          Functions can be made more reusable by adding
          <span class="emphasis"><em>hooks</em></span> to them. A <em class="firstterm">hook</em> is
          a function reference that can be redefined by a user to perform
          their own custom tasks during a standard operation.</p><p>假设您正在 makefile 中构建许多<em class="filename">库</em>。在某些系统上，您希望运行<em class="command">ranlib</em>，而在其他系统上您可能希望运行<em class="command">chmod</em>。您可以选择编写一个函数并添加一个钩子，而不是为这些操作编写显式命令：</p><p>Suppose you are building many libraries in your <em class="filename">makefile</em>. On some systems, you'd like to
          run <em class="command">ranlib</em> and on others you
          might want to run <em class="command">chmod</em>. Rather
          than writing explicit commands for these operations, you might
          choose to write a function and add a hook:</p><a id="OEBPS/ch04s03.html.I_4_tt255"></a><pre class="programlisting"># $(调用构建库，对象文件)
定义构建库
  $(AR) $(ARFLAGS) $@ $1
  $(调用构建库钩子，$@)
恩德夫</pre><pre class="programlisting"># $(call build-library, object-files)
define build-library
  $(AR) $(ARFLAGS) $@ $1
  $(call build-library-hook,$@)
endef</pre><p>要使用钩子，请定义函数<code class="function">build-library-hook</code>：</p><p>To use the hook, define the function <code class="function">build-library-hook</code>:</p><a id="OEBPS/ch04s03.html.I_4_tt256"></a><pre class="programlisting">$(foo_lib): 构建库钩子 = $(RANLIB) $1
$(foo_lib): $(foo_objects)
        $(调用构建库,$^)

$(bar_lib): 构建库钩子 = $(CHMOD) 444 $1
$(bar_lib): $(bar_objects)
        $(调用构建库,$^)</pre><pre class="programlisting">$(foo_lib): build-library-hook = $(RANLIB) $1
$(foo_lib): $(foo_objects)
        $(call build-library,$^)

$(bar_lib): build-library-hook = $(CHMOD) 444 $1
$(bar_lib): $(bar_objects)
        $(call build-library,$^)</pre></div><div class="sect2" title="传递参数"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch04s03.html.make3-CHP-4-SECT-3.3"></a>传递参数</h2><h2 class="title"><a></a>Passing Parameters</h2></div></div></div><p>一个函数可以得到它的<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1295" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1296" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1297" class="indexterm"></a>来自四个“源”的数据： using 传入的参数
          <code class="function">call</code>、全局变量、自动变量和特定于目标的变量。其中，依赖参数是最模块化的选择，因为它们的使用使函数免受全局数据的任何更改的影响，但有时这不是最重要的标准。</p><p>A function can get its<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> data from four "sources": parameters passed in using
          <code class="function">call</code>, global variables,
          automatic variables, and target-specific variables. Of these,
          relying on parameters is the most modular choice, since their use
          insulates the function from any changes to global data, but
          sometimes that isn't the most important criteria.</p><p>假设我们有几个使用一组通用
          <em class="command">make</em>函数的项目。每个项目都可以通过变量前缀（例如 ）来标识<code class="literal">PROJECT1_</code>，并且项目的关键变量都使用带有跨项目后缀的前缀。前面的示例 ,<code class="literal">PROJECT_SRC</code>可能看起来像<code class="literal">PROJECT1_SRC</code>, <code class="literal">PROJECT1_BIN</code>, 和<code class="literal">PROJECT1_LIB</code>。我们可以使用计算变量并传递单个参数，即前缀，而不是编写需要这三个变量的函数：</p><p>Suppose we have several projects using a common set of
          <em class="command">make</em> functions. Each project
          might be identified by a variable prefix, say <code class="literal">PROJECT1_</code>, and critical variables for the
          project all use the prefix with cross-project suffixes. The earlier
          example, <code class="literal">PROJECT_SRC</code>, might look
          like <code class="literal">PROJECT1_SRC</code>, <code class="literal">PROJECT1_BIN</code>, and <code class="literal">PROJECT1_LIB</code>. Rather than write a function
          that requires these three variables we could instead use computed
          variables and pass a single argument, the prefix:</p><a id="OEBPS/ch04s03.html.I_4_tt257"></a><pre class="programlisting"># $(调用流程-xml,项目前缀,文件名)
定义流程-xml
  $($1_LIB)/xmlto -o $($1_BIN)/xml/$2 $($1_SRC)/xml/$2
恩德夫</pre><pre class="programlisting"># $(call process-xml,project-prefix,file-name)
define process-xml
  $($1_LIB)/xmlto -o $($1_BIN)/xml/$2 $($1_SRC)/xml/$2
endef</pre><p>传递参数的另一种方法是使用特定于目标的变量。当大多数调用使用标准值但少数需要特殊处理时，这特别有用。当规则在包含文件中定义但从定义变量的<em class="filename">makefile调用时，特定于目标的变量还提供了灵活性。</em></p><p>Another approach to passing arguments uses target-specific
          variables. This is particularly useful when most invocations use a
          standard value but a few require special processing. Target-specific
          variables also provide flexibility when the rule is defined in an
          include file, but invoked from a <em class="filename">makefile</em> where the variable is
          defined.</p><a id="OEBPS/ch04s03.html.I_4_tt258"></a><pre class="programlisting">发布：MAKING_RELEASE = 1
发布：库可执行文件
...
$(foo_lib):
        $(调用构建库,$^)
...
# $(调用构建库，文件列表)
定义构建库
  $(AR) $(ARFLAGS) $@ \
    $(如果$(MAKING_RELEASE), \
      $(过滤掉调试/%,$1), \
      1 美元）
恩德夫</pre><pre class="programlisting">release: MAKING_RELEASE = 1
release: libraries executables
...
$(foo_lib):
        $(call build-library,$^)
...
# $(call build-library, file-list)
define build-library
  $(AR) $(ARFLAGS) $@           \
    $(if $(MAKING_RELEASE),     \
      $(filter-out debug/%,$1), \
      $1)
endef</pre><p>此代码设置一个特定于目标的变量来指示何时执行发布版本。在这种情况下，<a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298" class="indexterm"></a> <a id="OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299" class="indexterm"></a>库构建功能将从库中过滤掉任何调试模块。</p><p>This code sets a target-specific variable to indicate when a
          release build is being executed. In that case, the <a class="indexterm"></a> <a class="indexterm"></a>library-building
          function will filter out any debugging modules from the
          libraries.</p></div></div></div></div>
<div id="OEBPS/ch05.html"><div>
<div class="chapter" title="第 5 章命令"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05.html.make3-CHP-5"></a>第 5 章命令</h1><h1 class="title"><a></a>Chapter&nbsp;5.&nbsp;Commands</h1></div></div></div><p><em class="command">我们已经介绍了make</em>命令的许多基本元素，但为了确保我们都在同一页面上，让我们回顾一下。</p><p>We've already covered many of the basic elements of <em class="command">make</em> commands, but just to make sure we're all
      on the same page, let's review a little.</p><p>命令本质上是一行 shell 脚本。实际上，
       <em class="command">make</em>抓取每一行并将其传递给子 shell 来执行。事实上，如果<em class="command">make</em>能够保证省略 shell 不会改变程序的行为，它就可以优化这种（相对）昂贵的 fork/exec 算法。它通过扫描每个命令行中的 shell 特殊字符（例如通配符和 I/O 重定向）来检查这一点。如果没有找到，<em class="command">则 make</em>直接执行该命令，而不将其传递给子 shell。</p><p>Commands are essentially one-line shell scripts. In effect,
      <em class="command">make</em> grabs each line and passes it to
      a subshell for execution. In fact, <em class="command">make</em> can optimize this (relatively) expensive
      fork/exec algorithm if it can guarantee that omitting the shell will not
      change the behavior of the program. It checks this by scanning each
      command line for shell special characters, such as wildcard characters
      and i/o redirection. If none are found, <em class="command">make</em> directly executes the command without
      passing it to a subshell.</p><p>默认情况下，<em class="filename">/bin/sh</em>用于 shell。该 shell 由<em class="command">make</em>变量控制<code class="literal">SHELL</code>，但它不是从环境继承的。当<em class="command">make</em>启动时，它从用户环境中导入所有变量作为<em class="command">make</em>变量，除了<code class="literal">SHELL</code>。这是因为用户对 shell 的选择不应导致<em class="filename">makefile</em> 
      （可能包含在某些下载的软件包中）失败。如果用户确实想要更改<em class="command">make</em><code class="literal">SHELL</code>使用的默认 shell，他可以在<em class="filename">makefile</em>中显式设置该变量。我们将在
      本章后面的<a class="link" href="#OEBPS/ch05s02.html" title="使用哪个外壳">5.2 节中讨论这个问题。</a></p><p>By default, <em class="filename">/bin/sh</em> is used
      for the shell. This shell is controlled by the <em class="command">make</em> variable <code class="literal">SHELL</code> but it is not inherited from the
      environment. When <em class="command">make</em> starts, it
      imports all the variables from the user's environment as <em class="command">make</em> variables, except <code class="literal">SHELL</code>. This is because the user's choice of
      shell should not cause a <em class="filename">makefile</em>
      (possibly included in some downloaded software package) to fail. If a
      user really wants to change the default shell used by <em class="command">make</em>, he can set the <code class="literal">SHELL</code> variable explicitly in the <em class="filename">makefile</em>. We will discuss this issue in the
      <a class="link" href="#OEBPS/ch05s02.html" title="Which Shell to Use">Section 5.2</a> later in this
      chapter.</p><div class="sect1" title="解析命令"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05.html.make3-CHP-5-SECT-1"></a>解析命令</h1><h1 class="title"><a></a>Parsing Commands</h1></div></div></div><p>遵循<em class="command">make</em>目标，行<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1300" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1301" class="indexterm"></a>第一个字符是制表符的字符被假定为命令（除非前一行以反斜杠继续）。
         <acronym class="acronym">GNU </acronym> <em class="command">make</em>在处理其他上下文中的选项卡时尝试尽可能智能。例如，当不存在歧义时，注释、变量赋值和包含指令都可以使用制表符作为其第一个字符。如果<em class="command">make</em>读取的命令行没有紧跟目标，则会显示错误消息：</p><p>Following a <em class="command">make</em> target,
        lines <a class="indexterm"></a> <a class="indexterm"></a>whose first character is a tab are assumed to be
        commands (unless the previous line was continued with a backslash).
        <acronym class="acronym">GNU</acronym> <em class="command">make</em> tries
        to be as smart as possible when handling tabs in other contexts. For
        instance, when there is no possible ambiguity, comments, variable
        assignments, and include directives may all use a tab as their first
        character. If <em class="command">make</em> reads a command
        line that does not immediately follow a target, an error message is
        displayed:</p><a id="OEBPS/ch05.html.I_5_tt259"></a><pre class="programlisting">makefile:20: *** 命令在第一个目标之前开始。停止。</pre><pre class="programlisting">makefile:20: *** commands commence before first target.  Stop.</pre><p>该消息的措辞有点奇怪，因为它经常出现在指定“第一个”目标之后很久的<em class="filename">makefile</em>中间，但我们现在可以轻松理解它。此消息的更好措辞可能是“在目标上下文之外遇到命令”。</p><p>The wording of this message is a bit odd because it often occurs
        in the middle of a <em class="filename">makefile</em> long
        after the "first" target was specified, but we can now understand it
        without too much trouble. A better wording for this message might be,
        "encountered a command outside the context of a target."</p><p>当解析器在合法上下文中看到命令时，它会切换到“命令解析”模式，一次构建一行脚本。当遇到不可能是一部分的行时，它会停止附加到脚本<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1302" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1303" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1304" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1305" class="indexterm"></a>命令脚本的。脚本到此结束。命令脚本中可能会出现以下内容：</p><p>When the parser sees a command in a legal context, it switches
        to "command parsing" mode, building the script one line at a time. It
        stops appending to the script when it encounters a line that cannot
        possibly be part<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> of the command script. There the script ends. The
        following may appear in a command script:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>以制表符开头的行是将由子 shell 执行的命令。即使是通常被解释为<em class="command">make</em>结构的行（例如，<code class="literal">ifdef</code>注释、
            <code class="literal">include</code>指令）在“命令解析”模式下也会被视为命令。</p></li><li class="listitem"><p>Lines beginning with a tab character are commands that will
            be executed by a subshell. Even lines that would normally be
            interpreted as <em class="command">make</em> constructs
            (e.g., <code class="literal">ifdef</code>, comments,
            <code class="literal">include</code> directives) are treated
            as commands while in "command parsing" mode.</p></li><li class="listitem"><p>空行将被忽略。它们不是由子 shell“执行”的。</p></li><li class="listitem"><p>Blank lines are ignored. They are not "executed" by a
            subshell.</p></li><li class="listitem"><p>以 a 开头的行<code class="literal">#</code>（可能带有前导空格（不是制表符！））是<em class="filename">makefile</em>注释，会被忽略。</p></li><li class="listitem"><p>Lines beginning with a <code class="literal">#</code>,
            possibly with leading spaces (not tabs!), are <em class="filename">makefile</em> comments and are
            ignored.</p></li><li class="listitem"><p>条件处理指令（例如<code class="literal">ifdef</code>和<code class="literal">ifeq</code>）在命令脚本中正常识别和处理。</p></li><li class="listitem"><p>Conditional processing directives, such as <code class="literal">ifdef</code> and <code class="literal">ifeq</code>, are recognized and processed
            normally within command scripts.</p></li></ul></div><p>除非前面有制表符，否则内置<em class="command">make</em>函数会终止命令解析模式。这意味着它们必须扩展为有效的 shell 命令，或者扩展为空。函数<code class="function">warning</code>并<code class="function">eval</code>扩展为无字符。</p><p>Built-in <em class="command">make</em> functions
        terminate command parsing mode unless preceded by a tab character.
        This means they must expand to valid shell commands or to nothing. The
        functions <code class="function">warning</code> and <code class="function">eval</code> expand to no characters.</p><p><em class="command">命令脚本中允许空行和注释的</em>事实一开始可能会令人惊讶。以下几行显示了它是如何执行的：</p><p>The fact that blank lines and <em class="command">make</em> comments are allowed in command scripts
        can be surprising at first. The following lines show how it is carried
        out:</p><a id="OEBPS/ch05.html.I_5_tt260"></a><pre class="programlisting">长命令：
        @echo Line 2：后面是一个空行

        @echo 第 4 行：shell 注释如下
        # shell 注释（前导选项卡）
        @echo 第 6 行：下面是一条注释
# 注释，在行首
        @echo 第 8 行：缩进注释如下
  # 一条注释，前导空格缩进
        # 另一个注释，用前导空格缩进
        @echo 第 11 行：后面是条件语句
    ifdef 计算机规范
        @echo 运行 Windows
    万一
        @echo 第 15 行：随后是警告“命令”
        $(警告警告)
        @echo 第 17 行：eval“命令”如下
        $(eval $(shell echo Shell echo 1&gt;&amp;2))</pre><pre class="programlisting">long-command:
        @echo Line 2: A blank line follows

        @echo Line 4: A shell comment follows
        # A shell comment (leading tab)
        @echo Line 6: A make comment follows
# A make comment, at the beginning of a line
        @echo Line 8: Indented make comments follow
  # A make comment, indented with leading spaces
        # Another make comment, indented with leading spaces
        @echo Line 11: A conditional follows
    ifdef COMSPEC
        @echo Running Windows
    endif
        @echo Line 15: A warning "command" follows
        $(warning A warning)
        @echo Line 17: An eval "command" follows
        $(eval $(shell echo Shell echo 1&gt;&amp;2))</pre><p>请注意，第 5 行和第 10 行看起来相同，但有很大不同。第 5 行是 shell 注释，由前导制表符指示，而第 10 行是缩进 8 个空格的<em class="command">make</em>注释。显然，我们不建议以
        这种方式格式化<em class="command">make注释（除非您打算参加混淆的</em><em class="filename">makefile</em>竞赛）。正如您在以下输出中看到的，即使注释出现在命令脚本的上下文中，也不会执行<em class="command">make</em>注释，也不会回显到输出：</p><p>Notice that lines 5 and 10 appear identical, but are quite
        different. Line 5 is a shell comment, indicated by a leading tab,
        while line 10 is a <em class="command">make</em> comment
        indented eight spaces. Obviously, we do not recommend formatting
        <em class="command">make</em> comments this way (unless you
        intend entering an obfuscated <em class="filename">makefile</em> contest). As you can see in the
        following output, <em class="command">make</em> comments are
        not executed and are not echoed to the output even though they occur
        within the context of a command script:</p><a id="OEBPS/ch05.html.I_5_tt261"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
makefile:2：警告
贝壳回声
第 2 行：后面是一个空行
第 4 行：shell 注释如下
# shell 注释（前导选项卡）
第 6 行：后面是 make 注释
第 8 行：缩进，在后面添加注释
第 11 行：后面是条件语句
运行Windows
第 15 行：随后是警告命令
第 17 行：eval 命令如下</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
makefile:2: A warning
Shell echo
Line 2: A blank line follows
Line 4: A shell comment follows
# A shell comment (leading tab)
Line 6: A make comment follows
Line 8: Indented make comments follow
Line 11: A conditional follows
Running Windows
Line 15: A warning command follows
Line 17: An eval command follows</pre><p><code class="function">warning</code>
        和函数的输出<code class="function">eval</code>似乎是无序的，但不用担心，事实并非如此。 （我们将在本章后面的<a class="link" href="#OEBPS/ch05s05.html" title="评估命令">第 5.5 节</a>中讨论求值的顺序。）命令脚本可以包含任意数量的空行和注释，这一事实可能会成为令人沮丧的错误来源。假设您不小心引入了带有前导制表符的行。如果先前的目标（带或不带命令）存在，并且中间只有注释或空行，则<em class="command">make</em>会将意外的选项卡行视为与先前目标关联的命令。正如您所看到的，这是完全合法的，并且不会生成警告或错误，除非同一目标在<em class="filename">makefile</em>（或其包含文件之一）中的其他位置有规则。</p><p>The output of the <code class="function">warning</code>
        and <code class="function">eval</code> functions appears to be
        out of order, but don't worry, it isn't. (We'll discuss the order of
        evaluation later this chapter in <a class="link" href="#OEBPS/ch05s05.html" title="Evaluating Commands">Section 5.5</a>.) The fact that
        command scripts can contain any number of blank lines and comments can
        be a frustrating source of errors. Suppose you accidentally introduce
        a line with a leading tab. If a previous target (with or without
        commands) exists and you have only comments or blank lines
        intervening, <em class="command">make</em> will treat your
        accidental tabbed line as a command associated with the preceding
        target. As you've seen, this is perfectly legal and will not generate
        a warning or error unless the same target has a rule somewhere else in
        the <em class="filename">makefile</em> (or one of its
        include files).</p><p>如果幸运的话，您的<em class="filename">makefile</em>将在意外的制表符行和上一个命令脚本之间包含一个非空白、非注释。在这种情况下，您将收到“命令在第一个目标之前开始”消息。</p><p>If you're lucky, your <em class="filename">makefile</em> will include a nonblank,
        noncomment between your accidental tabbed line and the previous
        command script. In that case, you'll get the "commands commence before
        first target" message.</p><p>现在是简要提及软件工具的好时机。我想现在每个人都同意，使用前导选项卡来指示命令行是一个不幸的决定，但现在改变有点晚了。用一个<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1306" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1307" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1308" class="indexterm"></a>现代的语法感知编辑器可以通过明显标记可疑的结构来帮助避免潜在的问题。<acronym class="acronym">GNU </acronym>
        <em class="command">emacs</em>有一个非常好的编辑<em class="filename">makefile 的</em>模式。此模式执行语法突出显示并查找简单的语法错误，例如连续行后面的空格以及混合前导空格和制表符。稍后我将详细讨论如何使用<em class="command">emacs</em>和<em class="command">make 。</em></p><p>Now is a good time to briefly mention software tools. I think
        everyone agrees, now, that using a leading tab to indicate a command
        line was an unfortunate decision, but it's a little late to change.
        Using a <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>modern, syntax-aware editor can help head off potential
        problems by visibly marking dubious constructs. <acronym class="acronym">GNU</acronym>
        <em class="command">emacs</em> has a very nice mode for
        editing <em class="filename">makefile</em>s. This mode
        performs syntax highlighting and looks for simple syntactic errors,
        such as spaces after continuation lines and mixing leading spaces and
        tabs. I'll talk more about using <em class="command">emacs</em> and <em class="command">make</em> later on.</p><div class="sect2" title="连续长命令"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch05.html.make3-CHP-5-SECT-1.1"></a>连续长命令</h2><h2 class="title"><a></a>Continuing Long Commands</h2></div></div></div><p>由于每个命令都被执行<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1309" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1310" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1311" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1312" class="indexterm"></a>在它自己的 shell 中（或者至少
          <span class="emphasis"><em>看起来</em></span>是），需要一起运行的 shell 命令序列必须进行特殊处理。例如，假设我需要生成一个包含文件列表的文件。 Java编译器接受这样的文件来编译许多源文件。我可能会写一个这样的命令脚本：</p><p>Since each command is executed <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>in its own shell (or at least
          <span class="emphasis"><em>appears</em></span> to be), sequences of shell commands
          that need to be run together must be handled specially. For
          instance, suppose I need to generate a file containing a list of
          files. The Java compiler accepts such a file for compiling many
          source files. I might write a command script like this:</p><a id="OEBPS/ch05.html.I_5_tt262"></a><pre class="programlisting">.INTERMEDIATE：文件列表
文件列表：
        for d 在逻辑 ui 中
        做
          回显$d/*.java
        完成 &gt; $@</pre><pre class="programlisting">.INTERMEDIATE: file_list
file_list:
        for d in logic ui
        do
          echo $d/*.java
        done &gt; $@</pre><p>现在应该很清楚这是行不通的。它会生成错误：</p><p>By now it should be clear that this won't work. It generates
          the error:</p><a id="OEBPS/ch05.html.I_5_tt263"></a><pre class="programlisting">$ 制作
for d 在逻辑 ui 中
/bin/sh: -c: 第 2 行：语法错误：意外的文件结尾
make: *** [文件列表] 错误 2</pre><pre class="programlisting">$ make
for d in logic ui
/bin/sh: -c: line 2: syntax error: unexpected end of file
make: *** [file_list] Error 2</pre><p>我们的第一个修复是向每行添加连续字符：</p><p>Our first fix is to add continuation characters to each
          line:</p><a id="OEBPS/ch05.html.I_5_tt264"></a><pre class="programlisting">.INTERMEDIATE：文件列表
文件列表：
        对于逻辑 ui 中的 d \
        做 \
          回显 $d/*.java \
        完成 &gt; $@</pre><pre class="programlisting">.INTERMEDIATE: file_list
file_list:
        for d in logic ui       \
        do                      \
          echo $d/*.java        \
        done &gt; $@</pre><p>这会产生错误：</p><p>which generates the error:</p><a id="OEBPS/ch05.html.I_5_tt265"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
对于逻辑 ui 中的 d \
做 \
  回声/*.java \
完成 &gt; 文件列表
/bin/sh: -c: 第 1 行：意外标记“&gt;”附近出现语法错误
/bin/sh: -c: 第 1 行：`for d in 逻辑 ui do echo /*.java   
make: *** [文件列表] 错误 2</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
for d in logic ui       \
do                      \
  echo /*.java  \
done &gt; file_list
/bin/sh: -c: line 1: syntax error near unexpected token `&gt;'
/bin/sh: -c: line 1: `for d in logic ui  do                      echo /*.java   
make: *** [file_list] Error 2</pre><p>发生了什么？两个问题。首先，<code class="literal">d</code>需要转义对循环控制变量 的引用。其次，由于 for 循环作为单行传递到子 shell，因此我们必须在文件列表和 for 循环语句之后添加分号分隔符：</p><p>What happened? Two problems. First, the reference to the loop
          control variable, <code class="literal">d</code>, needs to be
          escaped. Second, since the for loop is passed to the subshell as a
          single line, we must add semicolon separators after the file list
          and for-loop statement:</p><a id="OEBPS/ch05.html.I_5_tt266"></a><pre class="programlisting">.INTERMEDIATE：文件列表
文件列表：
        对于逻辑 ui 中的 d； \
        做 \
          回声 $$d/*.java; \
        完成 &gt; $@</pre><pre class="programlisting">.INTERMEDIATE: file_list
file_list:
        for d in logic ui;      \
        do                      \
          echo $$d/*.java;      \
        done &gt; $@</pre><p>现在我们得到了我们期望的文件。声明目标<code class="literal">.INTERMEDIATE</code>，以便<em class="command">make</em>在编译完成后删除这个临时目标。</p><p>Now we get the file we expect. The target is declared <code class="literal">.INTERMEDIATE</code> so that <em class="command">make</em> will delete this temporary target
          after the compile is complete.</p><p>在更实际的示例中，目录列表将存储在<em class="command">make</em>变量中。如果我们确定文件的数量相对较小，我们可以使用<em class="command">make</em>函数执行相同的操作，而无需 for 循环：</p><p>In a more realistic example, the list of directories would be
          stored in a <em class="command">make</em> variable. If we
          are sure that the number of files is relatively small, we can
          perform this same operation without a for loop by using <em class="command">make</em> functions:</p><a id="OEBPS/ch05.html.I_5_tt267"></a><pre class="programlisting">.INTERMEDIATE：文件列表
文件列表：
        echo $(addsuffix /*.java,$(COMPILATION_DIRS)) &gt; $@</pre><pre class="programlisting">.INTERMEDIATE: file_list
file_list:
        echo $(addsuffix /*.java,$(COMPILATION_DIRS)) &gt; $@</pre><p>但是，如果我们期望目录列表随着时间的推移而增长，则 for 循环版本不太可能遇到命令行长度问题。</p><p>But the for-loop version is less likely to run up against
          command-line length issues if we expect the list of directories to
          grow with time.</p><p><em class="command">make</em>命令脚本中的另一个常见问题是如何切换目录。同样，应该清楚的是一个简单的命令脚本，例如：</p><p>Another common problem in <em class="command">make</em> command scripts is how to switch
          directories. Again, it should be clear that a simple command script
          like:</p><a id="OEBPS/ch05.html.I_5_tt268"></a><pre class="programlisting">标签：
        光盘源文件
        ctags--递归</pre><pre class="programlisting">TAGS:
        cd src
        ctags --recurse</pre><p>不会执行<em class="filename">src</em>子目录
          中的<em class="command">ctags</em>程序
          。为了获得我们想要的效果，我们必须将两个命令放在一行上，或者使用反斜杠转义换行符（并使用分号分隔命令）：<em class="filename"></em></p><p>will not execute the <em class="command">ctags</em>
          program in the <em class="filename">src</em>
          subdirectory. To get the effect we want, we must either place both
          commands on a single line or escape the newline with a backslash
          (and separate the commands with a semicolon):</p><a id="OEBPS/ch05.html.I_5_tt269"></a><pre class="programlisting">标签：
        cd 源文件； \
        ctags--递归</pre><pre class="programlisting">TAGS:
        cd src;           \
        ctags --recurse</pre><p>更好的版本会在执行<em class="command">ctags程序之前检查</em><em class="command">cd</em>的状态：<em class="command"></em></p><p>An even better version would check the status of the <em class="command">cd</em> before executing the <em class="command">ctags</em> program:</p><a id="OEBPS/ch05.html.I_5_tt270"></a><pre class="programlisting">标签：
        cd src &amp;&amp; \
        ctags--递归</pre><pre class="programlisting">TAGS:
        cd src &amp;&amp;           \
        ctags --recurse</pre><p>请注意，在某些情况下，省略分号可能不会产生<em class="command">make</em>或 shell 错误：</p><p>Notice that in some circumstances omitting the semicolon might
          not produce a <em class="command">make</em> or shell
          error:</p><a id="OEBPS/ch05.html.I_5_tt271"></a><pre class="programlisting">disk-free = echo "正在检查可用磁盘空间..." \
            df 。 | awk '{ 打印 $$4 }'</pre><pre class="programlisting">disk-free = echo "Checking free disk space..." \
            df . | awk '{ print $$4 }'</pre><p>此示例打印一条简单消息，后跟当前设备上的空闲块数。或者确实如此？我们不小心省略了<em class="command">echo</em>命令后面的分号，因此我们从未真正运行
          <em class="command">df</em>程序。相反，我们回响：</p><p>This example prints a simple message followed by the number of
          free blocks on the current device. Or does it? We have accidentally
          omitted the semicolon after the <em class="command">echo</em> command, so we never actually run the
          <em class="command">df</em> program. Instead, we
          echo:</p><a id="OEBPS/ch05.html.I_5_tt272"></a><pre class="programlisting">检查可用磁盘空间... df 。</pre><pre class="programlisting">Checking free disk space... df .</pre><p>进入<em class="command">awk</em>中，它会尽职尽责地打印第四个字段，<code class="literal">space..</code>..</p><p>into <em class="command">awk</em> which dutifully
          prints the fourth field, <code class="literal">space..</code>..</p><p>您可能会想到使用该<code class="literal">define</code>指令，该指令旨在创建多行命令序列，而不是连续行。不幸的是，这并不是同一个问题。当展开多行宏时，每一行都会插入到带有前导制表符的命令脚本中，并且<em class="command">make 会</em>独立处理每一行。宏的各行不在单个子 shell 中执行。因此，您还需要注意宏中的命令行延续。</p><p>It might have occurred to you to use the <code class="literal">define</code> directive, which is intended for
          creating multiline command sequences, rather than continuation
          lines. Unfortunately, this isn't quite the same problem. When a
          multiline macro is expanded, each line is inserted into the command
          script with a leading tab and <em class="command">make</em> treats each line independently. The
          lines of the macro are not executed in a single subshell. So you
          will need to pay attention to command-line continuation in macros as
          well.</p></div><div class="sect2" title="命令修饰符"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch05.html.make3-CHP-5-SECT-1.2"></a>命令修饰符</h2><h2 class="title"><a></a>Command Modifiers</h2></div></div></div><p>一个命令可以由多个前缀修改。我们之前已经见过<code class="literal">@</code>多次使用“silent”前缀。完整的前缀列表以及一些血淋淋的细节是：</p><p>A command can be modified by several prefixes. We've already
          seen the "silent" prefix, <code class="literal">@</code>, used
          many times before. The complete list of prefixes, along with some
          gory details, are:</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">@</code></span></dt><dt><span class="term"><code class="literal">@</code></span></dt><dd><p>不回声<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1313" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1314" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1315" class="indexterm"></a>命令。为了实现历史兼容性，<code class="literal">.SILENT</code>如果您希望隐藏其所有命令，则可以使您的目标成为特殊目标的先决条件
                。但是，首选使用<code class="literal">@</code>，因为它可以应用于命令脚本中的各个命令。如果你想将此修饰符应用于所有目标（尽管很难想象为什么），你可以使用
                <code class="option">—silent</code>(或<code class="option">-s</code>) 选项。</p><p><em class="command">隐藏命令可以使make</em>的输出更直观，但也会使命令的调试更加困难。如果您发现自己经常删除修饰符并恢复它们，则可以创建一个包含修饰符的<code class="literal">@</code>
                变量，例如，并在命令中使用它：<code class="literal">QUIET</code><code class="literal">@</code></p><a id="OEBPS/ch05.html.I_5_tt273"></a><pre class="programlisting">安静=@
毛茸茸的脚本：
        $(QUIET) 复杂脚本...</pre><p>然后，如果您需要在<em class="command">make</em>运行时查看复杂的脚本，只需
                <code class="literal">QUIET</code>从命令行重置变量即可：</p><a id="OEBPS/ch05.html.I_5_tt274"></a><pre class="programlisting">$ 让安静= hairy_script
复杂的脚本...</pre><div class="variablelist"><dl><dt><span class="term"><code class="literal">-</code></span></dt><dd><p>破折号前缀<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1316" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1317" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1318" class="indexterm"></a>表明错误在<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1319" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1320" class="indexterm"></a>命令应该被<em class="command">make</em>忽略。默认情况下，当
                      <em class="command">make</em>执行命令时，它会检查程序或管道的退出状态，如果返回非零（失败）退出状态，<em class="command">make</em>
                      将终止命令脚本其余部分的执行并退出。该修饰符指示<em class="command">make</em>忽略修改行的退出状态并继续，就像没有发生错误一样。我们将在下一节中更深入地讨论这个主题。</p><p>为了实现历史兼容性，您可以通过使目标成为<code class="literal">.IGNORE</code>特殊目标的先决条件来忽略命令脚本任何部分中的错误。如果要忽略整个<em class="filename">makefile中的所有错误，</em>可以使用
                      <code class="option">—ignore-errors</code>(或<code class="option">-i</code>) 选项。再说一遍，这似乎不太有用。</p></dd><dt><span class="term"><code class="literal">+</code></span></dt><dd><p>加号修饰符<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1321" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1322" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1323" class="indexterm"></a>告诉<em class="command">make</em>执行该命令，即使为<em class="command">make</em><code class="option">—just-print</code>提供了(或
                      <code class="option">-n</code>) 命令行选项
                      。它在编写递归<em class="filename">makefile</em>时使用。我们将在<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>的<a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="递归make">6.1 节</a>中更详细地讨论这个主题。<em class="command"></em><em class="filename"></em><a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="递归make"></a><a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目"></a></p></dd></dl></div><p>任何或所有这些修饰符都允许出现在一行中。显然，修饰符在命令执行之前被删除。</p></dd><dd><p>Do not echo <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>the command. For historical compatibility, you
                can make your target a prerequisite of the special target
                <code class="literal">.SILENT</code> if you want all of
                its commands to be hidden. Using <code class="literal">@</code> is preferred, however, because it
                can be applied to individual commands within a command script.
                If you want to apply this modifier to all targets (although it
                is hard to imagine why), you can use the
                <code class="option">—silent</code> (or <code class="option">-s</code>)
                option.</p><p>Hiding commands can make the output of <em class="command">make</em> easier on the eyes, but it can
                also make debugging the commands more difficult. If you find
                yourself removing the <code class="literal">@</code>
                modifiers and restoring them frequently, you might create a
                variable, say <code class="literal">QUIET</code>,
                containing the <code class="literal">@</code> modifier
                and use that on commands:</p><a></a><pre class="programlisting">QUIET = @
hairy_script:
        $(QUIET) complex script ...</pre><p>Then, if you need to see the complex script as <em class="command">make</em> runs it, just reset the
                <code class="literal">QUIET</code> variable from the
                command line:</p><a></a><pre class="programlisting">$ make QUIET= hairy_script
complex script ...</pre><div class="variablelist"><dl><dt><span class="term"><code class="literal">-</code></span></dt><dd><p>The dash prefix <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>indicates that errors in the<a class="indexterm"></a> <a class="indexterm"></a> command should be ignored by <em class="command">make</em>. By default, when
                      <em class="command">make</em> executes a
                      command, it examines the exit status of the program or
                      pipeline, and if a nonzero (failure) exit status is
                      returned, <em class="command">make</em>
                      terminates execution of the remainder of the command
                      script and exits. This modifier directs <em class="command">make</em> to ignore the exit status
                      of the modified line and continue as if no error
                      occurred. We'll discuss this topic in more depth in the
                      next section.</p><p>For historical compatibility, you can ignore
                      errors in any part of a command script by making the
                      target a prerequisite of the <code class="literal">.IGNORE</code> special target. If you
                      want to ignore all errors in the entire <em class="filename">makefile,</em> you can use the
                      <code class="option">—ignore-errors</code> (or <code class="option">-i</code>)
                      option. Again, this doesn't seem too useful.</p></dd><dt><span class="term"><code class="literal">+</code></span></dt><dd><p>The plus modifier <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>tells <em class="command">make</em> to execute the command
                      even if the <code class="option">—just-print</code> (or
                      <code class="option">-n</code>) command-line option is given to
                      <em class="command">make</em>. It is used when
                      writing recursive <em class="filename">makefile</em>s. We'll discuss this
                      topic in more detail in the <a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="Recursive make">Section 6.1</a> in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>.</p></dd></dl></div><p>Any or all of these modifiers are allowed on a single
                line. Obviously, the modifiers are stripped before the
                commands are executed.</p></dd></dl></div></div><div class="sect2" title="错误和中断"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch05.html.make3-CHP-5-SECT-1.3"></a>错误和中断</h2><h2 class="title"><a></a>Errors and Interrupts</h2></div></div></div><p><em class="command">make</em>
          执行的每个命令<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1324" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1325" class="indexterm"></a>返回一个状态码。状态为零表示命令成功。非零状态表示某种故障。有些程序使用返回状态代码来指示比简单的“错误”更有意义的内容。例如，
          如果找到匹配项， <em class="command">grep</em>将返回 0（成功）；如果未找到匹配项，则返回 1；如果发生某种错误，则返回 2。</p><p>Every command that <em class="command">make</em>
          executes <a class="indexterm"></a> <a class="indexterm"></a>returns a status code. A status of zero indicates that
          the command succeeded. A status of nonzero indicates some kind of
          failure. Some programs use the return status code to indicate
          something more meaningful than simply "error." For instance,
          <em class="command">grep</em> returns 0 (success) if a
          match is found, 1 if no match is found, and 2 if some kind of error
          occurred.</p><p>通常，当程序失败（即返回非零退出状态）时，<em class="command">make</em>会停止执行命令并以错误状态退出。有时您希望<em class="command">make</em>继续下去，尝试完成尽可能多的目标。例如，您可能希望编译尽可能多的文件，以便在一次运行中查看所有编译错误。您可以使用<code class="option">—keep-going</code>(或
          <code class="option">-k</code>) 选项来执行此操作。</p><p>Normally, when a program fails (i.e., returns a nonzero exit
          status), <em class="command">make</em> stops executing
          commands and exits with an error status. Sometimes you want <em class="command">make</em> to continue, trying to complete as
          many targets as possible. For instance, you might want to compile as
          many files as possible to see all the compilation errors in a single
          run. You can do this with the <code class="option">—keep-going</code> (or
          <code class="option">-k</code>) option.</p><p>尽管<code class="literal">-</code>修饰符会导致<em class="command">make</em>忽略各个命令中的错误，但我会尽可能避免使用它。这是因为它使自动错误处理变得复杂并且视觉上不和谐。</p><p>Although the <code class="literal">-</code> modifier
          causes <em class="command">make</em> to ignore errors in
          individual commands, I try to avoid its use whenever possible. This
          is because it complicates automated error processing and is visually
          jarring.</p><p>当<em class="command">make</em>忽略错误时，它会打印一条警告以及方括号中的目标名称。例如，以下是<em class="command">rm</em>尝试删除不存在的文件时的输出：</p><p>When <em class="command">make</em> ignores an error
          it prints a warning along with the name of the target in square
          brackets. For example, here is the output when <em class="command">rm</em> tries to delete a nonexistent
          file:</p><a id="OEBPS/ch05.html.I_5_tt275"></a><pre class="programlisting">rm 不存在的文件
rm：无法删除“不存在的文件”：没有这样的文件或目录
make: [clean] 错误 1（忽略）</pre><pre class="programlisting">rm non-existent-file
rm: cannot remove `non-existent-file': No such file or directory
make: [clean] Error 1 (ignored)</pre><p>某些命令（例如<em class="command">rm</em>）具有选项<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1326" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1327" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1328" class="indexterm"></a>抑制它们的错误退出状态。该
          <code class="option">-f</code>选项将强制<em class="command">rm</em>返回成功，同时抑制错误消息。使用此类选项比依赖前面的破折号更好。</p><p>Some commands, like <em class="command">rm</em>,
          have options <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>that suppress their error exit status. The
          <code class="option">-f</code> option will force <em class="command">rm</em> to return success while also
          suppressing error messages. Using such options is better than
          depending on a preceding dash.</p><p>有时，您希望命令失败，并且希望在程序成功时收到错误。对于这些情况，您应该能够简单地否定程序的退出状态：</p><p>Occasionally, you want a command to fail and would like to get
          an error if the program succeeds. For these situations, you should
          be able to simply negate the exit status of the program:</p><a id="OEBPS/ch05.html.I_5_tt276"></a><pre class="programlisting"># 验证代码中没有留下任何调试语句。
.PHONY：no_debug_printf
no_debug_printf：$（来源）
        ！ grep --line-number '"调试：' $^</pre><pre class="programlisting"># Verify there are no debug statements left in the code.
.PHONY: no_debug_printf
no_debug_printf: $(sources)
        ! grep --line-number '"debug:' $^</pre><p><em class="command">不幸的是， make</em> 3.80中有一个错误阻止了这种简单的使用。<em class="command">make</em>无法识别<code class="literal">!</code>需要 shell 处理的字符并执行命令行本身，从而导致错误。在这种情况下，一个简单的解决方法是添加 shell 特殊字符作为<em class="command">make 的</em>线索：</p><p>Unfortunately, there is a bug in <em class="command">make</em> 3.80 that prevents this
          straightforward use. <em class="command">make</em> does
          not recognize the <code class="literal">!</code> character as
          requiring shell processing and executes the command line itself,
          resulting in an error. In this case, a simple work around is to add
          a shell special character as a clue to <em class="command">make</em>:</p><a id="OEBPS/ch05.html.I_5_tt277"></a><pre class="programlisting"># 验证代码中没有留下任何调试语句
.PHONY：no_debug_printf
no_debug_printf：$（来源）
        ！ grep --line-number '"调试：' $^ &lt; /dev/null</pre><pre class="programlisting"># Verify there are no debug statement left in the code
.PHONY: no_debug_printf
no_debug_printf: $(sources)
        ! grep --line-number '"debug:' $^ &lt; /dev/null</pre><p>意外命令错误的另一个常见来源是使用<code class="function">if</code>不带<code class="literal">else</code>.</p><p>Another common source of unexpected command errors is using
          the shell's <code class="function">if</code> construct
          without an <code class="literal">else</code>.</p><a id="OEBPS/ch05.html.I_5_tt278"></a><pre class="programlisting">$（配置）：$（配置_模板）
        如果 [ ！ -d $(dir $@) ]; \
        然后 \
          $(MKDIR) $(目录 $@); \
        菲
        $(M4) $^ &gt; $@</pre><pre class="programlisting">$(config): $(config_template)
        if [ ! -d $(dir $@) ];     \
        then                       \
          $(MKDIR) $(dir $@);      \
        fi
        $(M4) $^ &gt; $@</pre><p>第一个命令测试输出目录是否存在，如果不存在则调用<em class="command">mkdir</em>创建它。不幸的是，如果该目录确实存在，该<code class="function">if</code>命令将返回失败退出状态（测试的退出状态），从而终止脚本。一种解决方案是添加一个<code class="literal">else</code>
          子句：</p><p>The first command tests if the output directory exists and
          calls <em class="command">mkdir</em> to create it if it
          does not. Unfortunately, if the directory does exist, the <code class="function">if</code> command returns a failure exit status
          (the exit status of the test), which terminates the script. One
          solution is to add an <code class="literal">else</code>
          clause:</p><a id="OEBPS/ch05.html.I_5_tt279"></a><pre class="programlisting">$（配置）：$（配置_模板）
        如果 [ ！ -d $(dir $@) ]; \
        然后 \
          $(MKDIR) $(目录 $@); \
        别的 \
          真的; \
        菲
        $(M4) $^ &gt; $@</pre><pre class="programlisting">$(config): $(config_template)
        if [ ! -d $(dir $@) ];     \
        then                       \
          $(MKDIR) $(dir $@);      \
        else                       \
          true;                    \
        fi
        $(M4) $^ &gt; $@</pre><p>在 shell 中，冒号 (:) 是<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1329" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1330" class="indexterm"></a>no-op 命令始终返回 true，并且可以用来代替<em class="command">true</em>。此处效果良好的替代实现是：</p><p>In the shell, the colon (:) is a<a class="indexterm"></a> <a class="indexterm"></a> no-op command that always returns true, and can be
          used instead of <em class="command">true</em>. An
          alternative implementation that works well here is:</p><a id="OEBPS/ch05.html.I_5_tt280"></a><pre class="programlisting">$（配置）：$（配置_模板）
        [[ -d $(dir $@) ]] || $(MKDIR) $(目录 $@)
        $(M4) $^ &gt; $@</pre><pre class="programlisting">$(config): $(config_template)
        [[ -d $(dir $@) ]] || $(MKDIR) $(dir $@)
        $(M4) $^ &gt; $@</pre><p>现在，当目录存在或<em class="command">mkdir</em>成功时，第一条语句为 true。另一种选择是使用<em class="command">mkdir</em>
          <code class="option">-p</code>。即使目录已经存在，这也允许<em class="command">mkdir</em>成功。即使目录存在，所有这些实现都会在子 shell 中执行某些操作。通过使用<code class="function">wildcard</code>，如果目录存在，我们可以完全省略执行。</p><p>Now the first statement is true when the directory exists or
          when the <em class="command">mkdir</em> succeeds. Another
          alternative is to use <em class="command">mkdir</em>
          <code class="option">-p</code>. This allows <em class="command">mkdir</em> to succeed even when the directory
          already exists. All these implementations execute something in a
          subshell even when the directory exists. By using <code class="function">wildcard</code>, we can omit the execution
          entirely if the directory is present.</p><a id="OEBPS/ch05.html.I_5_tt281"></a><pre class="programlisting"># $(调用 make-dir, 目录)
make-dir = $(if $(通配符 $1),,$(MKDIR) -p $1)

$（配置）：$（配置_模板）
        $(调用 make-dir, $(dir $@))
        $(M4) $^ &gt; $@</pre><pre class="programlisting"># $(call make-dir, directory)
make-dir = $(if $(wildcard $1),,$(MKDIR) -p $1)

$(config): $(config_template)
        $(call make-dir, $(dir $@))
        $(M4) $^ &gt; $@</pre><p>因为每个命令都是在自己的 shell 中执行，所以通常有<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1331" class="indexterm"></a> <a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1332" class="indexterm"></a>多行命令，每个组件用分号分隔。请注意，这些脚本中的错误可能不会终止脚本：</p><p>Because each command is executed in its own shell, it is
          common to have <a class="indexterm"></a> <a class="indexterm"></a>multiline commands with each component separated by
          semicolons. Be aware that errors within these scripts may not
          terminate the script:</p><a id="OEBPS/ch05.html.I_5_tt282"></a><pre class="programlisting">目标：
        rm rm-失败； echo 但下一个命令仍然执行</pre><pre class="programlisting">target:
        rm rm-fails; echo But the next command executes anyway</pre><p>最好尽量减少命令脚本的长度，并
          为您<em class="command">提供</em>管理退出状态和终止的机会。例如：</p><p>It is best to minimize the length of command scripts and give
          <em class="command">make</em> a chance to manage exit
          status and termination for you. For instance:</p><a id="OEBPS/ch05.html.I_5_tt283"></a><pre class="programlisting">路径修复 = -e "s;[a-zA-Z:/]*/src/;$(SOURCE_DIR)/;g" \
             -e "s;[a-zA-Z:/]*/bin/;$(OUTPUT_DIR)/;g"

# 一个好的版本。
定义修复项目路径
  sed $(路径修复) $1 &gt; $2.fixed &amp;&amp; \
  mv $2.固定$2
恩德夫

# 一个更好的版本。
定义修复项目路径
  sed $(路径修复) $1 &gt; $2.fixed
  mv $2.固定$2
恩德夫</pre><pre class="programlisting">path-fixup = -e "s;[a-zA-Z:/]*/src/;$(SOURCE_DIR)/;g" \
             -e "s;[a-zA-Z:/]*/bin/;$(OUTPUT_DIR)/;g"

# A good version.
define fix-project-paths
  sed $(path-fixup) $1 &gt; $2.fixed &amp;&amp; \
  mv $2.fixed $2
endef

# A better version.
define fix-project-paths
  sed $(path-fixup) $1 &gt; $2.fixed
  mv $2.fixed $2
endef</pre><p>该宏将 DOS 样式路径（带有正斜杠）转换为特定源和输出树的目标路径。该宏接受两个文件名，即输入文件和输出文件。仅当<em class="command">sed</em>命令正确完成时，才会小心地覆盖输出文件。 “好的”版本通过连接<em class="command">sed</em>和<em class="command">mv</em>来实现这一点<code class="literal">&amp;&amp;</code>，以便它们在单个 shell 中执行。 “更好”的版本将它们作为两个单独的命令执行，如果<em class="command">sed失败，则让</em><em class="command">make</em>终止脚本。 “更好”的版本并不更昂贵（<em class="command">mv</em>不需要shell并且直接执行），更容易阅读，并且在发生错误时提供更多信息（因为<em class="command">make</em>会指示哪个命令失败）。<em class="command"></em><em class="command"></em><em class="command"></em></p><p>This macro transforms DOS-style paths (with forward slashes)
          into destination paths for a particular source and output tree. The
          macro accepts two filenames, the input and output files. It is
          careful to overwrite the output file only if the <em class="command">sed</em> command completes correctly. The
          "good" version does this by connecting the <em class="command">sed</em> and <em class="command">mv</em> with <code class="literal">&amp;&amp;</code> so they execute in a single
          shell. The "better" version executes them as two separate commands,
          letting <em class="command">make</em> terminate the script
          if the <em class="command">sed</em> fails. The "better"
          version is no more expensive (the <em class="command">mv</em> doesn't need a shell and is executed
          directly), is easier to read, and provides more information when
          errors occur (because <em class="command">make</em> will
          indicate which command failed).</p><p><em class="command">请注意，这是一个与cd</em>常见问题不同的问题：</p><p>Note that this is a different issue than the common problem
          with <em class="command">cd</em>:</p><a id="OEBPS/ch05.html.I_5_tt284"></a><pre class="programlisting">标签：
        cd src &amp;&amp; \
        ctags--递归</pre><pre class="programlisting">TAGS:
        cd src &amp;&amp; \
        ctags --recurse</pre><p>在这种情况下，这两个语句必须在同一个子 shell 中执行。因此，命令必须由某种语句连接器分隔，例如<code class="literal">;</code>或<code class="literal">&amp;&amp;</code>。</p><p>In this case, the two statements must be executed within the
          same subshell. Therefore, the commands must be separated by some
          kind of statement connector, such as <code class="literal">;</code> or <code class="literal">&amp;&amp;</code>.</p><div class="sect3" title="删除和保留目标文件"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch05.html.make3-CHP-5-SECT-1.3.1"></a>删除和保留目标文件</h3><h3 class="title"><a></a>Deleting and preserving target files</h3></div></div></div><p>如果发生错误，<em class="command">make 会</em>
            假设目标<a id="OEBPS/ch05.html.make3-CHP-5-ITERM-1333" class="indexterm"></a>无法重制。以当前目标为先决条件的任何其他目标也无法重新创建，因此
            <em class="command">make</em>不会尝试它们，也不会执行其命令脚本的任何部分。如果
            使用<code class="option">—keep-going</code>(或<code class="option">-k</code>) 选项，则将尝试下一个目标；否则，<em class="command">退出</em>。如果当前目标是一个文件，如果该命令在完成其工作之前退出，则该文件可能会损坏。不幸的是，出于历史兼容性的原因，
             <em class="command">make</em>会将这个可能损坏的文件保留在磁盘上。由于文件的时间戳已更新，因此后续执行<em class="command">make</em>可能无法使用正确的数据更新文件。通过<em class="command">将</em>目标文件作为
            .<code class="literal">.DELETE_ON_ERROR</code>如果<code class="literal">.DELETE_ON_ERROR</code>在没有先决条件的情况下使用，则任何目标文件构建中的错误都将导致<em class="command">make</em>删除目标。</p><p>If an error occurs, <em class="command">make</em>
            assumes that the target <a class="indexterm"></a>cannot be remade. Any other targets that have the
            current target as a prerequisite also cannot be remade, so
            <em class="command">make</em> will not attempt them nor
            execute any part of their command scripts. If the
            <code class="option">—keep-going</code> (or <code class="option">-k</code>) option is
            used, the next goal will be attempted; otherwise, <em class="command">make</em> exits. If the current target is a
            file, it may be corrupt if the command exits before finishing its
            work. Unfortunately, for reasons of historical compatibility,
            <em class="command">make</em> will leave this
            potentially corrupt file on disk. Because the file's timestamp has
            been updated, subsequent executions of <em class="command">make</em> may not update the file with
            correct data. You can avoid this problem and cause <em class="command">make</em> to delete these questionable files
            when an error occurs by making the target file a prerequisite of
            <code class="literal">.DELETE_ON_ERROR</code>. If <code class="literal">.DELETE_ON_ERROR</code> is used with no
            prerequisites, errors in any target file build will cause <em class="command">make</em> to delete the target.</p><p><em class="command">当make</em>被信号（例如 Ctrl-C）中断时，就会出现互补问题。在这种情况下，
            如果文件已被修改，<em class="command">make 将</em>删除当前目标文件。有时删除文件是错误的做法。也许该文件的创建成本非常高，并且部分内容总比没有好，或者该文件可能必须存在才能使构建的其他部分继续进行。在这些情况下，您可以通过将其作为特殊目标的先决条件来保护该文件<code class="literal">.PRECIOUS</code>。</p><p>A complementary problem occurs when <em class="command">make</em> is interrupted by a signal, such as
            a Ctrl-C. In this case, <em class="command">make</em>
            deletes the current target file if the file has been modified.
            Sometimes deleting the file is the wrong thing to do. Perhaps the
            file is very expensive to create and partial contents are better
            than none, or perhaps the file must exist for other parts of the
            build to proceed. In these cases, you can protect the file by
            making it a prerequisite of the special target <code class="literal">.PRECIOUS</code>.</p></div></div></div></div></div></div>
<div id="OEBPS/ch05s02.html"><div>
<div class="sect1" title="使用哪个外壳"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05s02.html.make3-CHP-5-SECT-2"></a>使用哪个外壳</h1><h1 class="title"><a></a>Which Shell to Use</h1></div></div></div><p>当<em class="command">make</em>需要传递一个<a id="OEBPS/ch05s02.html.make3-CHP-5-ITERM-1334" class="indexterm"></a> <a id="OEBPS/ch05s02.html.make3-CHP-5-ITERM-1335" class="indexterm"></a> <a id="OEBPS/ch05s02.html.make3-CHP-5-ITERM-1336" class="indexterm"></a>命令行到子 shell，它使用<em class="filename">/bin/sh</em>。您可以通过设置<em class="command">make</em>变量来更改 shell <code class="literal">SHELL</code>。这样做之前请仔细考虑。通常，使用<em class="command">make</em>的目的
        是为开发人员社区提供一种工具，以从其源组件构建系统。通过使用对社区中其他开发人员不可用的工具或不正确的假设，很容易创建一个无法实现此目标的<em class="filename">makefile</em> 。
        在任何广泛分发的应用程序（通过匿名 ftp 或 open cvs 分发的应用程序）中使用除<em class="filename">/bin/sh之外的任何 shell 都被认为是非常糟糕的形式。我们将在</em><a class="link" href="#OEBPS/ch07.html" title="第 7 章可移植 Makefile">第 7 章</a>中更详细地讨论可移植性。</p><p>When <em class="command">make</em> needs to pass
        a<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> command line to a subshell, it uses <em class="filename">/bin/sh</em>. You can change the shell by
        setting the <em class="command">make</em> variable <code class="literal">SHELL</code>. Think carefully before doing this.
        Usually, the purpose of using <em class="command">make</em>
        is to provide a tool for a community of developers to build a system
        from its source components. It is quite easy to create a <em class="filename">makefile</em> that fails in this goal by using
        tools that are not available or assumptions that are not true for
        other developers in the community. It is considered very bad form to
        use any shell other than <em class="filename">/bin/sh</em>
        in any widely distributed application (one distributed via anonymous
        ftp or open cvs). We'll discuss portability in more detail in <a class="link" href="#OEBPS/ch07.html" title="Chapter&nbsp;7.&nbsp;Portable Makefiles">Chapter 7</a>.</p><p>然而，使用<em class="command">make</em>还有另一个上下文。通常，在封闭的开发环境中，开发人员与经过批准的开发人员小组一起在有限的机器和操作系统上工作。事实上，这是我最常遇到的环境。在这种情况下，自定义
        <em class="command">make</em>预期运行的环境是非常有意义的。开发人员将被指导如何设置他们的环境，以便在构建和生活中正常工作。</p><p>There is another context for using <em class="command">make</em>, however. Often, in closed development
        environments, the developers are working on a limited set of machines
        and operating systems with an approved group of developers. In fact,
        this is the environment I've most often found myself in. In this
        situation, it can make perfect sense to customize the environment
        <em class="command">make</em> is expected to run under.
        Developers are instructed in how to set up their environment to work
        properly with the build and life goes on.</p><p>在这样的环境中，我更喜欢“预先”做出一些可移植性牺牲。我相信这可以让整个开发过程更加顺利。其中一项牺牲是将<code class="literal">SHELL</code>变量显式设置为<em class="filename">/usr/bin/bash</em>。 bash shell 是一个可移植的、符合 POSIX 标准的 shell（因此是<em class="command">sh的超集） </em><em class="command">，</em>并且是 GNU/Linux 上的标准 shell。<em class="filename">makefile</em>中的许多可移植性问题是由于在命令脚本中使用不可移植的结构造成的。这可以通过显式使用一个标准 shell 而不是写入<em class="command">sh</em>的可移植子集来解决
        。 Paul Smith， <acronym class="acronym">GNU </acronym><em class="command">make</em>的维护者
        ，有一个网页“Paul's Rules of Makefiles”（<a class="ulink" href="http://make.paulandlesley.org/rules.html">http://make.paulandlesley.org/rules.html</a>），他在其中指出，“不要为编写可移植的 makefile 而烦恼，使用而是便携式
        <span class="emphasis"><em>品牌</em></span>！”我还会说，“如果可能的话，不要费力编写可移植的命令脚本，而是使用可移植的 shell (bash)。” bash shell<em class="command">可以</em>
        在大多数操作系统上运行，包括几乎所有 Unix、Windows、BeOS、Amiga 和 OS/2 变体。<em class="command"></em><em class="filename"></em><em class="command"></em><acronym class="acronym"></acronym> <em class="command"></em><a class="ulink" href="http://make.paulandlesley.org/rules.html"></a><span class="emphasis"><em></em></span><em class="command"></em></p><p>In environments such as this, I prefer to make some portability
        sacrifices "up front." I believe this can make the entire development
        process go much more smoothly. One such sacrifice is to explicitly set
        the <code class="literal">SHELL</code> variable to <em class="filename">/usr/bin/bash</em>. The <em class="command">bash</em> shell is a portable, POSIX-compliant
        shell (and, therefore, a superset of <em class="command">sh</em>) and is the standard shell on GNU/Linux.
        Many portability problems in <em class="filename">makefile</em>s are due to using nonportable
        constructs in command scripts. This can be solved by explicitly using
        one standard shell rather than writing to the portable subset of
        <em class="command">sh</em>. Paul Smith, the maintainer of
        <acronym class="acronym">GNU</acronym> <em class="command">make</em>, has a
        web page "Paul's Rules of Makefiles" (<a class="ulink" href="http://make.paulandlesley.org/rules.html">http://make.paulandlesley.org/rules.html</a>) on which he
        states, "Don't hassle with writing portable makefiles, use a portable
        <span class="emphasis"><em>make</em></span> instead!" I would also say, "Where possible,
        don't hassle with writing portable command scripts, use a portable
        shell (bash) instead." The <em class="command">bash</em>
        shell runs on most operating systems including virtually all variants
        of Unix, Windows, BeOS, Amiga, and OS/2.</p><p>在本书的其余部分中，我将在命令脚本使用特定于 bash 的功能时进行说明。</p><p>For the remainder of this book, I will note when a command
        script uses bash-specific features.</p></div></div></div>
<div id="OEBPS/ch05s03.html"><div>
<div class="sect1" title="空命令"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05s03.html.make3-CHP-5-SECT-3"></a>空命令</h1><h1 class="title"><a></a>Empty Commands</h1></div></div></div><p><em class="firstterm">空</em>命令是<a id="OEBPS/ch05s03.html.make3-CHP-5-ITERM-1337" class="indexterm"></a> <a id="OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338" class="indexterm"></a>一个什么也不做的人。</p><p>An <em class="firstterm">empty command</em> is<a class="indexterm"></a> <a class="indexterm"></a> one that does nothing.</p><a id="OEBPS/ch05s03.html.I_5_tt285"></a><pre class="programlisting">标题.h: ;</pre><pre class="programlisting">header.h: ;</pre><p>回想一下，目标的先决条件列表后面可以跟一个分号和命令。这里的分号后面什么都没有，表示没有命令。您可以使用仅包含选项卡的行来跟随目标，但这将无法读取。空命令最常用于防止模式规则匹配目标并执行您不想要的命令。</p><p>Recall that the prerequisites list for a target can be followed
        by a semicolon and the command. Here a semicolon with nothing after it
        indicates that there are no commands. You could instead follow the
        target with a line containing only a tab, but that would be impossible
        to read. Empty commands are most often used to prevent a pattern rule
        from matching the target and executing commands you don't want.</p><p>请注意，在其他版本的<em class="command">make</em>中，空目标有时被用作虚假目标。在<acronym class="acronym">GNU </acronym> <em class="command">make</em>中，改用<code class="literal">.PHONY</code>特殊目标；它更安全、更清晰。</p><p>Note that in other versions of <em class="command">make</em>, empty targets are sometimes used as
        phony targets. In <acronym class="acronym">GNU</acronym> <em class="command">make</em>, use the <code class="literal">.PHONY</code> special target instead; it's safer
        and clearer.</p></div></div></div>
<div id="OEBPS/ch05s04.html"><div>
<div class="sect1" title="命令环境"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05s04.html.make3-CHP-5-SECT-4"></a>命令环境</h1><h1 class="title"><a></a>Command Environment</h1></div></div></div><p><em class="command">make</em>执行的命令<em class="command"></em>
        <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1340" class="indexterm"></a><em class="command">从make</em>本身继承它们的处理环境。该环境包括当前工作目录、文件描述符以及<em class="command">make</em>传递的环境变量。</p><p>Commands executed by <em class="command">make</em>
        <a class="indexterm"></a> <a class="indexterm"></a>inherit their processing environment from <em class="command">make</em> itself. This environment includes the
        current working directory, file descriptors, and the environment
        variables passed by <em class="command">make</em>.</p><p>创建子 shell 时，<em class="command">make</em>会向环境添加一些变量：</p><p>When a subshell is created, <em class="command">make</em> adds a few variables to the
        environment:</p><a id="OEBPS/ch05s04.html.I_5_tt286"></a><pre class="programlisting">制作标志
MFLAGS
制造水平</pre><pre class="programlisting">MAKEFLAGS
MFLAGS
MAKELEVEL</pre><p>变量<code class="literal">MAKEFLAGS</code>​
        <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1343" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344" class="indexterm"></a><em class="command">包括传递给make 的</em>命令行选项。该<code class="literal">MFLAGS</code>变量反映<code class="literal">MAKEFLAGS</code>并因历史原因而存在。变量<code class="literal">MAKELEVEL</code>​<a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1347" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348" class="indexterm"></a><em class="command">表示嵌套make</em>调用的数量。也就是说，当<em class="command">make</em>递归调用<em class="command">make</em>时，<code class="literal">MAKELEVEL</code>变量加一。单父<em class="command">make</em>的子进程将有<code class="literal">MAKELEVEL</code>一个。这些变量通常用于管理递归<em class="command">make</em>。我们将在<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>的<a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="递归make">6.1 节</a>中讨论它们。<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目"></a></p><p>The <code class="literal">MAKEFLAGS</code> variable
        <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>includes the command-line options passed to <em class="command">make</em>. The <code class="literal">MFLAGS</code> variable mirrors <code class="literal">MAKEFLAGS</code> and exists for historical reasons.
        The <code class="literal">MAKELEVEL</code> variable <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>indicates the number of nested <em class="command">make</em> invocations. That is, when <em class="command">make</em> recursively invokes <em class="command">make</em>, the <code class="literal">MAKELEVEL</code> variable increases by one.
        Subprocesses of a single parent <em class="command">make</em> will have a <code class="literal">MAKELEVEL</code> of one. These variables are
        typically used for managing recursive <em class="command">make</em>. We'll discuss them in the <a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="Recursive make">Section 6.1</a> in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>.</p><p>当然，用户可以使用该<code class="function">export</code>指令将他们喜欢的任何变量添加到子进程环境中。</p><p>Of course, the user can add whatever variables they like to the
        subprocess environment with the use of the <code class="function">export</code> directive.</p><p>已执行命令的当前工作目录是父<em class="command">make</em>的工作目录。这通常与执行<em class="command">make</em>程序的目录相同，但可以使用
        (或) 命令行选项进行更改。请注意，仅
        使用指定不同的<em class="filename">makefile</em>不会更改当前目录，只会读取<em class="filename">makefile</em>。<code class="literal">--directory=<em class="replaceable"><code>directory</code></em></code><code class="option">-C</code><em class="filename"></em><code class="option">—file</code><em class="filename"></em></p><p>The current working directory for an executed command is the
        working directory of the parent <em class="command">make</em>. This is typically the same as the
        directory the <em class="command">make</em> program was
        executed from, but can be changed with the the <code class="literal">--directory=<em class="replaceable"><code>directory</code></em></code>
        (or <code class="option">-C</code>) command-line option. Note that simply
        specifying a different <em class="filename">makefile</em>
        using <code class="option">—file</code> does not change the current directory,
        only the <em class="filename">makefile</em> read.</p><p>每个子进程<em class="command">make</em> Spawn 都会继承<a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1351" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1352" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1353" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1354" class="indexterm"></a>三个标准文件描述符：<em class="filename">stdin</em>、<em class="filename">stdout</em>和<em class="filename">stderr</em>。除了观察到命令脚本可以读取其
        <em class="filename">stdin</em>之外，这并不是特别值得注意。这是“合理的”并且有效。脚本完成读取后，其余命令将按预期执行。但是<em class="filename">makefile</em>通常期望在没有这种交互的情况下运行。用户通常希望能够开始<em class="command">构建</em>并“离开”该过程，稍后返回检查结果。当然，读取<em class="filename">stdin</em>也往往会与基于<em class="command">cron</em>的自动化构建交互不良。</p><p>Each subprocess <em class="command">make</em> spawns
        inherits <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>the three standard file descriptors: <em class="filename">stdin</em>, <em class="filename">stdout</em>, and <em class="filename">stderr</em>. This is not particularly noteworthy
        except to observe that it is possible for a command script to read its
        <em class="filename">stdin</em>. This is "reasonable" and
        works. Once the script completes its read, the remaining commands are
        executed as expected. But <em class="filename">makefile</em>s are generally expected to run
        without this kind of interaction. Users often expect to be able to
        start a <em class="command">make</em> and "walk away" from
        the process, returning later to examine the results. Of course,
        reading the <em class="filename">stdin</em> will also tend
        to interact poorly with <em class="command">cron</em>-based
        automated builds.</p><p><em class="filename">makefile</em>中的一个常见错误是意外读取<em class="filename">stdin</em> 
        ：</p><p>A common error in <em class="filename">makefile</em>s
        is to read the <em class="filename">stdin</em>
        accidentally:</p><a id="OEBPS/ch05s04.html.I_5_tt287"></a><pre class="programlisting">$（数据文件）：$（原始数据）
        grep 模式 $(RAW_DATA_FILES) &gt; $@</pre><pre class="programlisting">$(DATA_FILE): $(RAW_DATA)
        grep pattern $(RAW_DATA_FILES) &gt; $@</pre><p>
        这里指定了<em class="command">grep</em>的输入文件<a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1355" class="indexterm"></a> <a id="OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356" class="indexterm"></a>带有一个变量（本例中拼写错误）。如果变量扩展为空，<em class="command">则 grep</em>会继续读取<em class="filename">标准输入</em>，而不会提示或指示<em class="command">make</em>为何“挂起”。解决此问题的一个简单方法是始终在命令行上包含<em class="filename">/dev/null作为附加“文件”：</em></p><p>Here the input file to <em class="command">grep</em>
        is specified <a class="indexterm"></a> <a class="indexterm"></a>with a variable (misspelled in this example). If the
        variable expands to nothing, the <em class="command">grep</em> is left to read the <em class="filename">stdin</em> with no prompt or indication of why
        the <em class="command">make</em> is "hanging." A simple way
        around this issue is to always include <em class="filename">/dev/null</em> on the command line as an
        additional "file":</p><a id="OEBPS/ch05s04.html.I_5_tt288"></a><pre class="programlisting">$（数据文件）：$（原始数据）
        grep 模式 $(RAW_DATA_FILES) /dev/null &gt; $@</pre><pre class="programlisting">$(DATA_FILE): $(RAW_DATA)
        grep pattern $(RAW_DATA_FILES) /dev/null &gt; $@</pre><p>此<em class="command">grep</em>命令永远不会尝试读取<em class="filename">stdin</em>。当然，调试<em class="filename">makefile</em>也是合适的！</p><p>This <em class="command">grep</em> command will never
        attempt to read <em class="filename">stdin</em>. Of course,
        debugging the <em class="filename">makefile</em> is also
        appropriate!</p></div></div></div>
<div id="OEBPS/ch05s05.html"><div>
<div class="sect1" title="评估命令"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05s05.html.make3-CHP-5-SECT-5"></a>评估命令</h1><h1 class="title"><a></a>Evaluating Commands</h1></div></div></div><p>命令脚本处理发生在<a id="OEBPS/ch05s05.html.make3-CHP-5-ITERM-1357" class="indexterm"></a>四个步骤：读取代码、扩展变量、计算
        <em class="command">make</em>表达式、执行命令。让我们看看这些步骤如何应用于复杂的命令脚本。考虑这个（有点做作的）<em class="filename">makefile</em>。链接应用程序，然后选择性地去除符号并使用<em class="command">upx</em>可执行加壳程序进行压缩：</p><p>Command script processing occurs in <a class="indexterm"></a>four steps: read the code, expand variables, evaluate
        <em class="command">make</em> expressions, and execute
        commands. Let's see how these steps apply to a complex command script.
        Consider this (somewhat contrived) <em class="filename">makefile</em>. An application is linked, then
        optionally stripped of symbols and compressed using the <em class="command">upx</em> executable packer:</p><a id="OEBPS/ch05s05.html.I_5_tt289"></a><pre class="programlisting"># $(调用条带程序，文件)
定义条带程序
  脱衣 $1
恩德夫

复杂脚本：
        $(CC) $^ -o $@
    ifdef 条带
        $(调用剥离程序，$@)
    万一
        $(如果$(PACK), upx --最好$@)
        $(警告最终大小：$(shell ls -s $@))</pre><pre class="programlisting"># $(call strip-program, file)
define strip-program
  strip $1
endef

complex_script:
        $(CC) $^ -o $@
    ifdef STRIP
        $(call strip-program, $@)
    endif
        $(if $(PACK), upx --best $@)
        $(warning Final size: $(shell ls -s $@))</pre><p>命令脚本的评估被推迟到执行后，但<code class="literal">ifdef</code>指令无论何时出现都会立即处理。因此，<em class="command">make</em>读取命令脚本，忽略内容并存储每一行​​，直到到达 line <code class="literal">ifdef</code> <code class="literal">STRIP</code>。它评估测试，如果
        <code class="literal">STRIP</code>未定义，<em class="command">则读取</em>并丢弃直到（包括结束）的所有文本<code class="literal">endif</code>。
        然后<em class="command">make</em>继续读取并存储脚本的其余部分。</p><p>The evaluation of command scripts is deferred until they are
        executed, but <code class="literal">ifdef</code> directives are
        processed immediately wherever they occur. Therefore, <em class="command">make</em> reads the command script, ignoring the
        content and storing each line until it gets to the line <code class="literal">ifdef</code> <code class="literal">STRIP</code>. It evaluates the test and, if
        <code class="literal">STRIP</code> is not defined, <em class="command">make</em> reads and discards all the text up to
        and including the closing <code class="literal">endif</code>.
        <em class="command">make</em> then continues reading and
        storing the rest of the script.</p><p>当要执行命令脚本时，<em class="command">make</em>首先扫描脚本以查找需要扩展或评估的<em class="command">make</em>结构。展开宏时，每行前面都会添加一个前导制表符。如果您没有做好准备，在执行任何命令之前进行扩展和评估可能会导致意外的执行顺序。在我们的示例中，脚本的最后一行是错误的。<code class="function">shell</code>和命令
        在链接应用程序<span class="emphasis"><em>之前</em></span><code class="function">warning</code>执行
        。因此，
         <em class="command">ls</em>命令将在其正在检查的文件更新之前执行。这解释了前面<a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1" title="解析命令">第 5.1 节</a>中看到的“乱序”输出。<span class="emphasis"><em></em></span><em class="command"></em><a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1" title="解析命令"></a></p><p>When a command script is to be executed, <em class="command">make</em> first scans the script for <em class="command">make</em> constructs that need to be expanded or
        evaluated. When macros are expanded, a leading tab is prepended to
        each line. Expanding and evaluating before any commands are executed
        can lead to an unexpected execution order if you aren't prepared for
        it. In our example, the last line of the script is wrong. The
        <code class="function">shell</code> and <code class="function">warning</code> commands are executed
        <span class="emphasis"><em>before</em></span> linking the application. Therefore, the
        <em class="command">ls</em> command will be executed before
        the file it is examining has been updated. This explains the "out of
        order" output seen earlier in <a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1" title="Parsing Commands">Section 5.1</a>.</p><p>另请注意，该<code class="literal">ifdef</code>
        <code class="literal">STRIP</code>行是在读取文件时评估的，但该行是在执行<code class="literal">$(if...)</code>
        命令之前立即评估的。<code class="literal">complex_script</code>使用该
        <code class="function">if</code>函数更加灵活，因为有更多机会控制何时定义变量，但它不太适合管理大文本块。</p><p>Also, notice that the <code class="literal">ifdef</code>
        <code class="literal">STRIP</code> line is evaluated while
        reading the file, but the <code class="literal">$(if...)</code>
        line is evaluated immediately before the commands for <code class="literal">complex_script</code> are executed. Using the
        <code class="function">if</code> function is more flexible
        since there are more opportunities to control when the variable is
        defined, but it is not very well suited for managing large blocks of
        text.</p><p>正如本例所示，始终注意哪个程序正在计算表达式（例如<em class="command">make</em>或 shell）以及何时执行计算，这一点很重要：</p><p>As this example shows, it is important to always attend to what
        program is evaluating an expression (e.g., <em class="command">make</em> or the shell) and when the evaluation
        is performed:</p><a id="OEBPS/ch05s05.html.I_5_tt290"></a><pre class="programlisting">$(LINK.c) $(shell find $(if $(ALL),$(通配符 core ext*),core) -name '*.o')</pre><pre class="programlisting">$(LINK.c) $(shell find $(if $(ALL),$(wildcard core ext*),core) -name '*.o')</pre><p>这个复杂的命令脚本尝试链接一组目标文件。评估的顺序和执行操作的程序（在括号中）是：</p><p>This convoluted command script attempts to link a set of object
        files. The sequence of evaluation and the program performing the
        operation (in parentheses) is:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>展开<code class="literal">$ALL</code>（<em class="command">制作</em>）。</p></li><li class="listitem"><p>Expand <code class="literal">$ALL</code> (<em class="command">make</em>).</p></li><li class="listitem"><p>评估<code class="function">if</code>（<em class="command">做出</em>）。</p></li><li class="listitem"><p>Evaluate <code class="function">if</code> (<em class="command">make</em>).</p></li><li class="listitem"><p>评估<code class="function">wildcard</code>，假设<code class="literal">ALL</code>不为空 ( <em class="command">make</em> )。</p></li><li class="listitem"><p>Evaluate the <code class="function">wildcard</code>,
            assuming <code class="literal">ALL</code> is not empty
            (<em class="command">make</em>).</p></li><li class="listitem"><p>评估<code class="function">shell</code>
            （<em class="command">制作</em>）。</p></li><li class="listitem"><p>Evaluate the <code class="function">shell</code>
            (<em class="command">make</em>).</p></li><li class="listitem"><p>执行查找<em class="command">（</em> 
            sh <em class="command">）</em>。</p></li><li class="listitem"><p>Execute the <em class="command">find</em>
            (<em class="command">sh</em>).</p></li><li class="listitem"><p><em class="command">完成make</em>结构的扩展和评估后
            ，执行链接命令 ( <em class="command">sh</em> )。</p></li><li class="listitem"><p>After completing the expansion and evaluation of the
            <em class="command">make</em> constructs, execute the
            link command (<em class="command">sh</em>).</p></li></ol></div></div></div></div>
<div id="OEBPS/ch05s06.html"><div>
<div class="sect1" title="命令行限制"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch05s06.html.make3-CHP-5-SECT-6"></a>命令行限制</h1><h1 class="title"><a></a>Command-Line Limits</h1></div></div></div><p>在处理大型项目时，您偶尔会<a id="OEBPS/ch05s06.html.make3-CHP-5-ITERM-1358" class="indexterm"></a><em class="command">make</em>尝试执行的命令长度受到限制
        。命令行限制随操作系统的不同而有很大差异。 Red Hat 9 GNU/Linux 似乎有大约 128K 字符的限制，而 Windows XP 则有 32K 字符的限制。生成的错误消息也各不相同。在使用 Cygwin 端口的 Windows 上，消息为：</p><p>When working with large projects, you occasionally <a class="indexterm"></a>bump up against limitations in the length of commands
        <em class="command">make</em> tries to execute. Command-line
        limits vary widely with the operating system. Red Hat 9 GNU/Linux
        appears to have a limit of about 128K characters, while Windows XP has
        a limit of 32K. The error message generated also varies. On Windows
        using the Cygwin port, the message is:</p><a id="OEBPS/ch05s06.html.I_5_tt291"></a><pre class="programlisting">C:\usr\cygwin\bin\bash: /usr/bin/ls: 无效参数</pre><pre class="programlisting">C:\usr\cygwin\bin\bash: /usr/bin/ls: Invalid argument</pre><p>当<em class="command">ls</em>给出的参数列表太长时。在 Red Hat 9 上，消息是：</p><p>when <em class="command">ls</em> is given too long an
        argument list. On Red Hat 9 the message is:</p><a id="OEBPS/ch05s06.html.I_5_tt292"></a><pre class="programlisting">/bin/ls：参数列表太长</pre><pre class="programlisting">/bin/ls: argument list too long</pre><p>对于命令行来说，即使 32K 听起来也很大，但是当您的项目在 100 个子目录中包含 3,000 个文件并且您想要操作所有文件时，此限制可能会受到限制。</p><p>Even 32K sounds like a lot of data for a command line, but when
        your project contains 3,000 files in 100 subdirectories and you want
        to manipulate them all, this limit can be constraining.</p><p>有两种基本方法可以让您陷入困境：使用 shell 工具扩展一些基本值，或者使用<em class="command">make</em>本身将变量设置为很长的值。例如，假设我们想在单个命令行中编译所有源文件：</p><p>There are two basic ways to get yourself into this mess: expand
        some basic value using shell tools, or use <em class="command">make</em> itself to set a variable to a very long
        value. For example, suppose we want to compile all our source files in
        a single command line:</p><a id="OEBPS/ch05s06.html.I_5_tt293"></a><pre class="programlisting">编译全部：
        $(JAVAC) $(通配符 $(addsuffix /*.java,$(source_dirs)))</pre><pre class="programlisting">compile_all:
        $(JAVAC) $(wildcard $(addsuffix /*.java,$(source_dirs)))</pre><p>make变量可能只包含几百个单词，但是在附加 Java 文件的通配符并使用 扩展它之后，<em class="command">这个</em>列表很容易超出系统的命令行限制。顺便说一下，<em class="command">make</em>没有内置的限制来约束我们。只要有可用的虚拟内存，<em class="command">make</em>就允许您创建任意数量的数据。<code class="literal">source_dirs</code><code class="function">wildcard</code><em class="command"></em><em class="command"></em></p><p>The <em class="command">make</em> variable <code class="literal">source_dirs</code> may contain only a couple
        hundred words, but after appending the wildcard for Java files and
        expanding it using <code class="function">wildcard</code>, this
        list can easily exceed the command-line limit of the system. By the
        way, <em class="command">make</em> has no built-in limits to
        constrain us. So long as there is virtual memory available, <em class="command">make</em> will allow any amount of data you care
        to create.</p><p>当你发现自己处于这种情况时，感觉就像古老的冒险游戏一样，“你处于一个曲折的迷宫中，通道都是相似的。”例如，您可能尝试使用<em class="command">xargs</em>解决上述问题，因为<em class="command">xargs</em>将通过将参数分配到系统特定的长度来管理长命令行：</p><p>When you find yourself in this situation, it can feel like the
        old Adventure game, "You are in a twisty maze of passages all alike."
        For instance, you might try to solve the above using <em class="command">xargs</em>, since <em class="command">xargs</em> will manage long command lines by
        parceling out arguments up to the system-specific length:</p><a id="OEBPS/ch05s06.html.I_5_tt294"></a><pre class="programlisting">编译全部：
        echo $(通配符$(addsuffix /*.java,$(source_dirs))) | \
        xargs $(JAVAC)</pre><pre class="programlisting">compile_all:
        echo $(wildcard $(addsuffix /*.java,$(source_dirs))) | \
        xargs $(JAVAC)</pre><p>不幸的是，我们刚刚将命令行限制问题从<em class="command">javac</em>命令行转移到了
        <em class="command">echo</em>命令<a id="OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359" class="indexterm"></a> <a id="OEBPS/ch05s06.html.make3-CHP-5-ITERM-1360" class="indexterm"></a>线。同样，我们不能使用<em class="command">echo</em>或<em class="command">printf</em>将数据写入文件（假设编译器可以从文件中读取文件列表）。</p><p>Unfortunately, we've just moved the command-line limit problem
        from the <em class="command">javac</em> command line to the
        <em class="command">echo</em> command <a class="indexterm"></a> <a class="indexterm"></a>line. Similarly, we cannot use <em class="command">echo</em> or <em class="command">printf</em> to write the data to a file (assuming
        the compiler can read the file list from a file).</p><p>不，处理这种情况的方法是首先避免一次创建所有文件列表。相反，使用 shell 一次遍历一个目录：</p><p>No, the way to handle this situation is to avoid creating the
        file list all at once in the first place. Instead, use the shell to
        glob one directory at a time:</p><a id="OEBPS/ch05s06.html.I_5_tt295"></a><pre class="programlisting">编译全部：
        for d in $(source_dirs); \
        做 \
            $(JAVAC) $$d/*.java; \
        完毕</pre><pre class="programlisting">compile_all:
        for d in $(source_dirs); \
        do                       \
            $(JAVAC) $$d/*.java; \
        done</pre><p>我们还可以将文件列表通过管道传输到<em class="command">xargs</em>，以更少的执行次数来执行任务：</p><p>We could also pipe the file list to <em class="command">xargs</em> to perform the task with fewer
        executions:</p><a id="OEBPS/ch05s06.html.I_5_tt296"></a><pre class="programlisting">编译全部：
        for d in $(source_dirs); \
        做 \
            回声 $$d/*.java; \
        完成 | \
        xargs $(JAVAC)</pre><pre class="programlisting">compile_all:
        for d in $(source_dirs); \
        do                       \
            echo $$d/*.java;     \
        done |                   \
        xargs $(JAVAC)</pre><p>遗憾的是，这些命令脚本都没有正确处理编译期间的错误。如果编译器支持从文件中读取其参数，更好的方法是保存完整的文件列表并将其提供给编译器。 Java 编译器支持此功能：</p><p>Sadly, neither of these command scripts handle errors during
        compilation properly. A better approach would be to save the full file
        list and feed it to the compiler, if the compiler supports reading its
        arguments from a file. Java compilers support this feature:</p><a id="OEBPS/ch05s06.html.I_5_tt297"></a><pre class="programlisting">编译全部：$(FILE_LIST)
        $(JAVA)@$&lt;

.INTERMEDIATE：$(FILE_LIST)
$（文件列表）：
        for d in $(source_dirs); \
        做 \
            回声 $$d/*.java; \
        完成 &gt; $@</pre><pre class="programlisting">compile_all: $(FILE_LIST)
        $(JAVA) @$&lt;

.INTERMEDIATE: $(FILE_LIST)
$(FILE_LIST):
        for d in $(source_dirs); \
        do                       \
            echo $$d/*.java;     \
        done &gt; $@</pre><p><em class="command">请注意for</em>循环中的微妙错误。如果任何目录不包含 Java 文件，则该字符串<code class="literal">*.java</code>将包含在文件列表中，并且 Java 编译器将生成“找不到文件”错误。我们可以通过设置选项使
        <em class="command">bash</em>折叠空的通配模式<code class="literal">nullglob</code>
        。</p><p>Notice the subtle error in the <em class="command">for</em> loop. If any of the directories does not
        contain a Java file, the string <code class="literal">*.java</code> will be included in the file list and
        the Java compiler will generate a "File not found" error. We can make
        <em class="command">bash</em> collapse empty globbing
        patterns by setting the <code class="literal">nullglob</code>
        option.</p><a id="OEBPS/ch05s06.html.I_5_tt298"></a><pre class="programlisting">编译全部：$(FILE_LIST)
        $(JAVA)@$&lt;

.INTERMEDIATE：$(FILE_LIST)
$（文件列表）：
        shopt -s nullglob； \
        for d in $(source_dirs); \
        做 \
            回声 $$d/*.java; \
        完成 &gt; $@</pre><pre class="programlisting">compile_all: $(FILE_LIST)
        $(JAVA) @$&lt;

.INTERMEDIATE: $(FILE_LIST)
$(FILE_LIST):
        shopt -s nullglob;       \
        for d in $(source_dirs); \
        do                       \
            echo $$d/*.java;     \
        done &gt; $@</pre><p>许多项目必须制作文件列表。这是一个包含生成文件列表的<em class="command">bash</em>脚本的宏。第一个参数是要更改到的根目录。列表中的所有文件都将相对于该根目录。第二个参数是用于搜索匹配文件的目录列表。第三个和第四个参数是可选的，代表文件后缀。</p><p>Many projects have to make lists of files. Here is a macro
        containing a <em class="command">bash</em> script producing
        file lists. The first argument is the root directory to change to. All
        the files in the list will be relative to this root directory. The
        second argument is a list of directories to search for matching files.
        The third and fourth arguments are optional and represent file
        suffixes.</p><a id="OEBPS/ch05s06.html.I_5_tt299"></a><pre class="programlisting"># $(调用collect-names, root-dir, dir-list, suffix1-opt, suffix2-opt)
定义收集名称
  echo 从目录列表中创建$@...
  光盘1美元； \
  shopt -s nullglob； \
  for f in $(foreach file,$2,'$(file)');做 \
    文件=( $$f$(如果$3,/*.{$3$(如果$4,$(逗号)$4)}) ); \
    if (( $${#files[@]} &gt; 0 )); \
    然后 \
      printf '"%s"\n' $${files[@]}; \
    别的 ：;菲； \
  完毕
恩德夫</pre><pre class="programlisting"># $(call collect-names, root-dir, dir-list, suffix1-opt, suffix2-opt)
define collect-names
  echo Making $@ from directory list...
  cd $1;                                                    \
  shopt -s nullglob;                                        \
  for f in $(foreach file,$2,'$(file)'); do                 \
    files=( $$f$(if $3,/*.{$3$(if $4,$(comma)$4)}) );       \
    if (( $${#files[@]} &gt; 0 ));                             \
    then                                                    \
      printf '"%s"\n' $${files[@]};                         \
    else :; fi;                                             \
  done
endef</pre><p>以下是创建图像文件列表的模式规则：</p><p>Here is a pattern rule for creating a list of image
        files:</p><a id="OEBPS/ch05s06.html.I_5_tt300"></a><pre class="programlisting">％。图片：
        @$(调用收集名称,$(SOURCE_DIR),$^,gif,jpeg) &gt; $@</pre><pre class="programlisting">%.images:
        @$(call collect-names,$(SOURCE_DIR),$^,gif,jpeg) &gt; $@</pre><p>宏执行是隐藏的，因为脚本很长，并且很少有理由剪切和粘贴此代码。先决条件中提供了目录列表。更改到根目录后，该脚本启用空通配。剩下的就是一个<em class="command">for</em>循环来处理我们想要搜索的每个目录。文件搜索表达式是传入参数的单词列表<code class="literal">$2</code>。该脚本使用单引号保护文件列表中的单词，因为它们可能包含 shell 特殊字符。特别是，Java 等语言中的文件名可以包含美元符号：</p><p>The macro execution is hidden because the script is long and
        there is seldom a reason to cut and paste this code. The directory
        list is provided in the prerequisites. After changing to the root
        directory, the script enables null globbing. The rest is a <em class="command">for</em> loop to process each directory we want
        to search. The file search expression is a list of words passed in
        parameter <code class="literal">$2</code>. The script protects
        words in the file list with single quotes because they may contain
        shell-special characters. In particular, filenames in languages like
        Java can contain dollar signs:</p><a id="OEBPS/ch05s06.html.I_5_tt301"></a><pre class="programlisting">for f in $(foreach file,$2,'$(file)');做</pre><pre class="programlisting">for f in $(foreach file,$2,'$(file)'); do</pre><p><code class="literal">files</code>我们通过填充数组来搜索目录<a id="OEBPS/ch05s06.html.make3-CHP-5-ITERM-1361" class="indexterm"></a> <a id="OEBPS/ch05s06.html.make3-CHP-5-ITERM-1362" class="indexterm"></a>通配符的结果。如果<code class="literal">files</code>数组包含任何元素，我们使用
        <em class="command">printf</em>写入每个单词，后跟换行符。使用数组允许宏正确处理带有嵌入空格的路径。这也是<em class="command">printf</em>用双引号将文件名引起来的原因。</p><p>We search a directory by filling the <code class="literal">files</code> array <a class="indexterm"></a> <a class="indexterm"></a>with the result of globbing. If the <code class="literal">files</code> array contains any elements, we use
        <em class="command">printf</em> to write each word followed
        by a newline. Using the array allows the macro to properly handle
        paths with embedded spaces. This is also the reason <em class="command">printf</em> surrounds the filename with double
        quotes.</p><p>文件列表是用以下行生成的：</p><p>The file list is produced with the line:</p><a id="OEBPS/ch05s06.html.I_5_tt302"></a><pre class="programlisting">文件=( $$f$(如果$3,/*.{$3$(如果$4,$(逗号)$4)}) );</pre><pre class="programlisting">files=( $$f$(if $3,/*.{$3$(if $4,$(comma)$4)}) );</pre><p>是<code class="literal">$$f</code>宏的目录或文件参数。以下表达式是<em class="command">make</em> <code class="function">if</code>
        测试第三个参数是否为非空。这是实现可选参数的方法。如果第三个参数为空，则假定第四个参数也为空。在这种情况下，用户传递的文件应该按原样包含在文件列表中。这允许宏构建通配符模式不合适的任意文件列表。如果提供了第三个参数，则<code class="function">if</code>附加<code class="literal">/*.{$3}</code>到根文件。如果提供了第四个参数，它将附加<code class="literal">,$4</code>在<code class="literal">$3</code>.请注意我们必须使用的诡计来将逗号插入到通配符模式中。通过在<em class="command">make</em>变量中放置逗号，
        我们可以将其偷偷地通过解析器，否则，逗号将被解释为<em class="replaceable"><code>then</code></em>将部分
        <em class="replaceable"><code>else</code></em>与<code class="function">if</code>.的定义<code class="literal">comma</code>很简单：</p><p>The <code class="literal">$$f</code> is the directory or
        file argument to the macro. The following expression is a <em class="command">make</em> <code class="function">if</code>
        testing whether the third argument is nonempty. This is how you can
        implement optional arguments. If the third argument is empty, it is
        assumed the fourth is as well. In this case, the file passed by the
        user should be included in the file list as is. This allows the macro
        to build lists of arbitrary files for which wildcard patterns are
        inappropriate. If the third argument is provided, the <code class="function">if</code> appends <code class="literal">/*.{$3}</code> to the root file. If the fourth
        argument is provided, it appends <code class="literal">,$4</code> after the <code class="literal">$3</code>. Notice the subterfuge we must use to
        insert a comma into the wildcard pattern. By placing a comma in a
        <em class="command">make</em> variable we can sneak it past
        the parser, otherwise, the comma would be interpreted as separating
        the <em class="replaceable"><code>then</code></em> part from the
        <em class="replaceable"><code>else</code></em> part of the <code class="function">if</code>. The definition of <code class="literal">comma</code> is straightforward:</p><a id="OEBPS/ch05s06.html.I_5_tt303"></a><pre class="programlisting">逗号 := ,</pre><pre class="programlisting">comma := ,</pre><p>前面的所有<em class="command">for</em>循环也受到命令行长度限制，因为它们使用通配符扩展。不同之处在于通配符是用单个目录的内容扩展的，超出限制的可能性要小得多。</p><p>All the preceding <em class="command">for</em> loops
        also suffer from the command-line length limit, since they use
        wildcard expansion. The difference is that the wildcard is expanded
        with the contents of a single directory, which is far less likely to
        exceed the limits.</p><p><em class="command">如果make</em>
        变量包含我们的长文件列表，我们该怎么办？好吧，那么我们真的有麻烦了。我发现只有两种方法可以将很长的
        <em class="command">make</em>变量传递给子 shell。第一种方法是通过过滤内容仅将变量内容的子集传递给任何一个子 shell 调用。</p><p>What do we do if a <em class="command">make</em>
        variable contains our long file list? Well, then we are in real
        trouble. There are only two ways I've found to pass a very long
        <em class="command">make</em> variable to a subshell. The
        first approach is to pass only a subset of the variable contents to
        any one subshell invocation by filtering the contents.</p><a id="OEBPS/ch05s06.html.I_5_tt304"></a><pre class="programlisting">编译全部：
        $(JAVAC) $(单词列表 1, 499, $(所有源文件))
        $(JAVAC) $(单词列表 500, 999, $(所有源文件))
        $(JAVAC) $(单词列表 1000, 1499, $(所有源文件))</pre><pre class="programlisting">compile_all:
        $(JAVAC) $(wordlist 1, 499, $(all-source-files))
        $(JAVAC) $(wordlist 500, 999, $(all-source-files))
        $(JAVAC) $(wordlist 1000, 1499, $(all-source-files))</pre><p>也可以使用该<code class="function">filter</code>函数，但这可能更加不确定，因为所选文件的数量将取决于所选模式空间内的分布。这里我们根据字母表选择一个模式：</p><p>The <code class="function">filter</code> function can be
        used as well, but that can be more uncertain since the number of files
        selected will depend on the distribution within the pattern space
        chosen. Here we choose a pattern based on the alphabet:</p><a id="OEBPS/ch05s06.html.I_5_tt305"></a><pre class="programlisting">编译全部：
        $(JAVAC) $(过滤 a%, $(所有源文件))
        $(JAVAC) $(过滤器 b%, $(所有源文件))</pre><pre class="programlisting">compile_all:
        $(JAVAC) $(filter a%, $(all-source-files))
        $(JAVAC) $(filter b%, $(all-source-files))</pre><p>其他模式可能会使用文件名本身的特殊特征。</p><p>Other patterns might use special characteristics of the
        filenames themselves.</p><p>请注意，很难进一步实现自动化。我们可以尝试将字母表方法包装在一个<code class="function">foreach</code>循环中：</p><p>Notice that it is difficult to automate this further. We could
        try to wrap the alphabet approach in a <code class="function">foreach</code> loop:</p><a id="OEBPS/ch05s06.html.I_5_tt306"></a><pre class="programlisting">编译全部：
        $(foreach l,abcde ..., \
          $(if $(过滤器 $l%, $(所有源文件)), \
            $(JAVAC) $(过滤器 $l%, $(所有源文件));))</pre><pre class="programlisting">compile_all:
        $(foreach l,a b c d e ...,                        \
          $(if $(filter $l%, $(all-source-files)),        \
            $(JAVAC) $(filter $l%, $(all-source-files));))</pre><p>但这行不通。<em class="command">make</em>
        将其扩展为单行文本，从而使行长度问题变得更加复杂。我们可以使用 eval 来代替：</p><p>but this doesn't work. <em class="command">make</em>
        expands this into a single line of text, thus compounding the
        line-length problem. We can instead use eval:</p><a id="OEBPS/ch05s06.html.I_5_tt307"></a><pre class="programlisting">编译全部：
        $(foreach l,abcde ..., \
          $(if $(过滤器 $l%, $(所有源文件)), \
            $(评估\
              $(外壳\
                $(JAVAC) $(过滤器 $l%, $(所有源文件));))))</pre><pre class="programlisting">compile_all:
        $(foreach l,a b c d e ...,                 \
          $(if $(filter $l%, $(all-source-files)), \
            $(eval                                 \
              $(shell                              \
                $(JAVAC) $(filter $l%, $(all-source-files));))))</pre><p>这是有效的，因为<code class="function">eval</code>
        将立即执行<code class="function">shell</code>命令，扩展为空。所以<code class="function">foreach</code>循环会扩展为空。问题是错误报告在这种情况下是没有意义的，因此编译错误不会被正确地传递给<em class="command">make</em>。</p><p>This works because <code class="function">eval</code>
        will execute the <code class="function">shell</code> command
        immediately, expanding to nothing. So the <code class="function">foreach</code> loop expands to nothing. The
        problem is that error reporting is meaningless in this context, so
        compilation errors will not be transmitted to <em class="command">make</em> correctly.</p><p>该<code class="function">wordlist</code>方法更糟糕。由于<em class="command">make</em>的数值能力有限，因此无法将该<code class="function">wordlist</code>技术包含在循环中。一般来说，处理巨大文件列表的令人满意的方法很少。</p><p>The <code class="function">wordlist</code> approach is
        worse. Due to <em class="command">make</em>'s limited
        numerical capabilities, there is no way to enclose the <code class="function">wordlist</code> technique in a loop. In general,
        there are very few satisfying ways to deal with immense file
        lists.</p></div></div></div>
<div id="OEBPS/pt02.html"><div>
<div class="part" title="第二部分。高级和专业主题"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pt02.html.make3-PART-2"></a>第二部分。高级和专业主题</h1><h1 class="title"><a></a>Part&nbsp;II.&nbsp;Advanced and Specialized Topics</h1></div></div></div><div class="partintro" title="高级和专业主题" id="OEBPS/pt02.html.id3152439"><div></div><p>在<a class="link" href="#OEBPS/pt02.html" title="第二部分。高级和专业主题">第二部分</a>中，我们以问题为导向的角度来看待<em class="command">make</em>。如何将<em class="command">make</em>
      应用于实际问题（例如多目录构建、新编程语言、可移植性和性能问题或调试）通常并不明显。每个问题都进行了讨论，并有一章涵盖了几个复杂的例子。</p><p>In <a class="link" href="#OEBPS/pt02.html" title="Part&nbsp;II.&nbsp;Advanced and Specialized Topics">Part II</a>, we take a
      problem-oriented view of <em class="command">make</em>. It is
      often not obvious how to apply <em class="command">make</em>
      to real-world problems such as multidirectory builds, new programming
      languages, portability and performance issues, or debugging. Each of
      these problems is discussed, along with a chapter covering several
      complex examples.</p><p><a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>，管理大型项目</p><p><a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>, Managing Large
      Projects</p><p><a class="link" href="#OEBPS/ch07.html" title="第 7 章可移植 Makefile">第 7 章</a>，可移植 Makefile</p><p><a class="link" href="#OEBPS/ch07.html" title="Chapter&nbsp;7.&nbsp;Portable Makefiles">Chapter 7</a>, Portable
      Makefiles</p><p><a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++">第8章</a>，C和C++</p><p><a class="link" href="#OEBPS/ch08.html" title="Chapter&nbsp;8.&nbsp;C and C++">Chapter 8</a>, C and C++</p><p><a class="link" href="#OEBPS/ch09.html" title="第 9 章 Java">第9章</a>，Java</p><p><a class="link" href="#OEBPS/ch09.html" title="Chapter&nbsp;9.&nbsp;Java">Chapter 9</a>, Java</p><p><a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能">第10章</a>，提高make的性能</p><p><a class="link" href="#OEBPS/ch10.html" title="Chapter&nbsp;10.&nbsp;Improving the Performance of make">Chapter 10</a>, Improving the
      Performance of make</p><p><a class="link" href="#OEBPS/ch11.html" title="第 11 章 Makefile 示例">第 11 章</a>，示例 Makefile</p><p><a class="link" href="#OEBPS/ch11.html" title="Chapter&nbsp;11.&nbsp;Example Makefiles">Chapter 11</a>, Example
      Makefiles</p><p><a class="link" href="#OEBPS/ch12.html" title="第 12 章调试 Makefile">第12章</a>，调试Makefile</p><p><a class="link" href="#OEBPS/ch12.html" title="Chapter&nbsp;12.&nbsp;Debugging Makefiles">Chapter 12</a>, Debugging
      Makefiles</p></div></div></div></div>
<div id="OEBPS/ch06.html"><div>
<div class="chapter" title="第 6 章管理大型项目"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06.html.make3-CHP-6"></a>第 6 章管理大型项目</h1><h1 class="title"><a></a>Chapter&nbsp;6.&nbsp;Managing Large Projects</h1></div></div></div><p>什么叫大项目？就我们的目的而言，它需要一组开发人员，可能在多种架构上运行，并且可能有多个需要维护的现场版本。当然，并不是所有这些都需要称为大型项目。单个平台上的一百万行预发布 C++ 仍然很大。但软件很少会永远保持预发布状态。如果成功的话，最终会有人在另一个平台上要求它。因此，大多数大型软件系统在一段时间后看起来都非常相似。</p><p>What do you call a large project? For our purposes, it is one that
      requires a team of developers, may run on multiple architectures, and
      may have several field releases that require maintenance. Of course, not
      all of these are required to call a project large. A million lines of
      prerelease C++ on a single platform is still large. But software rarely
      stays prerelease forever. And if it is successful, someone will
      eventually ask for it on another platform. So most large software
      systems wind up looking very similar after awhile.</p><p>大型软件项目通常是<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1363" class="indexterm"></a>通过将它们划分为主要组件来简化，这些组件通常收集到不同的程序、库或两者中。这些组件通常存储在它们自己的目录下，并由它们自己的
      <em class="filename">makefile</em>进行管理。构建整个组件系统的一种方法是使用顶级<em class="filename">makefile</em> ，以正确的顺序调用每个组件的<em class="filename">makefile</em> 。这种方法称为<em class="firstterm">递归 make，</em>
      因为顶级<em class="filename">makefile</em>在每个组件的<em class="filename">makefile</em>上
      递归调用<em class="command">make</em>。递归
      <em class="command">make</em>是一种常见的<em class="filename"></em><em class="command"></em><a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1364" class="indexterm"></a>处理组件式构建的技术。 Peter Miller 在 1998 年提出的替代方案通过使用包含每个组件目录信息的单个
      <em class="filename">makefile避免了递归</em><em class="command">make的许多问题。 </em><sup>[ </sup><sup><a id="OEBPS/ch06.html.make3-CHP-6-FNOTE-1" href="#OEBPS/ch06.html.ftn.make3-CHP-6-FNOTE-1" class="footnote">1</a></sup><sup> ]</sup><em class="filename"></em><sup><a id="OEBPS/ch06.html.make3-CHP-6-FNOTE-1" href="#OEBPS/ch06.html.ftn.make3-CHP-6-FNOTE-1" class="footnote"></a></sup></p><p>Large software projects are usually <a class="indexterm"></a>simplified by dividing them into major components, often
      collected into distinct programs, libraries, or both. These components
      are often stored under their own directories and managed by their own
      <em class="filename">makefile</em>s. One way to build an
      entire system of components employs a top-level <em class="filename">makefile</em> that invokes the <em class="filename">makefile</em> for each component in the proper
      order. This approach is called <em class="firstterm">recursive make</em>
      because the top-level <em class="filename">makefile</em>
      invokes <em class="command">make</em> recursively on each
      component's <em class="filename">makefile</em>. Recursive
      <em class="command">make</em> is a common <a class="indexterm"></a>technique for handling component-wise builds. An
      alternative suggested by Peter Miller in 1998 avoids many issues with
      recursive <em class="command">make</em> by using a single
      <em class="filename">makefile</em> that includes information
      from each component directory.<sup>[<a href="#OEBPS/ch06.html.ftn.make3-CHP-6-FNOTE-1" class="footnote">1</a>]</sup></p><p>一旦项目超出了构建其组件的范围，它最终会发现管理构建方面存在更大的组织问题。其中包括处理项目的多个版本的开发、支持多个平台、提供对源代码和二进制文件的高效访问以及执行自动化构建。我们将在本章后半部分讨论这些问题。</p><p>Once a project gets beyond building its components, it eventually
      finds that there are larger organizational issues in managing builds.
      These include handling development on multiple versions of a project,
      supporting several platforms, providing efficient access to source and
      binaries, and performing automated builds. We will discuss these
      problems in the second half of this chapter.</p><div class="sect1" title="递归make"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1"></a>递归make</h1><h1 class="title"><a></a>Recursive make</h1></div></div></div><p>递归背后的动机<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1365" class="indexterm"></a>make 很简单：<em class="command">make</em>
        在单个目录（或一小组目录）中工作得很好，但当目录数量增加时会变得更加复杂。因此，我们可以使用<em class="command">make</em>来构建一个大型项目，方法是为每个目录编写一个简单的、独立的<em class="filename">makefile</em>，然后单独执行它们。我们可以使用脚本工具来执行此执行，但使用<em class="command">make</em>本身更有效，因为还涉及更高级别的依赖关系。</p><p>The motivation behind recursive <a class="indexterm"></a>make is simple: <em class="command">make</em>
        works very well within a single directory (or small set of
        directories) but becomes more complex when the number of directories
        grows. So, we can use <em class="command">make</em> to build
        a large project by writing a simple, self-contained <em class="filename">makefile</em> for each directory, then executing
        them all individually. We could use a scripting tool to perform this
        execution, but it is more effective to use <em class="command">make</em> itself since there are also
        dependencies involved at the higher level.</p><p>例如，假设我有一个 MP3 播放器应用程序。它在逻辑上可以分为几个组件：用户界面、编解码器和数据库管理。这些可能由三个库表示：<em class="filename">libui.a</em>、<em class="filename">libcodec.a</em>和<em class="filename">libdb.a</em>。该应用程序本身由将这些部件粘合在一起的胶水组成。这些组件到文件结构的直接映射可能如图<a class="link" href="#OEBPS/ch06.html.make3-CHP-6-FIG-1" title="图 6-1。 MP3 播放器的文件布局">6-1</a>所示。</p><p>For example, suppose I have an mp3 player application. It can
        logically be divided into several components: the user interface,
        codecs, and database management. These might be represented by three
        libraries: <em class="filename">libui.a</em>, <em class="filename">libcodec.a</em>, and <em class="filename">libdb.a</em>. The application itself consists of
        glue holding these pieces together. A straightforward mapping of these
        components onto a file structure might look like <a class="link" href="#OEBPS/ch06.html.make3-CHP-6-FIG-1" title="Figure&nbsp;6-1.&nbsp;File layout for an MP3 player">Figure 6-1</a>.</p><div class="figure"><a id="OEBPS/ch06.html.make3-CHP-6-FIG-1"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch06.html.I_1_tt308"></a><img src="data:image/png;base64,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" width="146" alt="MP3 播放器的文件布局"></div></div><p class="title">图 6-1。 MP3 播放器的文件布局</p><p class="title">Figure&nbsp;6-1.&nbsp;File layout for an MP3 player</p></div><p>更传统的布局会将应用程序的主要功能和粘合放在顶部目录中，而不是放在子目录
        <em class="filename">app/player</em>中。我更喜欢将应用程序代码放在自己的目录中，以便在顶层创建更清晰的布局，并允许通过附加模块来扩展系统。例如，如果我们选择稍后添加一个单独的编目应用程序，它可以整齐地放置在<em class="filename">app/catalog</em>下。</p><p>A more traditional layout would place the application's main
        function and glue in the top directory rather than in the subdirectory
        <em class="filename">app/player</em>. I prefer to put
        application code in its own directory to create a cleaner layout at
        the top level and allow for growth of the system with additional
        modules. For instance, if we choose to add a separate cataloging
        application later it can neatly fit under <em class="filename">app/catalog</em>.</p><p>如果每个目录<em class="filename">lib/db</em>、<em class="filename">lib/codec</em>、<em class="filename">lib/ui</em>和<em class="filename">app/player</em>都包含一个<em class="filename">makefile</em>，那么顶级<em class="filename">makefile</em>的工作就是调用它们。</p><p>If each of the directories <em class="filename">lib/db</em>, <em class="filename">lib/codec</em>, <em class="filename">lib/ui</em>, and <em class="filename">app/player</em> contains a <em class="filename">makefile</em>, then it is the job of the
        top-level <em class="filename">makefile</em> to invoke
        them.</p><a id="OEBPS/ch06.html.I_1_tt309"></a><pre class="programlisting">lib_codec := lib/编解码器
lib_db := lib/db
lib_ui := lib/ui
库 := $(lib_ui) $(lib_db) $(lib_codec)
播放器 := 应用程序/播放器

.PHONY：所有 $(player) $(libraries)
全部：$（玩家）

$（玩家）$（图书馆）：
        $(MAKE) --目录=$@

$（玩家）：$（图书馆）
$(lib_ui): $(lib_db) $(lib_codec)</pre><pre class="programlisting">lib_codec := lib/codec
lib_db    := lib/db
lib_ui    := lib/ui
libraries := $(lib_ui) $(lib_db) $(lib_codec)
player    := app/player

.PHONY: all $(player) $(libraries)
all: $(player)

$(player) $(libraries):
        $(MAKE) --directory=$@

$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)</pre><p>顶级<em class="filename">makefile</em>通过将子目录列为目标的规则在每个子目录上
        调用<em class="command">make ，其操作是调用</em><em class="command">make</em>：</p><p>The top-level <em class="filename">makefile</em>
        invokes <em class="command">make</em> on each subdirectory
        through a rule that lists the subdirectories as targets and whose
        action is to invoke <em class="command">make</em>:</p><a id="OEBPS/ch06.html.I_1_tt310"></a><pre class="programlisting">$（玩家）$（图书馆）：
        $(MAKE) --目录=$@</pre><pre class="programlisting">$(player) $(libraries):
        $(MAKE) --directory=$@</pre><p>该变量<code class="literal">MAKE</code>应始终用于
        在<em class="filename">makefile中调用</em><em class="command">make</em>。该变量由<em class="command">make</em>识别并设置为
        <em class="command">make</em>的实际路径，因此递归调用都使用相同的可执行文件。此外，当使用命令行选项( )、
         ( ) 和
        ( ) 时，包含变量的行将被特殊处理。我们将在本章后面的<a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1.1" title="命令行选项">6.1.1 节</a>中详细讨论这一点。<em class="filename"></em><code class="literal">MAKE</code><em class="command"></em><em class="command"></em><code class="literal">MAKE</code><code class="option">—touch</code><code class="option">-t</code><code class="option">—just-print</code><code class="option">-n</code><code class="option">—question</code><code class="option">-q</code><a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1.1" title="命令行选项"></a></p><p>The variable <code class="literal">MAKE</code> should
        always be used to invoke <em class="command">make</em>
        within a <em class="filename">makefile</em>. The <code class="literal">MAKE</code> variable is recognized by <em class="command">make</em> and is set to the actual path of
        <em class="command">make</em> so recursive invocations all
        use the same executable. Also, lines containing the variable <code class="literal">MAKE</code> are handled specially when the
        command-line options <code class="option">—touch</code> (<code class="option">-t</code>),
        <code class="option">—just-print</code> (<code class="option">-n</code>), and
        <code class="option">—question</code> (<code class="option">-q</code>) are used. We'll
        discuss this in detail in <a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1.1" title="Command-Line Options">Section
        6.1.1</a> later in this chapter.</p><p>目标目录标记为 ，<code class="literal">.PHONY</code>因此即使目标可能是最新的，规则也会触发。<code class="option">—directory</code>
        ( )选项<code class="option">-C</code>用于使<em class="command">make在读取</em><em class="filename">makefile</em>之前更改到目标目录。</p><p>The target directories are marked with <code class="literal">.PHONY</code> so the rule fires even though the
        target may be up to date. The <code class="option">—directory</code>
        (<code class="option">-C</code>) option is used to cause <em class="command">make</em> to change to the target directory
        before reading a <em class="filename">makefile</em>.</p><p>该规则虽然有点微妙，但克服了与更简单的命令脚本相关的几个问题：</p><p>This rule, although a bit subtle, overcomes several problems
        associated with a more straightforward command script:</p><a id="OEBPS/ch06.html.I_1_tt311"></a><pre class="programlisting">全部：
        for d in $(player) $(libraries); \
        做 \
          $(MAKE) --目录=$$d; \
        完毕</pre><pre class="programlisting">all:
        for d in $(player) $(libraries); \
        do                               \
          $(MAKE) --directory=$$d;       \
        done</pre><p>此命令脚本无法正确地将错误传输到父<em class="command">make</em>。它还不允许
        <em class="command">make</em>并行执行任何子目录构建。我们将在<a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能">第 10 章讨论</a><em class="command">make</em>的这一特性。<a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能"></a></p><p>This command script fails to properly transmit errors to the
        parent <em class="command">make</em>. It also does not allow
        <em class="command">make</em> to execute any subdirectory
        builds in parallel. We'll discuss this feature of <em class="command">make</em> in <a class="link" href="#OEBPS/ch10.html" title="Chapter&nbsp;10.&nbsp;Improving the Performance of make">Chapter
        10</a>.</p><p>当<em class="command">make</em>规划依赖图的执行时，目标的先决条件是相互独立的。此外，相互之间没有依赖关系的单独目标也是独立的。例如，<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1366" class="indexterm"></a>
        库与目标或彼此之间没有<span class="emphasis"><em>内在</em></span>
        关系。<code class="literal">app/player</code>这意味着<em class="command">make</em>在构建任何库之前可以自由地执行<em class="filename">应用程序/播放器</em> <em class="filename">makefile</em> 。显然，这会导致构建失败，因为链接应用程序需要库。为了解决这个问题，我们提供了额外的依赖信息。</p><p>As <em class="command">make</em> is planning the
        execution of the dependency graph, the prerequisites of a target are
        independent of one another. In addition, separate targets with no
        dependency relationships to one another are also independent. For
        example, the <a class="indexterm"></a>libraries have no <span class="emphasis"><em>inherent</em></span>
        relationship to the <code class="literal">app/player</code>
        target or to each other. This means <em class="command">make</em> is free to execute the <em class="filename">app/player</em> <em class="filename">makefile</em> before building any of the
        libraries. Clearly, this would cause the build to fail since linking
        the application requires the libraries. To solve this problem, we
        provide additional dependency information.</p><a id="OEBPS/ch06.html.I_1_tt312"></a><pre class="programlisting">$（玩家）：$（图书馆）
$(lib_ui): $(lib_db) $(lib_codec)</pre><pre class="programlisting">$(player): $(libraries)
$(lib_ui): $(lib_db) $(lib_codec)</pre><p>这里我们声明library子目录下的<em class="filename">makefile</em>必须先于该目录下的<em class="filename">makefile</em>执行<code class="literal">player</code>。同样，<em class="filename">lib/ui</em>代码需要编译<em class="filename">lib/db</em>和<em class="filename">lib/codec</em>库。这确保了在编译<em class="filename">ui</em>代码
        之前已生成任何生成的代码（例如<em class="command">yacc</em> / <em class="command">lex文件）。</em><em class="filename"></em></p><p>Here we state that the <em class="filename">makefile</em>s in the library subdirectories
        must be executed before the <em class="filename">makefile</em> in the <code class="literal">player</code> directory. Similarly, the <em class="filename">lib/ui</em> code requires the <em class="filename">lib/db</em> and <em class="filename">lib/codec</em> libraries to be compiled. This
        ensures that any generated code (such as <em class="command">yacc</em>/<em class="command">lex</em>
        files) have been generated before the <em class="filename">ui</em> code is compiled.</p><p>还有一个更微妙的顺序<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1367" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1368" class="indexterm"></a>更新先决条件时出现问题。与所有依赖项一样，更新的顺序是通过对依赖关系图的分析来确定的，但是当目标的先决条件列在一行上时，<acronym class="acronym">GNU </acronym> <em class="command">make</em>恰好从左到右更新它们。例如：</p><p>There is a further subtle ordering <a class="indexterm"></a> <a class="indexterm"></a>issue when updating prerequisites. As with all
        dependencies, the order of updating is determined by the analysis of
        the dependency graph, but when the prerequisites of a target are
        listed on a single line, <acronym class="acronym">GNU</acronym> <em class="command">make</em> happens to update them from left to
        right. For example:</p><a id="OEBPS/ch06.html.I_1_tt313"></a><pre class="programlisting">全部：abc
全部： 定义</pre><pre class="programlisting">all: a b c
all: d e f</pre><p>如果没有其他依赖关系<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1369" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1370" class="indexterm"></a>考虑到，六个先决条件可以按任何顺序更新（例如，“dbace f”），但<acronym class="acronym">GNU </acronym> <em class="command">make</em>在单个目标行中使用从左到右的方式，产生更新顺序：“abcde f”
        <span class="emphasis"><em>或</em></span>“defab c”。尽管这个顺序是执行中的一个意外，但执行顺序看起来是正确的。人们很容易忘记正确的顺序是一个意外，并且未能提供完整的依赖信息。最终，依赖性分析将产生不同的顺序并导致问题。因此，如果必须按特定顺序更新一组目标，请在适当的先决条件下强制执行正确的顺序。</p><p>If there are no other dependency relationships to <a class="indexterm"></a> <a class="indexterm"></a>be considered, the six prerequisites can be updated in
        any order (e.g., "d b a c e f"), but <acronym class="acronym">GNU</acronym> <em class="command">make</em> uses left to right within a single
        target line, yielding the update order: "a b c d e f"
        <span class="emphasis"><em>or</em></span> "d e f a b c." Although this ordering is an
        accident of the implementation, the order of execution appears
        correct. It is easy to forget that the correct order is a happy
        accident and fail to provide full dependency information. Eventually,
        the dependency analysis will yield a different order and cause
        problems. So, if a set of targets must be updated in a specific order,
        enforce the proper order with appropriate prerequisites.</p><p>当顶层<em class="filename">makefile</em>
        运行时，我们看到：</p><p>When the top-level <em class="filename">makefile</em>
        is run, we see:</p><a id="OEBPS/ch06.html.I_1_tt314"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
使 --directory=lib/db
make[1]: 进入目录 `/test/book/out/ch06-simple/lib/db'
更新数据库...
make[1]：离开目录`/test/book/out/ch06-simple/lib/db'
make --directory=lib/编解码器
make[1]: 进入目录 `/test/book/out/ch06-simple/lib/codec'
更新编解码器库...
make[1]：离开目录`/test/book/out/ch06-simple/lib/codec'
使 --directory=lib/ui
make[1]: 进入目录 `/test/book/out/ch06-simple/lib/ui'
更新用户界面库...
make[1]：离开目录`/test/book/out/ch06-simple/lib/ui'
make --directory=应用程序/播放器
make[1]: 进入目录 `/test/book/out/ch06-simple/app/player'
更新播放器应用程序...
make[1]：离开目录`/test/book/out/ch06-simple/app/player'</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
make --directory=lib/db
make[1]: Entering directory `/test/book/out/ch06-simple/lib/db'
Update db library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/db'
make --directory=lib/codec
make[1]: Entering directory `/test/book/out/ch06-simple/lib/codec'
Update codec library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/codec'
make --directory=lib/ui
make[1]: Entering directory `/test/book/out/ch06-simple/lib/ui'
Update ui library...
make[1]: Leaving directory `/test/book/out/ch06-simple/lib/ui'
make --directory=app/player
make[1]: Entering directory `/test/book/out/ch06-simple/app/player'
Update player application...
make[1]: Leaving directory `/test/book/out/ch06-simple/app/player'</pre><p>当<em class="command">make</em>检测到它正在递归调用另一个<em class="command">make</em>时，它​​会启用<code class="option">—print-directory</code>( <code class="option">-w</code>) 选项，这会导致<em class="command">make</em>打印<code class="literal">Entering</code> <code class="literal">directory</code>和<code class="literal">Leaving</code> <code class="literal">directory</code>消息。使用<code class="option">—directory</code>( ) 选项时也会启用此选项。 <em class="command">make</em>变量<code class="option">-C</code>的值也打印在每行的方括号中。在这个简单的示例中，每个组件<em class="filename">makefile</em>都会打印一条有关更新组件的简单消息。<em class="command"></em><code class="literal">MAKELEVEL</code><em class="filename"></em></p><p>When <em class="command">make</em> detects that it is
        invoking another <em class="command">make</em> recursively,
        it enables the <code class="option">—print-directory</code> (<code class="option">-w</code>)
        option, which causes <em class="command">make</em> to print
        the <code class="literal">Entering</code> <code class="literal">directory</code> and <code class="literal">Leaving</code> <code class="literal">directory</code> messages. This option is also
        enabled when the <code class="option">—directory</code> (<code class="option">-C</code>)
        option is used. The value of the <em class="command">make</em> variable <code class="literal">MAKELEVEL</code> is printed in square brackets in
        each line as well. In this simple example, each component <em class="filename">makefile</em> prints a simple message about
        updating the component.</p><div class="sect2" title="命令行选项"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.1"></a>命令行选项</h2><h2 class="title"><a></a>Command-Line Options</h2></div></div></div><p>递归<em class="command">make</em>是一个简单的想法<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1371" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1372" class="indexterm"></a>这很快就会变得复杂。完美的递归<em class="command">make</em>实现的行为就像系统中的
          许多<em class="filename">makefile都是单个</em><em class="filename">makefile</em>一样。实现这种程度的协调实际上是不可能的，因此必须做出妥协。当我们研究如何处理命令行选项时，微妙的问题变得更加清晰。</p><p>Recursive <em class="command">make</em> is a simple
          idea<a class="indexterm"></a> <a class="indexterm"></a> that quickly becomes complicated. The perfect
          recursive <em class="command">make</em> implementation
          would behave as if the many <em class="filename">makefile</em>s in the system are a single
          <em class="filename">makefile</em>. Achieving this level
          of coordination is virtually impossible, so compromises must be
          made. The subtle issues become more clear when we look at how
          command-line options must be handled.</p><p>假设我们已将注释添加到 mp3 播放器中的头文件中。我们意识到我们可以执行<em class="command">make</em> <code class="option">—touch</code>来更新文件的时间戳，而不是重新编译依赖于修改后的标头的所有源代码。通过使用顶级makefile执行<em class="command">make </em> <em class="filename">，</em>我们希望<em class="command">make能够触及子</em><em class="command">make</em>管理的所有相应文件。让我们看看这是如何工作的。<code class="option">—touch</code><em class="filename"></em><em class="command"></em><em class="command"></em></p><p>Suppose we have added comments to a header file in our mp3
          player. Rather than recompiling all the source that depends on the
          modified header, we realize we can instead perform a <em class="command">make</em> <code class="option">—touch</code> to bring the
          timestamps of the files up to date. By executing the <em class="command">make</em> <code class="option">—touch</code> with the
          top-level <em class="filename">makefile,</em> we would
          like <em class="command">make</em> to touch all the
          appropriate files managed by sub-<em class="command">make</em>s. Let's see how this works.</p><p>通常，当<code class="option">—touch</code>在命令行上提供 时，规则的正常处理将被暂停。相反，会遍历依赖关系图，并通过在目标上执行<em class="command">touch</em><code class="literal">.PHONY</code>来更新
          选定的目标和那些未标记的先决条件。由于我们的子目录被标记为，它们通常会被忽略（像普通文件一样触摸它们是没有意义的）。但我们不希望这些目标被忽略，我们希望执行它们的命令脚本。为了做正确的事情，<em class="command">make会</em>自动标记包含修饰符的任何行，这意味着无论
          选项如何， <em class="command">make</em>都会运行子<em class="command">make</em>。<em class="command"></em><code class="literal">.PHONY</code><em class="command"></em><code class="literal">MAKE</code><code class="literal">+</code><em class="command"></em><em class="command"></em><code class="option">—touch</code></p><p>Usually, when <code class="option">—touch</code> is provided on the
          command line, the normal processing of rules is suspended. Instead,
          the dependency graph is traversed and the selected targets and those
          prerequisites that are not marked <code class="literal">.PHONY</code> are brought up to date by executing
          <em class="command">touch</em> on the target. Since our
          subdirectories are marked <code class="literal">.PHONY</code>,
          they would normally be ignored (touching them like normal files
          would be pointless). But we don't want those targets ignored, we
          want their command script executed. To do the right thing, <em class="command">make</em> automatically labels any line
          containing <code class="literal">MAKE</code> with the <code class="literal">+</code> modifier, meaning <em class="command">make</em> runs the sub-<em class="command">make</em> regardless of the
          <code class="option">—touch</code> option.</p><p>当<em class="command">make</em>运行子<em class="command">make</em>时，它​​还必须安排将<code class="option">—touch</code>标志传递给子进程。它通过<code class="literal">MAKEFLAGS</code>
          变量来做到这一点。当<em class="command">make</em>启动时，它会自动将大多数命令行选项附加到<code class="literal">MAKEFLAGS</code>.唯一的例外是选项<code class="option">—directory</code>( <code class="option">-C</code>)、
           <code class="option">—file</code>( <code class="option">-f</code>)、
           <code class="option">—old-file</code>( <code class="option">-o</code>) 和
          <code class="option">—new-file</code>( <code class="option">-W</code>)。然后该<code class="literal">MAKEFLAGS</code>变量被导出到环境中并由子<em class="command">make</em>在启动时读取。</p><p>When <em class="command">make</em> runs the
          sub-<em class="command">make</em> it must also arrange for
          the <code class="option">—touch</code> flag to be passed to the sub-process. It
          does this through the <code class="literal">MAKEFLAGS</code>
          variable. When <em class="command">make</em> starts, it
          automatically appends most command-line options to <code class="literal">MAKEFLAGS</code>. The only exceptions are the
          options <code class="option">—directory</code> (<code class="option">-C</code>),
          <code class="option">—file</code> (<code class="option">-f</code>),
          <code class="option">—old-file</code> (<code class="option">-o</code>), and
          <code class="option">—new-file</code> (<code class="option">-W</code>). The <code class="literal">MAKEFLAGS</code> variable is then exported to the
          environment and read by the sub-<em class="command">make</em> as it starts.</p><p>有了这种特殊的支持，子品牌<em class="command">的</em>行为基本上可以按照您想要的方式进行。适用于
          ( )的递归执行<code class="literal">$(MAKE)</code>
          和特殊处理也适用于选项( ) 和
          ( )。<code class="literal">MAKEFLAGS</code><code class="option">—touch</code><code class="option">-t</code><code class="option">—just-print</code><code class="option">-n</code><code class="option">—question</code><code class="option">-q</code></p><p>With this special support, sub-<em class="command">make</em>s behave mostly the way you want. The
          recursive execution of <code class="literal">$(MAKE)</code>
          and the special handling of <code class="literal">MAKEFLAGS</code> that is applied to
          <code class="option">—touch</code> (<code class="option">-t</code>) is also applied to the
          options <code class="option">—just-print</code> (<code class="option">-n</code>) and
          <code class="option">—question</code> (<code class="option">-q</code>).</p></div><div class="sect2" title="传递变量"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.2"></a>传递变量</h2><h2 class="title"><a></a>Passing Variables</h2></div></div></div><p>正如我们已经提到的，<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1373" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1374" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1375" class="indexterm"></a>变量通过环境传递给 sub- <em class="command">make</em><code class="function">export</code>并使用和
          <code class="function">unexport</code>指令进行控制。通过环境传递的变量被视为默认值，但会被对该变量的任何赋值所覆盖。使用
          <code class="option">—environment-overrides</code>( <code class="option">-e</code>) 选项允许环境变量覆盖本地分配。您可以使用指令显式覆盖特定分配的环境（即使<code class="option">—environment-overrides</code>使用该选项）<code class="function">override</code>
          ：</p><p>As we have already mentioned, <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>variables are passed to sub-<em class="command">make</em>s through the environment and
          controlled using the <code class="function">export</code> and
          <code class="function">unexport</code> directives. Variables
          passed through the environment are taken as default values, but are
          overridden by any assignment to the variable. Use the
          <code class="option">—environment-overrides</code> (<code class="option">-e</code>) option
          to allow environment variables to override the local assignment. You
          can explicitly override the environment for a specific assignment
          (even when the <code class="option">—environment-overrides</code> option is
          used) with the <code class="function">override</code>
          directive:</p><a id="OEBPS/ch06.html.I_1_tt315"></a><pre class="programlisting">覆盖 TMPDIR = ~/tmp</pre><pre class="programlisting">override TMPDIR = ~/tmp</pre><p>如果命令行上定义的变量使用合法的 shell 语法，则它们会自动导出到环境中。如果变量仅使用字母、数字和下划线，则该变量被视为合法。来自命令行的变量分配<code class="literal">MAKEFLAGS</code>与命令行选项一起存储在变量中。</p><p>Variables defined on the command line are automatically
          exported to the environment if they use legal shell syntax. A
          variable is considered legal if it uses only letters, numbers, and
          underscores. Variable assignments from the command line are stored
          in the <code class="literal">MAKEFLAGS</code> variable along
          with command-line options.</p></div><div class="sect2" title="错误处理"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.3"></a>错误处理</h2><h2 class="title"><a></a>Error Handling</h2></div></div></div><p>递归时会发生什么<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1376" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1377" class="indexterm"></a> <em class="command">make</em>出现错误？事实上，没什么特别不寻常的。接收到错误状态<em class="command">的 make</em>将终止其处理，退出状态为 2。然后父<em class="command">make</em>退出，将错误状态沿着递归<em class="command">make</em>
          进程树向上传播。如果在顶级<em class="command">make</em><code class="option">—keep-going</code>上使用
          ( ) 选项，它将像往常一样传递给子<em class="command">make</em>。子<em class="command">make</em>执行其通常执行的操作，跳过当前目标并继续执行下一个目标，该目标不使用错误目标作为先决条件。<code class="option">-k</code><em class="command"></em><em class="command"></em><em class="command"></em></p><p>What happens when a recursive<a class="indexterm"></a> <a class="indexterm"></a> <em class="command">make</em> gets an
          error? Nothing very unusual, actually. The <em class="command">make</em> receiving the error status terminates
          its processing with an exit status of 2. The parent <em class="command">make</em> then exits, propagating the error
          status up the recursive <em class="command">make</em>
          process tree. If the <code class="option">—keep-going</code>
          (<code class="option">-k</code>) option is used on the top-level <em class="command">make</em>, it is passed to sub-<em class="command">make</em>s as usual. The sub-<em class="command">make</em> does what it normally does, skips the
          current target and proceeds to the next goal that does not use the
          erroneous target as a prerequisite.</p><p>例如，如果我们的 mp3 播放器程序在<code class="literal">lib/db</code>
          组件中遇到编译错误，<code class="literal">lib/db</code> <em class="command">make</em>将退出，并向顶级<em class="filename">makefile</em>返回状态 2 。如果我们使用<code class="option">—keep-going</code>( <code class="option">-k</code>) 选项，顶级<em class="filename">makefile</em>
          将继续执行下一个不相关的目标<code class="literal">lib/codec</code>.当它完成该目标时，无论其退出状态如何，make<em class="command">都会</em>以状态 2 退出，因为由于 的失败而没有更多目标可以处理<code class="literal">lib/db</code>。</p><p>For example, if our mp3 player program encountered a
          compilation error in the <code class="literal">lib/db</code>
          component, the <code class="literal">lib/db</code> <em class="command">make</em> would exit, returning a status of 2
          to the top-level <em class="filename">makefile</em>. If
          we used the <code class="option">—keep-going</code> (<code class="option">-k</code>)
          option, the top-level <em class="filename">makefile</em>
          would proceed to the next unrelated target, <code class="literal">lib/codec</code>. When it had completed that
          target, regardless of its exit status, the <em class="command">make</em> would exit with a status of 2 since
          there are no further targets that can be processed due to the
          failure of <code class="literal">lib/db</code>.</p><p><code class="option">—question</code>( )选项<code class="option">-q</code>的行为非常相似。如果某个目标不是最新的，此选项会使<em class="command">make</em>返回退出状态 1，否则返回 0。当应用于
          <em class="filename">makefile</em>树时，<em class="command">make</em>开始递归执行
          <em class="filename">makefile</em>直到它可以确定项目是否是最新的。一旦发现过期文件，<em class="command">make</em>就会终止当前活动的<em class="command">make</em>并展开递归。</p><p>The <code class="option">—question</code> (<code class="option">-q</code>) option
          behaves very similarly. This option causes <em class="command">make</em> to return an exit status of 1 if some
          target is not up to date, 0 otherwise. When applied to a tree of
          <em class="filename">makefile</em>s, <em class="command">make</em> begins recursively executing
          <em class="filename">makefile</em>s until it can
          determine if the project is up to date. As soon as an out-of-date
          file is found, <em class="command">make</em> terminates
          the currently active <em class="command">make</em> and
          unwinds the recursion.</p></div><div class="sect2" title="制定其他目标"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.4"></a>制定其他目标</h2><h2 class="title"><a></a>Building Other Targets</h2></div></div></div><p>基础的<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1378" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1379" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1380" class="indexterm"></a>构建目标对于任何构建系统都是必不可少的，但是我们还需要我们所依赖的其他支持目标，例如<code class="literal">clean</code>、<code class="literal">install</code>、<code class="literal">print</code>等。因为这些是<code class="literal">.PHONY</code>目标，所以前面描述的技术不能很好地工作。</p><p>The basic <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>build target is essential for any build system, but we
          also need the other support targets we've come to depend upon, such
          as <code class="literal">clean</code>, <code class="literal">install</code>, <code class="literal">print</code>, etc. Because these are <code class="literal">.PHONY</code> targets, the technique described
          earlier doesn't work very well.</p><p>例如，有几种损坏的方法，例如：</p><p>For instance, there are several broken approaches, such
          as:</p><a id="OEBPS/ch06.html.I_1_tt316"></a><pre class="programlisting">干净：$（玩家）$（库）
        $(MAKE) --directory=$@ 干净</pre><pre class="programlisting">clean: $(player) $(libraries)
        $(MAKE) --directory=$@ clean</pre><p>或者：</p><p>or:</p><a id="OEBPS/ch06.html.I_1_tt317"></a><pre class="programlisting">$（玩家）$（图书馆）：
        $(MAKE) --directory=$@ 干净</pre><pre class="programlisting">$(player) $(libraries):
        $(MAKE) --directory=$@ clean</pre><p><code class="literal">$(player)</code>第一个被破坏了，因为先决条件将触发和<code class="literal">$(libraries)</code> <em class="filename">makefile</em>中默认目标的构建，而不是目标的构建<code class="literal">clean</code>。第二个是非法的，因为这些目标已经存在并具有不同的命令脚本。</p><p>The first is broken because the prerequisites would trigger a
          build of the default target in the <code class="literal">$(player)</code> and <code class="literal">$(libraries)</code> <em class="filename">makefile</em>s, not a build of the <code class="literal">clean</code> target. The second is illegal
          because these targets already exist with a different command
          script.</p><p>一种可行的方法依赖于 shell <em class="command">for</em>循环：</p><p>One approach that works relies on a shell <em class="command">for</em> loop:</p><a id="OEBPS/ch06.html.I_1_tt318"></a><pre class="programlisting">干净的：
        for d in $(player) $(libraries); \
        做 \
          $(MAKE) --directory=$$d 干净； \
        完毕</pre><pre class="programlisting">clean:
        for d in $(player) $(libraries); \
        do                               \
          $(MAKE) --directory=$$d clean; \
        done</pre><p>由于前面描述的所有原因，<em class="command">for</em>循环并不是很令人满意，但它（以及前面的非法示例）向我们指出了这个解决方案：</p><p>A <em class="command">for</em> loop is not very
          satisfying for all the reasons described earlier, but it (and the
          preceding illegal example) points us to this solution:</p><a id="OEBPS/ch06.html.I_1_tt319"></a><pre class="programlisting">$（玩家）$（图书馆）：
        $(MAKE) --directory=$@ $(目标)</pre><pre class="programlisting">$(player) $(libraries):
        $(MAKE) --directory=$@ $(TARGET)</pre><p>通过将变量添加<code class="literal">$(TARGET)</code>到递归<em class="command">make</em>行并<code class="literal">TARGET</code>在<em class="command">make</em>命令行上设置变量，我们可以向子<em class="command">make</em>添加任意目标：</p><p>By adding the variable <code class="literal">$(TARGET)</code> to the recursive <em class="command">make</em> line and setting the <code class="literal">TARGET</code> variable on the <em class="command">make</em> command line, we can add arbitrary
          goals to the sub-<em class="command">make</em>:</p><a id="OEBPS/ch06.html.I_1_tt320"></a><pre class="programlisting">$<strong class="userinput"><code>make TARGET=clean</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>make TARGET=clean</code></strong></pre><p>不幸的是，这不会调用<code class="literal">$(TARGET)</code>顶层<em class="filename">makefile</em>。通常这不是必需的，因为顶级<em class="filename">makefile</em>
          无关，但是，如果有必要，我们可以添加另一个由以下内容保护的<em class="command">make</em><code class="function">if</code>调用：</p><p>Unfortunately, this does not invoke the <code class="literal">$(TARGET)</code> on the top-level <em class="filename">makefile</em>. Often this is not necessary
          because the top-level <em class="filename">makefile</em>
          has nothing to do, but, if necessary, we can add another invocation
          of <em class="command">make</em> protected by an <code class="function">if</code>:</p><a id="OEBPS/ch06.html.I_1_tt321"></a><pre class="programlisting">$（玩家）$（图书馆）：
        $(MAKE) --directory=$@ $(目标)
        $(如果$(目标), $(MAKE) $(目标))</pre><pre class="programlisting">$(player) $(libraries):
        $(MAKE) --directory=$@ $(TARGET)
        $(if $(TARGET), $(MAKE) $(TARGET))</pre><p>现在我们可以通过简单地在命令行上<code class="literal">clean</code>
          进行设置来调用目标（或任何其他目标） 。<code class="literal">TARGET</code></p><p>Now we can invoke the <code class="literal">clean</code>
          target (or any other target) by simply setting <code class="literal">TARGET</code> on the command line.</p></div><div class="sect2" title="跨 Makefile 依赖关系"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.5"></a>跨 Makefile 依赖关系</h2><h2 class="title"><a></a>Cross-Makefile Dependencies</h2></div></div></div><p><em class="command">make</em>
          对命令行的特殊支持<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1381" class="indexterm"></a>通过环境变量进行的选项和通信表明递归<em class="command">make</em>已被调整为可以正常工作。那么前面提到的严重并发症是什么？</p><p>The special support in <em class="command">make</em>
          for command-line <a class="indexterm"></a>options and communication through environment
          variables suggests that recursive <em class="command">make</em> has been tuned to work well. So what
          are the serious complications alluded to earlier?</p><p>由递归命令链接的单独的<em class="filename">makefile</em><code class="literal">$(MAKE)</code>仅记录最表面的顶级链接。不幸的是，某些目录中经常隐藏着微妙的依赖关系。</p><p>Separate <em class="filename">makefile</em>s linked
          by recursive <code class="literal">$(MAKE)</code> commands
          record only the most superficial top-level links. Unfortunately,
          there are often subtle dependencies buried in some
          directories.</p><p>例如，假设<em class="filename">db</em>
          模块包含一个基于<em class="command">yacc</em>的解析器，用于导入和导出音乐数据。如果<em class="filename">ui</em>模块<em class="filename">ui.c</em>包含生成的<em class="command">yacc</em>标头，则这两个模块之间存在依赖关系。如果依赖关系被正确建模，
          只要语法头更新，<em class="command">make</em>就应该知道重新编译我们的
          <em class="filename">ui</em>模块。使用前面描述的自动依赖性生成技术来安排这一点并不困难。但是如果<em class="command">yacc</em>文件本身被修改了怎么办？在这种情况下，当运行<em class="filename">ui </em> <em class="filename">makefile时，正确的</em><em class="filename">makefile</em>将识别出在编译<em class="filename">ui.c之前必须首先运行</em><em class="command">yacc</em>来生成解析器和标头。在我们的递归分解中，这种情况不会发生，因为运行<em class="command">yacc</em>的规则和依赖项位于<em class="filename">db </em><em class="filename">makefile</em>中，而不是<em class="filename">ui </em><em class="filename">makefile 中</em>。<em class="filename"></em><code class="literal">make</code><em class="command"></em><em class="filename"></em> <em class="filename"></em><em class="filename"></em> <em class="filename"></em></p><p>For example, suppose a <em class="filename">db</em>
          module includes a <em class="command">yacc</em>-based
          parser for importing and exporting music data. If the <em class="filename">ui</em> module, <em class="filename">ui.c</em>, includes the generated <em class="command">yacc</em> header, we have a dependency between
          these two modules. If the dependencies are properly modeled,
          <em class="command">make</em> should know to recompile our
          <em class="filename">ui</em> module whenever the grammar
          header is updated. This is not difficult to arrange using the
          automatic dependency generation technique described earlier. But
          what if the <em class="command">yacc</em> file itself is
          modified? In this case, when the <em class="filename">ui</em> <em class="filename">makefile</em> is run, a correct <em class="filename">makefile</em> would recognize that <em class="command">yacc</em> must first be run to generate the
          parser and header before compiling <em class="filename">ui.c</em>. In our recursive <code class="literal">make</code> decomposition, this does not occur,
          because the rule and dependencies for running <em class="command">yacc</em> are in the <em class="filename">db</em> <em class="filename">makefile</em>, not the <em class="filename">ui</em> <em class="filename">makefile</em>.</p><p>在这种情况下，我们能做的最好的事情就是确保
          <em class="filename">db </em> <em class="filename">makefile始终在执行</em><em class="filename">ui </em> <em class="filename">makefile</em>之前执行。这种更高级别的依赖关系必须手动编码。我们在<em class="filename">makefile</em>的第一个版本中足够聪明地认识到了这一点，但总的来说，这是一个非常困难的维护问题。当编写和修改代码时，顶层<em class="filename">makefile</em>将无法正确记录模块间依赖关系。</p><p>In this case, the best we can do is to ensure that the
          <em class="filename">db</em> <em class="filename">makefile</em> is always executed before
          executing the <em class="filename">ui</em> <em class="filename">makefile</em>. This higher-level dependency
          must be encoded by hand. We were astute enough in the first version
          of our <em class="filename">makefile</em> to recognize
          this, but, in general, this is a very difficult maintenance problem.
          As code is written and modified, the top-level <em class="filename">makefile</em> will fail to properly record the
          intermodule dependencies.</p><p>继续这个例子，如果<em class="filename">db</em>中的<em class="command">yacc</em>语法被更新，并且<em class="filename">ui </em><em class="filename">makefile在</em><em class="filename">db </em><em class="filename">makefile</em>之前运行（通过直接执行它而不是通过顶级<em class="filename">makefile</em>），那么<em class="filename">ui </em><em class="filename">makefile</em>不知道 中存在未满足的依赖关系必须<em class="filename">运行 db makefile</em>和<em class="filename">yacc</em>来<em class="command">更新</em>头文件。相反，<em class="filename">ui </em><em class="filename">makefile使用旧的</em><em class="command">yacc</em>标头编译其程序。如果已定义新符号并且现在正在引用新符号，则会报告编译错误。因此，递归<em class="command">make</em>方法本质上比单个<em class="filename">makefile</em>更脆弱。<em class="filename"></em><em class="filename"></em> <em class="filename"></em><em class="filename"></em> <em class="filename"></em><em class="filename"></em><em class="filename"></em> <em class="filename"></em><em class="filename"></em> <em class="filename"></em><em class="command"></em><em class="filename"></em> <em class="filename"></em><em class="command"></em><em class="command"></em><em class="filename"></em></p><p>To continue the example, if the <em class="command">yacc</em> grammar in <em class="filename">db</em> is updated and the <em class="filename">ui</em> <em class="filename">makefile</em> is run before the <em class="filename">db</em> <em class="filename">makefile</em> (by executing it directly
          instead of through the top-level <em class="filename">makefile</em>), the <em class="filename">ui</em> <em class="filename">makefile</em> does not know there is an
          unsatisfied dependency in the <em class="filename">db</em> <em class="filename">makefile</em> and that <em class="command">yacc</em> must be run to update the header
          file. Instead, the <em class="filename">ui</em> <em class="filename">makefile</em> compiles its program with the
          old <em class="command">yacc</em> header. If new symbols
          have been defined and are now being referenced, then a compilation
          error is reported. Thus, the recursive <em class="command">make</em> approach is inherently more fragile
          than a single <em class="filename">makefile</em>.</p><p>当代码生成器被更广泛地使用时，问题会变得更加严重。假设将 RPC 存根生成器的使用添加到<em class="filename">ui中，并在</em><em class="filename">db</em>中引用标头。现在我们有相互参考来应对。为了解决这个问题，可能需要访问<em class="filename">db</em>来生成<em class="command">yacc</em>头，然后访问<em class="filename">ui</em>来生成RPC存根，然后访问<em class="filename">db</em>来编译文件，最后访问<em class="filename">ui</em>
          来完成编译过程。创建和编译项目源代码所需的遍数取决于代码的结构以及用于创建代码的工具。这种相互引用在复杂系统中很常见。</p><p>The problem worsens when code generators are used more
          extensively. Suppose that the use of an RPC stub generator is added
          to <em class="filename">ui</em> and the headers are
          referenced in <em class="filename">db</em>. Now we have
          mutual reference to contend with. To resolve this, it may be
          required to visit <em class="filename">db</em> to
          generate the <em class="command">yacc</em> header, then
          visit <em class="filename">ui</em> to generate the RPC
          stubs, then visit <em class="filename">db</em> to compile
          the files, and finally visit <em class="filename">ui</em>
          to complete the compilation process. The number of passes required
          to create and compile the source for a project is dependent on the
          structure of the code and the tools used to create it. This kind of
          mutual reference is common in complex systems.</p><p>现实世界中<em class="filename">makefile</em>的标准解决方案通常是 hack。为了确保所有文件都是最新的，当向顶级<em class="filename">makefile发出命令时，每个</em><em class="filename">makefile</em>都会被执行。请注意，这正是我们的 mp3 播放器<em class="filename">makefile</em>
          所做的事情。当顶层<em class="filename">makefile</em>运行时，四个子<em class="filename">makefile</em>中的每一个都会无条件运行。在复杂的情况下，会重复运行<em class="filename">makefile</em>以确保首先生成然后编译所有代码。通常，这种迭代执行完全是浪费时间，但有时是必需的。<em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em></p><p>The standard solution in real-world <em class="filename">makefile</em>s is usually a hack. To ensure
          that all files are up to date, every <em class="filename">makefile</em> is executed when a command is
          given to the top-level <em class="filename">makefile</em>. Notice that this is precisely
          what our mp3 player <em class="filename">makefile</em>
          does. When the top-level <em class="filename">makefile</em> is run, each of the four
          sub-<em class="filename">makefile</em>s is
          unconditionally run. In complex cases, <em class="filename">makefile</em>s are run repeatedly to ensure
          that all code is first generated then compiled. Often this iterative
          execution is a complete waste of time, but occasionally it is
          required.</p></div><div class="sect2" title="避免重复代码"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06.html.make3-CHP-6-SECT-1.6"></a>避免重复代码</h2><h2 class="title"><a></a>Avoiding Duplicate Code</h2></div></div></div><p>我们的应用程序的目录布局<a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1382" class="indexterm"></a> <a id="OEBPS/ch06.html.make3-CHP-6-ITERM-1383" class="indexterm"></a>包括三个库。这些库<em class="filename">的 makefile</em>非常相似。这是有道理的，因为这三个库在最终应用程序中具有不同的用途，但都是使用类似的命令构建的。这种分解是大型项目的典型做法，会导致许多类似的<em class="filename">makefile</em>和大量 ( <em class="filename">makefile</em> ) 代码重复。</p><p>The directory layout of our application <a class="indexterm"></a> <a class="indexterm"></a>includes three libraries. The <em class="filename">makefile</em>s for these libraries are very
          similar. This makes sense because the three libraries serve
          different purposes in the final application but are all built with
          similar commands. This kind of decomposition is typical of large
          projects and leads to many similar <em class="filename">makefile</em>s and lots of (<em class="filename">makefile</em>) code duplication.</p><p>代码重复是不好的，甚至<em class="filename">makefile</em>代码重复也是如此。它增加了软件的维护成本并导致更多的错误。它还使得理解算法和识别其中的微小变化变得更加困难。因此，我们希望尽可能避免<em class="filename">makefile中的代码重复。通过将</em><em class="filename">makefile</em>的公共部分移动到公共包含文件中，可以最轻松地实现此目的。</p><p>Code duplication is bad, even <em class="filename">makefile</em> code duplication. It increases
          the maintenance costs of the software and leads to more bugs. It
          also makes it more difficult to understand algorithms and identify
          minor variations in them. So we would like to avoid code duplication
          in our <em class="filename">makefile</em>s as much as
          possible. This is most easily accomplished by moving the common
          pieces of a <em class="filename">makefile</em> into a
          common include file.</p><p>例如，<em class="filename">编解码器</em>
          <em class="filename">makefile</em>包含：</p><p>For example, the <em class="filename">codec</em>
          <em class="filename">makefile</em> contains:</p><a id="OEBPS/ch06.html.I_1_tt322"></a><pre class="programlisting">lib_codec := libcodec.a
来源：=编解码器.c
对象 := $(subst .c,.o,$(来源))
依赖项 := $(subst .c,.d,$(源))

include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

全部：$(lib_codec)

$(lib_codec): $(对象)
        $(AR) $(ARFLAGS) $@ $^

.PHONY：干净
干净的：
        $(RM) $(lib_codec) $(对象) $(依赖项)

ifneq "$(MAKECMDGOALS)" "干净"
  包括 $(依赖项)
万一

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        sed 's,\($*\.o\) *:,\1 $@: ,' &gt; $@.tmp
        mv $@.tmp $@</pre><pre class="programlisting">lib_codec    := libcodec.a
sources      := codec.c
objects      := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))

include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

all: $(lib_codec)

$(lib_codec): $(objects)
        $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
        $(RM) $(lib_codec) $(objects) $(dependencies)

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; |      \
        sed 's,\($*\.o\) *:,\1 $@: ,' &gt; $@.tmp
        mv $@.tmp $@</pre><p>几乎所有这些代码都在<em class="filename">db</em>和<em class="filename">ui </em> <em class="filename">makefile</em>中重复。每个库唯一改变的行是库本身的名称和库包含的源文件。当重复的代码被移入<em class="filename">common.mk</em>时，我们可以将此<em class="filename">makefile</em>削减为：</p><p>Almost all of this code is duplicated in the <em class="filename">db</em> and <em class="filename">ui</em> <em class="filename">makefile</em>s. The only lines that change for
          each library are the name of the library itself and the source files
          the library contains. When duplicate code is moved into <em class="filename">common.mk</em>, we can pare this <em class="filename">makefile</em> down to:</p><a id="OEBPS/ch06.html.I_1_tt323"></a><pre class="programlisting">库 := libcodec.a
来源：=编解码器.c

包括../../common.mk</pre><pre class="programlisting">library := libcodec.a
sources := codec.c

include ../../common.mk</pre><p>查看我们已将哪些内容移入单个共享包含文件中：</p><p>See what we have moved into the single, shared include
          file:</p><a id="OEBPS/ch06.html.I_1_tt324"></a><pre class="programlisting">MV := mv -f
RM := rm -f
SED := sed

对象 := $(subst .c,.o,$(来源))
依赖项 := $(subst .c,.d,$(源))
include_dirs := .. ../../include
CPPFLAGS += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY：图书馆
图书馆：$（图书馆）

$（库）：$（对象）
        $(AR) $(ARFLAGS) $@ $^

.PHONY：干净
干净的：
        $(RM) $(对象) $(程序) $(库) $(依赖项) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "干净"
  -包括$（依赖项）
万一

%.c %.h: %.y
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        $(SED) 's,\($*\.o\) *:,\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre><pre class="programlisting">MV           := mv -f
RM           := rm -f
SED          := sed

objects      := $(subst .c,.o,$(sources))
dependencies := $(subst .c,.d,$(sources))
include_dirs := .. ../../include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))

vpath %.h $(include_dirs)

.PHONY: library
library: $(library)

$(library): $(objects)
        $(AR) $(ARFLAGS) $@ $^

.PHONY: clean
clean:
        $(RM) $(objects) $(program) $(library) $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif

%.c %.h: %.y
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; |      \
        $(SED) 's,\($*\.o\) *:,\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre><p><em class="filename">每个makefile</em><code class="literal">include_dirs</code>都不同的变量现在在所有
          <em class="filename">makefile</em>中都是相同的，因为我们重新设计了用于包含头文件的路径源文件，以使所有库使用相同的包含路径。<em class="filename"></em><em class="filename"></em></p><p>The variable <code class="literal">include_dirs</code>,
          which was different for each <em class="filename">makefile</em>, is now identical in all
          <em class="filename">makefile</em>s because we reworked
          the path source files use for included headers to make all libraries
          use the same include path.</p><p>common.mk<em class="filename">文件</em>甚至包含库包含文件的默认目标。原始的<em class="filename">makefile</em>使用默认的 target <code class="literal">all</code>。这会导致非库<em class="filename">makefile</em>出现问题，需要为其默认目标指定一组不同的先决条件。因此共享代码版本使用默认目标<code class="literal">library</code>.</p><p>The <em class="filename">common.mk</em> file even
          includes the default goal for the library include files. The
          original <em class="filename">makefile</em>s used the
          default target <code class="literal">all</code>. That would
          cause problems with nonlibrary <em class="filename">makefile</em>s that need to specify a
          different set of prerequisites for their default goal. So the shared
          code version uses a default target of <code class="literal">library</code>.</p><p><em class="filename">请注意，因为此公共文件包含目标，所以它必须包含在非库makefile</em>的默认目标之后。另请注意，<code class="literal">clean</code>命令脚本引用了变量<code class="literal">program</code>、<code class="literal">library</code>和<code class="literal">extra_clean</code>。对于库<em class="filename">makefile</em>，该<code class="literal">program</code>变量为空；对于程序
          <em class="filename">makefile</em>，该<code class="literal">library</code>变量为空。该<code class="literal">extra_clean</code>变量是专门为<em class="filename">db </em>
          <em class="filename">makefile</em>添加的。此<em class="filename">makefile</em>使用变量来表示<em class="command">yacc</em>生成的代码。<em class="filename">生成文件</em>是：</p><p>Notice that because this common file contains targets it must
          be included after the default target for nonlibrary <em class="filename">makefile</em>s. Also notice that the <code class="literal">clean</code> command script references the
          variables <code class="literal">program</code>, <code class="literal">library</code>, and <code class="literal">extra_clean</code>. For library <em class="filename">makefile</em>s, the <code class="literal">program</code> variable is empty; for program
          <em class="filename">makefile</em>s, the <code class="literal">library</code> variable is empty. The <code class="literal">extra_clean</code> variable was added
          specifically for the <em class="filename">db</em>
          <em class="filename">makefile</em>. This <em class="filename">makefile</em> uses the variable to denote code
          generated by <em class="command">yacc</em>. The <em class="filename">makefile</em> is:</p><a id="OEBPS/ch06.html.I_1_tt325"></a><pre class="programlisting">库 := libdb.a
来源：=扫描仪.c 播放列表.c
extra_clean := $(sources) playlist.h

.SECONDARY：播放列表.c 播放列表.h 扫描仪.c

包括../../common.mk</pre><pre class="programlisting">library     := libdb.a
sources     := scanner.c playlist.c
extra_clean := $(sources) playlist.h

.SECONDARY: playlist.c playlist.h scanner.c

include ../../common.mk</pre><p>使用这些技术，可以将代码重复保持在最低限度。随着更多的<em class="filename">makefile</em>代码被移入通用<em class="filename">makefile</em>中，它演变成
          整个项目的通用<em class="filename">makefile 。 </em><em class="command">make</em>变量和用户定义的函数用作自定义点，允许为每个目录修改通用<em class="filename">makefile 。</em></p><p>Using these techniques, code duplication can be kept to a
          minimum. As more <em class="filename">makefile</em> code
          is moved into the common <em class="filename">makefile</em>, it evolves into a generic
          <em class="filename">makefile</em> for the entire
          project. <em class="command">make</em> variables and
          user-defined functions are used as customization points, allowing
          the generic <em class="filename">makefile</em> to be
          modified for each directory.</p></div></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch06.html.ftn.make3-CHP-6-FNOTE-1" href="#OEBPS/ch06.html.make3-CHP-6-FNOTE-1" class="para">1</a> ]</sup> Miller，PA，<span class="emphasis"><em>递归使人认为有害</em></span>，AUUGN Journal of AUUG Inc.，19(1)，第 14-25 页 (1998)。也可从<a class="ulink" href="http://aegis.sourceforge.net/auug97.pdf">http://aegis.sourceforge.net/auug97.pdf</a>获取。</p><p><sup>[<a href="#OEBPS/ch06.html.make3-CHP-6-FNOTE-1" class="para">1</a>] </sup>Miller, P.A., <span class="emphasis"><em>Recursive Make Considered
          Harmful</em></span>, AUUGN Journal of AUUG Inc., 19(1), pp. 14-25
          (1998). Also available from <a class="ulink" href="http://aegis.sourceforge.net/auug97.pdf">http://aegis.sourceforge.net/auug97.pdf</a>.</p></div></div></div></div></div>
<div id="OEBPS/ch06s02.html"><div>
<div class="sect1" title="非递归make"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06s02.html.make3-CHP-6-SECT-2"></a>非递归make</h1><h1 class="title"><a></a>Nonrecursive make</h1></div></div></div><p>多目录项目<a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1384" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1385" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1386" class="indexterm"></a>也可以在没有递归<em class="command">make</em>的情况下进行管理。此处的区别在于<em class="filename">makefile</em>操作的源代码位于多个目录中。为了适应这种情况，对子目录中文件的引用必须包含文件的路径 - 绝对路径或相对路径。</p><p>Multidirectory projects <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>can also be managed without recursive <em class="command">make</em>s. The difference here is that the
        source manipulated by the <em class="filename">makefile</em> lives in more than one directory.
        To accommodate this, references to files in subdirectories must
        include the path to the file—either absolute or relative.</p><p>通常，管理大型项目的<em class="filename">makefile</em>
        有许多目标，项目中的每个模块都有一个目标。对于我们的 mp3 播放器示例，我们需要每个库和每个应用程序的目标。它也可能有用
        <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1387" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1388" class="indexterm"></a>为模块集合添加虚假目标，例如所有库的集合。默认目标通常会构建所有这些目标。通常，默认目标会构建文档并运行测试过程。</p><p>Often, the <em class="filename">makefile</em>
        managing a large project has many targets, one for each module in the
        project. For our mp3 player example, we would need targets for each of
        the libraries and each of the applications. It can also be useful
        <a class="indexterm"></a> <a class="indexterm"></a>to add phony targets for collections of modules such as
        the collection of all libraries. The default goal would typically
        build all of these targets. Often the default goal builds
        documentation and runs a testing procedure as well.</p><p><em class="command">非递归make</em>最直接的用法包括单个<em class="filename">makefile</em>中的目标、目标文件引用和依赖项。这对于熟悉递归<em class="command">make</em>的开发人员来说通常是不满意的，因为目录中文件的信息集中在单个文件中，而源文件本身分布在文件系统中。为了解决这个问题，Miller 关于非递归<em class="command">make 的</em>论文建议对每个包含文件列表和模块特定规则的目录使用一个<em class="command">make</em> include 文件。顶级
        <em class="filename">makefile</em>包含这些子<em class="filename">makefile</em>。</p><p>The most straightforward use of nonrecursive <em class="command">make</em> includes targets, object file
        references, and dependencies in a single <em class="filename">makefile</em>. This is often unsatisfying to
        developers familiar with recursive <em class="command">make</em> because information about the files in
        a directory is centralized in a single file while the source files
        themselves are distributed in the filesystem. To address this issue,
        the Miller paper on nonrecursive <em class="command">make</em> suggests using one <em class="command">make</em> include file for each directory
        containing file lists and module-specific rules. The top-level
        <em class="filename">makefile</em> includes these
        sub-<em class="filename">makefile</em>s.</p><p><a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-1" title="例 6-1。非递归 makefile">示例 6-1</a>显示了
        mp3 播放器的<em class="filename">makefile</em> ，其中包含
        每个子目录中的模块级<em class="filename">makefile 。</em><a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-2" title="例 6-2。非递归 makefile 的 lib/codec 包含文件">示例 6-2</a>显示了模块级包含文件之一。</p><p><a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-1" title="Example&nbsp;6-1.&nbsp;A nonrecursive makefile">Example 6-1</a> shows a
        <em class="filename">makefile</em> for our mp3 player that
        includes a module-level <em class="filename">makefile</em>
        from each subdirectory. <a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-2" title="Example&nbsp;6-2.&nbsp;The lib/codec include file for a nonrecursive makefile">Example
        6-2</a> shows one of the module-level include files.</p><div class="example"><a id="OEBPS/ch06s02.html.make3-CHP-6-EX-1"></a><p class="title">例 6-1。非递归 makefile</p><p class="title">Example&nbsp;6-1.&nbsp;A nonrecursive makefile</p><div class="example-contents"><pre class="programlisting"># 从这四个变量中收集每个模块的信息。
# 在这里将它们初始化为简单变量。
程序:=
来源:=
库:=
额外的清洁：=

对象 = $(subst .c,.o,$(来源))
依赖项 = $(subst .c,.d,$(源))

include_dirs := lib 包含
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV := mv -f
RM := rm -f
SED := sed

全部：

包含 lib/codec/module.mk
包含 lib/db/module.mk
包含 lib/ui/module.mk
包括应用程序/播放器/module.mk

.PHONY：全部
全部：$（程序）

.PHONY：库
图书馆：$（图书馆）

.PHONY：干净
干净的：
        $(RM) $(对象) $(程序) $(库) \
              $（依赖项）$（extra_clean）

ifneq "$(MAKECMDGOALS)" "干净"
  包括 $(依赖项)
万一

%.c %.h: %.y
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre><pre class="programlisting"># Collect information from each module in these four variables.
# Initialize them here as simple variables.
programs     :=
sources      :=
libraries    :=
extra_clean  :=

objects      = $(subst .c,.o,$(sources))
dependencies = $(subst .c,.d,$(sources))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include lib/codec/module.mk
include lib/db/module.mk
include lib/ui/module.mk
include app/player/module.mk

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
        $(RM) $(objects) $(programs) $(libraries) \
              $(dependencies) $(extra_clean)

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif

%.c %.h: %.y
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre></div></div><div class="example"><a id="OEBPS/ch06s02.html.make3-CHP-6-EX-2"></a><p class="title">例 6-2。非递归 makefile 的 lib/codec 包含文件</p><p class="title">Example&nbsp;6-2.&nbsp;The lib/codec include file for a nonrecursive
          makefile</p><div class="example-contents"><pre class="programlisting">local_dir := lib/编解码器
local_lib := $(local_dir)/libcodec.a
local_src := $(addprefix $(local_dir)/,codec.c)
local_objs := $(subst .c,.o,$(local_src))

库 += $(local_lib)
来源 += $(local_src)

$(local_lib): $(local_objs)
        $(AR) $(ARFLAGS) $@ $^</pre><pre class="programlisting">local_dir  := lib/codec
local_lib  := $(local_dir)/libcodec.a
local_src  := $(addprefix $(local_dir)/,codec.c)
local_objs := $(subst .c,.o,$(local_src))

libraries  += $(local_lib)
sources    += $(local_src)

$(local_lib): $(local_objs)
        $(AR) $(ARFLAGS) $@ $^</pre></div></div><p>因此，特定于模块的所有信息都包含在模块目录本身的包含文件中。这<a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1389" class="indexterm"></a>顶层<em class="filename">makefile</em>
        仅包含模块和指令的列表<code class="literal">include</code>。让我们
        详细检查一下<em class="filename">makefile</em>和<em class="filename">module.mk 。</em></p><p>Thus, all the information specific to a module is contained in
        an include file in the module directory itself. The <a class="indexterm"></a>top-level <em class="filename">makefile</em>
        contains only a list of modules and <code class="literal">include</code> directives. Let's examine the
        <em class="filename">makefile</em> and <em class="filename">module.mk</em> in detail.</p><p>每个<em class="filename">module.mk</em>包含文件将本地库名称附加到变量<code class="literal">libraries</code>，将本地源附加到<code class="literal">sources</code>.变量<code class="literal">local_</code>用于保存常量值或避免重复计算值。请注意，每个包含文件都重复使用这些相同的<code class="literal">local_</code>变量名称。因此，它使用简单变量（用 分配的变量<code class="literal">:=</code>）而不是递归变量，以便组合多个<em class="filename">makefile的构建不会有感染每个</em><em class="filename">makefile</em>中的变量的风险。库名称和源文件列表使用前面讨论的相对路径。最后，包含文件定义了更新本地库的规则。使用此规则中的变量没有问题，<code class="literal">local_</code>因为规则的目标和先决条件部分会立即评估。</p><p>Each <em class="filename">module.mk</em> include file
        appends the local library name to the variable <code class="literal">libraries</code> and the local sources to <code class="literal">sources</code>. The <code class="literal">local_</code> variables are used to hold constant
        values or to avoid duplicating a computed value. Note that each
        include file reuses these same <code class="literal">local_</code> variable names. Therefore, it uses
        simple variables (those assigned with <code class="literal">:=</code>) rather than recursive ones so that
        builds combining multiple <em class="filename">makefile</em>s hold no risk of infecting the
        variables in each <em class="filename">makefile</em>. The
        library name and source file lists use a relative path as discussed
        earlier. Finally, the include file defines a rule for updating the
        local library. There is no problem with using the <code class="literal">local_</code> variables in this rule because the
        target and prerequisite parts of a rule are immediately
        evaluated.</p><p>在顶层<em class="filename">makefile</em>中，前四行定义了累积每个模块的特定文件信息的变量。这些变量必须是简单变量，因为每个模块将使用相同的局部变量名称附加到它们：</p><p>In the top-level <em class="filename">makefile</em>,
        the first four lines define the variables that accumulate each
        module's specific file information. These variables must be simple
        variables because each module will append to them using the same local
        variable name:</p><a id="OEBPS/ch06s02.html.I_1_tt326"></a><pre class="programlisting">local_src := $(addprefix $(local_dir)/,codec.c)
...
来源 += $(local_src)</pre><pre class="programlisting">local_src  := $(addprefix $(local_dir)/,codec.c)
...
sources    += $(local_src)</pre><p>例如，如果将递归变量用于<code class="literal">sources</code>，则最终值将只是<code class="literal">local_src</code>一遍又一遍重复的最后一个值。即使分配了空值，也需要显式赋值来初始化这些简单变量，因为默认情况下变量是递归的。</p><p>If a recursive variable were used for <code class="literal">sources</code>, for instance, the final value would
        simply be the last value of <code class="literal">local_src</code> repeated over and over. An
        explicit assignment is required to initialize these simple variables,
        even though they are assigned null values, since variables are
        recursive by default.</p><p>下一部分<code class="literal">objects</code>根据变量计算目标文件列表、和依赖文件列表
        <code class="literal">sources</code>。这些变量是递归的，因为此时<em class="filename">makefile</em>中的变量<code class="literal">sources</code>为空。直到稍后读取包含文件时才会填充它。在此
        <em class="filename">makefile</em>中，将这些变量的定义移到包含之后并将其类型更改为简单变量是完全合理的，但是将基本文件列表（例如，<code class="literal">sources</code>、
         <code class="literal">libraries</code>、<code class="literal">objects</code>）放在一起可以简化对<em class="filename">makefile 的</em>理解，并且通常是很好的做法。另外，在其他<em class="filename">makefile</em>情况下，变量之间的相互引用需要使用递归变量。</p><p>The next section computes the object file list, <code class="literal">objects</code>, and dependency file list from the
        <code class="literal">sources</code> variable. These variables
        are recursive because at this point in the <em class="filename">makefile</em> the <code class="literal">sources</code> variable is empty. It will not be
        populated until later when the include files are read. In this
        <em class="filename">makefile</em>, it is perfectly
        reasonable to move the definition of these variables after the
        includes and change their type to simple variables, but keeping the
        basic file lists (e.g., <code class="literal">sources</code>,
        <code class="literal">libraries</code>, <code class="literal">objects</code>) together simplifies understanding
        the <em class="filename">makefile</em> and is generally
        good practice. Also, in other <em class="filename">makefile</em> situations, mutual references
        between variables require the use of recursive variables.</p><p>接下来，我们通过设置 .c 来处理 C 语言包含文件<code class="literal">CPPFLAGS</code>。这允许编译器找到标头。我们追加到<code class="literal">CPPFLAGS</code>变量中是因为我们不知道变量是否真的为空；命令行选项、环境变量或其他<em class="command">make</em>结构可能已经设置了它。该<code class="literal">vpath</code>
        指令允许<em class="command">make</em>查找存储在其他目录中的标头。该<code class="literal">include_dirs</code>变量用于避免重复包含目录列表。</p><p>Next, we handle C language include files by setting <code class="literal">CPPFLAGS</code>. This allows the compiler to find
        the headers. We append to the <code class="literal">CPPFLAGS</code> variable because we don't know if
        the variable is really empty; command-line options, environment
        variables, or other <em class="command">make</em> constructs
        may have set it. The <code class="literal">vpath</code>
        directive allows <em class="command">make</em> to find the
        headers stored in other directories. The <code class="literal">include_dirs</code> variable is used to avoid
        duplicating the include directory list.</p><p><em class="command">定义mv</em>、<em class="command">rm</em>和<em class="command">sed</em>的变量是为了避免将程序硬编码到<em class="filename">makefile</em>中。注意变量的情况。我们遵循<em class="command">制作</em>手册中建议的约定。<em class="filename">makefile</em>内部的变量是小写的；可以从命令行设置的变量是大写的。</p><p>Variables for <em class="command">mv</em>, <em class="command">rm</em>, and <em class="command">sed</em> are defined to avoid hard coding
        programs into the <em class="filename">makefile</em>.
        Notice the case of variables. We are following the conventions
        suggested in the <em class="command">make</em> manual.
        Variables that are internal to the <em class="filename">makefile</em> are lowercased; variables that
        might be set from the command line are uppercased.</p><p>在 makefile 的下一部分中<em class="filename">，</em>事情变得更加有趣。我们希望以默认目标 开始显式规则
        <code class="literal">all</code>。不幸的是， 的先决条件<code class="literal">all</code>是变量<code class="literal">programs</code>。该变量会立即计算，但通过读取模块包含文件来设置。因此，我们必须在<code class="literal">all</code>定义目标之前读取包含文件。再次不幸的是，包含模块包含目标，其中第一个将被视为默认目标。为了解决这个困境，我们可以指定<code class="literal">all</code>没有先决条件的目标，获取包含文件，然后添加先决条件
        <code class="literal">all</code>。</p><p>In the next section of the <em class="filename">makefile,</em> things get more interesting. We
        would like to begin the explicit rules with the default target,
        <code class="literal">all</code>. Unfortunately, the
        prerequisite for <code class="literal">all</code> is the
        variable <code class="literal">programs</code>. This variable is
        evaluated immediately, but is set by reading the module include files.
        So, we must read the include files before the <code class="literal">all</code> target is defined. Unfortunately again,
        the include modules contain targets, the first of which will be
        considered the default goal. To work through this dilemma, we can
        specify the <code class="literal">all</code> target with no
        prerequisites, source the include files, then add the prerequisites to
        <code class="literal">all</code> later.</p><p><em class="filename">makefile</em>的其余部分在前面的示例中已经很熟悉，但<em class="command">make</em>如何应用隐式规则值得注意。我们的源文件现在位于子目录中。当<em class="command">make</em>尝试应用标准<code class="literal">%.o: %.c</code>规则时，先决条件将是具有相对路径的文件，例如<em class="filename">lib/ui/ui.c</em>。<em class="command">make</em>将自动将该相对路径传播到目标文件并尝试更新<em class="filename">lib/ui/ui.o</em>。因此，<em class="command">make 会</em>自动做正确的事。</p><p>The remainder of the <em class="filename">makefile</em> is already familiar from previous
        examples, but how <em class="command">make</em> applies
        implicit rules is worth noting. Our source files now reside in
        subdirectories. When <em class="command">make</em> tries to
        apply the standard <code class="literal">%.o: %.c</code> rule,
        the prerequisite will be a file with a relative path, say <em class="filename">lib/ui/ui.c</em>. <em class="command">make</em> will automatically propagate that
        relative path to the target file and attempt to update <em class="filename">lib/ui/ui.o</em>. Thus, <em class="command">make</em> automagically does the Right
        Thing.</p><p>最后还有一个小故障。尽管<em class="command">make可以正确处理路径，但并非</em><em class="filename">makefile</em>使用的所有工具
        都是如此。特别是，当使用<em class="command">gcc</em>时，生成的依赖文件不包含目标对象文件的相对路径。也就是说， 的输出<code class="literal">gcc</code> <code class="literal">-M</code>
        是：</p><p>There is one final glitch. Although <em class="command">make</em> is handling paths correctly, not all
        the tools used by the <em class="filename">makefile</em>
        are. In particular, when using <em class="command">gcc</em>,
        the generated dependency file does not include the relative path to
        the target object file. That is, the output of <code class="literal">gcc</code> <code class="literal">-M</code>
        is:</p><a id="OEBPS/ch06s02.html.I_1_tt327"></a><pre class="programlisting">ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h</pre><pre class="programlisting">ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h</pre><p>而不是我们期望的：</p><p>rather than what we expect:</p><a id="OEBPS/ch06s02.html.I_1_tt328"></a><pre class="programlisting">lib/ui/ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h</pre><pre class="programlisting">lib/ui/ui.o: lib/ui/ui.c include/ui/ui.h lib/db/playlist.h</pre><p>这会破坏头文件先决条件的处理。要解决此问题，我们可以更改<em class="command">sed</em>
        命令以添加相对路径信息：</p><p>This disrupts the handling of header file prerequisites. To fix
        this problem we can alter the <em class="command">sed</em>
        command to add relative path information:</p><a id="OEBPS/ch06s02.html.I_1_tt329"></a><pre class="programlisting">$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,'</pre><pre class="programlisting">$(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,'</pre><p>调整<em class="filename">makefile</em>以处理各种工具的怪癖是使用<em class="command">make</em>的正常部分。可移植的<em class="filename">makefile</em>通常非常复杂，因为它们被迫依赖的各种工具的变化无常。</p><p>Tweaking the <em class="filename">makefile</em> to
        handle the quirks of various tools is a normal part of using <em class="command">make</em>. Portable <em class="filename">makefile</em>s are often very complex due to
        vagarities of the diverse set of tools they are forced to rely
        upon.</p><p>我们现在有了一个不错的非递归<em class="filename">makefile</em>，但存在维护问题。 module.mk<em class="filename">包含</em>文件大体相似。对其中一项的更改可能会涉及对所有项的更改。对于像我们的 MP3 播放器这样的小项目来说，这很烦人。对于具有数百个包含文件的大型项目来说，这可能是致命的。通过使用一致的变量名称并规范包含文件的内容，我们可以很好地解决这些问题。这是重构后的<em class="filename">lib/codec</em>
        包含文件：</p><p>We now have a decent nonrecursive <em class="filename">makefile</em>, but there are maintenance
        problems. The <em class="filename">module.mk</em> include
        files are largely similar. A change to one will likely involve a
        change to all of them. For small projects like our mp3 player it is
        annoying. For large projects with several hundred include files it can
        be fatal. By using consistent variable names and regularizing the
        contents of the include files, we position ourselves nicely to cure
        these ills. Here is the <em class="filename">lib/codec</em>
        include file after refactoring:</p><a id="OEBPS/ch06s02.html.I_1_tt330"></a><pre class="programlisting">local_src := $(通配符$(子目录)/*.c)

$(eval $(调用 make-library, $(子目录)/libcodec.a, $(local_src)))</pre><pre class="programlisting">local_src := $(wildcard $(subdirectory)/*.c)

$(eval $(call make-library, $(subdirectory)/libcodec.a, $(local_src)))</pre><p>我们假设要重建目录中的所有<em class="filename">.c</em>文件，而不是按名称指定源文件。这<a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1390" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1391" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1392" class="indexterm"></a> <code class="function">make-library</code>
        函数现在执行包含文件的大部分任务。该函数在我们项目<em class="filename">makefile</em>的顶部定义为：</p><p>Instead of specifying source files by name, we assume we want to
        rebuild all <em class="filename">.c</em> files in the
        directory. The <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <code class="function">make-library</code>
        function now performs the bulk of the tasks for an include file. This
        function is defined at the top of our project <em class="filename">makefile</em> as:</p><a id="OEBPS/ch06s02.html.I_1_tt331"></a><pre class="programlisting"># $(调用 make-library, 库名, 源文件列表)
定义 make-library
  图书馆 += $1
  来源 += $2

  $1: $(调用源到对象,$2)
    $(AR) $(ARFLAGS) $$@ $$^
恩德夫</pre><pre class="programlisting"># $(call make-library, library-name, source-file-list)
define make-library
  libraries += $1
  sources   += $2

  $1: $(call source-to-object,$2)
    $(AR) $(ARFLAGS) $$@ $$^
endef</pre><p>该函数将库和源附加到各自的变量，然后定义构建库的显式规则。请注意自动变量如何使用两个美元符号来推迟<code class="literal">$@</code>和的实际评估，<code class="literal">$^</code>直到规则被触发。该<code class="function">source-to-object</code>函数将源文件列表转换为其相应的目标文件：</p><p>The function appends the library and sources to their respective
        variables, then defines the explicit rule to build the library. Notice
        how the automatic variables use two dollar signs to defer actual
        evaluation of the <code class="literal">$@</code> and <code class="literal">$^</code> until the rule is fired. The <code class="function">source-to-object</code> function translates a list
        of source files to their corresponding object files:</p><a id="OEBPS/ch06s02.html.I_1_tt332"></a><pre class="programlisting">源到对象 = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(过滤器 %.y,$1)) \
                   $(subst .l,.o,$(过滤器 %.l,$1))</pre><pre class="programlisting">source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))</pre><p>在我们之前版本的<em class="filename">makefile中，我们掩盖了实际的解析器和扫描器源文件是</em><em class="filename">playlist.y</em>和<em class="filename">Scanner.l 的</em>事实。相反，我们将源文件列为生成的<em class="filename">.c</em>
        版本。这迫使我们明确列出它们并包含一个额外的变量<code class="literal">extra_clean</code>.我们通过允许<code class="literal">sources</code>变量直接包含<em class="filename">.y</em>和<em class="filename">.l</em>文件并让<code class="function">source-to-object</code> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1393" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1394" class="indexterm"></a>函数完成翻译它们的工作。</p><p>In our previous version of the <em class="filename">makefile</em>, we glossed over the fact that the
        actual parser and scanner source files are <em class="filename">playlist.y</em> and <em class="filename">scanner.l</em>. Instead, we listed the source
        files as the generated <em class="filename">.c</em>
        versions. This forced us to list them explicitly and to include an
        extra variable, <code class="literal">extra_clean</code>. We've
        fixed that issue here by allowing the <code class="literal">sources</code> variable to include <em class="filename">.y</em> and <em class="filename">.l</em> files directly and letting the <code class="function">source-to-object</code> <a class="indexterm"></a> <a class="indexterm"></a> function do the work of translating them.</p><p>除了修改 之外<code class="function">source-to-object</code>，我们还需要另一个函数来计算<em class="command">yacc</em>和<em class="command">lex</em>输出文件，以便<code class="literal">clean</code>目标可以执行适当的清理。这<code class="function">generated-source</code> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1395" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1396" class="indexterm"></a>函数只接受源列表并生成中间文件列表作为输出：</p><p>In addition to modifying <code class="function">source-to-object</code>, we need another function
        to compute the <em class="command">yacc</em> and <em class="command">lex</em> output files so the <code class="literal">clean</code> target can perform proper clean up.
        The <code class="function">generated-source</code> <a class="indexterm"></a> <a class="indexterm"></a> function simply accepts a list of sources and produces
        a list of intermediate files as output:</p><a id="OEBPS/ch06s02.html.I_1_tt333"></a><pre class="programlisting"># $(调用生成源，源文件列表)
生成源 = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(过滤器 %.y,$1)) \
                   $(subst .l,.c,$(过滤器 %.l,$1))</pre><pre class="programlisting"># $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(filter %.y,$1)) \
                   $(subst .l,.c,$(filter %.l,$1))</pre><p>我们的另一个辅助函数<code class="function">subdirectory</code>允许我们省略变量<code class="literal">local_dir</code>。</p><p>Our other helper function, <code class="function">subdirectory</code>, allows us to omit the
        variable <code class="literal">local_dir</code>.</p><a id="OEBPS/ch06s02.html.I_1_tt334"></a><pre class="programlisting">子目录 = $(patsubst %/makefile,%, \
                 $(单词\
                   $(单词$(MAKEFILE_LIST)),$(MAKEFILE_LIST)))</pre><pre class="programlisting">subdirectory = $(patsubst %/makefile,%,                         \
                 $(word                                         \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))</pre><p><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">正如第 4 章</a><a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1" title="字符串函数">4.2.1 节</a>所述，我们可以从 中检索当前<em class="filename">makefile</em>的名称。使用简单的方法，我们可以从顶级<em class="filename">makefile</em>中提取相对路径。这消除了另一个变量并减少了包含文件之间的差异。<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a><em class="filename"></em><code class="literal">MAKEFILE_LIST</code><code class="function">patsubst</code><em class="filename"></em></p><p>As noted in <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.1" title="String Functions">Section
        4.2.1</a> in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>, we can
        retrieve the name of the current <em class="filename">makefile</em> from <code class="literal">MAKEFILE_LIST</code>. Using a simple <code class="function">patsubst</code>, we can extract the relative path
        from the top-level <em class="filename">makefile</em>. This
        eliminates another variable and reduces the differences between
        include files.</p><p>我们最终的优化（至少对于这个例子），用于
        <code class="function">wildcard</code>获取源文件列表。这在大多数源代码树保持干净的环境中都很有效。然而，我参与过的项目却并非如此。旧代码保留在源代码树中“以防万一”。这在程序员的时间和痛苦方面带来了实际成本，因为当全局搜索和替换发现旧的、死的代码时，它会被维护，而新程序员（或不熟悉模块的老程序员）试图编译或调试从未使用过的代码。如果您使用的是现代源代码控制系统，例如 CVS，则无需在源代码树中保留死代码（因为它驻留在存储库中）并且使用<code class="function">wildcard</code>
        变得可行。</p><p>Our final optimization (at least for this example), uses
        <code class="function">wildcard</code> to acquire the source
        file list. This works well in most environments where the source tree
        is kept clean. However, I have worked on projects where this is not
        the case. Old code was kept in the source tree "just in case." This
        entailed real costs in terms of programmer time and anguish since old,
        dead code was maintained when it was found by global search and
        replace and new programmers (or old ones not familiar with a module)
        attempted to compile or debug code that was never used. If you are
        using a modern source code control system, such as CVS, keeping dead
        code in the source tree is unnecessary (since it resides in the
        repository) and using <code class="function">wildcard</code>
        becomes feasible.</p><p>指令<code class="literal">include</code>​
        <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1397" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398" class="indexterm"></a>还可以优化：</p><p>The <code class="literal">include</code> directives
        <a class="indexterm"></a> <a class="indexterm"></a>can also be optimzed:</p><a id="OEBPS/ch06s02.html.I_1_tt335"></a><pre class="programlisting">模块：= lib /编解码器lib / db lib / ui应用程序/播放器
 。 。 。
包括 $(addsuffix /module.mk,$(modules))</pre><pre class="programlisting">modules := lib/codec lib/db lib/ui app/player
 . . . 
include $(addsuffix /module.mk,$(modules))</pre><p>对于较大的项目，随着模块列表增长到数百或数千，这甚至可能成为维护问题。在这种情况下，最好定义<code class="literal">modules</code> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1399" class="indexterm"></a> <a id="OEBPS/ch06s02.html.make3-CHP-6-ITERM-1400" class="indexterm"></a>作为<em class="command">查找</em>
        命令：</p><p>For larger projects, even this can be a maintenance problem as
        the list of modules grows to the hundreds or thousands. Under these
        circumstances, it might be preferable to define <code class="literal">modules</code> <a class="indexterm"></a> <a class="indexterm"></a>as a <em class="command">find</em>
        command:</p><a id="OEBPS/ch06s02.html.I_1_tt336"></a><pre class="programlisting">模块 := $(subst /module.mk,,$(shell find .-name module.mk))
 。 。 。
包括 $(addsuffix /module.mk,$(modules))</pre><pre class="programlisting">modules := $(subst /module.mk,,$(shell find . -name module.mk))
 . . . 
include $(addsuffix /module.mk,$(modules))</pre><p><em class="command">我们从查找</em>输出中删除文件名，因此该<code class="literal">modules</code>变量作为模块列表更有用。如果没有必要，那么，当然，我们会省略<code class="function">subst</code>and
        并简单地将<em class="command">find</em><code class="function">addsuffix</code>的输出保存在 中。<a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-3" title="例 6-3。非递归 makefile，版本 2">例 6-3</a>显示了最终的
        <em class="filename">makefile</em>。<em class="command"></em><code class="literal">modules</code><a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-3" title="例 6-3。非递归 makefile，版本 2"></a><em class="filename"></em></p><p>We strip the filename from the <em class="command">find</em> output so the <code class="literal">modules</code> variable is more generally useful as
        the list of modules. If that isn't necessary, then, of course, we
        would omit the <code class="function">subst</code> and
        <code class="function">addsuffix</code> and simply save the
        output of <em class="command">find</em> in <code class="literal">modules</code>. <a class="link" href="#OEBPS/ch06s02.html.make3-CHP-6-EX-3" title="Example&nbsp;6-3.&nbsp;A nonrecursive makefile, version 2">Example 6-3</a> shows the final
        <em class="filename">makefile</em>.</p><div class="example"><a id="OEBPS/ch06s02.html.make3-CHP-6-EX-3"></a><p class="title">例 6-3。非递归 makefile，版本 2</p><p class="title">Example&nbsp;6-3.&nbsp;A nonrecursive makefile, version 2</p><div class="example-contents"><pre class="programlisting"># $(调用源到对象，源文件列表)
源到对象 = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(过滤器 %.y,$1)) \
                   $(subst .l,.o,$(过滤器 %.l,$1))

# $(子目录)
子目录 = $(patsubst %/module.mk,%, \
                 $(单词\
                   $(单词$(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

# $(调用 make-library, 库名, 源文件列表)
定义 make-library
  图书馆 += $1
  来源 += $2

  $1: $(调用源到对象,$2)
        $(AR) $(ARFLAGS) $$@ $$^
恩德夫

# $(调用生成源，源文件列表)
生成源 = $(subst .y,.c,$(filter %.y,$1)) \
                   $(subst .y,.h,$(过滤器 %.y,$1)) \
                   $(subst .l,.c,$(过滤器 %.l,$1))

# 从这四个变量中收集每个模块的信息。
# 在这里将它们初始化为简单变量。
模块：= lib /编解码器lib / db lib / ui应用程序/播放器
程序:=
库:=
来源:=

对象 = $(调用源到对象,$(源))
依赖项 = $(subst .o,.d,$(对象))

include_dirs := lib 包含
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV := mv -f
RM := rm -f
SED := sed

全部：

包括 $(addsuffix /module.mk,$(modules))

.PHONY：全部
全部：$（程序）

.PHONY：库
图书馆：$（图书馆）

.PHONY：干净
干净的：
        $(RM) $(对象) $(程序) $(库) $(依赖项) \
              $(调用生成源，$(源))

ifneq "$(MAKECMDGOALS)" "干净"
  包括 $(依赖项)
万一

%.c %.h: %.y
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre><pre class="programlisting"># $(call source-to-object, source-file-list)
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))

# $(subdirectory)
subdirectory = $(patsubst %/module.mk,%,                        \
                 $(word                                         \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

# $(call make-library, library-name, source-file-list)
define make-library
  libraries += $1
  sources   += $2

  $1: $(call source-to-object,$2)
        $(AR) $(ARFLAGS) $$@ $$^
endef

# $(call generated-source, source-file-list)
generated-source = $(subst .y,.c,$(filter %.y,$1))      \
                   $(subst .y,.h,$(filter %.y,$1))      \
                   $(subst .l,.c,$(filter %.l,$1))

# Collect information from each module in these four variables.
# Initialize them here as simple variables.
modules      := lib/codec lib/db lib/ui app/player
programs     :=
libraries    :=
sources      :=

objects      =  $(call source-to-object,$(sources))
dependencies =  $(subst .o,.d,$(objects))

include_dirs := lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MV  := mv -f
RM  := rm -f
SED := sed

all:

include $(addsuffix /module.mk,$(modules))

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
        $(RM) $(objects) $(programs) $(libraries) $(dependencies)       \
              $(call generated-source, $(sources))

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif

%.c %.h: %.y
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%.d: %.c
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $&lt; | \
        $(SED) 's,\($(notdir $*)\.o\) *:,$(dir $@)\1 $@: ,' &gt; $@.tmp
        $(MV) $@.tmp $@</pre></div></div><p>每个模块使用一个包含文件是相当可行的，并且有一些优点，但我不相信这是值得做的。我自己在大型 Java 项目中的经验表明，单个顶级<em class="filename">makefile</em>有效地将所有
        <em class="filename">module.mk</em>文件直接插入到
        <em class="filename">makefile</em>中，提供了合理的解决方案。该项目包括 997 个独立模块、大约两打库和六个应用程序。有几个<em class="filename">makefile</em>用于不相交的代码集。这些
        <em class="filename">makefile</em>大约有 2,500 行长。包含全局变量、用户定义函数和模式规则的公共包含文件还有 2,500 行。</p><p>Using one include file per module is quite workable and has some
        advantages, but I'm not convinced it is worth doing. My own experience
        with a large Java project indicates that a single top-level <em class="filename">makefile</em>, effectively inserting all the
        <em class="filename">module.mk</em> files directly into the
        <em class="filename">makefile</em>, provides a reasonable
        solution. This project included 997 separate modules, about two dozen
        libraries, and half a dozen applications. There were several <em class="filename">makefile</em>s for disjoint sets of code. These
        <em class="filename">makefile</em>s were roughly 2,500
        lines long. A common include file containing global variables,
        user-defined functions, and pattern rules was another 2,500
        lines.</p><p>无论您选择单个<em class="filename">makefile</em>还是将模块信息分解为包含文件，非递归<em class="command">make</em>解决方案都是构建大型项目的可行方法。它还解决了递归<em class="command">make</em>
        方法中发现的许多传统问题。我知道的唯一缺点是习惯于递归<em class="command">make 的</em>开发人员需要进行范式转变。</p><p>Whether you choose a single <em class="filename">makefile</em> or break out module information
        into include files, the nonrecursive <em class="command">make</em> solution is a viable approach to
        building large projects. It also solves many traditional problems
        found in the recursive <em class="command">make</em>
        approach. The only drawback I'm aware of is the paradigm shift
        required for developers used to recursive <em class="command">make</em>.</p></div></div></div>
<div id="OEBPS/ch06s03.html"><div>
<div class="sect1" title="大型系统的组件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06s03.html.make3-CHP-6-SECT-3"></a>大型系统的组件</h1><h1 class="title"><a></a>Components of Large Systems</h1></div></div></div><p>出于本次讨论的目的，有<a id="OEBPS/ch06s03.html.make3-CHP-6-ITERM-1401" class="indexterm"></a> <a id="OEBPS/ch06s03.html.make3-CHP-6-ITERM-1402" class="indexterm"></a> <a id="OEBPS/ch06s03.html.make3-CHP-6-ITERM-1403" class="indexterm"></a>当今流行两种开发风格：自由软件模型和商业开发模型。</p><p>For the purposes of this discussion, there <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>are two styles of development popular today: the free
        software model and the commercial development model.</p><p>在自由软件模型中，每个开发人员很大程度上依靠自己。一个项目有一个<em class="filename">makefile</em>和一个<em class="filename">README</em>，开发人员只需少量帮助就可以弄清楚它。该项目的负责人希望一切顺利，并希望收到来自大型社区的贡献，但他们最感兴趣的是技术熟练且积极主动的人的贡献。这不是批评。从这个角度来看，软件应该写得好，而不一定要按照时间表来写。</p><p>In the free software model, each developer is largely on his
        own. A project has a <em class="filename">makefile</em> and
        a <em class="filename">README</em> and developers are
        expected to figure it out with only a small amount of help. The
        principals of the project want things to work well and want to receive
        contributions from a large community, but they are mostly interested
        in contributions from the skilled and well-motivated. This is not a
        criticism. In this point of view, software should be written well, and
        not necessarily to a schedule.</p><p>在商业开发模式中，开发人员的技能水平各不相同，他们都必须能够开发软件来为盈利做出贡献。任何不知道如何完成工作的开发人员都是在浪费金钱。如果系统不能正常编译或运行，整个开发团队可能会闲置，这是最昂贵的情况。为了解决这些问题，开发过程由工程支持团队管理，该团队负责协调构建过程、软件工具的配置、新开发和维护工作的协调以及版本的管理。在这种环境下，效率问题在整个过程中占据主导地位。</p><p>In the commercial development model, developers come in a wide
        variety of skill levels and all of them must be able to develop
        software to contribute to the bottom line. Any developer who can't
        figure out how to do their job is wasting money. If the system doesn't
        compile or run properly, the development team as a whole may be idle,
        the most expensive possible scenario. To handle these issues, the
        development process is managed by an engineering support team that
        coordinates the build process, configuration of software tools,
        coordination of new development and maintenance work, and the
        management of releases. In this environment, efficiency concerns
        dominate the process.</p><p>商业开发模型倾向于创建复杂的构建系统。其主要原因是通过提高程序员效率来降低软件开发成本的压力。反过来，这应该会导致利润增加。这种模型最需要<em class="command">make</em>的支持。尽管如此，我们在这里讨论的技术也适用于自由软件模型，当他们的需求需要它时。</p><p>It is the commercial development model that tends to create
        elaborate build systems. The primary reason for this is pressure to
        reduce the cost of software development by increasing programmer
        efficiency. This, in turn, should lead to increased profit. It is this
        model that requires the most support from <em class="command">make</em>. Nevertheless, the techniques we
        discuss here apply to the free software model as well when their
        requirements demand it.</p><p>本节包含大量高级信息，但具体细节很少，也没有示例。这是因为很大程度上取决于所使用的语言和操作环境。在<a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++">第 8 章和</a><a class="link" href="#OEBPS/ch09.html" title="第 9 章 Java">第 9 章</a>中，我将提供如何实现其中许多功能的具体示例。</p><p>This section contains a lot of high-level information with very
        few specifics and no examples. That's because so much depends on the
        language and operating environment used. In <a class="link" href="#OEBPS/ch08.html" title="Chapter&nbsp;8.&nbsp;C and C++">Chapter 8</a> and <a class="link" href="#OEBPS/ch09.html" title="Chapter&nbsp;9.&nbsp;Java">Chapter 9</a>, I will provide specific
        examples of how to implement many of these features.</p><div class="sect2" title="要求"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch06s03.html.make3-CHP-6-SECT-3.1"></a>要求</h2><h2 class="title"><a></a>Requirements</h2></div></div></div><p>当然要求不同<a id="OEBPS/ch06s03.html.make3-CHP-6-ITERM-1404" class="indexterm"></a>每个项目和每个工作环境。在这里，我们涵盖了在许多商业开发环境中通常被认为重要的广泛范围。</p><p>Of course requirements vary <a class="indexterm"></a>with every project and every work environment. Here we
          cover a wide range that are often considered important in many
          commercial development environments.</p><p>开发团队期望的最常见的功能是将源代码与二进制代码分离。也就是说，编译生成的目标文件应该放置在单独的二叉树中。反过来，这允许添加许多其他功能。单独的二叉树提供了许多<a id="OEBPS/ch06s03.html.make3-CHP-6-ITERM-1405" class="indexterm"></a>优点：</p><p>The most common feature desired by development teams is the
          separation of source code from binary code. That is, the object
          files generated from a compile should be placed in a separate binary
          tree. This, in turn, allows many other features to be added.
          Separate binary trees offer many <a class="indexterm"></a>advantages:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>当可以指定大型二叉树的位置时，管理磁盘资源会更容易。</p></li><li class="listitem"><p>It is easier to manage disk resources when the location of
              large binary trees can be specified.</p></li><li class="listitem"><p>可以并行管理二叉树的许多版本。例如，单个源代码树可能具有可用的优化、调试和分析二进制版本。</p></li><li class="listitem"><p>Many versions of a binary tree can be managed in parallel.
              For instance, a single source tree may have optimized, debug,
              and profiling binary versions available.</p></li><li class="listitem"><p>可以同时支持多个平台。正确实现的源代码树可用于并行编译多个平台的二进制文件。</p></li><li class="listitem"><p>Multiple platforms can be supported simultaneously. A
              properly implemented source tree can be used to compile binaries
              for many platforms in parallel.</p></li><li class="listitem"><p>开发人员可以检查部分源代码树，并让构建系统自动从参考源代码和二进制树中“填充”缺失的文件。这并不严格要求分离源代码和二进制文件，但如果不进行分离，开发人员构建系统很可能会对应该在哪里找到二进制文件感到困惑。</p></li><li class="listitem"><p>Developers can check out partial source trees and have the
              build system automatically "fill in" the missing files from a
              reference source and binary trees. This doesn't strictly require
              separating source and binary, but without the separation it is
              more likely that developer build systems would get confused
              about where binaries should be found.</p></li><li class="listitem"><p>可以通过只读访问来保护源树。这提供了额外的保证，即构建反映存储库中的源代码。</p></li><li class="listitem"><p>Source trees can be protected with read-only access. This
              provides added assurance that the builds reflect the source code
              in the repository.</p></li><li class="listitem"><p><code class="literal">clean</code>如果可以将树视为单个单元而不是在树中搜索要操作的文件，则某些目标（例如）可以轻松实现（并且执行速度会显着加快）。</p></li><li class="listitem"><p>Some targets, such as <code class="literal">clean</code>, can be implemented trivially
              (and will execute dramatically faster) if a tree can be treated
              as a single unit rather than searching the tree for files to
              operate on.</p></li></ul></div><p>上述大多数要点本身就是重要的构建功能，并且可能是项目要求。</p><p>Most of the above points are themselves important build
          features and may be project requirements.</p><p>能够维护项目的参考版本通常是一个重要的系统功能。这个想法是，每晚都会对源代码进行干净的签出和构建，通常是通过<em class="command">cron</em>作业来执行。由于生成的源代码和二叉树相对于 CVS 源代码没有进行修改，因此我将它们称为参考源代码和二叉树。由此产生的树木有很多用途。</p><p>Being able to maintain reference builds of a project is often
          an important system feature. The idea is that a clean check-out and
          build of the source is performed nightly, typically by a <em class="command">cron</em> job. Since the resulting source and
          binary trees are unmodified with respect to the CVS source, I refer
          to these as reference source and binary trees. The resulting trees
          have many uses.</p><p>首先，需要查看源代码的程序员和管理人员可以使用参考源代码树。这可能看起来微不足道，但是当文件和版本的数量增加时，期望某人仅仅为了检查单个文件而检查源代码可能会很笨拙或不合理。此外，虽然 CVS 存储库浏览工具很常见，但它们通常不提供对整个源代码树的轻松搜索。为此，标签表甚至<em class="command">find</em> / <em class="command">grep</em>（或<em class="command">grep</em> <code class="option">-R</code>）更合适。</p><p>First, a reference source tree can be used by programmers and
          managers who need to look at the source. This may seem trivial, but
          when the number of files and releases grows it can be unwieldy or
          unreasonable to expect someone to check-out the source just to
          examine a single file. Also, while CVS repository browsing tools are
          common, they do not typically provide for easy searching of the
          entire source tree. For this, tags tables or even <em class="command">find</em>/<em class="command">grep</em> (or <em class="command">grep</em> <code class="option">-R</code>) are more
          appropriate.</p><p>其次，也是最重要的一点，参考二叉树表明源代码的构建是干净的。当开发人员每天早上开始工作时，他们知道系统是损坏还是完整。如果存在面向批处理的测试框架，则可以使用干净的构建来运行自动化测试。开发人员每天都可以检查测试报告来确定系统的运行状况，而无需浪费时间自己运行测试。如果开发人员只有源代码的修改版本，则节省的成本会更加复杂，因为他避免了花费额外的时间来执行干净的签出和构建。最后，开发人员可以运行参考版本来测试和比较特定组件的功能。</p><p>Second, and most importantly, a reference binary tree
          indicates that the source builds cleanly. When developers begin each
          morning, they know if the system is broken or whole. If a
          batch-oriented testing framework is in place, the clean build can be
          used to run automated tests. Each day developers can examine the
          test report to determine the health of the system without wasting
          time running the tests themselves. The cost savings is compounded if
          a developer has only a modified version of the source because he
          avoids spending additional time performing a clean check-out and
          build. Finally, the reference build can be run by developers to test
          and compare the functionality of specific components.</p><p>参考构建也可以以其他方式使用。对于包含许多库的项目，程序员可以使用夜间构建中的预编译库将他们自己的应用程序与他们未修改的库链接起来。这使他们能够通过从本地编译中省略大部分源代码树来缩短开发周期。当然，如果开发人员需要检查代码并且没有完整签出的源代码树，那么轻松访问本地文件服务器上的项目源代码会很方便。</p><p>The reference build can be used in other ways as well. For
          projects that consist of many libraries, the precompiled libraries
          from the nightly build can be used by programmers to link their own
          application with those libraries they are not modifying. This allows
          them to shorten their develoment cycle by omiting large portions of
          the source tree from their local compiles. Of course, easy access to
          the project source on a local file server is convenient if
          developers need to examine the code and do not have a complete
          checked out source tree.</p><p>由于有如此多的不同用途，验证参考源和二叉树的完整性变得更加重要。提高可靠性的一种简单而有效的方法是将源代码树设置为只读。因此，可以保证参考源文件准确地反映检出时存储库的状态。执行此操作可能需要特别小心，因为构建的许多不同方面可能会尝试因果地写入源树。特别是在生成源代码或写入临时文件时。将源代码树设置为只读还可以防止临时用户意外损坏源代码树（这是最常见的情况）。</p><p>With so many different uses, it becomes more important to
          verify the integrity of the reference source and binary trees. One
          simple and effective way to improve reliability is to make the
          source tree read-only. Thus, it is guaranteed that the reference
          source files accurately reflect the state of the repository at the
          time of check out. Doing this can require special care, because many
          different aspects of the build may attempt to causally write to the
          source tree. Especially when generating source code or writing
          temporary files. Making the source tree read-only also prevents
          casual users from accidentally corrupting the source tree, a most
          common occurrence.</p><p>项目构建系统的另一个常见要求是能够轻松处理不同的编译、链接和部署配置。构建系统通常必须能够管理项目的不同版本（可能是源存储库的分支）。</p><p>Another common requirement of the project build system is the
          ability to easily handle different compilation, linking, and
          deployment configurations. The build system typically must be able
          to manage different versions of the project (which may be branches
          of the source repository).</p><p>大多数大型项目都依赖于重要的第三方软件，无论是可链接库还是工具的形式。如果没有其他工具来管理软件的配置（通常没有），那么使用 makefile<em class="filename">和</em>构建系统来管理它通常是一个合理的选择。</p><p>Most large projects rely on significant third-party software,
          either in the form of linkable libraries or tools. If there are no
          other tools to manage configurations of the software (and often
          there are not), using the <em class="filename">makefile</em> and build system to manage this
          is often a reasonable choice.</p><p>最后，当软件发布给客户时，通常会从其开发形式重新打包。这可以像为 Windows 构建<em class="filename">setup.exe</em>文件一样复杂，也可以像格式化 HTML 文件并将其与 jar 捆绑一样简单。有时，此安装程序构建操作会与正常构建过程结合在一起。我更喜欢将构建和安装生成作为两个独立的阶段，因为它们似乎使用完全不同的流程。无论如何，这两个操作都可能会对构建系统产生影响。</p><p>Finally, when software is released to a customer, it is often
          repackaged from its development form. This can be as complex as
          constructing a <em class="filename">setup.exe</em> file
          for Windows or as simple as formatting an HTML file and bundling it
          with a jar. Sometimes this installer build operation is combined
          with the normal build process. I prefer to keep the build and the
          install generation as two separate stages because they seem to use
          radically different processes. In any case, it is likely that both
          of these operations will have an impact on the build system.</p></div></div></div></div>
<div id="OEBPS/ch06s04.html"><div>
<div class="sect1" title="文件系统布局"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06s04.html.make3-CHP-6-SECT-4"></a>文件系统布局</h1><h1 class="title"><a></a>Filesystem Layout</h1></div></div></div><p>一旦您选择支持f<a id="OEBPS/ch06s04.html.make3-CHP-6-ITERM-1406" class="indexterm"></a> <a id="OEBPS/ch06s04.html.make3-CHP-6-ITERM-1407" class="indexterm"></a>多个二叉树，就会出现文件系统布局的问题。在需要多个二叉树的环境中，往往会有<span class="emphasis"><em>很多</em></span><span class="emphasis"><em>二叉树</em></span> 。要保持所有这些树笔直，需要一些思考。<span class="emphasis"><em></em></span></p><p>Once you choose to support f<a class="indexterm"></a> <a class="indexterm"></a>multiple binary trees, the question of filesystem layout
        arises. In environments that require multiple binary trees, there are
        often <span class="emphasis"><em>a</em></span> <span class="emphasis"><em>lot</em></span> of binary trees.
        To keep all these trees straight requires some thought.</p><p>组织这些数据的常见方法是为二叉树“场”指定一个大磁盘。在该磁盘的顶层（或附近）是每个二叉树的一个目录。这些树的一种合理布局是在每个目录名称中包含二叉树的供应商、硬件平台、操作系统和构建参数：</p><p>A common way to organize this data is to designate a large disk
        for a binary tree "farm." At (or near) the top level of this disk is
        one directory for each binary tree. One reasonable layout for these
        trees is to include in each directory name the vendor, hardware
        platform, operating system, and build parameters of the binary
        tree:</p><a id="OEBPS/ch06s04.html.I_1_tt337"></a><pre class="programlisting">$<strong class="userinput"><code>ls</code></strong>
hp-386-windows-优化
hp-386-windows-调试
sgi-irix 优化
sgi-irix-调试
sun-solaris8-profiled
sun-solaris8-调试</pre><pre class="programlisting">$<strong class="userinput"><code>ls</code></strong>
hp-386-windows-optimized
hp-386-windows-debug
sgi-irix-optimzed
sgi-irix-debug
sun-solaris8-profiled
sun-solaris8-debug</pre><p>当必须保留许多不同时间的构建时，通常最好在目录名称中包含日期戳（甚至时间戳）。格式<code class="literal">yymmdd</code>
        或<code class="literal">yymmddhhmm</code>排序良好：</p><p>When builds from many different times must be kept, it is
        usually best to include a date stamp (and even a timestamp) in the
        directory name. The format <code class="literal">yymmdd</code>
        or <code class="literal">yymmddhhmm</code> sorts well:</p><a id="OEBPS/ch06s04.html.I_1_tt338"></a><pre class="programlisting">$<strong class="userinput"><code>ls</code></strong>
hp-386-windows-optimized-040123
hp-386-windows-debug-040123
sgi-irix-optimized-040127
sgi-irix-调试-040127
太阳-solaris8-profiled-040127
太阳-solaris8-调试-040127</pre><pre class="programlisting">$<strong class="userinput"><code>ls</code></strong>
hp-386-windows-optimized-040123
hp-386-windows-debug-040123
sgi-irix-optimzed-040127
sgi-irix-debug-040127
sun-solaris8-profiled-040127
sun-solaris8-debug-040127</pre><p>当然，这些文件名组成部分的顺序取决于您的站点。这些树的顶级目录是保存<em class="filename">makefile</em>和测试日志的好地方。</p><p>Of course, the order of these filename components is up to your
        site. The top-level directory of these trees is a good place to hold
        the <em class="filename">makefile</em> and testing
        logs.</p><p>此布局适合存储许多并行开发人员构建。如果开发团队可能为内部客户进行“发布”，您可以考虑添加一个额外的发布场，其结构为一组产品，每个产品可能都有版本号和时间戳，如图<a class="link" href="#OEBPS/ch06s04.html.make3-CHP-6-FIG-2" title="图 6-2。发布树布局示例">6-2</a>所示。</p><p>This layout is appropriate for storing many parallel developer
        builds. If a development team makes "releases," possibly for internal
        customers, you can consider adding an additional release farm,
        structured as a set of products, each of which may have a version
        number and timestamp as shown in <a class="link" href="#OEBPS/ch06s04.html.make3-CHP-6-FIG-2" title="Figure&nbsp;6-2.&nbsp;Example of a release tree layout">Figure 6-2</a>.</p><div class="figure"><a id="OEBPS/ch06s04.html.make3-CHP-6-FIG-2"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch06s04.html.I_1_tt339"></a><img src="data:image/jpg;base64,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" width="185" alt="发布树布局示例"></div></div><p class="title">图 6-2。发布树布局示例</p><p class="title">Figure&nbsp;6-2.&nbsp;Example of a release tree layout</p></div><p>这里的产品可能是库，是开发团队的输出，供其他开发人员使用。当然，它们也可能是传统意义上的产品。</p><p>Here products might be libraries that are the output of a
        development team for use by other developers. Of course, they may also
        be products in the traditional sense.</p><p>无论您的文件布局或环境如何，许多相同的标准都控制着实施。必须很容易识别每棵树。清理工作应该快速且明显。它有助于轻松移动树和归档树。此外，文件系统布局应与组织的进程结构紧密匹配。这使得经理、质量保证和技术出版物等非程序员可以轻松浏览林场。</p><p>Whatever your file layout or environment, many of the same
        criteria govern the implementation. It must be easy to identify each
        tree. Cleanup should be fast and obvious. It is useful to make it easy
        to move trees around and archive trees. In addition, the filesystem
        layout should closely match the process structure of the organization.
        This makes it easy for nonprogrammers such as managers, quality
        assurance, and technical publications to navigate the tree
        farm.</p></div></div></div>
<div id="OEBPS/ch06s05.html"><div>
<div class="sect1" title="自动化构建和测试"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch06s05.html.make3-CHP-6-SECT-5"></a>自动化构建和测试</h1><h1 class="title"><a></a>Automating Builds and Testing</h1></div></div></div><p>通常重要的是能够<a id="OEBPS/ch06s05.html.make3-CHP-6-ITERM-1409" class="indexterm"></a> <a id="OEBPS/ch06s05.html.make3-CHP-6-ITERM-1410" class="indexterm"></a>尽可能自动化构建过程。这允许在夜间执行参考树构建，从而节省开发人员白天的时间。它还允许开发人员自己在无人值守的情况下在自己的机器上运行构建。</p><p>It is typically important to be able to <a class="indexterm"></a> <a class="indexterm"></a>automate the build process as much as possible. This
        allows reference tree builds to be performed at night, saving
        developer time during the day. It also allows developers themselves to
        run builds on their own machines unattended.</p><p>对于“生产中”的软件，通常存在许多对不同产品的不同版本的构建的未决请求。对于负责满足这些请求的人来说，启动多个构建并“走开”的能力通常对于保持理智和满足请求至关重要。</p><p>For software that is "in production," there are often many
        outstanding requests for builds of different versions of different
        products. For the person in charge of satisfying these requests, the
        ability to fire off several builds and "walk away" is often critical
        to maintaining sanity and satisfying requests.</p><p>自动化测试也有其自身的问题。许多非图形应用程序可以使用简单的脚本来管理测试过程。<acronym class="acronym">GNU</acronym>工具dejaGnu还可用于测试需要交互的非图形实用程序<em class="command">。</em>当然，像 JUnit ( <a class="ulink" href="http://www.junit.org/">http://www.junit.org</a> ) 这样的测试框架也提供对非图形单元测试的支持。</p><p>Automated testing presents its own issues. Many nongraphical
        applications can use simple scripting to manage the testing process.
        The <acronym class="acronym">GNU</acronym> tool <em class="command">dejaGnu</em> can also be used to test
        nongraphical utilities that require interaction. Of course, testing
        frameworks like JUnit (<a class="ulink" href="http://www.junit.org">http://www.junit.org</a>)
        also provide support for nongraphical unit testing.</p><p>图形应用程序的测试呈现出特殊的<a id="OEBPS/ch06s05.html.make3-CHP-6-ITERM-1411" class="indexterm"></a>问题。对于基于 X11 的系统，我已使用虚拟帧缓冲区<em class="command">Xvfb</em>成功执行了无人值守、基于 cron 的测试。在Windows上，我还没有找到令人满意的无人值守测试解决方案。所有方法都依赖于保持测试帐户登录且屏幕解锁。</p><p>Testing of graphical applications presents special <a class="indexterm"></a>problems. For X11-based
        systems, I have successfully performed unattended, cron-based testing
        using the virtual frame buffer, <em class="command">Xvfb</em>. On Windows, I have not found a
        satisfactory solution to unattended testing. All approaches rely on
        leaving the testing account logged in and the screen unlocked.</p></div></div></div>
<div id="OEBPS/ch07.html"><div>
<div class="chapter" title="第 7 章可移植 Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07.html.make3-CHP-7"></a>第 7 章可移植 Makefile</h1><h1 class="title"><a></a>Chapter&nbsp;7.&nbsp;Portable Makefiles</h1></div></div></div><p><em class="filename">可移植makefile</em>是什么意思？作为一个极端的例子，我们希望
      <em class="filename">makefile可以在运行</em><acronym class="acronym">GNU </acronym> <em class="command">make</em>的任何系统上运行而无需更改。但由于操作系统种类繁多，这实际上是不可能的。更合理的解释是<em class="filename">makefile</em>很容易针对其运行的每个新平台进行更改。一个重要的附加限制是新系统的移植不会破坏对以前平台的支持。</p><p>What do we mean by a portable <em class="filename">makefile</em>? As an extreme example, we want a
      <em class="filename">makefile</em> that runs without change
      on any system that <acronym class="acronym">GNU</acronym> <em class="command">make</em> runs on. But this is virtually impossible
      due to the enormous variety in operating systems. A more reasonable
      interpretation is a <em class="filename">makefile</em> that
      is easy to change for each new platform it is run on. An important added
      constraint is that the port to the new system does not break support for
      the previous platforms.</p><p>我们可以达到这个水平<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1412" class="indexterm"></a>使用与传统编程相同的技术来实现<em class="filename">makefile</em>的可移植性：封装和抽象。通过使用变量和用户定义的函数，我们可以封装应用程序和算法。通过为命令行参数和参数定义变量，我们可以从恒定的元素中抽象出因平台而异的元素。</p><p>We can achieve this level of <a class="indexterm"></a>portability for <em class="filename">makefile</em>s using the same techniques as
      traditional programming: encapsulation and abstraction. By using
      variables and user-defined functions we can encapsulate applications and
      algorithms. By defining variables for command-line arguments and
      parameters, we can abstract out elements that vary from platform to
      platform from elements that are constant.</p><p>然后，您必须确定每个平台提供哪些工具来完成您的工作，以及每个平台使用哪些工具。可移植性的极致是仅使用所有感兴趣的平台上存在的工具和功能。这通常被称为“最小公分母”方法，显然可以给您留下非常原始的功能来使用。</p><p>You then have to determine what tools each platform offers to get
      your job done, and what to use from each platform. The extreme in
      portability is to use only those tools and features that exist on all
      platforms of interest. This is typically called the "least common
      denominator" approach and obviously can leave you with very primitive
      functionality to work with.</p><p>最小公分母方法的另一个版本是选择一组功能强大的工具，并确保将其带到每个平台，从而保证您在 makefile 中调用的命令在
      <em class="filename">任何</em>地方都完全相同。无论是在管理上还是在让你的组织配合你摆弄他们的系统方面，这都很难实现。但它可以成功，稍后我将通过适用于 Windows 的 Cygwin 软件包展示一个示例。正如您将看到的，工具标准化并不能解决所有问题。总是存在操作系统差异需要处理。</p><p>Another version of the least common denominator approach is to
      choose a powerful set of tools and make sure to bring it with you to
      every platform, thus guaranteeing that the commands you invoke in the
      <em class="filename">makefile</em> work exactly the same
      everywhere. This can be hard to pull off, both administratively and in
      terms of getting your organization to cooperate with your fiddling with
      their systems. But it can be successful, and I'll show one example of
      that later with the Cygwin package for Windows. As you'll see,
      standardizing on tools does not solve every problem; there are always
      operating system differences to deal with.</p><p>最后，您可以接受系统之间的差异，并通过仔细选择宏和函数来解决这些差异。我也将在本章中展示这种方法。</p><p>Finally, you can accept differences between systems and work
      around them by careful choices of macros and functions. I'll show this
      approach in this chapter, too.</p><p>因此，通过明智地使用变量和用户定义的函数，并通过最大限度地减少外来功能的使用并依赖标准工具，我们可以提高<em class="filename">makefile</em>的可移植性。如前所述，不存在完美的可移植性，因此我们的工作是平衡工作量与可移植性。但在我们探讨具体技术之前，让我们先回顾一下可移植<em class="filename">makefile</em>的一些问题。</p><p>So, by judicious use of variables and user-defined functions, and
      by minimizing the use of exotic features and relying on standard tools,
      we can increase the portability of our <em class="filename">makefile</em>s. As noted previously, there is no
      such thing as perfect portability, so it is our job to balance effort
      versus portability. But before we explore specific techniques, let's
      review some of the issues of portable <em class="filename">makefile</em>s.</p><div class="sect1" title="可移植性问题"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07.html.make3-CHP-7-SECT-1"></a>可移植性问题</h1><h1 class="title"><a></a>Portability Issues</h1></div></div></div><p>可移植性问题可能很难描述，因为它们涵盖了从总体范式转变（例如传统 Mac OS 与 System V Unix）到几乎微不足道的错误修复（例如修复程序错误退出状态中的错误）的整个范围。 ）。尽管如此，以下是每个
        <em class="filename">makefile</em>迟早必须处理的一些常见的可移植性问题：</p><p>Portability problems can be difficult to characterize since they
        span the entire spectrum from a total paradigm shift (such as
        traditional Mac OS versus System V Unix) to almost trivial bug fixes
        (such as a fix to a bug in the error exit status of a program).
        Nevertheless, here are some common portability problems that every
        <em class="filename">makefile</em> must deal with sooner or
        later:</p><div class="variablelist"><dl><dt><span class="term">程序名称</span></dt><dt><span class="term">Program names</span></dt><dd><p>这是很常见的<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1413" class="indexterm"></a> <a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1414" class="indexterm"></a>不同的平台对相同或相似的程序使用不同的名称。最常见的是 C 或 C++ 编译器的名称（例如<em class="command">cc</em>、
               <em class="command">xlc</em>）。<acronym class="acronym">GNU</acronym>版本的程序通常
              安装在带有
              <span class="emphasis"><em>g</em></span><acronym class="acronym">前缀的非GNU</acronym>系统上（例如<em class="command">gmake</em>、<em class="command">gawk</em>）。<span class="emphasis"><em></em></span><em class="command"></em><em class="command"></em></p></dd><dd><p>It is quite common for <a class="indexterm"></a> <a class="indexterm"></a>various platforms to use different names for the
              same or similar programs. The most common is the name of the C
              or C++ compiler (e.g., <em class="command">cc</em>,
              <em class="command">xlc</em>). It is also common for
              <acronym class="acronym">GNU</acronym> versions of programs to be installed on a
              non-<acronym class="acronym">GNU</acronym> system with the
              <span class="emphasis"><em>g</em></span> prefix (e.g., <em class="command">gmake</em>, <em class="command">gawk</em>).</p></dd><dt><span class="term">路径</span></dt><dt><span class="term">Paths</span></dt><dd><p>程序的位置和<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1415" class="indexterm"></a> <a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1416" class="indexterm"></a>文件通常因平台而异。例如，在 Solaris 系统上，X 目录存储在
              <em class="filename">/usr/X</em>下，而在许多其他系统上，路径是<em class="filename">/usr/X11R6</em>。此外，当您从一个系统转移到另一个系统时， <em class="filename">/bin</em>、
               <em class="filename">/usr/bin</em>、<em class="filename">/sbin</em>和<em class="filename">/usr/sbin</em>之间的区别通常相当模糊。</p></dd><dd><p>The location of programs and <a class="indexterm"></a> <a class="indexterm"></a>files often varies between platforms. For
              instance, on Solaris systems the X directories are stored under
              <em class="filename">/usr/X</em> while on many other
              systems the path is <em class="filename">/usr/X11R6</em>. In addition, the
              distinction between <em class="filename">/bin</em>,
              <em class="filename">/usr/bin</em>, <em class="filename">/sbin</em>, and <em class="filename">/usr/sbin</em> is often rather fuzzy as
              you move from one system to another.</p></dd><dt><span class="term">选项</span></dt><dt><span class="term">Options</span></dt><dd><p>命令行<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1417" class="indexterm"></a> <a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1418" class="indexterm"></a>程序的选项各不相同，特别是在使用替代实现时。此外，如果平台缺少实用程序或版本损坏，您可能需要将该实用程序替换为使用不同命令行选项的另一个实用程序。</p></dd><dd><p>The command-line <a class="indexterm"></a> <a class="indexterm"></a>options to programs vary, particularly when an
              alternate implementation is used. Furthermore, if a platform is
              missing a utility or comes with a broken version, you may need
              to replace the utility with another that uses different
              command-line options.</p></dd><dt><span class="term">外壳特点</span></dt><dt><span class="term">Shell features</span></dt><dd><p>默认情况下，<em class="command">make</em>
              执行命令脚本<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1419" class="indexterm"></a> <a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1420" class="indexterm"></a>与<em class="filename">/bin/sh</em>，但<em class="command">sh</em>实现的功能差异很大。特别是，POSIX 之前的 shell 缺少许多功能，并且不接受与现代 shell 相同的语法。</p><p>Open Group 有一份非常有用的白皮书，介绍了 System V shell 和 POSIX shell 之间的差异。可以在<a class="ulink" href="http://www.unix-systems.org/whitepapers/shdiffs.html">http://www.unix-systems.org/whitepapers/shdiffs.html</a>找到它。对于那些想要了解更多详细信息的人，可以在<a class="ulink" href="http://www.opengroup.org/onlinepubs/007904975/utilities/xcu_chap02.html">http://www.opengroup.org/onlinepubs/007904975/utilities/xcu_chap02.html</a>找到 POSIX shell 命令语言的规范。</p></dd><dd><p>By default, <em class="command">make</em>
              executes command scripts <a class="indexterm"></a> <a class="indexterm"></a>with <em class="filename">/bin/sh</em>,
              but <em class="command">sh</em> implementations vary
              widely in their features. In particular, pre-POSIX shells are
              missing many features and will not accept the same syntax as a
              modern shell.</p><p>The Open Group has a very useful white paper on the
              differences between the System V shell and the POSIX shell. It
              can be found at <a class="ulink" href="http://www.unix-systems.org/whitepapers/shdiffs.html">http://www.unix-systems.org/whitepapers/shdiffs.html</a>.
              For those who want more details, the specification of the POSIX
              shell's command language can be found at <a class="ulink" href="http://www.opengroup.org/onlinepubs/007904975/utilities/xcu_chap02.html">http://www.opengroup.org/onlinepubs/007904975/utilities/xcu_chap02.html</a>.</p></dd><dt><span class="term">程序行为</span></dt><dt><span class="term">Program behavior</span></dt><dd><p>便携式<em class="filename">makefile</em>必须竞争<a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1421" class="indexterm"></a> <a id="OEBPS/ch07.html.make3-CHP-7-ITERM-1422" class="indexterm"></a>与行为不同的程序。当不同的供应商修复或插入错误并添加功能时，这种情况很常见。还有一些实用程序的升级，这些升级可能已包含在供应商的版本中，也可能未包含在其中。例如，1987 年<em class="command">awk</em>程序经历了一次重大修改。近 20 年后，一些系统仍然没有安装这个升级版本作为标准
              <em class="command">awk</em>。</p></dd><dd><p>Portable <em class="filename">makefile</em>s
              must contend<a class="indexterm"></a> <a class="indexterm"></a> with programs that simply behave differently.
              This is very common as different vendors fix or insert bugs and
              add features. There are also upgrades to utilities that may or
              may not have made it into a vendor's release. For instance, in
              1987 the <em class="command">awk</em> program
              underwent a major revision. Nearly 20 years later, some systems
              still do not install this upgraded version as the standard
              <em class="command">awk</em>.</p></dd><dt><span class="term">操作系统</span></dt><dt><span class="term">Operating system</span></dt><dd><p>最后，还存在与完全不同的操作系统相关的可移植性问题，例如 Windows 与 Unix 或 Linux 与 VMS。</p></dd><dd><p>Finally, there are the portability problems associated
              with a completely different operating system such as Windows
              versus Unix or Linux versus VMS.</p></dd></dl></div></div></div></div></div>
<div id="OEBPS/ch07s02.html"><div>
<div class="sect1" title="西格温"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07s02.html.make3-CHP-7-SECT-2"></a>西格温</h1><h1 class="title"><a></a>Cygwin</h1></div></div></div><p>虽然有一个<a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1423" class="indexterm"></a> <a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1424" class="indexterm"></a><em class="command">make</em>的本机 Win32 端口，这是 Windows 可移植性问题的一小部分，因为该本机端口使用的 shell 是
        <span class="emphasis"><em>cmd.exe</em></span>（或<span class="emphasis"><em>command.exe</em></span>）。再加上大多数 Unix 工具的缺乏，使得跨平台可移植性成为一项艰巨的任务。幸运的是，Cygwin 项目 ( <a class="ulink" href="http://www.cygwin.com/">http://www.cygwin.com</a> ) 已经为 Windows 构建了一个与 Linux 兼容的库，许多程序<sup>[ <a id="OEBPS/ch07s02.html.make3-CHP-7-FNOTE-1" href="#OEBPS/ch07s02.html.ftn.make3-CHP-7-FNOTE-1" class="footnote">1</a> ]</sup>已移植到其中。对于想要 Linux 兼容性或访问 GNU 工具的 Windows 开发人员来说，我不认为有更好的工具可以找到。</p><p>Although there is a <a class="indexterm"></a> <a class="indexterm"></a>native Win32 port of <em class="command">make</em>, this is a small part of the Windows
        portability problem, because the shell this native port uses is
        <span class="emphasis"><em>cmd.exe</em></span> (or <span class="emphasis"><em>command.exe</em></span>).
        This, along with the absence of most of the Unix tools, makes
        cross-platform portability a daunting task. Fortunately, the Cygwin
        project (<a class="ulink" href="http://www.cygwin.com">http://www.cygwin.com</a>) has built a
        Linux-compatible library for Windows to which many programs<sup>[<a href="#OEBPS/ch07s02.html.ftn.make3-CHP-7-FNOTE-1" class="footnote">1</a>]</sup> have been ported. For Windows developers who want Linux
        compatibility or access to GNU tools, I don't believe there is a
        better tool to be found.</p><p>我在各种项目中使用 Cygwin 已超过 10 年，从组合的 C++/Lisp CAD 应用程序到纯 Java 工作流管理系统。 Cygwin 工具集包括许多编程语言的编译器和解释器。然而，即使应用程序本身是使用非 Cygwin 编译器和解释器实现的，Cygwin 也可以有利可图。 Cygwin 工具集只能用作协调开发和构建过程的辅助工具。换句话说，无需编写“Cygwin”应用程序或使用 Cygwin 语言工具即可获得 Cygwin 环境的好处。</p><p>I have used Cygwin for over 10 years on a variety of projects
        from a combined C++/Lisp CAD application to a pure Java workflow
        management system. The Cygwin tool set includes compilers and
        interpreters for many programming languages. However, Cygwin can be
        used profitably even when the applications themselves are implemented
        using non-Cygwin compilers and interpreters. The Cygwin tool set can
        be used solely as an aid to coordinating the development and build
        process. In other words, it is not necessary to write a "Cygwin"
        application or use Cygwin language tools to reap the benefits of the
        Cygwin environment.</p><p>然而，Linux 不是 Windows（谢天谢地！），将 Cygwin 工具应用于本机 Windows 应用程序时会遇到一些问题。几乎所有这些问题都与文件中使用的行结尾以及 Cygwin 和 Windows 之间传递的路径形式有关。</p><p>Nevertheless, Linux is not Windows (thank goodness!) and there
        are issues involved when applying Cygwin tools to native Windows
        applications. Almost all of these issues revolve around the line
        endings used in files and the form of paths passed between Cygwin and
        Windows.</p><div class="sect2" title="线路终端"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch07s02.html.make3-CHP-7-SECT-2.1"></a>线路终端</h2><h2 class="title"><a></a>Line Termination</h2></div></div></div><p>Windows 文件系统使用<a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1425" class="indexterm"></a> <a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1426" class="indexterm"></a>两个字符序列回车符后跟换行符（或 CRLF）以终止文本文件的每一行。 POSIX 系统使用单个字符，换行符（LF 或
          <em class="firstterm">换行符</em>）。有时，当程序报告语法错误或寻找数据文件中的错误位置时，这种差异可能会导致粗心的一些混乱。然而，Cygwin 库在解决这些问题方面做得非常好。安装 Cygwin 时（或者使用<em class="command">mount</em>命令时），您可以选择 Cygwin 是否应该翻译以 CRLF 结尾的文件。如果选择 DOS 文件格式，Cygwin 将在读取文本文件时将 CRLF 转换为 LF，在写入文本文件时将其反向转换，以便基于 Unix 的程序可以正确处理 DOS 文本文件。如果您计划使用本机语言工具（例如 Visual C++ 或 Sun 的 Java SDK），请选择 DOS 文件格式。如果您要使用 Cygwin 编译器，请选择 Unix。 （您的选择可以随时更改。）</p><p>Windows filesystems use a <a class="indexterm"></a> <a class="indexterm"></a>two-character sequence carriage return followed by
          line feed (or CRLF) to terminate each line of a text file. POSIX
          systems use a single character, a line feed (LF or
          <em class="firstterm">newline</em>). Occasionally this difference can
          cause the unwary some confusion as programs report syntax errors or
          seek to the wrong location in a data file. However, the Cygwin
          library does a very good job of working through these issues. When
          Cygwin is installed (or alternatively when the <em class="command">mount</em> command is used), you can choose
          whether Cygwin should translate files with CRLF endings. If a DOS
          file format is selected, Cygwin will translate CRLF to LF when
          reading and the reverse when writing text files so that Unix-based
          programs can properly handle DOS text files. If you plan to use
          native language tools such as Visual C++ or Sun's Java SDK, choose
          the DOS file format. If you are going to use Cygwin compilers,
          choose Unix. (Your choice can be changed at any time.)</p><p>此外，Cygwin 还附带了显式翻译文件的工具。如有必要，实用程序<em class="command">dos2unix</em>和<em class="command">unix2dos</em>会转换文件的行结尾。</p><p>In addition, Cygwin comes with tools to translate files
          explicitly. The utilities <em class="command">dos2unix</em> and <em class="command">unix2dos</em> transform the line endings of a
          file, if necessary.</p></div><div class="sect2" title="文件系统"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch07s02.html.make3-CHP-7-SECT-2.2"></a>文件系统</h2><h2 class="title"><a></a>Filesystem</h2></div></div></div><p>Cygwin 提供 POSIX 视图<a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1427" class="indexterm"></a> <a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1428" class="indexterm"></a>Windows 文件系统的。 POSIX 文件系统的根目录是<em class="filename">/</em>，它映射到 Cygwin 的安装目录。 Windows 驱动器可通过伪目录<em class="filename">/cygdrive/</em>
          <em class="replaceable"><code>letter</code></em>访问。因此，如果 Cygwin 安装在
          <em class="filename">C:\usr\cygwin （我的首选位置）中，</em><a class="link" href="#OEBPS/ch07s02.html.make3-CHP-7-TABLE-1" title="表 7-1。默认 Cygwin 目录映射">则表 7-1</a>中所示的目录映射将保留。</p><p>Cygwin provides a POSIX view <a class="indexterm"></a> <a class="indexterm"></a>of the Windows filesystem. The root directory of a
          POSIX filesystem is <em class="filename">/</em>, which
          maps to the directory in which Cygwin is installed. Windows drives
          are accessible through the pseudo-directory <em class="filename">/cygdrive/</em>
          <em class="replaceable"><code>letter</code></em>. So, if Cygwin is installed in
          <em class="filename">C:\usr\cygwin</em> (my preferred
          location), the directory mappings shown in <a class="link" href="#OEBPS/ch07s02.html.make3-CHP-7-TABLE-1" title="Table&nbsp;7-1.&nbsp;Default Cygwin directory mapping">Table 7-1</a> would hold.</p><div class="table"><a id="OEBPS/ch07s02.html.make3-CHP-7-TABLE-1"></a><p class="title">表 7-1。默认 Cygwin 目录映射</p><p class="title">Table&nbsp;7-1.&nbsp;Default Cygwin directory mapping</p><div class="table-contents"><table summary="Default Cygwin directory mapping" style="border-collapse:collapse;border-top:0.5pt solid;border-bottom:0.5pt solid;border-left:0.5pt solid;border-right:0.5pt solid"><colgroup><col><col><col></colgroup><thead><tr><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>本机 Windows 路径</p><p>Native Windows path</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>CYGWIN路径</p><p>Cygwin path</p></th><th style="border-bottom:0.5pt solid"><p>备用 Cygwin 路径</p><p>Alternate Cygwin path</p></th></tr></thead><tbody><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>c:\usr\cygwin</em></span>
                  </p><p> <span class="emphasis"><em>c:\usr\cygwin</em></span>
                  </p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/</em></span> </p><p> <span class="emphasis"><em>/</em></span> </p></td><td style="border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/cygdrive/c/usr/cygwin</em></span>
                  </p><p> <span class="emphasis"><em>/cygdrive/c/usr/cygwin</em></span>
                  </p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>c:\程序文件</em></span>
                  </p><p> <span class="emphasis"><em>c:\Program Files</em></span>
                  </p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/cygdrive/c/程序文件</em></span>
                  </p><p> <span class="emphasis"><em>/cygdrive/c/Program Files</em></span>
                  </p></td><td style="border-bottom:0.5pt solid">&nbsp;</td></tr><tr><td style="border-right:0.5pt solid"><p> <span class="emphasis"><em>c:\usr\cygwin\bin</em></span>
                  </p><p> <span class="emphasis"><em>c:\usr\cygwin\bin</em></span>
                  </p></td><td style="border-right:0.5pt solid"><p> <span class="emphasis"><em>/垃圾桶</em></span> </p><p> <span class="emphasis"><em>/bin</em></span> </p></td><td style=""><p>
                  <span class="emphasis"><em>/cygdrive/c/usr/cygwin/bin</em></span>
                  </p><p>
                  <span class="emphasis"><em>/cygdrive/c/usr/cygwin/bin</em></span>
                  </p></td></tr></tbody></table></div></div><p>一开始这可能有点令人困惑，但不会给工具带来任何问题。 Cygwin还包含一个<em class="command">mount</em>命令，可以让用户更方便地访问文件和目录。<em class="command">mount</em>、
           、的一个选项<code class="option">—change-cygdrive-prefix</code>允许您更改前缀。我发现将前缀更改为简单的<em class="filename">/</em>特别有用，因为可以更自然地访问驱动器号：</p><p>This can be a little confusing at first, but doesn't pose any
          problems to tools. Cygwin also includes a <em class="command">mount</em> command that allows users to access
          files and directories more conveniently. One option to <em class="command">mount</em>,
          <code class="option">—change-cygdrive-prefix</code>, allows you to change the
          prefix. I find that changing the prefix to simply <em class="filename">/</em> is particularly useful because drive
          letters can be accessed more naturally:</p><a id="OEBPS/ch07s02.html.I_2_tt340"></a><pre class="programlisting">$ mount --change-cygdrive-prefix /
$ ls /c
AUTOEXEC.BAT 主程序文件 hp
BOOT.INI I386 回收器 ntldr
CD IO.SYS 系统卷信息 pagefile.sys
CONFIG.SYS MSDOS.SYS 临时 tmp
C_DILLA NTDETECT.COM WINDOWS 用户
文档和设置 PERSIST WUTemp 工作</pre><pre class="programlisting">$ mount --change-cygdrive-prefix /
$ ls /c
AUTOEXEC.BAT            Home          Program Files              hp
BOOT.INI                I386          RECYCLER                   ntldr
CD                      IO.SYS        System Volume Information  pagefile.sys
CONFIG.SYS              MSDOS.SYS     Temp                       tmp
C_DILLA                 NTDETECT.COM  WINDOWS                    usr
Documents and Settings  PERSIST       WUTemp                     work</pre><p>一旦进行此更改，我们之前的目录映射将更改为<a class="link" href="#OEBPS/ch07s02.html.make3-CHP-7-TABLE-2" title="表 7-2。修改Cygwin目录映射">表 7-2</a>中所示的内容。</p><p>Once this change is made, our previous directory mapping would
          change to those shown in <a class="link" href="#OEBPS/ch07s02.html.make3-CHP-7-TABLE-2" title="Table&nbsp;7-2.&nbsp;Modified Cygwin directory mapping">Table
          7-2</a>.</p><div class="table"><a id="OEBPS/ch07s02.html.make3-CHP-7-TABLE-2"></a><p class="title">表 7-2。修改Cygwin目录映射</p><p class="title">Table&nbsp;7-2.&nbsp;Modified Cygwin directory mapping</p><div class="table-contents"><table summary="Modified Cygwin directory mapping" style="border-collapse:collapse;border-top:0.5pt solid;border-bottom:0.5pt solid;border-left:0.5pt solid;border-right:0.5pt solid"><colgroup><col><col><col></colgroup><thead><tr><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>本机 Windows 路径</p><p>Native Windows path</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>CYGWIN路径</p><p>Cygwin path</p></th><th style="border-bottom:0.5pt solid"><p>备用 Cygwin 路径</p><p>Alternate Cygwin path</p></th></tr></thead><tbody><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>c:\usr\cygwin</em></span>
                  </p><p> <span class="emphasis"><em>c:\usr\cygwin</em></span>
                  </p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/</em></span> </p><p> <span class="emphasis"><em>/</em></span> </p></td><td style="border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/c/usr/cygwin</em></span>
                  </p><p> <span class="emphasis"><em>/c/usr/cygwin</em></span>
                  </p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>c:\程序文件</em></span>
                  </p><p> <span class="emphasis"><em>c:\Program Files</em></span>
                  </p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <span class="emphasis"><em>/c/程序文件</em></span>
                  </p><p> <span class="emphasis"><em>/c/Program Files</em></span>
                  </p></td><td style="border-bottom:0.5pt solid">&nbsp;</td></tr><tr><td style="border-right:0.5pt solid"><p> <span class="emphasis"><em>c:\usr\cygwin\bin</em></span>
                  </p><p> <span class="emphasis"><em>c:\usr\cygwin\bin</em></span>
                  </p></td><td style="border-right:0.5pt solid"><p> <span class="emphasis"><em>/垃圾桶</em></span> </p><p> <span class="emphasis"><em>/bin</em></span> </p></td><td style=""><p> <span class="emphasis"><em>/c/usr/cygwin/bin</em></span>
                  </p><p> <span class="emphasis"><em>/c/usr/cygwin/bin</em></span>
                  </p></td></tr></tbody></table></div></div><p>如果需要将文件名传递给 Windows 程序（例如 Visual C++ 编译器），通常只需使用 POSIX 样式的正斜杠传递文件的相对路径即可。 Win32 API 不区分正斜杠和反斜杠。不幸的是，一些执行自己的命令行参数解析的实用程序将所有正斜杠视为命令选项。 DOS<em class="command">打印</em>命令就是这样的实用程序之一。另一个是<em class="command">net</em>命令。</p><p>If you need to pass a filename to a Windows program, such as
          the Visual C++ compiler, you can usually just pass the relative path
          to the file using POSIX-style forward slashes. The Win32 API does
          not distinguish between forward and backward slashes. Unfortunately,
          some utilities that perform their own command-line argument parsing
          treat all forward slashes as command options. One such utility is
          the DOS <em class="command">print</em> command; another is
          the <em class="command">net</em> command.</p><p>如果使用绝对路径，驱动器盘符语法始终是一个问题。尽管 Windows 程序通常喜欢使用正斜杠，但它们完全无法理解<em class="filename">/c</em>语法。驱动器号必须始终转换回<em class="filename">c:</em>。为了完成此操作以及正斜杠/反斜杠转换，Cygwin 提供了<em class="command">cygpath</em>实用程序来在 POSIX 路径和 Windows 路径之间进行转换。</p><p>If absolute paths are used, the drive letter syntax is always
          a problem. Although Windows programs are usually happy with forward
          slashes, they are completely unable to fathom the <em class="filename">/c</em> syntax. The drive letter must always
          be tranformed back into <em class="filename">c:</em>. To
          accomplish this and the forward/backslash conversion, Cygwin
          provides the <em class="command">cygpath</em> utility to
          translate between POSIX paths and Windows paths.</p><a id="OEBPS/ch07s02.html.I_2_tt341"></a><pre class="programlisting">$<strong class="userinput"><code>cygpath --windows /c/work/src/lib/foo.c</code></strong>
c:\work\src\lib\foo.c
$<strong class="userinput"><code>cygpath --mixed /c/work/src/lib/foo.c</code></strong>
c:/work/src/lib/foo.c
$ <strong class="userinput"><code>cygpath --mixed --path "/c/work/src:/c/work/include"</code></strong>
c:/work/src;c:/work/include</pre><pre class="programlisting">$<strong class="userinput"><code>cygpath --windows /c/work/src/lib/foo.c</code></strong>
c:\work\src\lib\foo.c
$ <strong class="userinput"><code>cygpath --mixed /c/work/src/lib/foo.c</code></strong>
c:/work/src/lib/foo.c
$ <strong class="userinput"><code>cygpath --mixed --path "/c/work/src:/c/work/include"</code></strong>
c:/work/src;c:/work/include</pre><p>该<code class="option">—windows</code>选项将命令行上给出的 POSIX 路径转换为 ​​Windows 路径（或者使用适当的参数反之亦然）。我更喜欢使用<code class="option">—mixed</code>
          生成 Windows 路径的选项，但使用正斜杠而不是反斜杠（当 Windows 实用程序接受它时）。这在 Cygwin shell 中效果更好，因为反斜杠是转义字符。<em class="command">cygpath</em>实用
          程序有许多选项，其中一些选项提供对重要 Windows 路径的可移植访问：</p><p>The <code class="option">—windows</code> option translates the POSIX path
          given on the command line into a Windows path (or vice versa with
          the proper argument). I prefer to use the <code class="option">—mixed</code>
          option that produces a Windows path, but with forward slashes
          instead of backslashes (when the Windows utility accepts it). This
          plays much better with the Cygwin shell because the backslash is the
          escape character. The <em class="command">cygpath</em>
          utility has many options, some of which provide portable access to
          important Windows paths:</p><a id="OEBPS/ch07s02.html.I_2_tt342"></a><pre class="programlisting">$<strong class="userinput"><code>cygpath --desktop</code></strong>
/c/文档和设置/所有者/桌面
$<strong class="userinput"><code>cygpath --homeroot</code></strong>
/c/文档和设置
$<strong class="userinput"><code>cygpath --smprograms</code></strong>
/c/文档和设置/所有者/开始菜单/程序
$<strong class="userinput"><code>cygpath --sysdir</code></strong>
/c/WINDOWS/SYSTEM32
$ <strong class="userinput"><code>cygpath --windir</code></strong>
/c/WINDOWS</pre><pre class="programlisting">$<strong class="userinput"><code>cygpath --desktop</code></strong>
/c/Documents and Settings/Owner/Desktop
$ <strong class="userinput"><code>cygpath --homeroot</code></strong>
/c/Documents and Settings
$ <strong class="userinput"><code>cygpath --smprograms</code></strong>
/c/Documents and Settings/Owner/Start Menu/Programs
$ <strong class="userinput"><code>cygpath --sysdir</code></strong>
/c/WINDOWS/SYSTEM32
$ <strong class="userinput"><code>cygpath --windir</code></strong>
/c/WINDOWS</pre><p>如果您在混合 Windows/Unix 环境中使用<em class="command">cygpath</em>，则需要将这些调用包装在可移植函数中：</p><p>If you're using <em class="command">cygpath</em> in
          a mixed Windows/Unix environment, you'll want to wrap these calls in
          a portable function:</p><a id="OEBPS/ch07s02.html.I_2_tt343"></a><pre class="programlisting">ifdef 计算机规范
  cygpath-混合 = $(shell cygpath -m "$1")
  cygpath-unix = $(shell cygpath -u "$1")
  驱动器字母到斜杠 = /$(subst :,,$1)
别的
  cygpath 混合 = $1
  cygpath-unix = $1
  驱动器号到斜杠 = $1
万一</pre><pre class="programlisting">ifdef COMSPEC
  cygpath-mixed         = $(shell cygpath -m "$1")
  cygpath-unix          = $(shell cygpath -u "$1")
  drive-letter-to-slash = /$(subst :,,$1)
else
  cygpath-mixed         = $1
  cygpath-unix          = $1
  drive-letter-to-slash = $1
endif</pre><p>如果您需要做的只是将<em class="filename">c:</em>驱动器盘符语法映射到 POSIX 形式，则该<code class="function">drive-letter-to-slash</code>
          函数比运行<em class="command">cygpath</em>程序更快。</p><p>If all you need to do is map the <em class="filename">c:</em> drive letter syntax to the POSIX form,
          the <code class="function">drive-letter-to-slash</code>
          function is faster than running the <em class="command">cygpath</em> program.</p><p>最后，Cygwin 无法隐藏 Windows 的所有怪癖。在 Windows 中无效的文件名在 Cygwin 中也无效。因此，诸如<em class="filename">aux.h</em>、
           <em class="filename">com1</em>和<em class="filename">prn</em>之类的名称不能在 POSIX 路径中使用，即使带有扩展名也是如此。</p><p>Finally, Cygwin cannot hide all the quirks of Windows.
          Filenames that are invalid in Windows are also invalid in Cygwin.
          Thus, names such as <em class="filename">aux.h</em>,
          <em class="filename">com1</em>, and <em class="filename">prn</em> cannot be used in a POSIX path, even
          with an extension.</p></div><div class="sect2" title="程序冲突"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch07s02.html.make3-CHP-7-SECT-2.3"></a>程序冲突</h2><h2 class="title"><a></a>Program Conflicts</h2></div></div></div><p>一些 Windows 程序有<a id="OEBPS/ch07s02.html.make3-CHP-7-ITERM-1429" class="indexterm"></a>与 Unix 程序同名。当然，Windows 程序不接受与 Unix 程序相同的命令行参数或以兼容的方式运行。如果您不小心调用了 Windows 版本，通常会导致严重混乱。最麻烦的似乎是<em class="command">find</em>、<em class="command">sort</em>、<em class="command">ftp</em>和<em class="command">telnet</em>。为了获得最大的可移植性，在 Unix、Windows 和 Cygwin 之间移植时，您应该确保提供这些程序的完整路径。</p><p>Several Windows programs have <a class="indexterm"></a>the same names as Unix programs. Of course, the
          Windows programs do not accept the same command-line arguments or
          behave in compatible ways with the Unix programs. If you
          accidentally invoke the Windows versions, the usual result is
          serious confusion. The most troublesome ones seem to be <em class="command">find</em>, <em class="command">sort</em>, <em class="command">ftp</em>, and <em class="command">telnet</em>. For maximum portability, you
          should be sure to provide full paths to these programs when porting
          between Unix, Windows, and Cygwin.</p><p>如果您对 Cygwin 的承诺坚定，并且不需要使用本机 Windows 支持工具进行构建，则可以安全地将 Cygwin <em class="filename">/bin</em>目录放置在 Windows 路径的前面。这将保证通过 Windows 版本访问 Cygwin 工具。</p><p>If your commitment to Cygwin is strong and you do not need to
          build using native Windows support tools, you can safely place the
          Cygwin <em class="filename">/bin</em> directory at the
          front of your Windows path. This will guarantee access to Cygwin
          tools over Windows versions.</p><p>如果您的<em class="filename">makefile</em>使用 Java 工具，请注意 Cygwin 包含
          
          与标准 Sun <em class="filename">jar文件格式不兼容的</em><acronym class="acronym">GNU </acronym> <em class="command">jar</em>程序。因此，Java jdk
           <em class="filename">bin</em>目录应该放在
          你的变量中Cygwin <em class="filename">/bin</em>目录之前，以避免使用Cygwin的<em class="command">jar</em>
          程序。<em class="filename"></em><em class="filename"></em><em class="filename"></em><code class="literal">Path</code><em class="command"></em></p><p>If your <em class="filename">makefile</em> is
          working with Java tools, be aware that Cygwin includes the
          <acronym class="acronym">GNU</acronym> <em class="command">jar</em>
          program that is incompatible with the standard Sun <em class="filename">jar</em> file format. Therefore, the Java jdk
          <em class="filename">bin</em> directory should be placed
          before the Cygwin <em class="filename">/bin</em>
          directory in your <code class="literal">Path</code> variable
          to avoid using Cygwin's <em class="command">jar</em>
          program.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch07s02.html.ftn.make3-CHP-7-FNOTE-1" href="#OEBPS/ch07s02.html.make3-CHP-7-FNOTE-1" class="para">1</a> ]</sup>我的 Cygwin <em class="filename">/bin</em>
            目录当前包含 1343 个可执行文件。</p><p><sup>[<a href="#OEBPS/ch07s02.html.make3-CHP-7-FNOTE-1" class="para">1</a>] </sup>My Cygwin <em class="filename">/bin</em>
            directory currently contains 1343 executables.</p></div></div></div></div></div>
<div id="OEBPS/ch07s03.html"><div>
<div class="sect1" title="管理程序和文件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07s03.html.make3-CHP-7-SECT-3"></a>管理程序和文件</h1><h1 class="title"><a></a>Managing Programs and Files</h1></div></div></div><p>最常见的管理方式<a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1430" class="indexterm"></a> <a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1431" class="indexterm"></a>程序的目的是对可能更改的程序名称或路径使用变量。正如我们所见，变量可以在一个简单的块中定义：</p><p>The most common way to manage <a class="indexterm"></a> <a class="indexterm"></a>programs is to use a variable for program names or paths
        that are likely to change. The variables can be defined in a simple
        block, as we have seen:</p><a id="OEBPS/ch07s03.html.I_2_tt344"></a><pre class="programlisting">MV ?= mv -f
RM ?= rm -f</pre><pre class="programlisting">MV ?= mv -f
RM ?= rm -f</pre><p>或者在条件块中：</p><p>or in a conditional block:</p><a id="OEBPS/ch07s03.html.I_2_tt345"></a><pre class="programlisting">ifdef 计算机规范
  MV ?= 移动
  RM ?= 删除
别的
  MV ?= mv -f
  RM ?= rm -f
万一</pre><pre class="programlisting">ifdef COMSPEC
  MV ?= move
  RM ?= del
else
  MV ?= mv -f
  RM ?= rm -f
endif</pre><p>如果使用简单的块，则可以通过在命令行上重置它们、编辑 makefile<em class="filename">或</em>（在本例中，因为我们使用条件赋值<code class="literal">?=</code>）通过设置环境变量来更改这些值。如前所述，测试 Windows 平台的一种方法是检查<code class="literal">COMSPEC</code>所有 Windows 操作系统都使用的变量。有时只需要更改路径：</p><p>If a simple block is used, the values can be changed by
        resetting them on the command line, by editing the <em class="filename">makefile</em>, or (in this case because we used
        conditional assignment, <code class="literal">?=</code>) by
        setting an environment variable. As mentioned previously, one way to
        test for a Windows platform is to check for the <code class="literal">COMSPEC</code> variable, which is used by all
        Windows operating systems. Sometimes only a path needs to
        change:</p><a id="OEBPS/ch07s03.html.I_2_tt346"></a><pre class="programlisting">ifdef 计算机规范
  输出根:= d:
  GCC_HOME := c:/gnu/usr/bin
别的
  输出根 := $(HOME)
  GCC_HOME := /usr/bin
万一

OUTPUT_DIR := $(OUTPUT_ROOT)/工作/二进制文件
CC := $(GCC_HOME)/gcc</pre><pre class="programlisting">ifdef COMSPEC
  OUTPUT_ROOT := d:
  GCC_HOME    := c:/gnu/usr/bin
else
  OUTPUT_ROOT := $(HOME)
  GCC_HOME    := /usr/bin
endif

OUTPUT_DIR := $(OUTPUT_ROOT)/work/binaries
CC := $(GCC_HOME)/gcc</pre><p>这种风格产生的<em class="filename">makefile</em>中大多数程序都是通过<em class="command">make</em>变量调用的。在您习惯之前，这可能会使<em class="filename">makefile</em>有点难以阅读。然而，无论如何，在<em class="filename">makefile</em>中使用变量通常更方便，因为它们可以比文字程序名称短得多，特别是在使用完整路径时。</p><p>This style results in a <em class="filename">makefile</em> in which most programs are invoked
        via <em class="command">make</em> variables. Until you get
        used to it, this can make the <em class="filename">makefile</em> a little harder to read. However,
        variables are often more convenient to use in the <em class="filename">makefile</em> anyway, because they can be
        considerably shorter than the literal program name, particularly when
        full paths are used.</p><p>可以使用相同的技术来管理不同的命令选项。例如，内置编译规则包含一个变量 ，<code class="literal">TARGET_ARCH</code>可用于设置特定于平台的标志：</p><p>The same technique can be used to manage different command
        options. For instance, the built-in compilation rules include a
        variable, <code class="literal">TARGET_ARCH</code>, that can be
        used to set platform-specific flags:</p><a id="OEBPS/ch07s03.html.I_2_tt347"></a><pre class="programlisting">ifeq "$(机器)" "hpux-hppa"
  TARGET_ARCH := -mdisable-fpregs
万一</pre><pre class="programlisting">ifeq "$(MACHINE)" "hpux-hppa"
  TARGET_ARCH := -mdisable-fpregs
endif</pre><p>当定义自己的程序变量时，您可能需要使用类似的方法：</p><p>When defining your own program variables, you may need to use a
        similar approach:</p><a id="OEBPS/ch07s03.html.I_2_tt348"></a><pre class="programlisting">MV := mv $(MV_FLAGS)

ifeq "$(MACHINE)" "solaris-sparc"
  MV_FLAGS := -f
万一</pre><pre class="programlisting">MV := mv $(MV_FLAGS)

ifeq "$(MACHINE)" "solaris-sparc"
  MV_FLAGS := -f
endif</pre><p>如果您要移植到许多平台，链接这些<code class="literal">ifdef</code>部分可能会变得丑陋且难以维护。不要使用 ，而是<code class="literal">ifdef</code>将每组特定于平台的变量放在其自己的文件中，该文件的名称包含平台指示符。例如，如果您通过<em class="command">uname</em>参数指定平台，则可以选择适当的<em class="command">make</em> include 文件，如下所示：</p><p>If you are porting to many platforms, chaining the <code class="literal">ifdef</code> sections can become ugly and difficult
        to maintain. Instead of using <code class="literal">ifdef</code>, place each set of platform-specific
        variables in its own file whose name contains a platform indicator.
        For instance, if you designate a platform by its <em class="command">uname</em> parameters, you can select the
        appropriate <em class="command">make</em> include file like
        this:</p><a id="OEBPS/ch07s03.html.I_2_tt349"></a><pre class="programlisting">机器 := $(shell uname -smo | sed 's/ /-/g')
包括 $(MACHINE)-defines.mk</pre><pre class="programlisting">MACHINE := $(shell uname -smo | sed 's/ /-/g')
include $(MACHINE)-defines.mk</pre><p><em class="command">带有空格的文件名给make</em>带来了一个特别恼人的问题。在解析过程中空格分隔标记的假设是<em class="command">的</em>基础。许多内置函数（例如
        <code class="function">word</code>、<code class="function">filter</code>、<code class="function">wildcard</code>和其他函数）假定它们的参数是空格分隔的单词。尽管如此，这里有一些技巧可能会在一些小方面有所帮助。第一个技巧，在<a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++">第 8 章</a>的<a class="link" href="#OEBPS/ch07s04.html.make3-CHP-7-SECT-4.1" title="标准外壳">7.4.1 节</a>中提到，是如何使用另一个字符替换空格：<a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++"></a><code class="function">subst</code></p><p>Filenames with spaces present a particularly irritating problem
        for <em class="command">make</em>. The assumption that
        whitespace separates tokens during parsing is fundamental to <em class="command">make</em>. Many built-in functions such as
        <code class="function">word</code>, <code class="function">filter</code>, <code class="function">wildcard</code>, and others assume their arguments
        are space-separated words. Nevertheless, here are some tricks that may
        help in small ways. The first trick, noted in <a class="link" href="#OEBPS/ch07s04.html.make3-CHP-7-SECT-4.1" title="A Standard Shell">Section 7.4.1</a> in <a class="link" href="#OEBPS/ch08.html" title="Chapter&nbsp;8.&nbsp;C and C++">Chapter 8</a>, is how to replace spaces with
        another character using <code class="function">subst</code>:</p><a id="OEBPS/ch07s03.html.I_2_tt350"></a><pre class="programlisting">空间 = $(空) $(空)

# $(调用问题空间,文件名)
空格到问题 = $(subst $(空格),?,$1)</pre><pre class="programlisting">space = $(empty) $(empty)

# $(call space-to-question,file-name)
space-to-question = $(subst $(space),?,$1)</pre><p>该<code class="function">space-to-question</code>
        函数用通配符问号替换所有空格。现在，我们可以实现可以处理空格的函数<code class="function">wildcard</code>
        ：<code class="function">file-exists</code></p><p>The <code class="function">space-to-question</code>
        function replaces all spaces with the globbing wildcard question mark.
        Now, we can implement <code class="function">wildcard</code>
        and <code class="function">file-exists</code> functions that
        can handle spaces:</p><a id="OEBPS/ch07s03.html.I_2_tt351"></a><pre class="programlisting"># $(调用通配符空格,文件名)
通配符空格 = $(通配符 $(调用空格到问题,$1))

# $(调用文件存在
文件存在= $(条带\
                 $(如果$1,,$(警告$1没有值)) \
                 $(调用通配符空格,$1))</pre><pre class="programlisting"># $(call wildcard-spaces,file-name)
wildcard-spaces = $(wildcard $(call space-to-question,$1))

# $(call file-exists
file-exists = $(strip                                       \
                 $(if $1,,$(warning $1 has no value))       \
                 $(call wildcard-spaces,$1))</pre><p>功能<code class="function">wildcard-spaces</code>
        ​<a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1432" class="indexterm"></a> <a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1433" class="indexterm"></a>用于<code class="function">space-to-question</code>允许<em class="filename">makefile</em>对包含空格的模式执行通配符操作。我们可以使用我们的<code class="function">wildcard-spaces</code>函数来实现
        <code class="function">file-exists</code>。当然，使用问号也可能导致<code class="function">wildcard-spaces</code>返回与原始通配符模式不正确匹配的文件（例如“my document.doc”和“my-document.doc”），但这是我们能做到的最好的做。</p><p>The <code class="function">wildcard-spaces</code>
        function <a class="indexterm"></a> <a class="indexterm"></a>uses <code class="function">space-to-question</code> to allow the <em class="filename">makefile</em> to perform a wildcard operation on
        a pattern including spaces. We can use our <code class="function">wildcard-spaces</code> function to implement
        <code class="function">file-exists</code>. Of course, the use
        of the question mark may also cause <code class="function">wildcard-spaces</code> to return files that do not
        correctly match the original wildcard pattern (e.g., "my document.doc"
        and "my-document.doc"), but this is the best we can do.</p><p>功能<code class="function">space-to-question</code>
        ​<a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1434" class="indexterm"></a> <a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1435" class="indexterm"></a>还可以用于转换目标和先决条件中带有空格的文件名，因为它们允许使用通配模式。</p><p>The <code class="function">space-to-question</code>
        function <a class="indexterm"></a> <a class="indexterm"></a>can also be used to transform filenames with spaces in
        targets and prerequisites, since those allow globbing patterns to be
        used.</p><a id="OEBPS/ch07s03.html.I_2_tt352"></a><pre class="programlisting">空间 := $(空) $(空)

# $(调用问题空间,文件名)
空格到问题 = $(subst $(空格),?,$1)

# $(调用问题到空间,文件名)
问题到空格 = $(subst ?,$(space),$1)

$(调用空格到问题,foo bar): $(调用空格到问题,bar baz)
        触摸“$(呼叫问题到空间,$@)”</pre><pre class="programlisting">space := $(empty) $(empty)

# $(call space-to-question,file-name)
space-to-question = $(subst $(space),?,$1)

# $(call question-to-space,file-name)
question-to-space = $(subst ?,$(space),$1)

$(call space-to-question,foo bar): $(call space-to-question,bar baz)
        touch "$(call question-to-space,$@)"</pre><p>假设文件“ <em class="filename">bar baz</em> ”存在，第一次执行该<em class="filename">makefile</em>时就会找到先决条件，因为会评估通配模式。但是目标通配模式会失败，因为目标尚不存在，因此
        <code class="literal">$@</code>值 也不存在<code class="literal">foo?bar</code>。然后，命令脚本用于
        <code class="function">question-to-space</code>将其转换
        <code class="literal">$@</code>回带有我们真正想要的空格的文件。下次运行<em class="filename">makefile</em>时，会找到目标，因为通配模式找到带有空格的目标。有点难看，但我发现这些技巧在真正的<em class="filename">makefile</em>中很有用。</p><p>Assuming the file "<em class="filename">bar baz</em>"
        exists, the first time this <em class="filename">makefile</em> is executed the prerequisite is
        found because the globbing pattern is evaluated. But the target
        globbing pattern fails because the target does not yet exist, so
        <code class="literal">$@</code> has the value <code class="literal">foo?bar</code>. The command script then uses
        <code class="function">question-to-space</code> to transform
        <code class="literal">$@</code> back to the file with spaces
        that we really want. The next time the <em class="filename">makefile</em> is run, the target is found
        because the globbing pattern finds the target with spaces. A bit ugly,
        but I have found these tricks useful in real <em class="filename">makefile</em>s.</p><div class="sect2" title="源树布局"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch07s03.html.make3-CHP-7-SECT-3.1"></a>源树布局</h2><h2 class="title"><a></a>Source Tree Layout</h2></div></div></div><p>可移植性的另一个方面是<a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1436" class="indexterm"></a> <a id="OEBPS/ch07s03.html.make3-CHP-7-ITERM-1437" class="indexterm"></a>允许开发人员在他们认为必要时自由管理其开发环境的能力。例如，如果构建系统要求开发人员始终将其源代码、二进制文件、库和支持工具放在同一目录下或同一 Windows 磁盘驱动器上，就会出现问题。最终，一些磁盘空间不足的开发人员将面临必须对这些不同文件进行分区的问题。</p><p>Another aspect of portability is the <a class="indexterm"></a> <a class="indexterm"></a>ability to allow developers freedom to manage their
          development environment as they deem necessary. There will be
          problems if the build system requires the developers to always place
          their source, binaries, libraries, and support tools under the same
          directory or on the same Windows disk drive, for instance.
          Eventually, some developer low on disk space will be faced with the
          problem of having to partition these various files.</p><p>相反，使用变量来引用这些文件集合并设置合理的默认值来实现<em class="filename">makefile</em>是有意义的。此外，每个支持库和工具都可以通过变量引用，以允许开发人员根据需要自定义文件位置。对于最可能的自定义变量，请使用条件赋值运算符，以便开发人员可以通过简单的方法使用环境变量覆盖<em class="filename">makefile 。</em></p><p>Instead, it makes sense to implement the <em class="filename">makefile</em> using variables to reference
          these collections of files and set reasonable defaults. In addition,
          each support library and tool can be referenced through a variable
          to allow developers to customize file locations as they find
          necessary. For the most likely customization variables, use the
          conditional assignment operator to allow developers a simple way of
          overriding the <em class="filename">makefile</em> with
          environment variables.</p><p>此外，轻松支持源代码和二叉树的多个副本的能力对开发人员来说是一个福音。即使他们不必支持不同的平台或编译选项，开发人员也经常发现自己正在使用源代码的多个副本，要么是出于调试目的，要么是因为他们并行处理多个项目。已经讨论了支持这一点的两种方法：使用“顶级”环境变量来标识源代码和二叉树的根，或者使用 makefile 的目录
          <em class="filename">和</em>固定的相对路径来查找二叉树。其中任何一个都允许开发人员灵活地支持多棵树。</p><p>In addition, the ability to easily support multiple copies of
          the source and binary tree is a boon to developers. Even if they
          don't have to support different platforms or compilation options,
          developers often find themselves working with several copies of the
          source, either for debugging purposes or because they work on
          several projects in parallel. Two ways to support this have already
          been discussed: use a "top-level" environment variable to identify
          the root of the source and binary trees, or use the directory of the
          <em class="filename">makefile</em> and a fixed relative
          path to find the binary tree. Either of these allows developers the
          flexibility of supporting more than one tree.</p></div></div></div></div>
<div id="OEBPS/ch07s04.html"><div>
<div class="sect1" title="使用非便携式工具"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07s04.html.make3-CHP-7-SECT-4"></a>使用非便携式工具</h1><h1 class="title"><a></a>Working with Nonportable Tools</h1></div></div></div><p>如前所述，<a id="OEBPS/ch07s04.html.make3-CHP-7-ITERM-1438" class="indexterm"></a><em class="filename">将makefile</em>写入最小公分母的一种替代方法是采用一些标准工具。当然，目标是确保标准工具至少与您正在构建的应用程序一样可移植。便携式工具的明显选择是来自
        <acronym class="acronym">GNU</acronym>项目的程序，但便携式工具的来源多种多样。 Perl 和 Python 是我想到的另外两个工具。</p><p>As noted previously, <a class="indexterm"></a>one alternative to writing <em class="filename">makefile</em>s to the least common denominator
        is to adopt some standard tools. Of course, the goal is to make sure
        the standard tools are at least as portable as the application you are
        building. The obvious choice for portable tools are programs from the
        <acronym class="acronym">GNU</acronym> project, but portable tools come from a wide
        variety of sources. Perl and Python are two other tools that come to
        mind.</p><p>在缺乏可移植工具的情况下，将不可移植工具封装在<em class="command">make</em>函数中有时也能起到同样的作用。例如，为了支持 Enterprise JavaBeans 的多种编译器（每种编译器的调用语法略有不同），我们可以编写一个基本函数来编译 EJB jar 并将其参数化以允许插入不同的编译器。</p><p>In the absence of portable tools, encapsulating nonportable
        tools in <em class="command">make</em> functions can
        sometimes do just as well. For instance, to support a variety of
        compilers for Enterprise JavaBeans (each of which has a slightly
        different invocation syntax), we can write a basic function to compile
        an EJB jar and parameterize it to allow one to plug in different
        compilers.</p><a id="OEBPS/ch07s04.html.I_2_tt353"></a><pre class="programlisting">EJB_TMP_JAR = $(TMPDIR)/temp.jar

# $(调用compile-generic-bean, bean-type, jar-name,
# bean-files-wildcard, 清单名称-opt )
定义编译通用 bean
  $(RM) $(目录 $(META_INF))
  $(MKDIR) $(META_INF)
  $(if $(过滤器 %.xml %.xmi, $3), \
    cp $(过滤器 %.xml %.xmi, $3) $(META_INF))
  $(调用编译-$1-bean-hook,$2)
  cd $(OUTPUT_DIR) &amp;&amp; \
  $(JAR) -cf0 $(EJB_TMP_JAR) \
         $(调用 jar-file-arg,$(META_INF)) \
         $(调用bean类，$3)
  $(调用$1-编译命令，$2)
  $(调用create-manifest,$(if $4,$4,$2),,)
恩德夫</pre><pre class="programlisting">EJB_TMP_JAR = $(TMPDIR)/temp.jar

# $(call compile-generic-bean, bean-type, jar-name,
#                              bean-files-wildcard, manifest-name-opt )
define compile-generic-bean
  $(RM) $(dir $(META_INF))
  $(MKDIR) $(META_INF)
  $(if $(filter %.xml %.xmi, $3),            \
    cp $(filter %.xml %.xmi, $3) $(META_INF))
  $(call compile-$1-bean-hook,$2)
  cd $(OUTPUT_DIR) &amp;&amp;                        \
  $(JAR) -cf0 $(EJB_TMP_JAR)                 \
         $(call jar-file-arg,$(META_INF))    \
         $(call bean-classes,$3)
  $(call $1-compile-command,$2)
  $(call create-manifest,$(if $4,$4,$2),,)
endef</pre><p>这个通用 EJB 编译函数的第一个参数是我们正在使用的 bean 编译器的类型，例如 Weblogic、Websphere 等。其余参数是 jar 名称、构成 jar 内容的文件（包括配置文件）和可选的清单文件。模板函数首先通过删除任何旧的临时目录并重新创建它来创建一个干净的临时区域。接下来，该函数将先决条件中存在的<em class="filename">xml</em>或
        <em class="filename">xmi</em><code class="literal">$(META_INF)</code>文件复制到该
        目录中。此时，我们可能需要执行自定义操作来清理<em class="filename">META-INF</em>文件或准备<em class="filename">.class</em>文件。为了支持这些操作，我们包含一个钩子函数，<code class="function">compile-$1-bean-hook</code>用户可以根据需要定义该函数。例如，如果 Websphere 编译器需要额外的控制文件（例如<em class="filename">xsl</em>
        文件），我们将编写以下钩子：</p><p>The first argument to this general EJB compilation function is
        the type of bean compiler we are using, such as Weblogic, Websphere,
        etc. The remaining arguments are the jar name, the files forming the
        content of the jar (including configuration files), and an optional
        manifest file. The template function first creates a clean temporary
        area by deleting any old temporary directory and recreating it. Next,
        the function copies in the <em class="filename">xml</em> or
        <em class="filename">xmi</em> files present in the
        prerequisites into the <code class="literal">$(META_INF)</code>
        directory. At this point, we may need to perform custom operations to
        clean up the <em class="filename">META-INF</em> files or
        prepare the <em class="filename">.class</em> files. To
        support these operations, we include a hook function, <code class="function">compile-$1-bean-hook</code>, that the user can
        define, if necessary. For instance, if the Websphere compiler required
        an extra control file, say an <em class="filename">xsl</em>
        file, we would write this hook:</p><a id="OEBPS/ch07s04.html.I_2_tt354"></a><pre class="programlisting"># $(调用compile-websphere-bean-hook, 文件列表)
定义编译 websphere-bean-hook
  cp $(过滤器%.xsl, $1) $(META_INF)
恩德夫</pre><pre class="programlisting"># $(call compile-websphere-bean-hook, file-list)
define compile-websphere-bean-hook
  cp $(filter %.xsl, $1) $(META_INF)
endef</pre><p>通过简单地定义这个函数，我们确保<code class="function">call</code>in<code class="function">compile-generic-bean</code>将被适当地扩展。如果我们不选择编写钩子函数，则调用<code class="function">compile-generic-bean</code>将扩展为空。</p><p>By simply defining this function, we make sure the <code class="function">call</code> in <code class="function">compile-generic-bean</code> will be expanded
        appropriately. If we do not choose to write a hook function, the call
        in <code class="function">compile-generic-bean</code> expands
        to nothing.</p><p>接下来，我们的通用函数创建 jar。辅助函数
        <code class="function">jar-file-arg</code>将普通文件路径分解为<code class="option">-C</code>选项和相对路径：</p><p>Next, our generic function creates the jar. The helper function
        <code class="function">jar-file-arg</code> decomposes a normal
        file path into a <code class="option">-C</code> option and a relative
        path:</p><a id="OEBPS/ch07s04.html.I_2_tt355"></a><pre class="programlisting"># $(调用 jar-file-arg, 文件名)
定义 jar 文件参数
  -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)
恩德夫</pre><pre class="programlisting"># $(call jar-file-arg, file-name)
define jar-file-arg
  -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)
endef</pre><p>辅助函数<code class="function">bean-classes</code>从源文件列表中提取适当的类文件（jar 文件只需要接口和主类）：</p><p>The helper function <code class="function">bean-classes</code> extracts the appropriate class
        files from a source file list (the jar file only needs the interface
        and home classes):</p><a id="OEBPS/ch07s04.html.I_2_tt356"></a><pre class="programlisting"># $(调用 bean-classes, bean-files-list)
定义bean类
  $(subst $(SOURCE_DIR)/,, \
    $(过滤器 %Interface.class %Home.class, \
      $(subst .java,.class,$1)))
恩德夫</pre><pre class="programlisting"># $(call bean-classes, bean-files-list)
define bean-classes
  $(subst $(SOURCE_DIR)/,,                 \
    $(filter %Interface.class %Home.class, \
      $(subst .java,.class,$1)))
endef</pre><p>然后通用函数调用选择的编译器
        <code class="literal">$(call
        $1-compile-command,$2)</code>：</p><p>Then the generic function invokes the compiler of choice with
        <code class="literal">$(call
        $1-compile-command,$2)</code>:</p><a id="OEBPS/ch07s04.html.I_2_tt357"></a><pre class="programlisting">定义 weblogic 编译命令
  cd $(TMPDIR) &amp;&amp; \
  $(JVM) weblogic.ejbc -编译器 $(EJB_JAVAC) $(EJB_TMP_JAR) $1
恩德夫</pre><pre class="programlisting">define weblogic-compile-command
  cd $(TMPDIR) &amp;&amp; \
  $(JVM) weblogic.ejbc -compiler $(EJB_JAVAC) $(EJB_TMP_JAR) $1
endef</pre><p>最后，我们的通用函数添加了清单。</p><p>Finally, our generic function adds the manifest.</p><p>定义后<code class="literal">compile-generic-bean</code>，我们将其包装在我们想要支持的每个环境的特定于编译器的函数中。</p><p>Having defined <code class="literal">compile-generic-bean</code>, we wrap it in a
        compiler-specific function for each environment we want to
        support.</p><a id="OEBPS/ch07s04.html.I_2_tt358"></a><pre class="programlisting"># $(调用compile-weblogic-bean, jar-name,
# bean-files-wildcard, 清单名称-opt )
定义编译 weblogic-bean
  $(调用compile-generic-bean,weblogic,$1,$2,$3)
恩德夫</pre><pre class="programlisting"># $(call compile-weblogic-bean, jar-name,
#                               bean-files-wildcard, manifest-name-opt )
define compile-weblogic-bean
  $(call compile-generic-bean,weblogic,$1,$2,$3)
endef</pre><div class="sect2" title="标准外壳"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch07s04.html.make3-CHP-7-SECT-4.1"></a>标准外壳</h2><h2 class="title"><a></a>A Standard Shell</h2></div></div></div><p>值得重申的是<a id="OEBPS/ch07s04.html.make3-CHP-7-ITERM-1439" class="indexterm"></a> <a id="OEBPS/ch07s04.html.make3-CHP-7-ITERM-1440" class="indexterm"></a>在从一个系统迁移到另一个系统时，人们发现的令人讨厌的不兼容性之一是
          <em class="filename">/bin/sh的功能，它是</em><em class="command">make</em>使用的默认 shell 。如果您发现自己在<em class="filename">makefile</em>中调整命令脚本，则应该考虑标准化您的 shell。当然，这对于<em class="filename">makefile</em>在不受控制的环境中执行的典型开源项目来说是不合理的。然而，在受控环境中，使用一组固定的专门配置的机器，这是相当合理的。</p><p>It is worth reiterating<a class="indexterm"></a> <a class="indexterm"></a> here that one of the irksome incompatibilities one
          finds in moving from system to system is the capabilities of
          <em class="filename">/bin/sh</em>, the default shell used
          by <em class="command">make</em>. If you find yourself
          tweaking the command scripts in your <em class="filename">makefile</em>, you should consider
          standardizing your shell. Of course, this is not reasonable for the
          typical open source project where the <em class="filename">makefile</em> is executed in uncontrolled
          environments. However, in a controlled setting, with a fixed set of
          specially configured machines, this is quite reasonable.</p><p>除了避免 shell 不兼容之外，许多 shell 还提供可以避免使用大量小型实用程序的功能。例如，<em class="command">bash</em> shell 包括增强的 shell 变量扩展，例如<code class="literal">%%</code>和<code class="literal">##</code>，这可以帮助避免使用 shell 实用程序，例如<em class="command">sed</em>和
          <em class="command">expr</em>。</p><p>In addition to avoiding shell incompatibilities, many shells
          provide features that can avoid the use of numerous small utilities.
          For example, the <em class="command">bash</em> shell
          includes enhanced shell variable expansion, such as <code class="literal">%%</code> and <code class="literal">##</code>, that can help avoid the use of shell
          utilities, such as <em class="command">sed</em> and
          <em class="command">expr</em>.</p></div></div></div></div>
<div id="OEBPS/ch07s05.html"><div>
<div class="sect1" title="汽车制造商"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch07s05.html.make3-CHP-7-SECT-5"></a>汽车制造商</h1><h1 class="title"><a></a>Automake</h1></div></div></div><p>本章重点<a id="OEBPS/ch07s05.html.make3-CHP-7-ITERM-1441" class="indexterm"></a>一直致力于有效地使用<acronym class="acronym">GNU </acronym> <em class="command">make</em>和支持工具来实现可移植的构建系统。然而，有时即使是这些适度的要求也无法实现。如果您无法使用<acronym class="acronym">GNU </acronym> <em class="command">make</em>的增强功能，并且被迫依赖一组最小公分母功能，那么您应该考虑使用<em class="command">automake</em>工具，<a class="ulink" href="http://www.gnu.org/software/automake/automake.html">http://www.gnu.org/software/automake/automake。 html</a>。</p><p>The focus of this chapter <a class="indexterm"></a>has been on using <acronym class="acronym">GNU</acronym> <em class="command">make</em> and supporting tools effectively to
        achieve a portable build system. There are times, however, when even
        these modest requirements are beyond reach. If you cannot use the
        enhanced features of <acronym class="acronym">GNU</acronym> <em class="command">make</em> and are forced to rely on a
        least-common-denominator set of features, you should consider using
        the <em class="command">automake</em> tool, <a class="ulink" href="http://www.gnu.org/software/automake/automake.html">http://www.gnu.org/software/automake/automake.html</a>.</p><p><em class="command">automake</em>工具接受程式化的<em class="filename">makefile</em>作为输入，并生成可移植的旧式<em class="filename">makefile</em>作为输出。<em class="command">automake</em>是围绕一组<em class="command">m4宏构建的，这些宏允许在输入文件（称为</em><em class="filename">makefile.am</em>）中使用非常简洁的符号。通常，<em class="command">automake与</em><em class="command">autoconf</em>（C/C++ 程序的可移植性支持包）结合使用
        ，但<em class="command">autoconf</em>不是必需的。</p><p>The <em class="command">automake</em> tool accepts a
        stylized <em class="filename">makefile</em> as input and
        generates a portable old-style <em class="filename">makefile</em> as output. <em class="command">automake</em> is built around a set of <em class="command">m4</em> macros that allow a very terse notation
        in the input file (called <em class="filename">makefile.am</em>). Typically, <em class="command">automake</em> is used in conjunction with
        <em class="command">autoconf</em>, a portability support
        package for C/C++ programs, but <em class="command">autoconf</em> is not required.</p><p>虽然<em class="command">automake</em>对于需要最大可移植性的构建系统来说是一个很好的解决方案，
        但它生成的<em class="filename">makefile不能使用</em><acronym class="acronym">GNU </acronym> <em class="command">make</em>的任何高级功能，除了附加赋值 之外<code class="literal">+=</code>，它对此有特殊支持。此外， <em class="command">automake</em>的输入与正常的<em class="filename">makefile</em>输入几乎没有相似之处
        。因此，使用
        <em class="command">automake</em>（不带<em class="command">autoconf</em>）与使用最小公分母方法并没有太大区别。</p><p>While <em class="command">automake</em> is a good
        solution for build systems that require maxium portability, the
        <em class="filename">makefile</em>s it generates cannot use
        any of the advanced features of <acronym class="acronym">GNU</acronym> <em class="command">make</em> with the exception of appending
        assignment, <code class="literal">+=</code>, for which it has
        special support. Furthermore, the input to <em class="command">automake</em> bears little resemblance to normal
        <em class="filename">makefile</em> input. Thus, using
        <em class="command">automake</em> (without <em class="command">autoconf</em>) isn't terribly different from
        using the least-common-denominator approach.</p></div></div></div>
<div id="OEBPS/ch08.html"><div>
<div class="chapter" title="第 8 章 C 和 C++"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08.html.make3-CHP-8"></a>第 8 章 C 和 C++</h1><h1 class="title"><a></a>Chapter&nbsp;8.&nbsp;C and C++</h1></div></div></div><p><a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a>中介绍的问题和技术在本章中得到增强并应用于 C 和 C++ 项目。我们将继续在非递归<em class="filename">makefile</em>上构建 mp3 播放器示例。</p><p>The issues and techniques shown in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a> are enhanced and applied in this
      chapter to C and C++ projects. We'll continue with the mp3 player
      example building on our nonrecursive <em class="filename">makefile</em>.</p><div class="sect1" title="分离源代码和二进制文件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08.html.make3-CHP-8-SECT-1"></a>分离源代码和二进制文件</h1><h1 class="title"><a></a>Separating Source and Binary</h1></div></div></div><p>如果我们想支持单个<a id="OEBPS/ch08.html.make3-CHP-8-ITERM-1442" class="indexterm"></a> <a id="OEBPS/ch08.html.make3-CHP-8-ITERM-1443" class="indexterm"></a>源树具有多个平台并且每个平台有多个构建，因此必须将源树和二叉树分开，那么我们该怎么做呢？<em class="command">make</em>程序最初是为单个目录中的文件而编写的。尽管自那时起它已经发生了巨大的变化，但它并没有忘记它的根源。当 make 更新的文件位于当前目录（或其子目录）中时，<em class="command">make可以最好地处理多个目录。</em></p><p>If we want to support a single <a class="indexterm"></a> <a class="indexterm"></a>source tree with multiple platforms and multiple builds
        per platform, separating the source and binary trees is necessary, so
        how do we do it? The <em class="command">make</em> program
        was originally written to work well for files in a single directory.
        Although it has changed dramatically since then, it hasn't forgotten
        its roots. <em class="command">make</em> works with multiple
        directories best when the files it is updating live in the current
        directory (or its subdirectories).</p><div class="sect2" title="简单的方法"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch08.html.make3-CHP-8-SECT-1.1"></a>简单的方法</h2><h2 class="title"><a></a>The Easy Way</h2></div></div></div><p><em class="command">让make</em>将二进制文件放置在与源代码不同的目录中的最简单方法是从二进制目录
          启动<em class="command">make</em>程序。输出文件是使用相对路径访问的，如上一章所示，而输入文件必须通过显式路径或通过搜索来找到<code class="literal">vpath</code>。无论哪种情况，我们都需要在多个位置引用源目录，因此我们从一个变量来保存它：</p><p>The easiest way to get <em class="command">make</em>
          to place binaries in a separate directory from sources is to start
          the <em class="command">make</em> program from the binary
          directory. The output files are accessed using relative paths, as
          shown in the previous chapter, while the input files must be found
          either through explicit paths or through searching through <code class="literal">vpath</code>. In either case, we'll need to refer
          to the source directory in several places, so we start with a
          variable to hold it:</p><a id="OEBPS/ch08.html.I_3_tt359"></a><pre class="programlisting">SOURCE_DIR := ../mp3_player</pre><pre class="programlisting">SOURCE_DIR := ../mp3_player</pre><p><em class="filename">在我们之前的makefile 的</em>基础上构建，该<code class="function">source-to-object</code>函数未更改，但该<code class="function">subdirectory</code>函数现在需要考虑源的相对路径。</p><p>Building on our previous <em class="filename">makefile</em>, the <code class="function">source-to-object</code> function is unchanged,
          but the <code class="function">subdirectory</code> function
          now needs to take into account the relative path to the
          source.</p><a id="OEBPS/ch08.html.I_3_tt360"></a><pre class="programlisting"># $(调用源到对象，源文件列表)
源到对象 = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(过滤器 %.y,$1)) \
                   $(subst .l,.o,$(过滤器 %.l,$1))

# $(子目录)
子目录 = $(patsubst $(SOURCE_DIR)/%/module.mk,%, \
                 $(单词\
                   $(单词$(MAKEFILE_LIST)),$(MAKEFILE_LIST)))</pre><pre class="programlisting"># $(call source-to-object, source-file-list)
source-to-object = $(subst .c,.o,$(filter %.c,$1)) \
                   $(subst .y,.o,$(filter %.y,$1)) \
                   $(subst .l,.o,$(filter %.l,$1))

# $(subdirectory)
subdirectory = $(patsubst $(SOURCE_DIR)/%/module.mk,%,  \
                 $(word                                 \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))</pre><p>在我们的新<em class="filename">makefile</em>中，列出的文件<code class="literal">MAKEFILE_LIST</code>
          将包含源的相对路径。因此，要提取模块目录的相对路径，我们必须去掉前缀和<em class="filename">module.mk</em>
          后缀。</p><p>In our new <em class="filename">makefile</em>, the
          files listed in the <code class="literal">MAKEFILE_LIST</code>
          will include the relative path to the source. So to extract the
          relative path to the module's directory, we must strip off the
          prefix as well as the <em class="filename">module.mk</em>
          suffix.</p><p>接下来，为了帮助<em class="command">找到</em>来源，我们使用以下<code class="literal">vpath</code>
          功能：</p><p>Next, to help <em class="command">make</em> find the
          sources, we use the <code class="literal">vpath</code>
          feature:</p><a id="OEBPS/ch08.html.I_3_tt361"></a><pre class="programlisting">vpath %.y $(SOURCE_DIR)
vpath %.l $(SOURCE_DIR)
vpath %.c $(SOURCE_DIR)</pre><pre class="programlisting">vpath %.y $(SOURCE_DIR)
vpath %.l $(SOURCE_DIR)
vpath %.c $(SOURCE_DIR)</pre><p>这允许我们对源文件和输出文件使用简单的相对路径。当<em class="command">make</em>需要源文件时，
          <code class="literal">SOURCE_DIR</code>如果在输出树的当前目录中找不到该文件，它将进行搜索。接下来，我们必须更新<code class="literal">include_dirs</code>
          变量：</p><p>This allows us to use simple relative paths for our source
          files as well as our output files. When <em class="command">make</em> needs a source file, it will search
          <code class="literal">SOURCE_DIR</code> if it cannot find the
          file in the current directory of the output tree. Next, we must
          update the <code class="literal">include_dirs</code>
          variable:</p><a id="OEBPS/ch08.html.I_3_tt362"></a><pre class="programlisting">include_dirs := lib $(SOURCE_DIR)/lib $(SOURCE_DIR)/include</pre><pre class="programlisting">include_dirs := lib $(SOURCE_DIR)/lib $(SOURCE_DIR)/include</pre><p>除了源目录之外，该变量现在还包括二进制树中的<em class="filename">lib目录，因为生成的</em><em class="command">yacc</em>和<em class="command">lex</em>头文件将放置在那里。</p><p>In addition to the source directories, this variable now
          includes the <em class="filename">lib</em> directory from
          the binary tree because the generated <em class="command">yacc</em> and <em class="command">lex</em> header files will be placed
          there.</p><p>必须更新make指令才能从源目录访问<em class="filename">module.mk文件</em><em class="command">，因为</em> <em class="command">make</em>不使用 来查找包含文件：<code class="literal">include</code><em class="filename"></em><em class="command"></em><code class="literal">vpath</code></p><p>The <em class="command">make</em> <code class="literal">include</code> directive must be updated to
          access the <em class="filename">module.mk</em> files from
          their source directories since <em class="command">make</em> does not use the <code class="literal">vpath</code> to find include files:</p><a id="OEBPS/ch08.html.I_3_tt363"></a><pre class="programlisting">包括 $(patsubst %,$(SOURCE_DIR)/%/module.mk,$(modules))</pre><pre class="programlisting">include $(patsubst %,$(SOURCE_DIR)/%/module.mk,$(modules))</pre><p>最后，我们自己创建输出目录：</p><p>Finally, we create the output directories themselves:</p><a id="OEBPS/ch08.html.I_3_tt364"></a><pre class="programlisting">创建输出目录 := \
        $($(模块) 中的 f 的 shell; \
                做 \
                  $(测试) -d $$f || $(MKDIR) $$f; \
                完毕）</pre><pre class="programlisting">create-output-directories :=                            \
        $(shell for f in $(modules);                    \
                do                                      \
                  $(TEST) -d $$f || $(MKDIR) $$f;       \
                done)</pre><p>此赋值创建了一个虚拟变量，其值从未使用过，但由于简单的变量赋值，我们保证在<em class="command">make</em>执行任何其他工作之前将创建目录。我们必须“手动”创建目录，因为<em class="command">yacc</em>、<em class="command">lex</em>和依赖文件生成本身不会创建输出目录。</p><p>This assignment creates a dummy variable whose value is never
          used, but because of the simple variable assignment we are
          guaranteed that the directories will be created before <em class="command">make</em> performs any other work. We must
          create the directories "by hand" because <em class="command">yacc</em>, <em class="command">lex</em>, and the dependency file generation
          will not create the output directories themselves.</p><p>确保创建这些目录的另一种方法是将这些目录作为先决条件添加到依赖项文件（
           <em class="filename">.d</em>文件）中。这是一个坏主意，因为该目录并不是真正的先决条件。 yacc <em class="command">、</em> lex或依赖文件不依赖于目录的<span class="emphasis"><em>内容</em></span><em class="command">，也不应该仅仅因为目录时间戳更新而</em>重新生成它们。事实上，如果在输出目录中添加或删除文件时重新制作项目，这将导致效率极低。<span class="emphasis"><em></em></span></p><p>Another way to ensure these directories are created is to add
          the directories as prerequisites to the dependency files (the
          <em class="filename">.d</em> files). This is a bad idea
          because the directory is not really a prerequisite. The <em class="command">yacc</em>, <em class="command">lex</em>, or dependency files do not depend on
          the <span class="emphasis"><em>contents</em></span> of the directory, nor should they
          be regenerated just because the directory timestamp is updated. In
          fact, this would be a source of great inefficiency if the project
          were remade when a file was added or removed from an output
          directory.</p><p><em class="filename">对module.mk</em>文件的修改就更简单了：</p><p>The modifications to the <em class="filename">module.mk</em> file are even simpler:</p><a id="OEBPS/ch08.html.I_3_tt365"></a><pre class="programlisting">local_src := $(addprefix $(子目录)/,playlist.y Scanner.l)

$(eval $(调用 make-library, $(子目录)/libdb.a, $(local_src)))

.SECONDARY：$（调用生成源，$（local_src））

$(子目录)/scanner.d: $(子目录)/playlist.d</pre><pre class="programlisting">local_src := $(addprefix $(subdirectory)/,playlist.y scanner.l)

$(eval $(call make-library, $(subdirectory)/libdb.a, $(local_src)))

.SECONDARY: $(call generated-source, $(local_src))

$(subdirectory)/scanner.d: $(subdirectory)/playlist.d</pre><p>此版本省略了通配符来查找源。恢复此功能是一件简单的事情，留给读者作为练习。有一个小故障似乎是原始<em class="filename">makefile</em>中的一个错误。运行此示例时，我发现<em class="filename">Scanner.d</em>依赖文件是在它所依赖的<em class="filename">playlist.h</em>之前生成的。原始<em class="filename">makefile</em>中缺少此依赖项
          ，但它的工作无论如何纯粹是偶然的。即使在小型项目中，确保<span class="emphasis"><em>所有</em></span>依赖关系正确也是一项艰巨的任务。</p><p>This version omits the wildcard to find the source. It is a
          straightforward matter to restore this feature and is left as an
          exercise for the reader. There is one glitch that appears to be a
          bug in the original <em class="filename">makefile</em>.
          When this example was run, I discovered that the <em class="filename">scanner.d</em> dependency file was being
          generated before <em class="filename">playlist.h</em>,
          which it depends upon. This dependency was missing from the original
          <em class="filename">makefile</em>, but it worked anyway
          purely by accident. Getting <span class="emphasis"><em>all</em></span> the
          dependencies right is a difficult task, even in small
          projects.</p><p>假设源代码位于子目录<em class="filename">mp3_player中，以下是我们如何使用新的</em><em class="filename">makefile</em>构建项目：</p><p>Assuming the source is in the subdirectory <em class="filename">mp3_player</em>, here is how we build our
          project with the new <em class="filename">makefile</em>:</p><a id="OEBPS/ch08.html.I_3_tt366"></a><pre class="programlisting">$ mkdir mp3_player_out
$ cd mp3_player_out
$ make --file=../mp3_player/makefile</pre><pre class="programlisting">$ mkdir mp3_player_out
$ cd mp3_player_out
$ make --file=../mp3_player/makefile</pre><p>makefile是正确的并且运行良好，但是被迫将目录更改为输出目录，然后被迫添加
          ( ) 选项，<em class="filename">这</em>相当烦人。这个问题可以通过一个简单的 shell 脚本来解决：<code class="option">—file</code><code class="option">-f</code></p><p>The <em class="filename">makefile</em> is correct
          and works well, but it is rather annoying to be forced to change
          directories to the output directory and then be forced to add the
          <code class="option">—file</code> (<code class="option">-f</code>) option. This can be
          cured with a simple shell script:</p><a id="OEBPS/ch08.html.I_3_tt367"></a><pre class="programlisting">#！ /bin/bash
如果 [[ ！ -d $OUTPUT_DIR ]]
然后
  如果 ！ mkdir -p $OUTPUT_DIR
  然后
    echo“无法创建输出目录”&gt; /dev/stderr
    1号出口
  菲
菲

cd $OUTPUT_DIR
make --file=$SOURCE_DIR/makefile "$@"</pre><pre class="programlisting">#! /bin/bash
if [[ ! -d $OUTPUT_DIR ]]
then
  if ! mkdir -p $OUTPUT_DIR
  then
    echo "Cannot create output directory" &gt; /dev/stderr
    exit 1
  fi
fi

cd $OUTPUT_DIR
make --file=$SOURCE_DIR/makefile "$@"</pre><p>该脚本假设源目录和输出目录分别存储在环境变量<code class="literal">SOURCE_DIR</code>和中<code class="literal">OUTPUT_DIR</code>。这是一种标准做法，允许开发人员轻松切换树，但仍避免过于频繁地键入路径。</p><p>This script assumes the source and output directories are
          stored in the environment variables <code class="literal">SOURCE_DIR</code> and <code class="literal">OUTPUT_DIR</code>, respectively. This is a
          standard practice that allows developers to switch trees easily but
          still avoid typing paths too frequently.</p><p>最后一点警告。<em class="command">make</em>或<em class="filename">makefile</em>中没有任何内容可以阻止开发人员从源代码​​树执行 makefile <em class="filename">，</em>即使它应该从二进制树执行。这是一个常见的错误，某些命令脚本可能表现不佳。例如，<code class="literal">clean</code>
          目标：</p><p>One last caution. There is nothing in <em class="command">make</em> or our <em class="filename">makefile</em> to prevent a developer from
          executing the <em class="filename">makefile</em> from the
          source tree, even though it should be executed from the binary tree.
          This is a common mistake and some command scripts might behave
          badly. For instance, the <code class="literal">clean</code>
          target:</p><a id="OEBPS/ch08.html.I_3_tt368"></a><pre class="programlisting">.PHONY：干净
干净的：
        $(RM) -r *</pre><pre class="programlisting">.PHONY: clean
clean:
        $(RM) -r *</pre><p>将删除用户的整个源代码树！哎呀。在最高级别的<em class="filename">makefile</em>中添加对这种可能性的检查似乎是谨慎的做法。这是一个合理的检查：</p><p>would delete the user's entire source tree! Oops. It seems
          prudent to add a check for this eventuality in the <em class="filename">makefile</em> at the highest level. Here is a
          reasonable check:</p><a id="OEBPS/ch08.html.I_3_tt369"></a><pre class="programlisting">$(如果 $(过滤器 $(notdir $(SOURCE_DIR)),$(notdir $(CURDIR))),\
  $(错误请从二叉树运行 makefile。))</pre><pre class="programlisting">$(if $(filter $(notdir $(SOURCE_DIR)),$(notdir $(CURDIR))),\
  $(error Please run the makefile from the binary tree.))</pre><p>此代码测试当前工作目录 ( ) 的名称是否<code class="literal">$(notdir $(CURDIR))</code>与源目录 ( ) 相同<code class="literal">$(notdir
          $(SOURCE_DIR))</code>。如果是这样，则打印错误并退出。由于<code class="function">if</code>和<code class="function">error</code>函数扩展为空，因此我们可以将这两行紧接在 的定义之后<code class="literal">SOURCE_DIR</code>。</p><p>This code tests if the name of the current working directory
          (<code class="literal">$(notdir $(CURDIR))</code>) is the same
          as the source directory (<code class="literal">$(notdir
          $(SOURCE_DIR))</code>). If so, print the error and exit. Since
          the <code class="function">if</code> and <code class="function">error</code> functions expand to nothing, we can
          place these two lines immediately after the definition of <code class="literal">SOURCE_DIR</code>.</p></div><div class="sect2" title="艰难的道路"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch08.html.make3-CHP-8-SECT-1.2"></a>艰难的道路</h2><h2 class="title"><a></a>The Hard Way</h2></div></div></div><p>一些开发人员发现必须<em class="command">cd</em>进入二叉树非常烦人，以至于他们会竭尽全力避免它，或者<em class="filename">makefile</em>维护者可能正在 shell 脚本包装器或别名不适合的环境中工作。在任何情况下，都可以修改<em class="filename">makefile以允许从源代码树运行</em><em class="command">make</em> 
          ，并通过在所有输出文件名前加上路径前缀将二进制文件放置在单独的输出树中。此时，我通常使用绝对路径，因为这提供了更大的灵活性，尽管它确实加剧了命令行长度限制的问题。输入文件继续使用<em class="filename">makefile</em>
          目录中的简单相对路径。</p><p>Some developers find having to <em class="command">cd</em> into the binary tree so annoying that
          they will go to great lengths to avoid it, or maybe the <em class="filename">makefile</em> maintainer is working in an
          environment where shell script wrappers or aliases are unsuitable.
          In any case, the <em class="filename">makefile</em> can
          be modified to allow running <em class="command">make</em>
          from the source tree and placing binary files in a separate output
          tree by prefixing all the output filenames with a path. At this
          point I usually go with absolute paths since this provides more
          flexibility, although it does exacerbate problems with command-line
          length limits. The input files continue to use simple relative paths
          from the <em class="filename">makefile</em>
          directory.</p><p><a class="link" href="#OEBPS/ch08.html.make3-CHP-8-EX-1" title="例8-1。一个将源代码和二进制文件分开的 makefile，可以从源代码树执行">示例 8-1</a>显示了
          修改后的<em class="filename">makefile</em>，以允许从源代码树执行<em class="command">make</em>并将二进制文件写入二进制树。</p><p><a class="link" href="#OEBPS/ch08.html.make3-CHP-8-EX-1" title="Example&nbsp;8-1.&nbsp;A makefile separating source and binary that can be executed from the source tree">Example 8-1</a> shows the
          <em class="filename">makefile</em> modified to allow
          executing <em class="command">make</em> from the source
          tree and writing binary files to a binary tree.</p><div class="example"><a id="OEBPS/ch08.html.make3-CHP-8-EX-1"></a><p class="title">例8-1。一个将源代码和二进制文件分开的 makefile，可以从源代码树执行</p><p class="title">Example&nbsp;8-1.&nbsp;A makefile separating source and binary that can be
            executed from the source tree</p><div class="example-contents"><pre class="programlisting">SOURCE_DIR := /test/book/examples/ch07-separate-binaries-1
BINARY_DIR := /test/book/out/mp3_player_out

# $(调用源目录到二进制目录，目录列表)
源目录到二进制目录 = $(addprefix $(BINARY_DIR)/, $1)

# $(调用源到对象，源文件列表)
源到对象 = $(调用源目录到二进制目录，\
                     $(subst .c,.o,$(过滤器 %.c,$1)) \
                     $(subst .y,.o,$(过滤器 %.y,$1)) \
                     $(subst .l,.o,$(过滤器 %.l,$1)))

# $(子目录)
子目录 = $(patsubst %/module.mk,%, \
                 $(单词\
                   $(单词$(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

# $(调用 make-library, 库名, 源文件列表)
定义 make-library
  库 += $(BINARY_DIR)/$1
  来源 += $2

  $(BINARY_DIR)/$1: $(调用源目录到二进制目录，\
                      $(subst .c,.o,$(过滤器 %.c,$2)) \
                      $(subst .y,.o,$(过滤器 %.y,$2)) \
                      $(subst .l,.o,$(过滤器 %.l,$2)))
        $(AR) $(ARFLAGS) $$@ $$^
恩德夫

# $(调用生成源，源文件列表)
生成的源 = $(调用源目录到二进制目录，\
                     $(subst .y,.c,$(过滤器 %.y,$1)) \
                     $(subst .y,.h,$(过滤器 %.y,$1)) \
                     $(subst .l,.c,$(过滤器 %.l,$1))) \
                   $(过滤%.c,$1)

# $(编译规则)
定义编译规则
  $(foreach f, $(local_src),\
    $(调用单编译规则,$(调用源到对象,$f),$f))
恩德夫

# $(调用单编译规则、二进制文件、源文件)
定义一次编译规则
  $1：$（调用生成源，$2）
        $(COMPILE.c) -o $$@ $$&lt;

  $(subst .o,.d,$1): $(调用生成源,$2)
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $$&lt; | \
        $(SED) 's,\($$(notdir $$*)\.o\) *:,$$(dir $$@)\1 $$@: ,' &gt; $$@.tmp
        $(MV) $$@.tmp $$@

恩德夫

模块：= lib /编解码器lib / db lib / ui应用程序/播放器
程序:=
库:=
来源:=

对象 = $(调用源到对象,$(源))
依赖项 = $(subst .o,.d,$(对象))

include_dirs := $(BINARY_DIR)/lib lib 包含
CPPFLAGS += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MKDIR := mkdir -p
MV := mv -f
RM := rm -f
SED := sed
测试：=测试

创建输出目录 := \
        $(shell for f in $(call source-dir-to-binary-dir,$(modules)); \
                做 \
                  $(测试) -d $$f || $(MKDIR) $$f; \
                完毕）

全部：

包括 $(addsuffix /module.mk,$(modules))

.PHONY：全部
全部：$（程序）

.PHONY：库
图书馆：$（图书馆）

.PHONY：干净
干净的：
        $(RM) -r $(BINARY_DIR)

ifneq "$(MAKECMDGOALS)" "干净"
  包括 $(依赖项)
万一</pre><pre class="programlisting">SOURCE_DIR := /test/book/examples/ch07-separate-binaries-1
BINARY_DIR := /test/book/out/mp3_player_out

# $(call source-dir-to-binary-dir, directory-list)
source-dir-to-binary-dir = $(addprefix $(BINARY_DIR)/, $1)

# $(call source-to-object, source-file-list)
source-to-object = $(call source-dir-to-binary-dir,     \
                     $(subst .c,.o,$(filter %.c,$1))    \
                     $(subst .y,.o,$(filter %.y,$1))    \
                     $(subst .l,.o,$(filter %.l,$1)))

# $(subdirectory)
subdirectory = $(patsubst %/module.mk,%,                \
                 $(word                                 \
                   $(words $(MAKEFILE_LIST)),$(MAKEFILE_LIST)))

# $(call make-library, library-name, source-file-list)
define make-library
  libraries += $(BINARY_DIR)/$1
  sources   += $2

  $(BINARY_DIR)/$1: $(call source-dir-to-binary-dir,    \
                      $(subst .c,.o,$(filter %.c,$2))   \
                      $(subst .y,.o,$(filter %.y,$2))   \
                      $(subst .l,.o,$(filter %.l,$2)))
        $(AR) $(ARFLAGS) $$@ $$^
endef

# $(call generated-source, source-file-list)
generated-source = $(call source-dir-to-binary-dir,     \
                     $(subst .y,.c,$(filter %.y,$1))    \
                     $(subst .y,.h,$(filter %.y,$1))    \
                     $(subst .l,.c,$(filter %.l,$1)))   \
                   $(filter %.c,$1)

# $(compile-rules)
define compile-rules
  $(foreach f, $(local_src),\
    $(call one-compile-rule,$(call source-to-object,$f),$f))
endef

# $(call one-compile-rule, binary-file, source-files)
define one-compile-rule
  $1: $(call generated-source,$2)
        $(COMPILE.c) -o $$@ $$&lt;

  $(subst .o,.d,$1): $(call generated-source,$2)
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $$&lt; | \
        $(SED) 's,\($$(notdir $$*)\.o\) *:,$$(dir $$@)\1 $$@: ,' &gt; $$@.tmp
        $(MV) $$@.tmp $$@

endef

modules      := lib/codec lib/db lib/ui app/player
programs     :=
libraries    :=
sources      :=

objects      =  $(call source-to-object,$(sources))
dependencies =  $(subst .o,.d,$(objects))

include_dirs := $(BINARY_DIR)/lib lib include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))
vpath %.h $(include_dirs)

MKDIR := mkdir -p
MV    := mv -f
RM    := rm -f
SED   := sed
TEST  := test

create-output-directories :=                                            \
        $(shell for f in $(call source-dir-to-binary-dir,$(modules));   \
                do                                                      \
                  $(TEST) -d $$f || $(MKDIR) $$f;                       \
                done)

all:

include $(addsuffix /module.mk,$(modules))

.PHONY: all
all: $(programs)

.PHONY: libraries
libraries: $(libraries)

.PHONY: clean
clean:
        $(RM) -r $(BINARY_DIR)

ifneq "$(MAKECMDGOALS)" "clean"
  include $(dependencies)
endif</pre></div></div><p>在此版本中，该<code class="function">source-to-object</code>函数被修改为将路径添加到二叉树的前面。这个前缀操作会执行多次，所以将其写成一个函数：</p><p>In this version the <code class="function">source-to-object</code> function is modified to
          prepend the path to the binary tree. This prefixing operation is
          performed several times, so write it as a function:</p><a id="OEBPS/ch08.html.I_3_tt370"></a><pre class="programlisting">SOURCE_DIR := /test/book/examples/ch07-separate-binaries-1
BINARY_DIR := /test/book/out/mp3_player_out

# $(调用源目录到二进制目录，目录列表)
源目录到二进制目录 = $(addprefix $(BINARY_DIR)/, $1)

# $(调用源到对象，源文件列表)
源到对象 = $(调用源目录到二进制目录，\
                     $(subst .c,.o,$(过滤器 %.c,$1)) \
                     $(subst .y,.o,$(过滤器 %.y,$1)) \
                     $(subst .l,.o,$(过滤器 %.l,$1)))</pre><pre class="programlisting">SOURCE_DIR := /test/book/examples/ch07-separate-binaries-1
BINARY_DIR := /test/book/out/mp3_player_out

# $(call source-dir-to-binary-dir, directory-list)
source-dir-to-binary-dir = $(addprefix $(BINARY_DIR)/, $1)

# $(call source-to-object, source-file-list)
source-to-object = $(call source-dir-to-binary-dir,     \
                     $(subst .c,.o,$(filter %.c,$1))    \
                     $(subst .y,.o,$(filter %.y,$1))    \
                     $(subst .l,.o,$(filter %.l,$1)))</pre><p>该<code class="function">make-library</code>函数也进行了类似的更改，以在输出文件中添加前缀<code class="literal">BINARY_DIR</code>.由于包含路径再次是简单的相对路径，因此该<code class="function">subdirectory</code>函数恢复到其先前版本。一个小障碍；<em class="command">make</em> 3.80中的一个错误阻止<code class="function">source-to-object</code>在新版本的<code class="function">make-library</code>.该错误已在 3.81 中修复。我们可以通过手动扩展功能来解决该错误
          <code class="function">source-to-object</code>
          。</p><p>The <code class="function">make-library</code> function
          is similarly altered to prefix the output file with <code class="literal">BINARY_DIR</code>. The <code class="function">subdirectory</code> function is restored to its
          previous version since the include path is again a simple relative
          path. One small snag; a bug in <em class="command">make</em> 3.80 prevents calling <code class="function">source-to-object</code> within the new version
          of <code class="function">make-library</code>. This bug has
          been fixed in 3.81. We can work around the bug by hand expanding the
          <code class="function">source-to-object</code>
          function.</p><p>现在我们到了真正丑陋的部分。当输出文件无法从<em class="filename">makefile</em>的相对路径直接访问时，隐式规则将不再触发。例如，基本编译规则<code class="literal">%.o</code>：<code class="literal">%.c</code>当两个文件位于同一目录中时，或者即使 C 文件位于子目录中（例如
          <em class="filename">lib/codec/codec.c</em>）时，效果很好。当源文件位于远程目录中时，我们可以指示<em class="command">make</em>使用该功能搜索源
          <code class="literal">vpath</code>。但是，当目标文件位于远程目录中时，<em class="command">make</em>无法确定目标文件所在的位置，并且目标/先决条件链会被破坏。</p><p>Now we get to the truly ugly part. When the output file is not
          directly accessible from a path relative to the <em class="filename">makefile</em>, the implicit rules no longer
          fire. For instance, the basic compile rule <code class="literal">%.o</code>: <code class="literal">%.c</code> works well when the two files live in
          the same directory, or even if the C file is in a subdirectory, say
          <em class="filename">lib/codec/codec.c</em>. When the
          source file lives in a remote directory, we can instruct <em class="command">make</em> to search for the source with the
          <code class="literal">vpath</code> feature. But when the
          object file lives in a remote directory, <em class="command">make</em> has no way of determining where the
          object file resides and the target/prerequisite chain is
          broken.</p><p><em class="command">通知make</em>
          输出文件位置的唯一方法是提供链接源文件和目标文件的显式规则：</p><p>The only way to inform <em class="command">make</em>
          of the location of the output file is to provide an explicit rule
          linking the source and object files:</p><a id="OEBPS/ch08.html.I_3_tt371"></a><pre class="programlisting">$(BINARY_DIR)/lib/codec/codec.o: lib/codec/codec.c</pre><pre class="programlisting">$(BINARY_DIR)/lib/codec/codec.o: lib/codec/codec.c</pre><p>必须对每个目标文件执行此操作。</p><p>This must be done for every single object file.</p><p>更糟糕的是，这个目标/先决条件对与隐式规则不匹配<code class="literal">%.o: %.c</code>。这意味着我们还必须提供命令脚本，复制隐式数据库中的所有内容，并可能多次重复该脚本。这个问题也适用于我们一直使用的自动依赖关系生成规则。
          如果手动完成，为<em class="filename">makefile</em>中的每个目标文件添加两个显式规则是维护的噩梦。但是，我们可以通过编写一个函数来生成这些规则，从而最大限度地减少代码重复和维护：</p><p>Worse, this target/prerequisite pair is not matched against
          the implicit rule, <code class="literal">%.o: %.c</code>. That
          means we must also provide the command script, duplicating whatever
          is in the implicit database and possibly repeating this script many
          times. The problem also applies to the automatic dependency
          generation rule we've been using. Adding two explicit rules for
          every object file in a <em class="filename">makefile</em>
          is a maintenance nightmare, if done by hand. However, we can
          minimize the code duplication and maintenance by writing a function
          to generate these rules:</p><a id="OEBPS/ch08.html.I_3_tt372"></a><pre class="programlisting"># $(调用单编译规则、二进制文件、源文件)
定义一次编译规则
  $1：$（调用生成源，$2）
        $(COMPILE.c) $$@ $$&lt;

  $(subst .o,.d,$1): $(调用生成源,$2)
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $$&lt; | \
        $(SED) 's,\($$(notdir $$*)\.o\) *:,$$(dir $$@)\1 $$@: ,' &gt; $$@.tmp
        $(MV) $$@.tmp $$@

恩德夫</pre><pre class="programlisting"># $(call one-compile-rule, binary-file, source-files)
define one-compile-rule
  $1: $(call generated-source,$2)
        $(COMPILE.c) $$@ $$&lt;

  $(subst .o,.d,$1): $(call generated-source,$2)
        $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $$&lt; | \
        $(SED) 's,\($$(notdir $$*)\.o\) *:,$$(dir $$@)\1 $$@: ,' &gt; $$@.tmp
        $(MV) $$@.tmp $$@

endef</pre><p>该函数的前两行是对象到源依赖关系的显式规则。规则的先决条件必须使用我们在<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">第 6 章</a><code class="function">generated-source</code>中编写的函数
          来计算，因为某些源文件是<em class="command">yacc</em>和
          <em class="command">lex</em>文件，当它们出现在命令脚本中（例如，用 扩展）时，它们会导致编译失败。自动变量被引用，以便稍后在执行命令脚本时而不是在通过 求值用户定义的函数时扩展它们。该函数已被修改为返回未更改的 C 文件以及<em class="command">yacc</em>和
          <em class="command">lex</em>的生成源：<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目"></a><em class="command"></em><em class="command"></em><code class="literal">$^</code><code class="function">eval</code><code class="function">generated-source</code><em class="command"></em><em class="command"></em></p><p>The first two lines of the function are the explicit rule for
          the object-to-source dependency. The prerequisites for the rule must
          be computed using the <code class="function">generated-source</code> function we wrote in
          <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a> because some of the
          source files are <em class="command">yacc</em> and
          <em class="command">lex</em> files that will cause
          compilation failures when they appear in the command script
          (expanded with <code class="literal">$^</code>, for instance).
          The automatic variables are quoted so they are expanded later when
          the command script is executed rather than when the user-defined
          function is evaluated by <code class="function">eval</code>.
          The <code class="function">generated-source</code> function
          has been modified to return C files unaltered as well as the
          generated source for <em class="command">yacc</em> and
          <em class="command">lex</em>:</p><a id="OEBPS/ch08.html.I_3_tt373"></a><pre class="programlisting"># $(调用生成源，源文件列表)
生成的源 = $(调用源目录到二进制目录，\
                     $(subst .y,.c,$(过滤器 %.y,$1)) \
                     $(subst .y,.h,$(过滤器 %.y,$1)) \
                     $(subst .l,.c,$(过滤器 %.l,$1))) \
                   $(过滤%.c,$1)</pre><pre class="programlisting"># $(call generated-source, source-file-list)
generated-source = $(call source-dir-to-binary-dir,     \
                     $(subst .y,.c,$(filter %.y,$1))    \
                     $(subst .y,.h,$(filter %.y,$1))    \
                     $(subst .l,.c,$(filter %.l,$1)))   \
                   $(filter %.c,$1)</pre><p>经过此更改，该函数现在产生以下输出：</p><p>With this change, the function now produces this
          output:</p><a id="OEBPS/ch08.html.I_3_tt374"></a><pre class="programlisting">参数结果
lib/db/playlist.y /c/mp3_player_out/lib/db/playlist.c
                       /c/mp3_player_out/lib/db/playlist.h
lib/db/scanner.l /c/mp3_player_out/lib/db/scanner.c
应用程序/播放器/play_mp3.c 应用程序/播放器/play_mp3.c</pre><pre class="programlisting">Argument               Result
lib/db/playlist.y      /c/mp3_player_out/lib/db/playlist.c
                       /c/mp3_player_out/lib/db/playlist.h
lib/db/scanner.l       /c/mp3_player_out/lib/db/scanner.c
app/player/play_mp3.c  app/player/play_mp3.c</pre><p>依赖关系生成的显式规则类似。再次注意依赖脚本所需的额外引用（双美元符号）。</p><p>The explicit rule for dependency generation is similar. Again,
          note the extra quoting (double dollar signs) required by the
          dependency script.</p><p>现在必须为模块中的每个源文件扩展我们的新函数：</p><p>Our new function must now be expanded for each source file in
          a module:</p><a id="OEBPS/ch08.html.I_3_tt375"></a><pre class="programlisting"># $(编译规则)
定义编译规则
  $(foreach f, $(local_src),\
    $(调用单编译规则,$(调用源到对象,$f),$f))
恩德夫</pre><pre class="programlisting"># $(compile-rules)
define compile-rules
  $(foreach f, $(local_src),\
    $(call one-compile-rule,$(call source-to-object,$f),$f))
endef</pre><p><em class="filename">该函数依赖于module.mk</em><code class="literal">local_src</code>文件使用的全局变量。更通用的方法会将此文件列表作为参数传递，但在这个项目中似乎没有必要。这些函数可以轻松添加到我们的<em class="filename">module.mk</em>文件中：<em class="filename"></em><em class="filename"></em></p><p>This function relies on the global variable <code class="literal">local_src</code> used by the <em class="filename">module.mk</em> files. A more general approach
          would pass this file list as an argument, but in this project it
          seems unnecessary. These functions are easily added to our <em class="filename">module.mk</em> files:</p><a id="OEBPS/ch08.html.I_3_tt376"></a><pre class="programlisting">local_src := $(子目录)/codec.c

$(eval $(调用 make-library,$(子目录)/libcodec.a,$(local_src)))

$(eval $(编译规则))</pre><pre class="programlisting">local_src := $(subdirectory)/codec.c

$(eval $(call make-library,$(subdirectory)/libcodec.a,$(local_src)))

$(eval $(compile-rules))</pre><p>我们必须使用该函数<code class="function">eval</code>，因为该<code class="function">compile-rules</code>函数会扩展到不止一行<em class="command">make</em>代码。</p><p>We must use <code class="function">eval</code> because
          the <code class="function">compile-rules</code> function
          expands to more than one line of <em class="command">make</em> code.</p><p>还有最后一个并发症。如果标准 C 编译模式规则无法与二进制输出路径匹配，则<em class="command">lex</em>的隐式规则和<em class="command">yacc</em>的模式规则也将失败。我们可以轻松地手动更新这些。由于它们不再适用于其他<em class="command">lex</em>或<em class="command">yacc</em>文件，我们可以将它们移至
          <em class="filename">lib/db/module.mk</em>：</p><p>There is one last complication. If the standard C compilation
          pattern rule fails to match with binary output paths, the implicit
          rule for <em class="command">lex</em> and our pattern rule
          for <em class="command">yacc</em> will also fail. We can
          update these by hand easily. Since they are no longer applicable to
          other <em class="command">lex</em> or <em class="command">yacc</em> files, we can move them into
          <em class="filename">lib/db/module.mk</em>:</p><a id="OEBPS/ch08.html.I_3_tt377"></a><pre class="programlisting">local_dir := $(BINARY_DIR)/$(子目录)
local_src := $(addprefix $(子目录)/,playlist.y Scanner.l)

$(eval $(调用 make-library,$(子目录)/libdb.a,$(local_src)))

$(eval $(编译规则))

.SECONDARY：$（调用生成源，$（local_src））

$(local_dir)/scanner.d: $(local_dir)/playlist.d

$(local_dir)/%.c $(local_dir)/%.h: $(子目录)/%.y
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $(dir $@)$*.c
        $(MV) y.tab.h $(dir $@)$*.h

$(local_dir)/scanner.c: $(子目录)/scanner.l
        @$(RM)$@
        $(LEX.l) $&lt; &gt; $@</pre><pre class="programlisting">local_dir := $(BINARY_DIR)/$(subdirectory)
local_src := $(addprefix $(subdirectory)/,playlist.y scanner.l)

$(eval $(call make-library,$(subdirectory)/libdb.a,$(local_src)))

$(eval $(compile-rules))

.SECONDARY: $(call generated-source, $(local_src))

$(local_dir)/scanner.d: $(local_dir)/playlist.d

$(local_dir)/%.c $(local_dir)/%.h: $(subdirectory)/%.y
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $(dir $@)$*.c
        $(MV) y.tab.h $(dir $@)$*.h

$(local_dir)/scanner.c: $(subdirectory)/scanner.l
        @$(RM) $@
        $(LEX.l) $&lt; &gt; $@</pre><p>lex规则已作为普通显式规则实现，但<em class="command">yacc</em><em class="command">规则</em>是模式规则。为什么？因为<em class="command">yacc</em>规则用于构建两个目标，一个C文件和一个头文件。如果我们使用正常的显式规则，<em class="command">make</em>将执行命令脚本两次，一次用于创建 C 文件，一次用于标头。但是<em class="command">make</em>假设具有多个目标的模式规则通过一次执行更新两个目标。</p><p>The <em class="command">lex</em> rule has been
          implemented as a normal explicit rule, but the <em class="command">yacc</em> rule is a pattern rule. Why? Because
          the <em class="command">yacc</em> rule is used to build
          two targets, a C file and a header file. If we used a normal
          explicit rule, <em class="command">make</em> would execute
          the command script twice, once for the C file to be created and once
          for the header. But <em class="command">make</em> assumes
          that a pattern rule with multiple targets updates both targets with
          a single execution.</p><p>如果可能的话，我将使用更简单的从二进制文件进行编译的方法，而不是本节中显示的<em class="filename">makefile</em><a id="OEBPS/ch08.html.make3-CHP-8-ITERM-1444" class="indexterm"></a> <a id="OEBPS/ch08.html.make3-CHP-8-ITERM-1445" class="indexterm"></a>树。正如您所看到的，当尝试从源代码树进行编译时，复杂性立即出现（并且似乎变得越来越糟）。</p><p>If possible, instead of the <em class="filename">makefile</em>s shown in this section, I would
          use the simpler approach of compiling from the binary <a class="indexterm"></a> <a class="indexterm"></a>tree. As you can see,
          complications arise immediately (and seem to get worse and worse)
          when trying to compile from the source tree.</p></div></div></div></div></div>
<div id="OEBPS/ch08s02.html"><div>
<div class="sect1" title="只读源"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08s02.html.make3-CHP-8-SECT-2"></a>只读源</h1><h1 class="title"><a></a>Read-Only Source</h1></div></div></div><p>一旦源代码和二进制文件<a id="OEBPS/ch08s02.html.make3-CHP-8-ITERM-1446" class="indexterm"></a> <a id="OEBPS/ch08s02.html.make3-CHP-8-ITERM-1447" class="indexterm"></a>树是分开的，如果构建生成的唯一文件是放置在输出树中的二进制文件，则将参考源树设置为只读的能力通常是免费的。但是，如果生成了源文件，那么我们必须注意将它们放置在二叉树中。</p><p>Once the source and binary <a class="indexterm"></a> <a class="indexterm"></a>trees are separate, the ability to make a reference
        source tree read-only often comes for free if the only files generated
        by the build are the binary files placed in the output tree. However,
        if source files are generated, then we must take care that they are
        placed in the binary tree.</p><p>在更简单的“从二叉树编译”方法中，生成的文件会自动写入二叉树，因为<em class="command">yacc</em>和<em class="command">lex</em>程序是从二叉树执行的。在“从源树编译”方法中，我们被迫为源文件和目标文件提供显式路径，因此指定二叉树文件的路径不需要额外的工作，只是我们必须记住这样做。</p><p>In the simpler "compile from binary tree" approach, the
        generated files are written into the binary tree automatically because
        the <em class="command">yacc</em> and <em class="command">lex</em> programs are executed from the binary
        tree. In the "compile from source tree" approach, we are forced to
        provide explicit paths for our source and target files, so specifying
        the path to a binary tree file is no extra work, except that we must
        remember to do it.</p><p>使参考源树只读的其他障碍通常是我们自己设置的。通常，遗留构建系统将包括在源树中创建文件的操作，因为原始作者没有考虑只读源树的优点。示例包括生成的文档、日志文件和临时文件。将这些文件移动到输出树有时可能很困难，但如果需要从单个源构建多个二叉树，则替代方法是维护多个相同的源树并使它们保持同步。</p><p>The other obstacles to making the reference source tree read
        only are usually self-imposed. Often a legacy build system will
        include actions that create files in the source tree because the
        original author had not considered the advantages to a read-only
        source tree. Examples include generated documentation, log files, and
        temporary files. Moving these files to the output tree can sometimes
        be arduous, but if building multiple binary trees from a single source
        is necessary, the alternative is to maintain multiple, identical
        source trees and keep them in sync.</p></div></div></div>
<div id="OEBPS/ch08s03.html"><div>
<div class="sect1" title="依赖生成"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08s03.html.make3-CHP-8-SECT-3"></a>依赖生成</h1><h1 class="title"><a></a>Dependency Generation</h1></div></div></div><p>我们简单介绍了<a id="OEBPS/ch08s03.html.make3-CHP-8-ITERM-1448" class="indexterm"></a> <a id="OEBPS/ch08s03.html.make3-CHP-8-ITERM-1449" class="indexterm"></a><a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章</a><a class="link" href="#OEBPS/ch02s07.html" title="自动依赖生成">2.7 节</a>中的依赖项生成，但它留下了几个未解决的问题。因此，本节为已经描述的简单解决方案提供了一些替代方案。<sup>[ </sup><sup><a id="OEBPS/ch08s03.html.make3-CHP-8-FNOTE-1" href="#OEBPS/ch08s03.html.ftn.make3-CHP-8-FNOTE-1" class="footnote">1</a></sup><sup> ]</sup>特别是，前面描述的简单方法和<acronym class="acronym">GNU </acronym><em class="command">make</em>
        手册中存在以下缺陷：<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a><sup><a id="OEBPS/ch08s03.html.make3-CHP-8-FNOTE-1" href="#OEBPS/ch08s03.html.ftn.make3-CHP-8-FNOTE-1" class="footnote"></a></sup><acronym class="acronym"></acronym> <em class="command"></em></p><p>We gave a brief introduction to <a class="indexterm"></a> <a class="indexterm"></a>dependency generation in the <a class="link" href="#OEBPS/ch02s07.html" title="Automatic Dependency Generation">Section 2.7</a> in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>, but it left several problems
        unaddressed. Therefore, this section offers some alternatives to the
        simple solution already described.<sup>[<a href="#OEBPS/ch08s03.html.ftn.make3-CHP-8-FNOTE-1" class="footnote">1</a>]</sup> In particular, the simple approach described earlier and
        in the <acronym class="acronym">GNU</acronym> <em class="command">make</em>
        manual suffer from these failings:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>这是低效的。当<em class="command">make</em>发现依赖文件丢失或过期时，它会更新<em class="filename">.d</em>文件并自行重新启动。如果在读取 makefile
            <em class="filename">和</em>分析依赖关系图期间执行许多任务，则重新读取<em class="filename">makefile 的效率可能会很低。</em><em class="filename"></em></p></li><li class="listitem"><p>It is inefficient. When <em class="command">make</em> discovers that a dependency file is
            missing or out of date, it updates the <em class="filename">.d</em> file and restarts itself. Rereading
            the <em class="filename">makefile</em> can be
            inefficient if it performs many tasks during the reading of the
            <em class="filename">makefile</em> and the analysis of
            the dependency graph.</p></li><li class="listitem"><p><em class="command"></em>当您第一次构建目标以及每次添加新的源文件时，<em class="command">make</em>都会生成警告。此时，与新源文件关联的依赖文件尚不存在，因此当<em class="command">make</em>尝试读取依赖文件时，它将在生成依赖文件之前生成一条警告消息。这并不致命，只是令人恼火。</p></li><li class="listitem"><p><em class="command">make</em> generates a warning
            when you build a target for the first time and each time you add
            new source files. At these times the dependency file associated
            with a new source file does not yet exist, so when <em class="command">make</em> attempts to read the dependency
            file it will produce a warning message before generating the
            dependency file. This is not fatal, merely irritating.</p></li><li class="listitem"><p>如果删除源文件，<em class="command">make 将</em>在后续构建过程中停止并出现致命错误。在这种情况下，存在一个包含已删除文件的依赖文件作为先决条件。由于<em class="command">make</em>找不到删除的文件并且不知道如何制作它，因此<em class="command">make</em>打印以下消息：</p><a id="OEBPS/ch08s03.html.I_3_tt378"></a><pre class="programlisting">make: *** 没有规则可以生成 foo.d 需要的目标 foo.h。停止。</pre></li><li class="listitem"><p>If you remove a source file, <em class="command">make</em> stops with a fatal error during
            subsequent builds. In this situation, there exists a dependency
            file containing the removed file as a prerequisite. Since <em class="command">make</em> cannot find the removed file and
            doesn't know how to make it, <em class="command">make</em> prints the message:</p><a></a><pre class="programlisting">make: *** No rule to make target foo.h, needed by foo.d.  Stop.</pre></li><li class="listitem"><p>此外，由于此错误，<em class="command">make</em>无法重建依赖文件。唯一的办法是手动删除依赖文件，但由于这些文件通常很难找到，用户通常会删除所有依赖文件并执行干净的构建。文件重命名时也会出现此错误。</p></li><li class="listitem"><p>Furthermore, <em class="command">make</em> cannot
            rebuild the dependency file because of this error. The only
            recourse is to remove the dependency file by hand, but since these
            files are often hard to find, users typically delete all the
            dependency files and perform a clean build. This error also occurs
            when files are renamed.</p></li><li class="listitem"><p><em class="filename">请注意，此问题在删除或重命名头文件而不是.c</em>文件时最为明显。这是因为<em class="filename">.c</em>文件将自动从依赖文件列表中删除，不会影响构建。</p></li><li class="listitem"><p>Note that this problem is most noticeable with removed or
            renamed header files rather than <em class="filename">.c</em> files. This is because <em class="filename">.c</em> files will be removed from the list
            of dependency files automatically and will not trouble the
            build.</p></li></ul></div><div class="sect2" title="特罗米之路"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch08s03.html.make3-CHP-8-SECT-3.1"></a>特罗米之路</h2><h2 class="title"><a></a>Tromey's Way</h2></div></div></div><p>让我们分别解决这些问题。</p><p>Let's address these problems individually.</p><p>我们怎样才能避免重新启动<em class="command">make</em>呢？</p><p>How can we avoid restarting <em class="command">make</em>?</p><p>仔细考虑一下，我们发现重新启动<em class="command">make</em>是没有必要的。如果更新了依赖文件，则意味着至少其先决条件之一已更改，这意味着我们必须更新目标。在执行<em class="command">make</em>时不需要了解更多信息，因为更多的依赖信息不会改变<em class="command">make</em>的行为。但我们希望更新依赖文件，以便下次运行<em class="command">make</em>将具有完整的依赖信息。</p><p>On careful consideration, we can see that restarting <em class="command">make</em> is unnecessary. If a dependency file
          is updated, it means that at least one of its prerequisites has
          changed, which means we must update the target. Knowing more than
          that isn't necessary in this execution of <em class="command">make</em> because more dependency information
          won't change <em class="command">make</em>'s behavior. But
          we want the dependency file updated so that the next run of <em class="command">make</em> will have complete dependency
          information.</p><p><em class="command">由于我们在执行make</em>时不需要依赖文件
          ，因此我们可以在更新目标的同时生成该文件。我们可以通过重写编译规则来更新依赖文件来做到这一点。</p><p>Since we don't need the dependency file in this execution of
          <em class="command">make</em>, we could generate the file
          at the same time as we update the target. We can do this by
          rewriting the compilation rule to also update the dependency
          file.</p><a id="OEBPS/ch08s03.html.I_3_tt379"></a><pre class="programlisting"># $(调用 make-depend,源文件,目标文件,依赖文件)
定义 make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 | \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' &gt; $3.tmp
  $(MV) $3.tmp $3
恩德夫

%.o: %.c
        $(调用 make-depend,$&lt;,$@,$(subst .o,.d,$@))
        $(COMPILE.c) -o $@ $&lt;</pre><pre class="programlisting"># $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 | \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' &gt; $3.tmp
  $(MV) $3.tmp $3
endef

%.o: %.c
        $(call make-depend,$&lt;,$@,$(subst .o,.d,$@))
        $(COMPILE.c) -o $@ $&lt;</pre><p><code class="function">make-depend</code>我们使用接受源、对象和依赖文件名的函数来实现依赖项生成功能。如果我们稍后需要在不同的上下文中重用该函数，这可以提供最大的灵活性。当我们这样修改编译规则时，我们必须删除<code class="literal">%.d: %.c</code>我们编写的模式规则，以避免生成两次依赖文件。</p><p>We implement the dependency generation feature with the
          function <code class="function">make-depend</code> that
          accepts the source, object, and dependency filenames. This provides
          maximum flexibility if we need to reuse the function later in a
          different context. When we modify our compilation rule this way, we
          must delete the <code class="literal">%.d: %.c</code> pattern
          rule we wrote to avoid generating the dependency files twice.</p><p>现在，目标文件和依赖文件在逻辑上链接在一起：如果一个存在，则另一个也必须存在。因此，我们并不真正关心依赖文件是否丢失。如果是，则目标文件也丢失，并且两者都将在下一个构建时更新。因此，我们现在可以忽略因缺少<em class="filename">.d</em>文件而导致的任何警告。</p><p>Now, the object file and dependency file are logically linked:
          if one exists the other must exist. Therefore, we don't really care
          if a dependency file is missing. If it is, the object file is also
          missing and both will be updated by the next build. So we can now
          ignore any warnings that result from missing <em class="filename">.d</em> files.</p><p>在<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏">第 3 章</a>
          的<a class="link" href="#OEBPS/ch03s07.html.make3-CHP-3-SECT-7.2" title="包含和依赖关系">3.7.2 节</a>中，我介绍了
          指令的另一种形式（或），它忽略错误并且不生成警告：<a class="link" href="#OEBPS/ch03.html" title="第 3 章变量和宏"></a><code class="literal">include</code><code class="literal">-include</code><code class="literal">sinclude</code></p><p>In <a class="link" href="#OEBPS/ch03s07.html.make3-CHP-3-SECT-7.2" title="include and Dependencies">Section 3.7.2</a>
          in <a class="link" href="#OEBPS/ch03.html" title="Chapter&nbsp;3.&nbsp;Variables and Macros">Chapter 3</a>, I introduced an
          alternate form of <code class="literal">include</code>
          directive, <code class="literal">-include</code> (or <code class="literal">sinclude</code>), that ignores errors and does
          not generate warnings:</p><a id="OEBPS/ch08s03.html.I_3_tt380"></a><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "干净"
  -包括$（依赖项）
万一</pre><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif</pre><p>这解决了第二个问题，即当依赖文件尚不存在时出现烦人的消息。</p><p>This solves the second problem, that of an annoying message
          when a dependency file does not yet exist.</p><p>最后，当发现缺少先决条件时，我们可以通过一些技巧来避免警告。诀窍是为丢失的文件创建一个没有先决条件和命令的目标。例如，假设我们的依赖文件生成器创建了此依赖项：</p><p>Finally, we can avoid the warning when missing prerequisites
          are discovered with a little trickery. The trick is to create a
          target for the missing file that has no prerequisites and no
          commands. For example, suppose our dependency file generator has
          created this dependency:</p><a id="OEBPS/ch08s03.html.I_3_tt381"></a><pre class="programlisting">target.o target.d: header.h</pre><pre class="programlisting">target.o target.d: header.h</pre><p>现在假设，由于代码重构，<em class="filename">header.h</em>不再存在。下次我们运行<em class="filename">makefile</em>时，我们会收到错误：</p><p>Now suppose that, due to code refactoring, <em class="filename">header.h</em> no longer exists. The next time
          we run the <em class="filename">makefile</em> we'll get
          the error:</p><a id="OEBPS/ch08s03.html.I_3_tt382"></a><pre class="programlisting">make: *** 没有规则可以生成 target.d 所需的目标 header.h。停止。</pre><pre class="programlisting">make: *** No rule to make target header.h, needed by target.d.  Stop.</pre><p><em class="filename">但如果我们将一个没有header.h</em>命令的目标添加到依赖文件中，则不会出现错误：</p><p>But if we add a target with no command for <em class="filename">header.h</em> to the dependency file, the
          error does not occur:</p><a id="OEBPS/ch08s03.html.I_3_tt383"></a><pre class="programlisting">target.o target.d: header.h
标头.h：</pre><pre class="programlisting">target.o target.d: header.h
header.h:</pre><p>这是因为，如果<em class="filename">header.h</em>不存在，它将被简单地视为过时，并且使用它作为先决条件的任何目标都将被更新。因此依赖文件将重新生成，而没有<em class="filename">header.h，</em>
          因为它不再被引用。如果<em class="filename">header.h</em>确实存在，<em class="command">make</em>会认为它是最新的并继续。因此，我们需要做的就是确保每个先决条件都有一个关联的空规则。您可能还记得，我们第一次遇到这种规则是在<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则">第 2 章的</a><a class="link" href="#OEBPS/ch02.html.make3-CHP-2-SECT-1.2" title="虚假目标">2.1.2 节</a>中。这是添加新目标的版本
          ：<a class="link" href="#OEBPS/ch02.html" title="第 2 章 规则"></a><code class="function">make-depend</code></p><p>This is because, if <em class="filename">header.h</em> does not exist, it will simply
          be considered out of date and any targets that use it as a
          prerequisite will be updated. So the dependency file will be
          regenerated without <em class="filename">header.h</em>
          because it is no longer referenced. If <em class="filename">header.h</em> does exist, <em class="command">make</em> considers it up to date and
          continues. So, all we need to do is ensure that every prerequisite
          has an associated empty rule. You may recall that we first
          encountered this kind of rule in <a class="link" href="#OEBPS/ch02.html.make3-CHP-2-SECT-1.2" title="Phony Targets">Section 2.1.2</a> in <a class="link" href="#OEBPS/ch02.html" title="Chapter&nbsp;2.&nbsp;Rules">Chapter 2</a>. Here is a version of
          <code class="function">make-depend</code> that adds the new
          targets:</p><a id="OEBPS/ch08s03.html.I_3_tt384"></a><pre class="programlisting"># $(调用 make-depend,源文件,目标文件,依赖文件)
定义 make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 | \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' &gt; $3.tmp
  $(SED) -e 's/#.*//' \
         -e 's/^[^:]*: *//' \
         -e's/*\\$$$$//'\
         -e '/^$$$$/ d' \
         -e 's/$$$$/ :/' $3.tmp &gt;&gt; $3.tmp
  $(MV) $3.tmp $3
恩德夫</pre><pre class="programlisting"># $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -M $1 |        \
  $(SED) 's,\($$(notdir $2)\) *:,$$(dir $2) $3: ,' &gt; $3.tmp
  $(SED) -e 's/#.*//'                                       \
         -e 's/^[^:]*: *//'                                 \
         -e 's/ *\\$$$$//'                                  \
         -e '/^$$$$/ d'                                     \
         -e 's/$$$$/ :/' $3.tmp &gt;&gt; $3.tmp
  $(MV) $3.tmp $3
endef</pre><p>我们对依赖文件执行新的<em class="command">sed</em>
          命令来生成附加规则。这块<em class="command">sed</em>代码执行五次转换：</p><p>We execute a new <em class="command">sed</em>
          command on the dependency file to generate the additional rules.
          This chunk of <em class="command">sed</em> code performs
          five transformations:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>删除评论</p></li><li class="listitem"><p>Deletes comments</p></li><li class="listitem"><p>删除目标文件和后续空格</p></li><li class="listitem"><p>Deletes the target file(s) and subsequent spaces</p></li><li class="listitem"><p>删除尾随空格</p></li><li class="listitem"><p>Deletes trailing spaces</p></li><li class="listitem"><p>删除空行</p></li><li class="listitem"><p>Deletes blank lines</p></li><li class="listitem"><p>在每行末尾添加一个冒号</p></li><li class="listitem"><p>Adds a colon to the end of every line</p></li></ol></div><p>（<acronym class="acronym">GNU </acronym> <em class="command">sed</em>
          能够在单个命令行中读取文件并附加到该文件，从而使我们不必使用第二个临时文件。此功能可能无法在其他系统上工作。）新的<em class="command">sed</em>命令将接受看起来像的输入喜欢：</p><p>(<acronym class="acronym">GNU</acronym> <em class="command">sed</em>
          is able to read from a file and append to it in a single command
          line, saving us from having to use a second temporary file. This
          feature may not work on other systems.) The new <em class="command">sed</em> command will take input that looks
          like:</p><a id="OEBPS/ch08s03.html.I_3_tt385"></a><pre class="programlisting">＃ 任何意见
target.o target.d: prereq1 prereq2 prereq3 \
     先决条件4</pre><pre class="programlisting"># any comments
target.o target.d: prereq1 prereq2 prereq3 \
     prereq4</pre><p>并将其转化为：</p><p>and transform it into:</p><a id="OEBPS/ch08s03.html.I_3_tt386"></a><pre class="programlisting">先决条件1 先决条件2 先决条件3：
先决条件4：</pre><pre class="programlisting">prereq1 prereq2 prereq3:
prereq4:</pre><p>因此，<code class="function">make-depend</code>将这个新输出附加到原始依赖文件中。这解决了“没有规则来创建目标”错误。</p><p>So <code class="function">make-depend</code> appends
          this new output to the original dependency file. This solves the "No
          rule to make target" error.</p></div><div class="sect2" title="依赖程序"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch08s03.html.make3-CHP-8-SECT-3.2"></a>依赖程序</h2><h2 class="title"><a></a>makedepend Programs</h2></div></div></div><p>到现在为止我们已经<a id="OEBPS/ch08s03.html.make3-CHP-8-ITERM-1450" class="indexterm"></a>内容是使用<code class="option">-M</code>大多数编译器提供的选项，但是如果这个选项不存在怎么办？或者，还有比我们的简单更好的选择吗
          <code class="option">-M</code>？</p><p>Up to now we have been <a class="indexterm"></a>content to use the <code class="option">-M</code> option provided
          by most compilers, but what if this option doesn't exist?
          Alternatively, are there better options than our simple
          <code class="option">-M</code>?</p><p>如今，大多数 C 编译器都支持从源代码生成
          <em class="command">make</em>依赖项，但不久前这还不是真的。在 X Window System 项目的早期，他们实现了一个工具<em class="command">makedepend</em>，用于计算一组 C 或 C++ 源代码的依赖关系。该工具可通过互联网免费获得。使用<em class="command">makedepend</em>有点尴尬，因为它被编写为将其输出附加到
          <em class="filename">makefile</em>，而我们不想这样做。<em class="command">makedepend</em>的输出
          假定目标文件与源文件位于同一目录中。这再次意味着我们的<em class="command">sed</em>
          表达式必须改变：</p><p>These days most C compilers have some support for generating
          <em class="command">make</em> dependencies from the
          source, but not long ago this wasn't true. In the early days of the
          X Window System project, they implemented a tool, <em class="command">makedepend</em>, that computes the dependencies
          from a set of C or C++ sources. This tool is freely available over
          the Internet. Using <em class="command">makedepend</em> is
          a little awkward because it is written to append its output to the
          <em class="filename">makefile</em>, which we do not want
          to do. The output of <em class="command">makedepend</em>
          assumes the object files reside in the same directory as the source.
          This means that, again, our <em class="command">sed</em>
          expression must change:</p><a id="OEBPS/ch08s03.html.I_3_tt387"></a><pre class="programlisting"># $(调用 make-depend,源文件,目标文件,依赖文件)
定义 make-depend
  $(MAKEDEPEND) -f- $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) $1 | \
  $(SED) 's,^.*/\([^/]*\.o\) *:,$(dir $2)\1 $3: ,' &gt; $3.tmp
  $(SED) -e 's/#.*//' \
         -e 's/^[^:]*: *//' \
         -e's/*\\$$$$//'\
         -e '/^$$$$/ d' \
         -e 's/$$$$/ :/' $3.tmp &gt;&gt; $3.tmp
  $(MV) $3.tmp $3
恩德夫</pre><pre class="programlisting"># $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(MAKEDEPEND) -f- $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) $1 | \
  $(SED) 's,^.*/\([^/]*\.o\) *:,$(dir $2)\1 $3: ,' &gt; $3.tmp
  $(SED) -e 's/#.*//'                                         \
         -e 's/^[^:]*: *//'                                   \
         -e 's/ *\\$$$$//'                                    \
         -e '/^$$$$/ d'                                       \
         -e 's/$$$$/ :/' $3.tmp &gt;&gt; $3.tmp
  $(MV) $3.tmp $3
endef</pre><p>该<code class="option">-f-</code>选项告诉<em class="command">makedepend</em>将其依赖关系信息写入标准输出。</p><p>The <code class="option">-f-</code> option tells <em class="command">makedepend</em> to write its dependency
          information to the standard output.</p><p><em class="command">使用makedepend</em>或本机编译器的替代方法是使用<em class="command">gcc</em>。它提供了一组令人眼花缭乱的选项来生成依赖性信息。最适合我们当前要求的是：</p><p>An alternative to using <em class="command">makedepend</em> or your native compiler is to
          use <em class="command">gcc</em>. It sports a bewildering
          set of options for generating dependency information. The ones that
          seem most apropos for our current requirements are:</p><a id="OEBPS/ch08s03.html.I_3_tt388"></a><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "干净"
  -包括$（依赖项）
万一

# $(调用 make-depend,源文件,目标文件,依赖文件)
定义 make-depend
  $(GCC)-MM \
         -MF $3 \
         -MP \
         -MT $2 \
         $(CFLAGS) \
         $(CPPFLAGS) \
         $(TARGET_ARCH) \
         1 美元
恩德夫

%.o: %.c
        $(调用 make-depend,$&lt;,$@,$(subst .o,.d,$@))
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "clean"
  -include $(dependencies)
endif

# $(call make-depend,source-file,object-file,depend-file)
define make-depend
  $(GCC) -MM            \
         -MF $3         \
         -MP            \
         -MT $2         \
         $(CFLAGS)      \
         $(CPPFLAGS)    \
         $(TARGET_ARCH) \
         $1
endef

%.o: %.c
        $(call make-depend,$&lt;,$@,$(subst .o,.d,$@))
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>该<code class="option">-MM</code>选项导致<em class="command">gcc</em>从先决条件列表中省略“系统”标头。这很有用，因为这些文件很少（如果有的话）发生更改，并且随着构建系统变得更加复杂，减少混乱会有所帮助。最初，这样做可能是出于性能原因。对于当今的处理器，性能差异几乎无法衡量。</p><p>The <code class="option">-MM</code> option causes <em class="command">gcc</em> to omit "system" headers from the
          prerequisites list. This is useful because these files rarely, if
          ever, change and, as the build system gets more complex, reducing
          the clutter helps. Originally, this may have been done for
          performance reasons. With today's processors, the performance
          difference is barely measurable.</p><p>该<code class="option">-MF</code>选项指定依赖文件名。这将是对象文件名，其中<em class="filename">.d</em>后缀替换<em class="filename">.o</em>。还有另一个<em class="command">gcc</em>选项<code class="option">-MD</code>或
          <code class="option">-MMD</code>，可以使用类似的替换自动生成输出文件名。理想情况下，我们更愿意使用此选项，但替换无法包含目标文件目录的正确相对路径，而是将
          <em class="filename">.d</em>文件放置在当前目录中。因此，我们被迫使用
          <code class="option">-MF</code>.</p><p>The <code class="option">-MF</code> option specifies the dependency
          filename. This will be the object filename with the <em class="filename">.d</em> suffix substituted for <em class="filename">.o</em>. There is another <em class="command">gcc</em> option, <code class="option">-MD</code> or
          <code class="option">-MMD</code>, that automatically generates the output
          filename using a similar substitution. Ideally we would prefer to
          use this option, but the substitution fails to include the proper
          relative path to the object file directory and instead places the
          <em class="filename">.d</em> file in the current
          directory. So, we are forced to do the job ourselves using
          <code class="option">-MF</code>.</p><p>该<code class="option">-MP</code>选项指示<em class="command">gcc</em>为每个先决条件包含虚假目标。这完全消除了我们函数中混乱的五部分
          <em class="command">sed</em><code class="function">make-depend</code>表达式。似乎是
          发明假目标技术的<em class="command">automake</em>开发人员导致将此选项添加到
          <em class="command">gcc</em>中。</p><p>The <code class="option">-MP</code> option instructs <em class="command">gcc</em> to include phony targets for each
          prerequisite. This completely eliminates the messy five-part
          <em class="command">sed</em> expression in our <code class="function">make-depend</code> function. It seems that the
          <em class="command">automake</em> developers who invented
          the phony target technique caused this option to be added to
          <em class="command">gcc</em>.</p><p>最后，该<code class="option">-MT</code>选项指定用于依赖文件中的目标的字符串。同样，如果没有此选项，<em class="command">gcc</em>将无法包含目标文件输出目录的相对路径。</p><p>Finally, the <code class="option">-MT</code> option specifies the string
          to use for the target in the dependency file. Again, without this
          option, <em class="command">gcc</em> fails to include the
          relative path to the object file output directory.</p><p>通过使用<em class="command">gcc</em>，我们可以将以前生成依赖项所需的四个命令减少为单个命令。即使使用专有编译器，也可以使用<em class="command">gcc</em>进行依赖性管理。</p><p>By using <em class="command">gcc</em>, we can reduce
          the four commands previously required for dependency generation to a
          single command. Even when proprietary compilers are used it may be
          possible to use <em class="command">gcc</em> for
          dependency management.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch08s03.html.ftn.make3-CHP-8-FNOTE-1" href="#OEBPS/ch08s03.html.make3-CHP-8-FNOTE-1" class="para">1</a> ]</sup>本节中的大部分材料是 Tom Tromey ( <span class="email"><a class="email" href="#OEBPS/mailto:tromey@cygnus.com">tromey@cygnus.com</a></span> ) 为
            <acronym class="acronym">GNU </acronym> <em class="command">automake</em>
            实用程序发明的，并摘自 Paul Smith（<acronym class="acronym">GNU </acronym> <em class="command">make</em>的维护者）在他的网站<a class="ulink" href="http://make.paulandlesley.org/">http上发表的优秀总结文章。 ://make.paulandlesley.org</a>。</p><p><sup>[<a href="#OEBPS/ch08s03.html.make3-CHP-8-FNOTE-1" class="para">1</a>] </sup>Much of the material in this section was invented by Tom
            Tromey (<span class="email"><a class="email" href="#OEBPS/mailto:tromey@cygnus.com">tromey@cygnus.com</a></span>) for the
            <acronym class="acronym">GNU</acronym> <em class="command">automake</em>
            utility and is taken from the excellent summary article by Paul
            Smith (the maintainer of <acronym class="acronym">GNU</acronym> <em class="command">make</em>) from his web site <a class="ulink" href="http://make.paulandlesley.org">http://make.paulandlesley.org</a>.</p></div></div></div></div></div>
<div id="OEBPS/ch08s04.html"><div>
<div class="sect1" title="支持多个二叉树"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08s04.html.make3-CHP-8-SECT-4"></a>支持多个二叉树</h1><h1 class="title"><a></a>Supporting Multiple Binary Trees</h1></div></div></div><p>一旦<em class="filename">makefile</em>修改为写入<a id="OEBPS/ch08s04.html.make3-CHP-8-ITERM-1451" class="indexterm"></a>将二进制文件放入单独的树中，支持许多树变得相当简单。对于交互式或开发人员调用的构建，开发人员从键盘启动构建，几乎不需要任何准备。开发人员创建输出目录，<em class="command">通过 cd</em>进入该目录并
        在<em class="filename">makefile</em>上调用<em class="command">make</em>。<em class="filename"></em></p><p>Once the <em class="filename">makefile</em> is
        modified to write <a class="indexterm"></a>binary files into a separate tree, supporting many trees
        becomes quite simple. For interactive or developer-invoked builds,
        where a developer initiates a build from the keyboard, there is little
        or no preparation required. The developer creates the output
        directory, <em class="command">cd</em>'s to it and invokes
        <em class="command">make</em> on the <em class="filename">makefile</em>.</p><a id="OEBPS/ch08s04.html.I_3_tt389"></a><pre class="programlisting">$$$<strong class="userinput"><code>mkdir -p ~/work/mp3_player_out</code></strong>
​<strong class="userinput"><code>cd ~/work/mp3_player_out</code></strong>
​<strong class="userinput"><code>make -f ~/work/mp3_player/makefile</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>mkdir -p ~/work/mp3_player_out</code></strong>
$ <strong class="userinput"><code>cd ~/work/mp3_player_out</code></strong>
$ <strong class="userinput"><code>make -f ~/work/mp3_player/makefile</code></strong></pre><p>如果过程比这更复杂，那么 shell 脚本包装器通常是最好的解决方案。该包装器还可以解析当前目录并设置一个环境变量，供<em class="filename">makefile</em><code class="literal">BINARY_DIR</code>使用。<em class="filename"></em></p><p>If the process is more involved than this, then a shell script
        wrapper is usually the best solution. This wrapper can also parse the
        current directory and set an environment variable like <code class="literal">BINARY_DIR</code> for use by the <em class="filename">makefile</em>.</p><a id="OEBPS/ch08s04.html.I_3_tt390"></a><pre class="programlisting">#！ /bin/bash

# 假设我们位于源目录中。
当前=$PWD
导出 SOURCE_DIR=$curr
而[[ $SOURCE_DIR ]]
做
  if [[ -e $SOURCE_DIR/[Mm]akefile ]]
  然后
    休息;
  菲
  SOURCE_DIR=${SOURCE_DIR%/*}
完毕

# 如果我们没有找到 makefile，则打印错误。
如果 [[ ！ $SOURCE_DIR ]]
然后
  printf "run-make: 找不到 makefile" &gt; /dev/stderr
  1号出口
菲

# 如果未设置，则将输出目录设置为默认值。
如果 [[ ！ $BINARY_DIR ]]
然后
  BINARY_DIR=${SOURCE_DIR}_out
菲

# 创建输出目录
mkdir --parents $BINARY_DIR

# 运行 make.
make --directory="$BINARY_DIR" "$@"</pre><pre class="programlisting">#! /bin/bash

# Assume we are in the source directory.
curr=$PWD
export SOURCE_DIR=$curr
while [[ $SOURCE_DIR ]]
do
  if [[ -e $SOURCE_DIR/[Mm]akefile ]]
  then
    break;
  fi
  SOURCE_DIR=${SOURCE_DIR%/*}
done

# Print an error if we haven't found a makefile.
if [[ ! $SOURCE_DIR ]]
then
  printf "run-make: Cannot find a makefile" &gt; /dev/stderr
  exit 1
fi

# Set the output directory to a default, if not set.
if [[ ! $BINARY_DIR ]]
then
  BINARY_DIR=${SOURCE_DIR}_out
fi

# Create the output directory
mkdir --parents $BINARY_DIR

# Run the make.
make --directory="$BINARY_DIR" "$@"</pre><p>这个特殊的脚本有点奇特。它首先在当前目录中搜索
        <em class="filename">makefile</em>，然后在树上的父目录中搜索，直到
        找到<em class="filename">makefile</em> 。然后它检查二叉树的变量是否已设置。如果没有，则通过将“_out”附加到源目录来设置。然后该脚本创建输出目录并执行<em class="command">make</em>。</p><p>This particular script is a bit fancier. It searches for the
        <em class="filename">makefile</em> first in the current
        directory and then in the parent directory on up the tree until a
        <em class="filename">makefile</em> is found. It then checks
        that the variable for the binary tree is set. If not, it is set by
        appending "_out" to the source directory. The script then creates the
        output directory and executes <em class="command">make</em>.</p><p>如果构建是在不同平台上执行的，则需要某种区分平台的方法。最简单的方法是要求开发人员为每种类型的平台设置一个环境变量，并根据该变量在<em class="filename">makefile</em>和源代码中添加条件。更好的方法是根据<em class="command">uname</em>的输出自动设置平台类型。</p><p>If the build is being performed on different platforms, some
        method for differentiating between platforms is required. The simplest
        approach is to require the developer to set an environment variable
        for each type of platform and add conditionals to the <em class="filename">makefile</em> and source based on this variable.
        A better approach is to set the platform type automatically based on
        the output of <em class="command">uname</em>.</p><a id="OEBPS/ch08s04.html.I_3_tt391"></a><pre class="programlisting">空间 := $(空) $(空)
导出机器 := $(subst $(空格),-,$(shell uname -smo))</pre><pre class="programlisting">space := $(empty) $(empty)
export MACHINE := $(subst $(space),-,$(shell uname -smo))</pre><p><em class="command">如果从cron</em>自动调用构建，我发现辅助 shell 脚本是比让<em class="command">cron</em>调用<em class="command">make</em>本身更好的方法。包装器脚本为自动构建的设置、错误恢复和完成提供更好的支持。该脚本也是设置变量和命令行参数的合适位置。</p><p>If the builds are being invoked automatically from <em class="command">cron</em>, I've found that a helper shell script
        is a better approach than having <em class="command">cron</em> invoke <em class="command">make</em> itself. A wrapper script provides
        better support for setup, error recovery, and finalization of an
        automated build. The script is also an appropriate place to set
        variables and command-line parameters.</p><p>最后，如果项目支持一组固定的树和平台，您可以使用目录名称来自动识别当前构建。例如：</p><p>Finally, if a project supports a fixed set of trees and
        platforms, you can use directory names to automatically identify the
        current build. For example:</p><a id="OEBPS/ch08s04.html.I_3_tt392"></a><pre class="programlisting">ALL_TREES := /builds/hp-386-windows-optimized \
             /builds/hp-386-windows-debug \
             /builds/sgi-irix-optimzed \
             /builds/sgi-irix-debug \
             /builds/sun-solaris8-profiled \
             /builds/sun-solaris8-debug

BINARY_DIR := $(foreach t,$(ALL_TREES),\
                $(过滤器$(ALL_TREES)/%,$(CURDIR)))

BUILD_TYPE := $(notdir $(subst -,/,$(BINARY_DIR)))

MACHINE_TYPE := $(条\
                  $(替换/,-,\
                    $(patsubst %/,%, \
                      $(目录\
                        $(替换-,/,\
                          $(notdir $(BINARY_DIR)))))))</pre><pre class="programlisting">ALL_TREES := /builds/hp-386-windows-optimized \
             /builds/hp-386-windows-debug     \
             /builds/sgi-irix-optimzed        \
             /builds/sgi-irix-debug           \
             /builds/sun-solaris8-profiled    \
             /builds/sun-solaris8-debug

BINARY_DIR := $(foreach t,$(ALL_TREES),\
                $(filter $(ALL_TREES)/%,$(CURDIR)))

BUILD_TYPE := $(notdir $(subst -,/,$(BINARY_DIR)))

MACHINE_TYPE := $(strip                         \
                  $(subst /,-,                  \
                    $(patsubst %/,%,            \
                      $(dir                     \
                        $(subst -,/,            \
                          $(notdir $(BINARY_DIR)))))))</pre><p>该<code class="literal">ALL_TREES</code>变量保存一个<a id="OEBPS/ch08s04.html.make3-CHP-8-ITERM-1452" class="indexterm"></a> <a id="OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453" class="indexterm"></a> <a id="OEBPS/ch08s04.html.make3-CHP-8-ITERM-1454" class="indexterm"></a>所有有效二叉树的列表。该<code class="function">foreach</code>循环将当前目录与每个有效的二叉树进行匹配。只有一个可以匹配。一旦识别了二叉树，我们就可以从构建目录名称中提取构建类型（例如，优化、调试或分析）。我们通过将破折号分隔的单词转换为斜杠分隔的单词并使用<code class="function">notdir</code>.获取最后一个单词来检索目录名称的最后一个组成部分。类似地，我们通过抓取最后一个单词并使用相同的技术删除最后一个破折号组件来检索机器类型。</p><p>The <code class="literal">ALL_TREES</code> variable holds
        a <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>list of all valid binary trees. The <code class="function">foreach</code> loop matches the current directory
        against each of the valid binary trees. Only one can match. Once the
        binary tree has been identified, we can extract the build type (e.g.,
        optimized, debug, or profiled) from the build directory name. We
        retrieve the last component of the directory name by transforming the
        dash-separated words into slash-separated words and grabbing the last
        word with <code class="function">notdir</code>. Similarly, we
        retrieve the machine type by grabbing the last word and using the same
        technique to remove the last dash component.</p></div></div></div>
<div id="OEBPS/ch08s05.html"><div>
<div class="sect1" title="部分源树"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08s05.html.make3-CHP-8-SECT-5"></a>部分源树</h1><h1 class="title"><a></a>Partial Source Trees</h1></div></div></div><p>在真正的大型项目中，<a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1455" class="indexterm"></a> <a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1456" class="indexterm"></a>仅仅检查和维护源代码可能会给开发人员带来负担。如果一个系统由许多模块组成，并且特定的开发人员只修改其中的局部部分，那么检查和编译整个项目可能会花费大量时间。相反，每晚执行的集中管理构建可用于填补开发人员的源代码和二叉树中的漏洞。</p><p>On really large projects, <a class="indexterm"></a> <a class="indexterm"></a>just checking out and maintaining the source can be a
        burden on developers. If a system consists of many modules and a
        particular developer is modifying only a localized part of it,
        checking out and compiling the entire project can be a large time
        sink. Instead, a centrally managed build, performed nightly, can be
        used to fill in the holes in a developer's source and binary
        trees.</p><p>这样做需要两种类型<a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1457" class="indexterm"></a> <a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1458" class="indexterm"></a> <a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1459" class="indexterm"></a> <a id="OEBPS/ch08s05.html.make3-CHP-8-ITERM-1460" class="indexterm"></a>搜索。首先，当编译器需要缺少的头文件时，必须指示它在参考源代码树中进行搜索。其次，当<em class="filename">makefile</em>
        需要缺少的库时，必须告诉它在引用二叉树中搜索。为了帮助编译器找到源代码，我们可以简单地在
        指定本地目录的选项<code class="option">-I</code>后面添加附加选项。<code class="option">-I</code>为了帮助<em class="command">查找</em>库，我们可以向<code class="literal">vpath</code>.</p><p>Doing so requires two types of <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>search. First, when a missing header file is required by
        the compiler, it must be instructed to search in the reference source
        tree. Second, when the <em class="filename">makefile</em>
        requires a missing library, it must be told to search in the reference
        binary tree. To help the compiler find source, we can simply add
        additional <code class="option">-I</code> options after the <code class="option">-I</code>
        options specifying local directories. To help <em class="command">make</em> find libraries, we can add additional
        directories to the <code class="literal">vpath</code>.</p><a id="OEBPS/ch08s05.html.I_3_tt393"></a><pre class="programlisting">SOURCE_DIR := ../mp3_player
REF_SOURCE_DIR := /reftree/src/mp3_player
REF_BINARY_DIR := /binaries/mp3_player
...
include_dirs := lib $(SOURCE_DIR)/lib $(SOURCE_DIR)/include
CPPFLAGS += $(addprefix -I ,$(include_dirs)) \
                $(addprefix -I $(REF_SOURCE_DIR)/,$(include_dirs))
vpath %.h $(include_dirs) \
                $(addprefix $(REF_SOURCE_DIR)/,$(include_dirs))

vpath %.a $(addprefix $(REF_BINARY_DIR)/lib/，编解码器 db ui)</pre><pre class="programlisting">SOURCE_DIR     := ../mp3_player
REF_SOURCE_DIR := /reftree/src/mp3_player
REF_BINARY_DIR := /binaries/mp3_player
...
include_dirs := lib $(SOURCE_DIR)/lib $(SOURCE_DIR)/include
CPPFLAGS     += $(addprefix -I ,$(include_dirs))                  \
                $(addprefix -I $(REF_SOURCE_DIR)/,$(include_dirs))
vpath %.h       $(include_dirs)                                   \
                $(addprefix $(REF_SOURCE_DIR)/,$(include_dirs))

vpath %.a       $(addprefix $(REF_BINARY_DIR)/lib/, codec db ui)</pre><p>此方法假设 CVS 签出的“粒度”是库或程序模块。在这种情况下，如果开发人员选择不检查丢失的库和程序目录，则可以设计为跳过它们<em class="command">。</em>当需要使用这些库时，搜索路径将自动填充丢失的文件。</p><p>This approach assumes that the "granularity" of a CVS check out
        is a library or program module. In this case, the <em class="command">make</em> can be contrived to skip missing
        library and program directories if a developer has chosen not to check
        them out. When it comes time to use these libraries, the search path
        will automatically fill in the missing files.</p><p>在<em class="filename">makefile</em>中，该
        变量列出了要搜索<em class="filename">module.mk</em><code class="literal">modules</code>文件的子目录集。如果未签出子目录，则必须编辑此列表以删除子目录。或者，<em class="filename">模块</em>
        变量可以通过通配符设置：<em class="filename"></em><em class="filename"></em></p><p>In the <em class="filename">makefile</em>, the
        <code class="literal">modules</code> variable lists the set of
        subdirectories to be searched for <em class="filename">module.mk</em> files. If a subdirectory is not
        checked out, this list must be edited to remove the subdirectory.
        Alternatively, the <em class="filename">modules</em>
        variable can be set by wildcard:</p><a id="OEBPS/ch08s05.html.I_3_tt394"></a><pre class="programlisting">模块 := $(dir $(通配符 lib/*/module.mk))</pre><pre class="programlisting">modules := $(dir $(wildcard lib/*/module.mk))</pre><p><em class="filename">该表达式将查找包含module.mk</em>文件的所有子目录
        并返回目录列表。请注意，由于该<code class="function">dir</code>函数的工作原理，每个目录都将包含一个尾部斜杠。</p><p>This expression will find all the subdirectories containing a
        <em class="filename">module.mk</em> file and return the
        directory list. Note that because of how the <code class="function">dir</code> function works, each directory will
        contain a trailing slash.</p><p><em class="command">make</em>还可以
        在单​​个文件级别管理部分源代码树，通过从本地开发人员树中收集一些目标文件并从引用树中收集丢失的文件来构建库。然而，根据我的经验，这相当混乱，开发人员对此并不满意。</p><p>It is also possible for <em class="command">make</em>
        to manage partial source trees at the individual file level, building
        libraries by gathering some object files from a local developer tree
        and missing files from a reference tree. However, this is quite messy
        and developers are not happy with it, in my experience.</p></div></div></div>
<div id="OEBPS/ch08s06.html"><div>
<div class="sect1" title="参考版本、库和安装程序"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch08s06.html.make3-CHP-8-SECT-6"></a>参考版本、库和安装程序</h1><h1 class="title"><a></a>Reference Builds, Libraries, and Installers</h1></div></div></div><p>此时我们已经差不多了<a id="OEBPS/ch08s06.html.make3-CHP-8-ITERM-1461" class="indexterm"></a> <a id="OEBPS/ch08s06.html.make3-CHP-8-ITERM-1462" class="indexterm"></a> <a id="OEBPS/ch08s06.html.make3-CHP-8-ITERM-1463" class="indexterm"></a> <a id="OEBPS/ch08s06.html.make3-CHP-8-ITERM-1464" class="indexterm"></a>涵盖了实现参考构建所需的一切。自定义单个顶级<em class="filename">makefile</em>以支持该功能非常简单。只需将简单作业替换为<code class="literal">SOURCE_DIR</code>和<code class="literal">BINARY_DIR</code>即可<code class="literal">?=</code>。从<em class="command">cron</em>运行的脚本
        可以使用以下基本方法：</p><p>At this point we've pretty much <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>covered everything needed to implement reference builds.
        Customizing the single top-level <em class="filename">makefile</em> to support the feature is
        straightforward. Simply replace the simple assignments to <code class="literal">SOURCE_DIR</code> and <code class="literal">BINARY_DIR</code> with <code class="literal">?=</code> assignments. The scripts you run from
        <em class="command">cron</em> can use this basic
        approach:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>重定向输出并设置日志文件的名称</p></li><li class="listitem"><p>Redirect output and set the names of log files</p></li><li class="listitem"><p>清理旧版本并清理参考源树</p></li><li class="listitem"><p>Clean up old builds and clean the reference source
            tree</p></li><li class="listitem"><p>查看新鲜来源</p></li><li class="listitem"><p>Check out fresh source</p></li><li class="listitem"><p>设置源和二进制目录变量</p></li><li class="listitem"><p>Set the source and binary directory variables</p></li><li class="listitem"><p>调用<code class="literal">make</code></p></li><li class="listitem"><p>Invoke <code class="literal">make</code></p></li><li class="listitem"><p>扫描日志以查找错误</p></li><li class="listitem"><p>Scan the logs for errors</p></li><li class="listitem"><p>计算标签文件，并可能更新定位数据库<sup>[ <a id="OEBPS/ch08s06.html.make3-CHP-8-FNOTE-2" href="#OEBPS/ch08s06.html.ftn.make3-CHP-8-FNOTE-2" class="footnote">2</a> ]</sup></p></li><li class="listitem"><p>Compute tags files, and possibly update the locate
            database<sup>[<a href="#OEBPS/ch08s06.html.ftn.make3-CHP-8-FNOTE-2" class="footnote">2</a>]</sup></p></li><li class="listitem"><p>发布有关构建成功或失败的信息</p></li><li class="listitem"><p>Post information on the success or failure of the
            build</p></li></ol></div><p>在参考构建模型中，维护一组旧构建是很方便的，以防恶意签入破坏树。我通常保留 7 或 14 个夜间构建。当然，夜间构建脚本会将其输出记录到存储在构建本身附近的文件中，并且脚本会清除旧的构建和日志。扫描日志中的错误通常是使用<em class="command">awk</em>脚本完成的。最后，我通常让脚本维护<em class="filename">最新的</em>符号链接。为了确定构建是否有效，我在每个<em class="filename">makefile</em><code class="literal">validate</code>中包含一个目标。该目标执行简单的验证来确定目标是否已构建。<em class="filename"></em></p><p>It is convenient, in the reference build model, to maintain a
        set of old builds in case a rogue check-in corrupts the tree. I
        usually keep 7 or 14 nightly builds. Of course, the nightly build
        script logs its output to files stored near the builds themselves and
        the script purges old builds and logs. Scanning the logs for errors is
        usually done with an <em class="command">awk</em> script.
        Finally, I usually have the script maintain a <em class="filename">latest</em> symbolic link. To determine if the
        build is valid, I include a <code class="literal">validate</code> target in each <em class="filename">makefile</em>. This target performs simple
        validation that the targets were built.</p><a id="OEBPS/ch08s06.html.I_3_tt395"></a><pre class="programlisting">.PHONY：validate_build
验证构建：
        测试 $(foreach f,$(RELEASE_FILES),-s $f -a) -e 。</pre><pre class="programlisting">.PHONY: validate_build
validate_build:
        test $(foreach f,$(RELEASE_FILES),-s $f -a) -e .</pre><p>该命令脚本只是测试一组预期文件是否存在并且不为空。当然，这并不能取代测试，而是对构建进行方便的健全性检查。如果测试返回失败，则<em class="command">make</em>返回失败，并且夜间构建脚本可以保留指向旧构建的<em class="filename">最新符号链接。</em></p><p>This command script simply tests if a set of expected files
        exists and is not empty. Of course, this doesn't take the place of
        testing, but is a convenient sanity check for a build. If the test
        returns failure, the <em class="command">make</em> returns
        failure and the nightly build script can leave the <em class="filename">latest</em> symbolic link pointing to the old
        build.</p><p>第三方库总是有点麻烦<a id="OEBPS/ch08s06.html.make3-CHP-8-ITERM-1465" class="indexterm"></a>管理。我同意一个普遍的观点，即在 CVS 中存储大型二进制文件是不好的。这是因为 CVS 无法将增量存储为差异，并且底层 RCS 文件可能会增长到巨大的大小。 CVS 存储库中的非常大的文件可能会减慢许多常见的 CVS 操作，从而影响所有开发。</p><p>Third-party libraries are always a bit of a hassle <a class="indexterm"></a>to manage. I subscribe to the commonly held belief that
        it is bad to store large binary files in CVS. This is because CVS
        cannot store deltas as diffs and the underlying RCS files can grow to
        enormous size. Very large files in the CVS repository can slow down
        many common CVS operations, thus affecting all development.</p><p>如果第三方库未存储在 CVS 中，则必须以其他方式管理它们。我目前的偏好是在引用树中创建一个库目录，并在目录名称中记录库版本号，如图<a class="link" href="#OEBPS/ch08s06.html.make3-CHP-8-FIG-1" title="图 8-1。第三方库的目录布局">8-1</a>所示。</p><p>If third-party libraries are not stored in CVS, they must be
        managed some other way. My current preference is to create a library
        directory in the reference tree and record the library version number
        in the directory name, as shown in <a class="link" href="#OEBPS/ch08s06.html.make3-CHP-8-FIG-1" title="Figure&nbsp;8-1.&nbsp;Directory layout for third-party libraries">Figure 8-1</a>.</p><div class="figure"><a id="OEBPS/ch08s06.html.make3-CHP-8-FIG-1"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch08s06.html.I_3_tt396"></a><img src="data:image/png;base64,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" height="118" alt="第三方库的目录布局"></div></div><p class="title">图 8-1。第三方库的目录布局</p><p class="title">Figure&nbsp;8-1.&nbsp;Directory layout for third-party libraries</p></div><p><em class="filename">这些目录名称由makefile</em>引用：</p><p>These directory names are referenced by the <em class="filename">makefile</em>:</p><a id="OEBPS/ch08s06.html.I_3_tt397"></a><pre class="programlisting">ORACLE_9011_DIR ?= /reftree/third_party/oracle-9.0.1.1/Ora90
ORACLE_9011_JAR ?= $(ORACLE_9011_DIR)/jdbc/lib/classes12.jar</pre><pre class="programlisting">ORACLE_9011_DIR ?= /reftree/third_party/oracle-9.0.1.1/Ora90
ORACLE_9011_JAR ?= $(ORACLE_9011_DIR)/jdbc/lib/classes12.jar</pre><p>当供应商更新其库时，在引用树中创建一个新目录并在<em class="filename">makefile</em>中声明新变量。这样<em class="filename">makefile</em>始终明确反映正在使用的版本。</p><p>When the vendor updates its libraries, create a new directory in
        the reference tree and declare new variables in the <em class="filename">makefile</em>. This way the <em class="filename">makefile</em>, which is properly maintained with
        tags and branches, always explicitly reflects the versions being
        used.</p><p>安装人员也是一个难题。我相信将基本构建过程与创建安装程序映像分开是一件好事。当前的安装工具既复杂又脆弱。将它们折叠到（通常也是复杂且脆弱的）构建系统中会产生难以维护的系统。相反，基本构建可以将其结果写入“发布”目录，其中包含安装程序构建工具所需的所有（或大部分）数据。该工具可以由其自己的<em class="filename">makefile</em>驱动，最终生成可执行的安装映像。</p><p>Installers are also a difficult issue. I believe that separating
        the basic build process from creating the installer image is a good
        thing. Current installer tools are complex and fragile. Folding them
        into the (also often complex and fragile) build system yields
        difficult-to-maintain systems. Instead, the basic build can write its
        results into a "release" directory that contains all (or most of) the
        data required by the installer build tool. This tool may be driven
        from its own <em class="filename">makefile</em> that
        ultimately yields an executable setup image.</p><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch08s06.html.ftn.make3-CHP-8-FNOTE-2" href="#OEBPS/ch08s06.html.make3-CHP-8-FNOTE-2" class="para">2</a> ]</sup>定位数据库是文件系统上存在的所有文件名的编译。这是一种按名称执行<em class="command">查找</em>的快速方法。我发现这个数据库对于管理大型源代码树非常有价值，并且喜欢在构建完成后每晚更新它。</p><p><sup>[<a href="#OEBPS/ch08s06.html.make3-CHP-8-FNOTE-2" class="para">2</a>] </sup>The locate database is a compilation of all the
                filenames present on a filesystem. It is a fast way of
                performing a <em class="command">find</em> by name.
                I have found this database invaluable for managing large
                source trees and like to have it updated nightly after the
                build has completed.</p></div></div></div></div></div>
<div id="OEBPS/ch09.html"><div>
<div class="chapter" title="第 9 章 Java"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09.html.make3-CHP-9"></a>第 9 章 Java</h1><h1 class="title"><a></a>Chapter&nbsp;9.&nbsp;Java</h1></div></div></div><p>许多 Java 开发人员喜欢<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1466" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1467" class="indexterm"></a>集成开发环境 (IDE)，例如 Eclipse。鉴于 Java IDE 和<em class="command">Ant</em>等众所周知的替代方案，读者很可能会问为什么他们应该考虑在 Java 项目上使用<em class="command">make 。本章探讨了</em><em class="command">make</em>在这些情况下的价值；特别是，它提供了一个通用的<em class="filename">makefile</em> 
      ，只需最少的修改即可将其放入几乎任何 Java 项目中，并执行所有标准的重建任务。</p><p>Many Java developers like <a class="indexterm"></a> <a class="indexterm"></a>Integrated Development Environments (IDEs) such as
      Eclipse. Given such well-known alternatives as Java IDEs and <em class="command">Ant</em>, readers could well ask why they should
      even think of using <em class="command">make</em> on Java
      projects. This chapter explores the value of <em class="command">make</em> in these situations; in particular, it
      presents a generalized <em class="filename">makefile</em>
      that can be dropped into just about any Java project with minimal
      modification and carry out all the standard rebuilding tasks.</p><p>在 Java 中使用<em class="command">make会引发一些问题</em><a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1468" class="indexterm"></a>问题并介绍了一些机会。这主要是由于三个因素：Java 编译器<em class="command">javac</em>非常快；标准Java编译器支持<code class="literal">@filename</code>
      从文件读取“命令行参数”的语法；如果指定了 Java 包，则 Java 语言会指定<em class="filename">.class</em>文件的路径
      。</p><p>Using <em class="command">make</em> with Java raises
      several <a class="indexterm"></a>issues and introduces some opportunities. This is
      primarily due to three factors: the Java compiler, <em class="command">javac</em>, is extremely fast; the standard Java
      compiler supports the <code class="literal">@filename</code>
      syntax for reading "command-line parameters" from a file; and if a Java
      package is specified, the Java language specifies a path to the
      <em class="filename">.class</em> file.</p><p>标准 Java 编译器非常快。这主要是由于该指令的工作方式造成的<code class="function">import</code>。与 C 中的 a 类似<code class="function">#include</code>，该伪指令用于允许访问外部定义的符号。然而，Java 不是重新读取源代码（然后需要重新解析和分析），而是直接读取类文件。由于类文件中的符号在编译过程中不能更改，因此类文件由编译器缓存。即使在中型项目中，这也意味着与 C 相比，Java 编译器可以避免重新读取、解析和分析数百万行代码。性能的提升幅度较小，这是由于大多数 Java 编译器执行了最低限度的优化。相反，Java 依赖于复杂的即时 (JIT)<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1469" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1470" class="indexterm"></a>由 Java 虚拟机 (JVM) 本身执行的优化。</p><p>Standard Java compilers are very fast. This is primarily due to
      the way the <code class="function">import</code> directive works.
      Similar to a <code class="function">#include</code> in C, this
      directive is used to allow access to externally defined symbols.
      However, rather than rereading source code, which then needs to be
      reparsed and analyzed, Java reads the class files directly. Because the
      symbols in a class file cannot change during the compilation process,
      the class files are cached by the compiler. In even medium-sized
      projects, this means the Java compiler can avoid rereading, parsing, and
      analyzing literally millions of lines of code compared with C. A more
      modest performance improvement is due to the bare minimum of
      optimization performed by most Java compilers. Instead, Java relies on
      sophisticated just-in-time (JIT) <a class="indexterm"></a> <a class="indexterm"></a>optimizations performed by the Java virtual machine (JVM)
      itself.</p><p>大多数大型 Java 项目都使<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1471" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1472" class="indexterm"></a>广泛使用Java的<em class="firstterm">包</em>
      特性。一个类被声明为封装在<code class="literal">package</code>形成一个<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1473" class="indexterm"></a>范围围绕文件定义的符号。包名称是分层的并隐式定义文件结构。例如，该包<code class="literal">a.b.c</code>将隐式定义目录结构<em class="filename">a/b/c</em>。声明在
      <code class="literal">a.b.c</code>包内的代码将被编译为<em class="filename">a/b/c</em>目录中的类文件。这意味着<em class="command">make</em>将二进制文件与其源关联的正常算法失败。但这也意味着无需指定<code class="option">-o</code>选项来指示输出文件应放置的位置。指示输出树的根（对于所有文件都相同）就足够了。反过来，这意味着可以使用相同的命令行调用来编译来自不同目录的源文件。</p><p>Most large Java projects make <a class="indexterm"></a> <a class="indexterm"></a>extensive use of Java's <em class="firstterm">package</em>
      feature. A class is declared to be encapsulated in a <code class="literal">package</code> that forms a <a class="indexterm"></a>scope around the symbols defined by the file. Package
      names are hierarchical and implicitly define a file structure. For
      instance, the package <code class="literal">a.b.c</code> would
      implicitly define a directory structure <em class="filename">a/b/c</em>. Code declared to be within the
      <code class="literal">a.b.c</code> package would be compiled to
      class files in the <em class="filename">a/b/c</em> directory.
      This means that <em class="command">make</em>'s normal
      algorithm for associating a binary file with its source fails. But it
      also means that there is no need to specify a <code class="option">-o</code> option
      to indicate where output files should be placed. Indicating the root of
      the output tree, which is the same for all files, is sufficient. This,
      in turn, means that source files from different directories can be
      compiled with the same command-line invocation.</p><p>标准Java编译器都支持<code class="literal">@filename</code>允许从文件读取命令行参数的语法。这与包功能结合起来非常重要，因为这意味着可以通过一次 Java 编译器的执行来编译项目的整个 Java 源代码。这是一个重大的性能改进，因为加载和执行编译器所需的时间是构建时间的主要贡献者。</p><p>The standard Java compilers all support the <code class="literal">@filename</code> syntax that allows command-line
      parameters to be read from a file. This is significant in conjunction
      with the package feature because it means that the entire Java source
      for a project can be compiled with a single execution of the Java
      compiler. This is a major performance improvement because the time it
      takes to load and execute the compiler is a major contributor to build
      times.</p><p>总之，通过编写正确的命令行，在 2.5 GHz Pentium 4 处理器上编译 400,000 行 Java 大约需要三分钟。编译一个等效的 C++ 应用程序需要几个小时。</p><p>In summary, by composing the proper command line, compiling
      400,000 lines of Java takes about three minutes on a 2.5-GHz Pentium 4
      processor. Compiling an equivalent C++ application would require
      hours.</p><div class="sect1" title="替代方案"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09.html.make3-CHP-9-SECT-1"></a>替代方案</h1><h1 class="title"><a></a>Alternatives to make</h1></div></div></div><p>如前所述，Java 开发人员社区热情地采用新技术。让我们看看其中的两个（
         <em class="command">Ant和 IDE）如何与</em><em class="command">make</em>相关。</p><p>As previously mentioned, the Java developer community
        enthusiastically adopts new technologies. Let's see how two of these,
        <em class="command">Ant</em> and IDEs, relate to <em class="command">make</em>.</p><div class="sect2" title="蚂蚁"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch09.html.make3-CHP-9-SECT-1.1"></a>蚂蚁</h2><h2 class="title"><a></a>Ant</h2></div></div></div><p>Java 社区是<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1474" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1475" class="indexterm"></a>非常活跃，以令人印​​象深刻的速度生产新工具和 API。<em class="command">Ant</em>就是这些新工具之一，它是一个旨在取代
          Java 开发过程中<em class="command">make 的构建工具。与</em><em class="command">make</em>一样，<em class="command">Ant</em>使用描述文件来指示项目的目标和先决条件。与<em class="command">make</em>不同，<em class="command">Ant</em>是用 Java 和<em class="command">Ant编写的</em>构建文件是用 XML 编写的。</p><p>The Java community is <a class="indexterm"></a> <a class="indexterm"></a>very active, producing new tools and APIs at an
          impressive rate. One of these new tools is <em class="command">Ant</em>, a build tool intended to replace
          <em class="command">make</em> in the Java development
          process. Like <em class="command">make</em>, <em class="command">Ant</em> uses a description file to indicate
          the targets and prerequisites of a project. Unlike <em class="command">make</em>, <em class="command">Ant</em> is written in Java and <em class="command">Ant</em> build files are written in XML.</p><p>让您感受 XML 构建<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1476" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1477" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1478" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1479" class="indexterm"></a><em class="command">文件，以下是Ant</em>构建文件的摘录：</p><p>To give you a feel for the XML build <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>file, here is an excerpt from the <em class="command">Ant</em> build file:</p><a id="OEBPS/ch09.html.I_4_tt398"></a><pre class="programlisting">&lt;目标名称=“构建”
        取决于=“准备，检查可选包”
        description="--&gt; 编译源代码"&gt;
  &lt;mkdir dir="${build.dir}"/&gt;
  &lt;mkdir dir="${build.classes}"/&gt;
  &lt;mkdir dir="${build.lib}"/&gt;

  &lt;javac srcdir="${java.dir}"
         destdir="${build.classes}"
         调试=“$ {调试}”
         弃用=“${弃用}”
         目标=“$ {javac.target}”
         优化=“${优化}”&gt;
    &lt;classpath refid="classpath"/&gt;
  &lt;/javac&gt;

  ...

  &lt;copy todir="${build.classes}"&gt;
    &lt;文件集目录=“$ {java.dir}”&gt;
      &lt;include name="**/*.properties"/&gt;
      &lt;include name="**/*.dtd"/&gt;
    &lt;/文件集&gt;
  &lt;/复制&gt;
 &lt;/目标&gt;</pre><pre class="programlisting">&lt;target name="build"
        depends="prepare, check_for_optional_packages"
        description="--&gt; compiles the source code"&gt;
  &lt;mkdir dir="${build.dir}"/&gt;
  &lt;mkdir dir="${build.classes}"/&gt;
  &lt;mkdir dir="${build.lib}"/&gt;

  &lt;javac srcdir="${java.dir}"
         destdir="${build.classes}"
         debug="${debug}"
         deprecation="${deprecation}"
         target="${javac.target}"
         optimize="${optimize}" &gt;
    &lt;classpath refid="classpath"/&gt;
  &lt;/javac&gt;

  ...

  &lt;copy todir="${build.classes}"&gt;
    &lt;fileset dir="${java.dir}"&gt;
      &lt;include name="**/*.properties"/&gt;
      &lt;include name="**/*.dtd"/&gt;
    &lt;/fileset&gt;
  &lt;/copy&gt;
 &lt;/target&gt;</pre><p>正如您所看到的，目标是通过 XML<code class="literal">&lt;target&gt;</code>标签引入的。每个目标都有一个分别用<code class="literal">&lt;name&gt;</code>和属性指定的名称和依赖项列表<code class="literal">&lt;depends&gt;</code>。行动是<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1480" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1481" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1482" class="indexterm"></a>由<em class="command">Ant执行的</em>
          <em class="firstterm">任务</em>。任务用 Java 编写并绑定到 XML 标记。例如，通过标签指定创建目录的任务<code class="literal">&lt;mkdir&gt;</code>
          ，并触发Java方法的执行<code class="function">Mkdir.execute</code>，最终调用
          <code class="function">File.mkdir</code>.所有任务都尽可能使用Java API 来实现。</p><p>As you can see, a target is introduced with an XML <code class="literal">&lt;target&gt;</code> tag. Each target has a name
          and dependency list specified with <code class="literal">&lt;name&gt;</code> and <code class="literal">&lt;depends&gt;</code> attributes, respectively.
          Actions are <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>performed by <em class="command">Ant</em>
          <em class="firstterm">tasks</em>. A task is written in Java and bound to
          an XML tag. For instance, the task of creating a directory is
          specified with the <code class="literal">&lt;mkdir&gt;</code>
          tag and triggers the execution of the Java method <code class="function">Mkdir.execute</code>, which eventually calls
          <code class="function">File.mkdir</code>. As far as possible,
          all tasks are implemented using the Java API.</p><p><em class="command">使用make</em>语法的等效构建文件将是：</p><p>An equivalent build file using <em class="command">make</em> syntax would be:</p><a id="OEBPS/ch09.html.I_4_tt399"></a><pre class="programlisting"># 编译源代码
构建：$(all_javas) 准备 check_for_Optional_packages
        $(MKDIR) -p $(build.dir) $(build.classes) $(build.lib)
        $(JAVAC) -sourcepath $(java.dir) \
                 -d $(build.classes) \
                 $（调试）\
                 $（弃用）\
                 -目标 $(javac.target) \
                 $（优化）\
                 -类路径$(类路径)\
                 @$&lt;
        ...
        $（查找）。 \(-name '*.properties' -o -name '*.dtd' \) | \
        $(TAR) -c -f - -T - | $(TAR) $(TAR) -C $(build.classes) -x -f -</pre><pre class="programlisting"># compiles the source code
build: $(all_javas) prepare check_for_optional_packages
        $(MKDIR) -p $(build.dir) $(build.classes) $(build.lib)
        $(JAVAC) -sourcepath $(java.dir)                        \
                 -d $(build.classes)                            \
                 $(debug)                                       \
                 $(deprecation)                                 \
                 -target $(javac.target)                        \
                 $(optimize)                                    \
                 -classpath $(classpath)                        \
                 @$&lt;
        ...
        $(FIND) . \( -name '*.properties' -o -name '*.dtd' \) | \
        $(TAR) -c -f - -T - | $(TAR) -C $(build.classes) -x -f -</pre><p><em class="command">这段make</em>代码使用了本书尚未讨论的技术。可以说，先决条件<em class="filename">all.javas （即变量</em><em class="filename">all_javas</em>的值）包含<code class="literal">java</code>要编译的所有文件的列表。 <em class="command">Ant</em>任务、<code class="literal">&lt;mkdir&gt;</code>、<code class="literal">&lt;javac&gt;</code>还<code class="literal">&lt;copy&gt;</code>执行依赖性检查。也就是说，如果目录已经存在，则不会执行<em class="command">mkdir</em> 。同样，如果 Java 类文件比源文件新，则不会编译源文件。尽管如此，<em class="command">make</em>命令脚本执行的功能本质上是相同的。<em class="command">Ant</em>包含一个名为 的通用任务<code class="literal">&lt;exec&gt;</code>来运行本地程序。</p><p>This snippet of <em class="command">make</em> uses
          techniques that this book hasn't discussed yet. Suffice to say that
          the prerequisite <em class="filename">all.javas</em> ,
          which is the value of the variable <em class="filename">all_javas</em>,
          contains a list of all <code class="literal">java</code> files to be compiled.
          The <em class="command">Ant</em> tasks <code class="literal">&lt;mkdir&gt;</code>, <code class="literal">&lt;javac&gt;</code>, and <code class="literal">&lt;copy&gt;</code> also perform dependency
          checking. That is, if the directory already exists, <em class="command">mkdir</em> is not executed. Likewise, if the
          Java class files are newer than the source files, the source files
          are not compiled. Nevertheless, the <em class="command">make</em> command script performs essentially
          the same functions. <em class="command">Ant</em> includes
          a generic task, called <code class="literal">&lt;exec&gt;</code>, to run a local
          program.</p><p><em class="command">Ant</em>是一种聪明而新颖的构建工具方法；然而，它提出了一些值得考虑的问题：</p><p><em class="command">Ant</em> is a clever and fresh
          approach to build tools; however, it presents some issues worth
          considering:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>尽管<em class="command">Ant</em>在 Java 社区中得到了广泛接受，但在其他地方它仍然相对不为人知。此外，它的受欢迎程度是否会远远超出 Java 范围似乎值得怀疑（出于此处列出的原因）。
              另一方面，<em class="command">make</em>一直被应用于广泛的领域，包括软件开发、文档处理和排版、网站和工作站维护等。对于需要在各种软件系统上工作的任何人来说，理解<em class="command">make都很重要。</em></p></li><li class="listitem"><p>Although <em class="command">Ant</em> has found
              wide acceptance in the Java community, it is still relatively
              unknown elsewhere. Also, it seems doubtful that its popularity
              will spread much beyond Java (for the reasons listed here).
              <em class="command">make</em>, on the other hand, has
              consistently been applied to a broad range of fields including
              software development, document processing and typesetting, and
              web site and workstation maintenance, to name a few.
              Understanding <em class="command">make</em> is
              important for anyone who needs to work on a variety of software
              systems.</p></li><li class="listitem"><p>选择 XML 作为描述语言适合基于 Java 的工具。但 XML 的书写或阅读并不是特别令人愉快（对于许多人来说）。好的 XML 编辑器可能很难找到，而且通常不能与现有工具很好地集成（要么我的集成开发环境包含一个好的 XML 编辑器，要么我必须离开 IDE 并寻找一个单独的工具）。正如您从前面的示例中看到的，
              与<em class="command">make</em>和 shell 语法相比，XML 和<em class="command">Ant</em>方言尤其冗长。 XML 充满了它自己的特性。<em class="command"></em></p></li><li class="listitem"><p>The choice of XML as the description language is
              appropriate for a Java-based tool. But XML is not particularly
              pleasant to write or to read (for many). Good XML editors can be
              difficult to find and often do not integrate well with existing
              tools (either my integrated development environment includes a
              good XML editor or I must leave my IDE and find a separate
              tool). As you can see from the previous example, XML and the
              <em class="command">Ant</em> dialect, in particular,
              are verbose compared with <em class="command">make</em> and shell syntax. And the XML is
              filled with its own idiosyncrasies.</p></li><li class="listitem"><p>当编写<em class="command">Ant</em>构建文件时，您<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1483" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1484" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1485" class="indexterm"></a>必须与另一层间接竞争。<em class="command">Ant</em> 任务<code class="literal">&lt;mkdir&gt;</code>不会调用系统的底层<em class="command">mkdir</em><code class="function">mkdir( )</code>程序。相反，它执行类的Java方法<code class="function">java.io.File</code>。这可能会或可能不会达到您的预期。本质上，程序员向<em class="command">Ant</em>提供的有关常用工具行为的任何知识都是可疑的，必须根据<em class="command">Ant</em>文档、Java 文档或<em class="command">Ant</em>
              源代码进行检查。此外，例如，为了调用 Java 编译器，我可能被迫浏览十几个或更多不熟悉的 XML 属性，例如<code class="literal">&lt;srcdir&gt;</code>、<code class="literal">&lt;debug&gt;</code>等，这些属性在编译器手册中没有记录。相比之下，<em class="command">make</em>脚本是完全透明的，也就是说，我通常可以将命令直接键入 shell 中以查看它们的行为方式。</p></li><li class="listitem"><p>When writing <em class="command">Ant</em> build
              files you <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>must contend with another layer of indirection.
              The <em class="command">Ant</em> <code class="literal">&lt;mkdir&gt;</code> task does not invoke the
              underlying <em class="command">mkdir</em> program for
              your system. Instead, it executes the Java <code class="function">mkdir( )</code> method of the <code class="function">java.io.File</code> class. This may or may
              not do what you expect. Essentially, any knowledge a programmer
              brings to <em class="command">Ant</em> about the
              behavior of common tools is suspect and must be checked against
              the <em class="command">Ant</em> documentation, Java
              documentation, or the <em class="command">Ant</em>
              source. In addition, to invoke the Java compiler, for instance,
              I may be forced to navigate through a dozen or more unfamiliar
              XML attributes, such as <code class="literal">&lt;srcdir&gt;</code>, <code class="literal">&lt;debug&gt;</code>, etc., that are not
              documented in the compiler manual. In contrast, the <em class="command">make</em> script is completely transparent,
              that is, I can typically type the commands directly into a shell
              to see how they behave.</p></li><li class="listitem"><p>虽然<em class="command">蚂蚁</em>肯定是<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1486" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1487" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1488" class="indexterm"></a>便携，<em class="command">make</em>也是如此。如<a class="link" href="#OEBPS/ch07.html" title="第 7 章可移植 Makefile">第 7 章</a>所示，编写可移植
              <em class="filename">makefile</em>就像编写可移植<em class="command">Ant</em>文件一样，需要经验和知识。程序员编写可移植
              <em class="filename">makefile</em>已经有二十年了。此外，<em class="command">Ant</em>
              文档指出，Unix 上的符号链接和 Windows 上的长文件名存在可移植性问题，MacOS X 是唯一受支持的 Apple 操作系统，并且不保证对其他平台的支持。此外，诸如设置文件执行位之类的基本操作无法从 Java API 执行。必须使用外部程序。可移植性从来都不是一件容易或完全的事情。</p></li><li class="listitem"><p>Although <em class="command">Ant</em> is
              certainly <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>portable, so is <em class="command">make</em>. As shown in <a class="link" href="#OEBPS/ch07.html" title="Chapter&nbsp;7.&nbsp;Portable Makefiles">Chapter 7</a>, writing portable
              <em class="filename">makefile</em>s, like writing
              portable <em class="command">Ant</em> files, requires
              experience and knowledge. Programmers have been writing portable
              <em class="filename">makefile</em>s for two decades.
              Furthermore, the <em class="command">Ant</em>
              documentation notes that there are portability issues with
              symbolic links on Unix and long filenames on Windows, that MacOS
              X is the only supported Apple operating system, and that support
              for other platforms is not guaranteed. Also, basic operations
              like setting the execution bit on a file cannot be performed
              from the Java API. An external program must be used. Portability
              is never easy or complete.</p></li><li class="listitem"><p><em class="command">Ant</em>工具没有准确解释它在做什么。由于<em class="command">Ant</em>任务通常不是通过执行 shell 命令来实现的，因此<em class="command">Ant</em>工具很难显示其操作。通常，显示内容由<code class="function">print</code>任务作者添加的语句中的自然语言散文组成。用户无法从 shell 执行这些打印语句。相反，<em class="command">make</em>回显的行通常是命令行，用户可以将其复制并粘贴到 shell 中以重新执行。这意味着<em class="command">Ant</em>构建对于试图了解构建过程和工具的开发人员来说不太有用。此外，开发人员不可能在键盘上即兴重复使用任务的部分内容。</p></li><li class="listitem"><p>The <em class="command">Ant</em> tool does not
              explain precisely what it is doing. Since <em class="command">Ant</em> tasks are not generally
              implemented by executing shell commands, the <em class="command">Ant</em> tool has a difficult time
              displaying its actions. Typically, the display consists of
              natural language prose from <code class="function">print</code> statements added by the task
              author. These print statements cannot be executed by a user from
              a shell. In contrast, the lines echoed by <em class="command">make</em> are usually command lines that a
              user can copy and paste into a shell for reexecution. This means
              the <em class="command">Ant</em> build is less useful
              to developers trying to understand the build process and tools.
              Also, it is not possible for a developer to reuse parts of a
              task, impromptu, at the keyboard.</p></li><li class="listitem"><p>最后也是最重要的一点是，<em class="command">Ant</em>将构建范例从脚本化编程语言转变为非脚本化编程语言。<em class="command">Ant</em>任务是用 Java 编写的。如果任务不存在或没有执行您想要的操作，您必须用 Java 编写自己的任务或使用该<code class="literal">&lt;exec&gt;</code>任务。 （当然，如果您经常使用该任务，那么简单地使用<em class="command">make</em>及其宏、函数和更紧凑的语法<code class="literal">&lt;exec&gt;</code>会更好。）<em class="command"></em></p></li><li class="listitem"><p>Last and most importantly, <em class="command">Ant</em> shifts the build paradigm from a
              scripted to a nonscripted programming language. <em class="command">Ant</em> tasks are written in Java. If a
              task does not exist or does not do what you want, you must
              either write your own task in Java or use the <code class="literal">&lt;exec&gt;</code> task. (Of course, if you
              use the <code class="literal">&lt;exec&gt;</code> task
              often, you would do far better to simply use <em class="command">make</em> with its macros, functions, and
              more compact syntax.)</p></li><li class="listitem"><p>另一方面，脚本语言的发明和繁荣正是为了解决此类问题。<em class="command">make</em>已经存在了近 30 年，可以在最复杂的情​​况下使用，而无需扩展其实现。当然，这三十年里也有过几次延期。其中许多是在<acronym class="acronym">GNU </acronym> <em class="command">make</em>中构思和实现的。</p></li><li class="listitem"><p>Scripting languages, on the other hand, were invented and
              flourish precisely to address this type of issue. <em class="command">make</em> has existed for nearly 30 years
              and can be used in the most complex situations without extending
              its implementation. Of course, there have been a handful of
              extensions in those 30 years. Many of them conceived and
              implemented in <acronym class="acronym">GNU</acronym> <em class="command">make</em>.</p></li></ul></div><p><em class="command">Ant</em>是一个在 Java 社区中被广泛接受的奇妙工具。但是，在开始新项目之前，请仔细考虑<em class="command">Ant</em>是否适合您的开发环境。本章将有希望向您证明<em class="command">make</em>可以有力地满足您的 Java 构建需求。</p><p><em class="command">Ant</em> is a marvelous tool
          that is widely accepted in the Java community. However, before
          embarking on a new project, consider carefully if <em class="command">Ant</em> is appropriate for your development
          environment. This chapter will hopefully prove to you that <em class="command">make</em> can powerfully meet your Java build
          needs.</p></div><div class="sect2" title="IDE"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch09.html.make3-CHP-9-SECT-1.2"></a>IDE</h2><h2 class="title"><a></a>IDEs</h2></div></div></div><p>许多 Java 开发人员使用 Integrated<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1489" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1490" class="indexterm"></a>将编辑器、编译器、调试器和代码浏览器捆绑在单个（通常）图形环境中的开发环境 (IDE)。示例包括开源<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1491" class="indexterm"></a>Eclipse ( <a class="ulink" href="http://www.eclipse.org/">http://www.eclipse.org</a> ) 和 Emacs JDEE ( <a class="ulink" href="http://jdee.sunsite.dk/">http://jdee.sunsite.dk</a> )，以及，来自<a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1492" class="indexterm"></a> <a id="OEBPS/ch09.html.make3-CHP-9-ITERM-1493" class="indexterm"></a>商业供应商，Sun Java Studio ( <a class="ulink" href="http://wwws.sun.com/software/sundev/jde">http://wwws.sun.com/software/sundev/jde</a> ) 和 JBuilder ( <a class="ulink" href="http://www.borland.com/jbuilder">http://www.borland.com/jbuilder</a> )。这些环境通常具有项目构建过程的概念，该过程编译必要的文件并启用应用程序执行。</p><p>Many Java developers use Integrated <a class="indexterm"></a> <a class="indexterm"></a>Development Environments (IDEs) that bundle an editor,
          compiler, debugger, and code browser in a single (typically)
          graphical environment. Examples include the open source <a class="indexterm"></a>Eclipse (<a class="ulink" href="http://www.eclipse.org">http://www.eclipse.org</a>)
          and Emacs JDEE (<a class="ulink" href="http://jdee.sunsite.dk">http://jdee.sunsite.dk</a>), and,
          from <a class="indexterm"></a> <a class="indexterm"></a>commercial vendors, Sun Java Studio (<a class="ulink" href="http://wwws.sun.com/software/sundev/jde">http://wwws.sun.com/software/sundev/jde</a>) and JBuilder
          (<a class="ulink" href="http://www.borland.com/jbuilder">http://www.borland.com/jbuilder</a>). These
          environments typically have the notion of a project-build process
          that compiles the necessary files and enables the application
          execution.</p><p>如果 IDE 支持所有这些，我们为什么要考虑使用
          <em class="command">make</em>？最明显的原因是便携性。如果需要在另一个平台上构建项目，则在移植到新目标时构建可能会失败。尽管 Java 本身可以跨平台移植，但支持工具却常常不能。例如，如果项目的配置文件包含 Unix 或 Windows 样式的路径，则当构建在其他操作系统上运行时，这些路径可能会生成错误。使用<em class="command">make 的</em>第二个原因是支持无人值守构建。有些 IDE 支持批量构建，有些则不支持。此功能的支持质量也各不相同。最后，所包含的构建支持通常是有限的。如果您希望实现定制的发布目录结构、集成外部应用程序的帮助文件、支持自动化测试以及处理分支和并行开发线，您可能会发现集成构建支持不足。</p><p>If the IDEs support all this, why should we consider using
          <em class="command">make</em>? The most obvious reason is
          portability. If there is ever a need to build the project on another
          platform, the build may fail when ported to the new target. Although
          Java itself is portable across platforms, the support tools are
          often not. For instance, if the configuration files for your project
          include Unix- or Windows-style paths, these may generate errors when
          the build is run on the other operating system. A second reason to
          use <em class="command">make</em> is to support unattended
          builds. Some IDEs support batch building and some do not. The
          quality of support for this feature also varies. Finally, the build
          support included is often limited. If you hope to implement
          customized release directory structures, integrate help files from
          external applications, support automated testing, and handle
          branching and parallel lines of development, you may find the
          integrated build support inadequate.</p><p>根据我自己的经验，我发现 IDE 适合小规模或本地化开发，但生产构建需要<em class="command">make</em>可以提供的更全面的支持。我通常使用 IDE 来编写和调试代码，并为生产构建和发布编写<em class="filename">makefile</em> 。在开发过程中，我使用 IDE 将项目编译到适合调试的状态。但是，如果我更改许多文件或修改输入到代码生成器的文件，那么我会运行<em class="filename">makefile</em>。我使用的 IDE 对外部源代码生成工具没有很好的支持。通常，IDE 构建的结果不适合发布给内部或外部客户。对于该任务，我使用<em class="command">make</em>。</p><p>In my own experience, I have found the IDEs to be fine for
          small scale or localized development, but production builds require
          the more comprehensive support that <em class="command">make</em> can provide. I typically use an IDE
          to write and debug code, and write a <em class="filename">makefile</em> for production builds and
          releases. During development I use the IDE to compile the project to
          a state suitable for debugging. But if I change many files or modify
          files that are input to code generators, then I run the <em class="filename">makefile</em>. The IDEs I've used do not have
          good support for external source code generation tools. Usually the
          result of an IDE build is not suitable for release to internal or
          external customers. For that task I use <em class="command">make</em>.</p></div></div></div></div></div>
<div id="OEBPS/ch09s02.html"><div>
<div class="sect1" title="通用 Java Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09s02.html.make3-CHP-9-SECT-2"></a>通用 Java Makefile</h1><h1 class="title"><a></a>A Generic Java Makefile</h1></div></div></div><p><a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="例 9-1。 Java 的通用 makefile">例 9-1</a>显示了一个通用的<em class="filename">makefile</em><a id="OEBPS/ch09s02.html.make3-CHP-9-ITERM-1494" class="indexterm"></a> <a id="OEBPS/ch09s02.html.make3-CHP-9-ITERM-1495" class="indexterm"></a>爪哇；我将在本章后面解释它的每个部分。</p><p><a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="Example&nbsp;9-1.&nbsp;Generic makefile for Java">Example 9-1</a> shows a
        generic <em class="filename">makefile</em> for <a class="indexterm"></a> <a class="indexterm"></a>Java; I'll explain each of its parts later in the
        chapter.</p><div class="example"><a id="OEBPS/ch09s02.html.make3-CHP-9-EX-1"></a><p class="title">例 9-1。 Java 的通用 makefile</p><p class="title">Example&nbsp;9-1.&nbsp;Generic makefile for Java</p><div class="example-contents"><pre class="programlisting"># Java 项目的通用 makefile。

VERSION_NUMBER := 1.0

# 树木的位置。
SOURCE_DIR := src
OUTPUT_DIR := 类

# Unix 工具
AWK := awk
查找 := /bin/查找
MKDIR := mkdir -p
RM := rm -rf
外壳:= /bin/bash

# 支持工具的路径
JAVA_HOME := /opt/j2sdk1.4.2_03
AXIS_HOME := /opt/axis-1_1
TOMCAT_HOME := /opt/jakarta-tomcat-5.0.18
XERCES_HOME := /opt/xerces-1_4_4
JUNIT_HOME := /opt/junit3.8.1

# Java 工具
JAVA := $(JAVA_HOME)/bin/java
JAVAC := $(JAVA_HOME)/bin/javac

JFLAGS := -源路径 $(SOURCE_DIR) \
               -d $(OUTPUT_DIR) \
               -来源1.4

JVMFLAGS := -ea \
               -欧空局\
               -X未来

JVM := $(JAVA) $(JVMFLAGS)

JAR := $(JAVA_HOME)/bin/jar
罐子标志 := cf

JAVADOC := $(JAVA_HOME)/bin/javadoc
JDFLAGS := -源路径 $(SOURCE_DIR) \
               -d $(OUTPUT_DIR) \
               -链接http://java.sun.com/products/jdk/1.4/docs/api

# 罐子
COMMONS_LOGGING_JAR := $(AXIS_HOME)/lib/commons-logging.jar
LOG4J_JAR := $(AXIS_HOME)/lib/log4j-1.2.8.jar
XERCES_JAR := $(XERCES_HOME)/xerces.jar
JUNIT_JAR := $(JUNIT_HOME)/junit.jar

# 设置Java类路径
类路径 := 输出目录 \
              XERCES_JAR \
              COMMONS_LOGGING_JAR \
              LOG4J_JAR \
              JUNIT_JAR

# 空格 - 空格
空间 := $(空) $(空)

# $(调用构建类路径，变量列表)
定义构建类路径
$(条\
  $(patsubst :%,%, \
    $(替换:,:,\
      $(条\
        $(foreach j,$1,$(调用 get-file,$j):)))))
恩德夫

# $(调用 get-file, 变量名)
定义获取文件
  $(条\
    $($1) \
    $(如果$(调用文件存在-eval,$1),, \
      $(警告变量引用的文件\
                找不到“$1”（$(​​$1))）））
恩德夫

# $(调用文件存在评估，变量名称)
定义文件存在评估
  $(条\
    $(如果 $($1),,$(警告 '$1' 没有值)) \
    $(通配符$($1)))
恩德夫

# $(调用简要帮助，makefile)
定义简短帮助
  $(AWK) '$$1 ~ /^[^.][-A-Za-z0-9]*:/ \
         { 打印 substr($$1, 1, 长度($$1)-1) }' $1 | \
  排序| \
  pr -T -w 80 -4
恩德夫

# $(调用文件存在，通配符模式)
文件存在= $(通配符$1)

# $(调用检查文件，文件列表)
定义检查文件
  $(foreach f, $1, \
    $(如果$(调用文件存在,$($f)),,\
      $（警告$f（$（$f））丢失）））
恩德夫

# #(调用 make-temp-dir, root-opt)
定义 make-temp-dir
  mktemp -t $(if $1,$1,make).XXXXXXXXXX
恩德夫

# MANIFEST_TEMPLATE - m4 宏处理器的清单输入
MANIFEST_TEMPLATE := src/manifest/manifest.mf
TMP_JAR_DIR := $(调用 make-temp-dir)
TMP_MANIFEST := $(TMP_JAR_DIR)/manifest.mf

# $(调用 add-manifest、jar、jar-name、manifest-file-opt)
定义添加清单
  $(RM) $(目录 $(TMP_MANIFEST))
  $(MKDIR) $(目录 $(TMP_MANIFEST))
  m4 --define=NAME="$(notdir $2)" \
     --define=IMPL_VERSION=$(VERSION_NUMBER) \
     --define=SPEC_VERSION=$(VERSION_NUMBER) \
     $(如果$3,$3,$(MANIFEST_TEMPLATE)) \
     &gt; $(TMP_MANIFEST)
  $(JAR) -ufm $1 $(TMP_MANIFEST)
  $(RM) $(目录 $(TMP_MANIFEST))
恩德夫

# $(调用 make-jar,jar-variable-prefix)
定义 make-jar
  .PHONY：$1 $$($1_name)
  $1：$($1_名称)
  $$（$1_名称）：
        cd $(OUTPUT_DIR); \
        $(JAR) $(JARFLAGS) $$(notdir $$@) $$($1_packages)
        $$（调用添加清单，$$@，$$（$1_name），$$（$1_manifest））
恩德夫

# 设置类路径
导出 CLASSPATH := $(调用构建类路径，$(class_path))

# make-directories - 确保输出目录存在。
make-directories := $(shell $(MKDIR) $(OUTPUT_DIR))

# help - 默认目标
.PHONY：帮助
帮助：
        @$(调用简短帮助，$(CURDIR)/Makefile)

# all - 执行完整构建的所有任务
.PHONY：全部
all：编译jar javadoc

# all_javas - 用于保存源文件列表的临时文件
all_javas := $(OUTPUT_DIR)/all.javas

#compile - 编译源代码
.PHONY：编译
编译：$(all_javas)
        $(JAVAC) $(JFLAGS) @$&lt;

# all_javas - 收集源文件列表
.INTERMEDIATE：$(all_javas)
$(all_javas):
        $(FIND) $(SOURCE_DIR) -name '*.java' &gt; $@

# jar_list - 要创建的所有 jar 的列表
jar_list := server_jar ui_jar

# jars - 创建所有 jars
.PHONY：罐子
罐子：$(jar_list)

# server_jar - 创建 $(server_jar)
server_jar_name := $(OUTPUT_DIR)/lib/a.jar
server_jar_manifest := src/com/company/manifest/foo.mf
server_jar_packages := com/company/m com/company/n

# ui_jar - 创建 $(ui_jar)
ui_jar_name := $(OUTPUT_DIR)/lib/b.jar
ui_jar_manifest := src/com/company/manifest/bar.mf
ui_jar_packages := com/company/o com/company/p

# 为每个 jar 创建明确的规则
# $(foreach j, $(jar_list), $(eval $(call make-jar,$j)))
$(eval $(调用 make-jar,server_jar))
$(eval $(调用 make-jar,ui_jar))

# javadoc - 从源生成 Java 文档
.PHONY：javadoc
javadoc：$(all_javas)
        $(JAVADOC) $(JDFLAGS) @$&lt;

.PHONY：干净
干净的：
        $(RM) $(OUTPUT_DIR)

.PHONY：类路径
类路径：
        @echo CLASSPATH='$(CLASSPATH)'

.PHONY：检查配置
检查配置：
        @echo 正在检查配置...
        $(调用检查文件, $(class_path) JAVA_HOME)

.PHONY：打印
打印：
        $(foreach v, $(V), \
          $(警告$v = $($v)))</pre><pre class="programlisting"># A generic makefile for a Java project.

VERSION_NUMBER := 1.0

# Location of trees.
SOURCE_DIR  := src
OUTPUT_DIR  := classes

# Unix tools
AWK         := awk
FIND        := /bin/find
MKDIR       := mkdir -p
RM          := rm -rf
SHELL       := /bin/bash

# Path to support tools
JAVA_HOME   := /opt/j2sdk1.4.2_03
AXIS_HOME   := /opt/axis-1_1
TOMCAT_HOME := /opt/jakarta-tomcat-5.0.18
XERCES_HOME := /opt/xerces-1_4_4
JUNIT_HOME  := /opt/junit3.8.1

# Java tools
JAVA        := $(JAVA_HOME)/bin/java
JAVAC       := $(JAVA_HOME)/bin/javac

JFLAGS      := -sourcepath $(SOURCE_DIR)        \
               -d $(OUTPUT_DIR)                 \
               -source 1.4

JVMFLAGS    := -ea                              \
               -esa                             \
               -Xfuture

JVM         := $(JAVA) $(JVMFLAGS)

JAR         := $(JAVA_HOME)/bin/jar
JARFLAGS    := cf

JAVADOC     := $(JAVA_HOME)/bin/javadoc
JDFLAGS     := -sourcepath $(SOURCE_DIR)        \
               -d $(OUTPUT_DIR)                 \
               -link http://java.sun.com/products/jdk/1.4/docs/api

# Jars
COMMONS_LOGGING_JAR   := $(AXIS_HOME)/lib/commons-logging.jar
LOG4J_JAR             := $(AXIS_HOME)/lib/log4j-1.2.8.jar
XERCES_JAR            := $(XERCES_HOME)/xerces.jar
JUNIT_JAR             := $(JUNIT_HOME)/junit.jar

# Set the Java classpath
class_path := OUTPUT_DIR                \
              XERCES_JAR                \
              COMMONS_LOGGING_JAR       \
              LOG4J_JAR                 \
              JUNIT_JAR

# space - A blank space
space := $(empty) $(empty)

# $(call build-classpath, variable-list)
define build-classpath
$(strip                                         \
  $(patsubst :%,%,                              \
    $(subst : ,:,                               \
      $(strip                                   \
        $(foreach j,$1,$(call get-file,$j):)))))
endef

# $(call get-file, variable-name)
define get-file
  $(strip                                       \
    $($1)                                       \
    $(if $(call file-exists-eval,$1),,          \
      $(warning The file referenced by variable \
                '$1' ($($1)) cannot be found)))
endef

# $(call file-exists-eval, variable-name)
define file-exists-eval
  $(strip                                       \
    $(if $($1),,$(warning '$1' has no value))   \
    $(wildcard $($1)))
endef

# $(call brief-help, makefile)
define brief-help
  $(AWK) '$$1 ~ /^[^.][-A-Za-z0-9]*:/                   \
         { print substr($$1, 1, length($$1)-1) }' $1 |  \
  sort |                                                \
  pr -T -w 80 -4
endef

# $(call file-exists, wildcard-pattern)
file-exists = $(wildcard $1)

# $(call check-file, file-list)
define check-file
  $(foreach f, $1,                              \
    $(if $(call file-exists, $($f)),,           \
      $(warning $f ($($f)) is missing)))
endef

# #(call make-temp-dir, root-opt)
define make-temp-dir
  mktemp -t $(if $1,$1,make).XXXXXXXXXX
endef

# MANIFEST_TEMPLATE - Manifest input to m4 macro processor
MANIFEST_TEMPLATE := src/manifest/manifest.mf
TMP_JAR_DIR       := $(call make-temp-dir)
TMP_MANIFEST      := $(TMP_JAR_DIR)/manifest.mf

# $(call add-manifest, jar, jar-name, manifest-file-opt)
define add-manifest
  $(RM) $(dir $(TMP_MANIFEST))
  $(MKDIR) $(dir $(TMP_MANIFEST))
  m4 --define=NAME="$(notdir $2)"                       \
     --define=IMPL_VERSION=$(VERSION_NUMBER)            \
     --define=SPEC_VERSION=$(VERSION_NUMBER)            \
     $(if $3,$3,$(MANIFEST_TEMPLATE))                   \
     &gt; $(TMP_MANIFEST)
  $(JAR) -ufm $1 $(TMP_MANIFEST)
  $(RM) $(dir $(TMP_MANIFEST))
endef

# $(call make-jar,jar-variable-prefix)
define make-jar
  .PHONY: $1 $$($1_name)
  $1: $($1_name)
  $$($1_name):
        cd $(OUTPUT_DIR); \
        $(JAR) $(JARFLAGS) $$(notdir $$@) $$($1_packages)
        $$(call add-manifest, $$@, $$($1_name), $$($1_manifest))
endef

# Set the CLASSPATH
export CLASSPATH := $(call build-classpath, $(class_path))

# make-directories - Ensure output directory exists.
make-directories := $(shell $(MKDIR) $(OUTPUT_DIR))

# help - The default goal
.PHONY: help
help:
        @$(call brief-help, $(CURDIR)/Makefile)

# all - Perform all tasks for a complete build
.PHONY: all
all: compile jars javadoc

# all_javas - Temp file for holding source file list
all_javas := $(OUTPUT_DIR)/all.javas

# compile - Compile the source
.PHONY: compile
compile: $(all_javas)
        $(JAVAC) $(JFLAGS) @$&lt;

# all_javas - Gather source file list
.INTERMEDIATE: $(all_javas)
$(all_javas):
        $(FIND) $(SOURCE_DIR) -name '*.java' &gt; $@

# jar_list - List of all jars to create
jar_list := server_jar ui_jar

# jars - Create all jars
.PHONY: jars
jars: $(jar_list)

# server_jar - Create the $(server_jar)
server_jar_name     := $(OUTPUT_DIR)/lib/a.jar
server_jar_manifest := src/com/company/manifest/foo.mf
server_jar_packages := com/company/m com/company/n

# ui_jar - create the $(ui_jar)
ui_jar_name     := $(OUTPUT_DIR)/lib/b.jar
ui_jar_manifest := src/com/company/manifest/bar.mf
ui_jar_packages := com/company/o com/company/p

# Create an explicit rule for each jar
# $(foreach j, $(jar_list), $(eval $(call make-jar,$j)))
$(eval $(call make-jar,server_jar))
$(eval $(call make-jar,ui_jar))

# javadoc - Generate the Java doc from sources
.PHONY: javadoc
javadoc: $(all_javas)
        $(JAVADOC) $(JDFLAGS) @$&lt;

.PHONY: clean
clean:
        $(RM) $(OUTPUT_DIR)

.PHONY: classpath
classpath:
        @echo CLASSPATH='$(CLASSPATH)'

.PHONY: check-config
check-config:
        @echo Checking configuration...
        $(call check-file, $(class_path) JAVA_HOME)

.PHONY: print
print:
        $(foreach v, $(V), \
          $(warning $v = $($v)))</pre></div></div></div></div></div>
<div id="OEBPS/ch09s03.html"><div>
<div class="sect1" title="编译Java"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09s03.html.make3-CHP-9-SECT-3"></a>编译Java</h1><h1 class="title"><a></a>Compiling Java</h1></div></div></div><p>Java 可以通过两种方式使用<em class="command">make</em>进行编译：传统方法，每个源文件执行一次<em class="command">javac</em> ；或前面概述的使用语法的快速方法<code class="literal">@filename</code>。</p><p>Java can be compiled with <em class="command">make</em> in two ways: the traditional approach,
        one <em class="command">javac</em> execution per source
        file; or the fast approach outlined previously using the <code class="literal">@filename</code> syntax.</p><div class="sect2" title="快速方法：一体化编译"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch09s03.html.make3-CHP-9-SECT-3.1"></a>快速方法：一体化编译</h2><h2 class="title"><a></a>The Fast Approach: All-in-One Compile</h2></div></div></div><p>让我们从快速方法开始。正如您在通用<em class="filename">makefile</em>中看到的：</p><p>Let's start with the fast approach. As you can see in the
          generic <em class="filename">makefile</em>:</p><a id="OEBPS/ch09s03.html.I_4_tt400"></a><pre class="programlisting"># all_javas - 用于保存源文件列表的临时文件
all_javas := $(OUTPUT_DIR)/all.javas

#compile - 编译源代码
.PHONY：编译
编译：$(all_javas)
        $(JAVAC) $(JFLAGS) @$&lt;

# all_javas - 收集源文件列表
.INTERMEDIATE：$(all_javas)
$(all_javas):
        $(FIND) $(SOURCE_DIR) -name '*.java' &gt; $@</pre><pre class="programlisting"># all_javas - Temp file for holding source file list
all_javas := $(OUTPUT_DIR)/all.javas

# compile - Compile the source
.PHONY: compile
compile: $(all_javas)
        $(JAVAC) $(JFLAGS) @$&lt;

# all_javas - Gather source file list
.INTERMEDIATE: $(all_javas)
$(all_javas):
        $(FIND) $(SOURCE_DIR) -name '*.java' &gt; $@</pre><p>虚假目标<code class="literal">compile</code>
          调用<em class="command">javac</em>一次来编译项目的所有源代码。</p><p>The phony target <code class="literal">compile</code>
          invokes <em class="command">javac</em> once to compile all
          the source of the project.</p><p>先决<code class="literal">$(all_javas)</code>
          条件是一个文件<em class="filename">all.javas</em>，其中包含 Java 文件列表，每行一个文件名。每个文件不必都在自己的行上，但这样<code class="literal">grep -v</code>在需要时可以更容易地过滤文件。创建<em class="filename">all.javas</em>的规则被标记<code class="literal">.INTERMEDIATE</code>，以便<em class="command">make</em>将在每次运行后删除该文件，从而在每次编译前创建一个新文件。创建文件的命令脚本很简单。为了获得最大的可维护性，我们使用<em class="command">find</em>命令来检索所有<em class="command">java</em>源树中的文件。该命令可能有点慢，但保证在源树发生变化时几乎无需修改即可正确工作。</p><p>The <code class="literal">$(all_javas)</code>
          prerequisite is a file, <em class="filename">all.javas</em>, containing a list of Java
          files, one filename per line. It is not necessary for each file to
          be on its own line, but this way it is much easier to filter files
          with <code class="literal">grep -v</code> if the need ever
          arises. The rule to create <em class="filename">all.javas</em> is marked <code class="literal">.INTERMEDIATE</code> so that <em class="command">make</em> will remove the file after each run
          and thus create a new one before each compile. The command script to
          create the file is straightforward. For maximum maintainability we
          use the <em class="command">find</em> command to retrieve
          all the <em class="command">java</em> files in the source
          tree. This command can be a bit slow, but is guaranteed to work
          correctly with virtually no modification as the source tree
          changes.</p><p><em class="filename">如果makefile</em>中有可用的源目录列表，则可以使用更快的命令脚本来构建<em class="filename">all.javas</em>。如果源目录列表的长度中等，以便命令行的长度不超过操作系统的限制，则这个简单的脚本将执行以下操作：</p><p>If you have a list of source directories readily available in
          the <em class="filename">makefile</em>, you can use
          faster command scripts to build <em class="filename">all.javas</em>. If the list of source
          directories is of medium length so that the length of the command
          line does not exceed the operating system's limits, this simple
          script will do:</p><a id="OEBPS/ch09s03.html.I_4_tt401"></a><pre class="programlisting">$(all_javas):
        shopt -s nullglob； \
        printf "%s\n" $(addsuffix /*.java,$(PACKAGE_DIRS)) &gt; $@</pre><pre class="programlisting">$(all_javas):
        shopt -s nullglob; \
        printf "%s\n" $(addsuffix /*.java,$(PACKAGE_DIRS)) &gt; $@</pre><p>该脚本使用 shell 通配符来确定每个目录中的 Java 文件列表。但是，如果目录不包含 Java 文件，我们希望通配符产生空字符串，而不是原始的通配符模式（许多 shell 的默认行为）。为了达到此效果，我们使用<em class="command">bash</em>选项<em class="command">shopt -s nullglob</em>。大多数其他 shell 都有类似的选项。最后，我们使用 globbing 和<em class="command">printf</em>而不是<em class="command">ls -1，</em>因为它们内置于
          <em class="command">bash</em>中，因此无论包目录的数量如何，我们的命令脚本都只执行单个程序。</p><p>This script uses shell wildcards to determine the list of Java
          files in each directory. If, however, a directory contains no Java
          files, we want the wildcard to yield the empty string, not the
          original globbing pattern (the default behavior of many shells). To
          achieve this effect, we use the <em class="command">bash</em> option <em class="command">shopt
          -s nullglob</em>. Most other shells have similar options.
          Finally, we use globbing and <em class="command">printf</em> rather than <em class="command">ls -1</em> because these are built-in to
          <em class="command">bash</em>, so our command script
          executes only a single program regardless of the number of package
          directories.</p><p>或者，我们可以使用以下方法来避免 shell 通配<code class="function">wildcard</code>：</p><p>Alternately, we can avoid shell globbing by using <code class="function">wildcard</code>:</p><a id="OEBPS/ch09s03.html.I_4_tt402"></a><pre class="programlisting">$(all_javas):
        打印“%s\n”$(通配符\
                       $(addsuffix /*.java,$(PACKAGE_DIRS))) &gt; $@</pre><pre class="programlisting">$(all_javas):
        print "%s\n" $(wildcard \
                       $(addsuffix /*.java,$(PACKAGE_DIRS))) &gt; $@</pre><p>如果您有非常多的源目录（或非常长的路径），上述脚本可能会超出操作系统的命令行长度限制。在这种情况下，以下脚本可能更合适：</p><p>If you have very many source directories (or very long paths),
          the above script may exceed the command-line length limit of the
          operating system. In that case, the following script may be
          preferable:</p><a id="OEBPS/ch09s03.html.I_4_tt403"></a><pre class="programlisting">.INTERMEDIATE：$(all_javas)
$(all_javas):
        shopt -s nullglob； \
        for f in $(PACKAGE_DIRS); \
        做 \
          printf "%s\n" $$f/*.java; \
        完成 &gt; $@</pre><pre class="programlisting">.INTERMEDIATE: $(all_javas)
$(all_javas):
        shopt -s nullglob;            \
        for f in $(PACKAGE_DIRS);     \
        do                            \
          printf "%s\n" $$f/*.java;   \
        done &gt; $@</pre><p>请注意，<code class="literal">compile</code>
          目标和支持规则遵循非递归<em class="command">make</em>方法。不管有多少个子目录，我们仍然有一个<em class="filename">makefile</em>和一个编译器的执行。如果您想编译所有源代码，这已经是最快的了。</p><p>Notice that the <code class="literal">compile</code>
          target and the supporting rule follow the nonrecursive <em class="command">make</em> approach. No matter how many
          subdirectories there are, we still have one <em class="filename">makefile</em> and one execution of the
          compiler. If you want to compile all of the source, this is as fast
          as it gets.</p><p>此外，我们完全丢弃了所有依赖信息。有了这些规则，<em class="command">make</em>既不知道也不关心哪个文件比哪个文件新。它只是在每次调用时编译所有内容。作为一个额外的好处，我们可以从源代码树而不是二叉树执行<em class="filename">makefile</em> 。
          考虑到<em class="command">make</em>管理依赖关系的能力，这似乎是一种愚蠢的组织 makefile 的方法<em class="filename">，但请考虑一下：</em><em class="command"></em></p><p>Also, we completely discarded all dependency information. With
          these rules, <em class="command">make</em> neither knows
          nor cares about which file is newer than which. It simply compiles
          everything on every invocation. As an added benefit, we can execute
          the <em class="filename">makefile</em> from the source
          tree, instead of the binary tree. This may seem like a silly way to
          organize the <em class="filename">makefile</em>
          considering <em class="command">make</em>'s abilities to
          manage dependencies, but consider this:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>另一种方法（我们将很快探讨）使用标准依赖方法。这会为每个文件调用一个新的<em class="command">javac</em>进程，增加大量开销。但是，如果项目很小，编译所有源文件不会比编译几个文件花费更长的时间，因为<em class="command">javac</em>
              编译器非常快，而进程创建通常很慢。任何花费时间少于 15 秒的构建基本上是等效的，无论它做了多少工作。例如，在我的 1.8 GHz Pentium 4、512 MB RAM 上编译大约 500 个源文件（来自 Ant 发行版）需要 14 秒。编译一个文件需要五秒钟。</p></li><li class="listitem"><p>The alternative (which we will explore shortly) uses the
              standard dependency approach. This invokes a new <em class="command">javac</em> process for each file, adding a
              lot of overhead. But, if the project is small, compiling all the
              source files will not take significantly longer than compiling a
              few files because the <em class="command">javac</em>
              compiler is so fast and process creation is typically slow. Any
              build that takes less than 15 seconds is basically equivalent
              regardless of how much work it does. For instance, compiling
              approximately 500 source files (from the Ant distribution) takes
              14 seconds on my 1.8-GHz Pentium 4 with 512 MB of RAM. Compiling
              one file takes five seconds.</p></li><li class="listitem"><p>大多数开发人员将使用某种为单个文件提供快速编译的开发环境。当更改更广泛、需要完全重建或需要无人值守构建时，很可能会使用makefile <em class="filename">。</em></p></li><li class="listitem"><p>Most developers will be using some kind of development
              environment that provides fast compilation for individual files.
              The <em class="filename">makefile</em> will most
              likely be used when changes are more extensive, complete
              rebuilds are required, or unattended builds are
              necessary.</p></li><li class="listitem"><p>正如我们将看到的，实现和维护依赖项所涉及的工作相当于 C/C++ 的单独源代码和二叉树构建（<a class="link" href="#OEBPS/ch08.html" title="第 8 章 C 和 C++">第 8 章</a>中描述）。这是一项不可低估的任务。</p></li><li class="listitem"><p>As we shall see, the effort involved in implementing and
              maintaining dependencies is equal to the separate source and
              binary tree builds for C/C++ (described in <a class="link" href="#OEBPS/ch08.html" title="Chapter&nbsp;8.&nbsp;C and C++">Chapter 8</a>). Not a task to be
              underestimated.</p></li></ul></div><p>正如我们将在后面的示例中看到的，该变量除了简单地构建<em class="filename">all.javas</em><code class="literal">PACKAGE_DIRS</code>文件之外还有其他用途
          。但维持这些变量可能是一个劳动密集型且可能很困难的步骤。对于较小的项目，可以在<em class="filename">makefile</em>中手动维护目录列表，但是当目录数量超过一百个时，手动编辑就变得容易出错且令人厌烦。此时，谨慎的做法可能是使用<em class="command">find</em>来扫描这些目录：<em class="filename"></em><em class="filename"></em><em class="command"></em></p><p>As we will see in later examples, the <code class="literal">PACKAGE_DIRS</code> variable has uses other than
          simply building the <em class="filename">all.javas</em>
          file. But maintaining this variables can be a labor-intensive, and
          potentially difficult, step. For smaller projects, the list of
          directories can be maintained by hand in the <em class="filename">makefile</em>, but when the number grows
          beyond a hundred directories, hand editing becomes error-prone and
          irksome. At this point, it might be prudent to use <em class="command">find</em> to scan for these directories:</p><a id="OEBPS/ch09s03.html.I_4_tt404"></a><pre class="programlisting"># $(调用 find-compilation-dirs, 根目录)
查找编译目录= \
  $(patsubst %/,%, \
    $(排序\
      $(目录\
        $(shell $(FIND) $1 -name '*.java'))))

PACKAGE_DIRS := $(调用 find-compilation-dirs, $(SOURCE_DIR))</pre><pre class="programlisting"># $(call find-compilation-dirs, root-directory)
find-compilation-dirs =                       \
  $(patsubst %/,%,                            \
    $(sort                                    \
      $(dir                                   \
        $(shell $(FIND) $1 -name '*.java'))))

PACKAGE_DIRS := $(call find-compilation-dirs, $(SOURCE_DIR))</pre><p>find命令返回文件列表，丢弃文件只留下目录，<em class="command">从</em>列表中删除重复项，并去掉尾部斜杠。请注意，查找要编译的文件列表时，仅丢弃文件名，然后<em class="filename">all.javas</em>规则使用通配符来恢复文件名。这看起来很浪费，但我经常发现包含源代码的包列表在构建的其他部分非常有用，例如扫描 EJB 配置文件。如果您的情况不需要包列表，那么请务必使用前面提到的更简单的方法之一来构建<em class="filename">all.javas</em>。<code class="function">dir</code><code class="function">sort</code><code class="function">patsubst</code><code class="function">find-compilation-dirs</code><em class="filename"></em><em class="filename"></em></p><p>The <em class="command">find</em> command returns a
          list of files, <code class="function">dir</code> discards the
          file leaving only the directory, <code class="function">sort</code> removes duplicates from the list,
          and <code class="function">patsubst</code> strips the
          trailing slash. Notice that <code class="function">find-compilation-dirs</code> finds the list of
          files to compile, only to discard the filenames, then the <em class="filename">all.javas</em> rule uses wildcards to restore
          the filenames. This seems wasteful, but I have often found that a
          list of the packages containing source code is very useful in other
          parts of the build, for instance to scan for EJB configuration
          files. If your situation does not require a list of packages, then
          by all means use one of the simpler methods previously mentioned to
          build <em class="filename">all.javas</em>.</p></div><div class="sect2" title="使用依赖项进行编译"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch09s03.html.make3-CHP-9-SECT-3.2"></a>使用依赖项进行编译</h2><h2 class="title"><a></a>Compiling with Dependencies</h2></div></div></div><p>以完全依赖的方式编译<a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496" class="indexterm"></a> <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1497" class="indexterm"></a>检查时，您首先需要一个工具来从 Java 源文件中提取依赖关系信息，类似于
          <code class="literal">cc -M</code>. Jikes ( <a class="ulink" href="http://www.ibm.com/developerworks/opensource/jikes">http://www.ibm.com/developerworks/opensource/jikes</a> ) 是一个开源 Java 编译器，它通过
          <code class="option">-makefile</code>或<code class="option">+M</code>选项支持此功能。 Jikes 对于单独的源代码和二进制编译来说并不理想，因为它总是将依赖文件写入与源文件相同的目录中，但它是免费提供的并且可以工作。从好的方面来说，它在编译时生成依赖文件，避免了单独的传递。</p><p>To compile with full dependency <a class="indexterm"></a> <a class="indexterm"></a>checking, you first need a tool to extract dependency
          information from the Java source files, something similar to
          <code class="literal">cc -M</code>. Jikes (<a class="ulink" href="http://www.ibm.com/developerworks/opensource/jikes">http://www.ibm.com/developerworks/opensource/jikes</a>)
          is an open source Java compiler that supports this feature with the
          <code class="option">-makefile</code> or <code class="option">+M</code> option. Jikes is
          not ideal for separate source and binary compilation because it
          always writes the dependency file in the same directory as the
          source file, but it is freely available and it works. On the plus
          side, it generates the dependency file while compiling, avoiding a
          separate pass.</p><p>这是一个依赖处理函数和使用它的规则：</p><p>Here is a dependency processing function and a rule to use
          it:</p><a id="OEBPS/ch09s03.html.I_4_tt405"></a><pre class="programlisting">%.class: %.java
        $(JAVAC) $(JFLAGS) +M $&lt;
        $(调用 java-process-depend,$&lt;,$@)

# $(调用 java-process-depend, 源文件, 对象文件)
定义java进程依赖
  $(SED) -e 's/^.*\.class *:/$2 $(subst .class,.d,$2):/' \
         $(subst .java,.u,$1) &gt; $(subst .class,.tmp,$2)
  $(SED) -e 's/#.*//' \
         -e 's/^[^:]*: *//' \
         -e's/*\\$$$$//'\
         -e '/^$$$$/ d' \
         -e 's/$$$$/ :/' $(subst .class,.tmp,$2) \
         &gt;&gt; $(subst .class,.tmp,$2)
  $(MV) $(subst .class,.tmp,$2).tmp $(subst .class,.d,$2)
恩德夫</pre><pre class="programlisting">%.class: %.java
        $(JAVAC) $(JFLAGS) +M $&lt;
        $(call java-process-depend,$&lt;,$@)

# $(call java-process-depend, source-file, object-file)
define java-process-depend
  $(SED) -e 's/^.*\.class *:/$2 $(subst .class,.d,$2):/'   \
         $(subst .java,.u,$1) &gt; $(subst .class,.tmp,$2)
  $(SED) -e 's/#.*//'                                      \
         -e 's/^[^:]*: *//'                                \
         -e 's/ *\\$$$$//'                                 \
         -e '/^$$$$/ d'                                    \
         -e 's/$$$$/ :/' $(subst .class,.tmp,$2)           \
         &gt;&gt;  $(subst .class,.tmp,$2)
  $(MV) $(subst .class,.tmp,$2).tmp  $(subst .class,.d,$2)
endef</pre><p>这要求<em class="filename">makefile</em>从二叉树执行，并设置<code class="literal">vpath</code>为查找源。如果您只想使用 Jikes 编译器生成依赖项，而使用不同的编译器来生成实际代码，则可以使用该<code class="option">+B</code>选项来阻止 Jikes 生成字节码。</p><p>This requires that the <em class="filename">makefile</em> be executed from the binary tree
          and that the <code class="literal">vpath</code> be set to find
          the source. If you want to use the Jikes compiler only for
          dependency generation, resorting to a different compiler for actual
          code generation, you can use the <code class="option">+B</code> option to
          prevent Jikes from generating bytecodes.</p><p>在编译 223 个 Java 文件的简单计时测试中，前面描述的快速方法单行编译在我的机器上需要 9.9 秒。使用单独的编译行编译相同的 223 个文件需要 411.6 秒，即 41.5 倍。此外，通过单独编译，任何需要编译四个以上文件的构建都比使用单个编译行编译所有源文件要慢。如果依赖项生成和编译由单独的程序执行，则差异将会增加。</p><p>In a simple timing test compiling 223 Java files, the single
          line compile described previously as the fast approach required 9.9
          seconds on my machine. The same 223 files compiled with individual
          compilation lines required 411.6 seconds or 41.5 times longer.
          Furthermore, with separate compilation, any build that required
          compiling more than four files was slower than compiling all the
          source files with a single compile line. If the dependency
          generation and compilation were performed by separate programs, the
          discrepancy would increase.</p><p>当然，开发环境会有所不同，但仔细考虑您的目标很重要。最大限度地减少编译文件的数量并不总是能最大限度地缩短构建系统所需的时间。特别是对于 Java，完整的依赖性检查和最小化编译文件的数量对于正常的程序开发来说似乎并不是必需的。</p><p>Of course, development environments vary, but it is important
          to carefully consider your goals. Minimizing the number of files
          compiled will not always minimize the time it takes to build a
          system. For Java in particular, full dependency checking and
          minimizing the number of files compiled does not appear to be
          necessary for normal program development.</p></div><div class="sect2" title="设置类路径"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch09s03.html.make3-CHP-9-SECT-3.3"></a>设置类路径</h2><h2 class="title"><a></a>Setting CLASSPATH</h2></div></div></div><p>最重要的问题之一<a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1498" class="indexterm"></a> <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499" class="indexterm"></a> <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500" class="indexterm"></a>使用 Java 开发软件时正确设置
          <code class="literal">CLASSPATH</code>变量。该变量确定解析类引用时加载哪些代码。要正确编译 Java 应用程序，<em class="filename">makefile</em>必须包含正确的<code class="literal">CLASSPATH</code>.<code class="literal">CLASSPATH</code>随着 Java 包、API 和支持工具被添加到系统中，它们很快就会变得又长又复杂。如果<code class="literal">CLASSPATH</code>很难正确设置，则将其设置在一处是有意义的。</p><p>One of the most important issues <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>when developing software with Java is setting the
          <code class="literal">CLASSPATH</code> variable correctly.
          This variable determines which code is loaded when a class reference
          is resolved. To compile a Java application correctly, the <em class="filename">makefile</em> must include the proper <code class="literal">CLASSPATH</code>. The <code class="literal">CLASSPATH</code> can quickly become long and
          complex as Java packages, APIs, and support tools are added to a
          system. If the <code class="literal">CLASSPATH</code> can be
          difficult to set properly, it makes sense to set it in one
          place.</p><p>我发现有用的一项技术是使用<em class="filename">makefile</em>来设置<code class="literal">CLASSPATH</code>自身和其他程序。例如，目标<code class="literal">classpath</code>
          可以将调用<em class="filename">makefile</em><code class="literal">CLASSPATH</code>返回到 shell ：<em class="filename"></em></p><p>A technique I've found useful is to use the <em class="filename">makefile</em> to set the <code class="literal">CLASSPATH</code> for itself and other programs.
          For instance, a target <code class="literal">classpath</code>
          can return the <code class="literal">CLASSPATH</code> to the
          shell invoking the <em class="filename">makefile</em>:</p><a id="OEBPS/ch09s03.html.I_4_tt406"></a><pre class="programlisting">.PHONY：类路径
类路径：
        @echo“导出 CLASSPATH='$(CLASSPATH)'”</pre><pre class="programlisting">.PHONY: classpath
classpath:
        @echo "export CLASSPATH='$(CLASSPATH)'"</pre><p>开发人员可以使用<code class="literal">CLASSPATH</code>此设置（如果他们使用<em class="command">bash</em>）：</p><p>Developers can set their <code class="literal">CLASSPATH</code> with this (if they use <em class="command">bash</em>):</p><a id="OEBPS/ch09s03.html.I_4_tt407"></a><pre class="programlisting">$ eval $(创建类路径)</pre><pre class="programlisting">$ eval $(make classpath)</pre><p><code class="literal">CLASSPATH</code>Windows 环境中的 可以通过以下调用进行设置：</p><p>The <code class="literal">CLASSPATH</code> in the
          Windows environment can be set with this invocation:</p><a id="OEBPS/ch09s03.html.I_4_tt408"></a><pre class="programlisting">.PHONY：windows_classpath
windows_classpath：
        regtool set /user/Environment/CLASSPATH "$(subst /,\\,$(CLASSPATH))"
        控制 sysdm.cpl,@1,3 &amp;
        @echo“现在单击环境变量，然后单击确定，然后再次单击确定。”</pre><pre class="programlisting">.PHONY: windows_classpath
windows_classpath:
        regtool set /user/Environment/CLASSPATH "$(subst /,\\,$(CLASSPATH))"
        control sysdm.cpl,@1,3 &amp;
        @echo "Now click Environment Variables, then OK, then OK again."</pre><p><em class="command">regtool</em>程序是一个
          <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1501" class="indexterm"></a> <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1502" class="indexterm"></a>Cygwin 开发系统中用于操作 Windows 注册表的实用程序。但是，仅设置注册表不会导致 Windows 读取新值。执行此操作的一种方法是访问“环境变量”对话框，然后单击“确定”退出。</p><p>The program <em class="command">regtool</em> is a
          <a class="indexterm"></a> <a class="indexterm"></a>utility in the Cygwin development system that
          manipulates the Windows Registry. Simply setting the Registry
          doesn't cause the new values to be read by Windows, however. One way
          to do this is to visit the Environment Variable dialog box and
          simply exit by clicking OK.</p><p>命令脚本的第二行使 Windows 显示“系统属性”对话框，其中“高级”选项卡处于活动状态。不幸的是，该命令无法显示“环境变量”对话框或激活“确定”按钮，因此最后一行提示用户完成任务。</p><p>The second line of the command script causes Windows to
          display the System Properties dialog box with the Advanced tab
          active. Unfortunately, the command cannot display the Environment
          Variables dialog box or activate the OK button, so the last line
          prompts the user to complete the task.</p><p>将其导出<code class="literal">CLASSPATH</code>到其他程序（例如 Emacs JDEE 或 JBuilder 项目文件）并不困难。</p><p>Exporting the <code class="literal">CLASSPATH</code> to
          other programs, such as Emacs JDEE or JBuilder project files, is not
          difficult.</p><p>设置本身也可以通过<em class="command">make</em><code class="literal">CLASSPATH</code>
          来管理。以明显的方式设置变量当然是合理的：<em class="command"></em><code class="literal">CLASSPATH</code></p><p>Setting the <code class="literal">CLASSPATH</code>
          itself can also be managed by <em class="command">make</em>. It is certainly reasonable to set
          the <code class="literal">CLASSPATH</code> variable in the
          obvious way with:</p><a id="OEBPS/ch09s03.html.I_4_tt409"></a><pre class="programlisting">CLASSPATH = /third_party/toplink-2.5/TopLink.jar:/third_party/...</pre><pre class="programlisting">CLASSPATH = /third_party/toplink-2.5/TopLink.jar:/third_party/...</pre><p>为了可维护性，最好使用变量：</p><p>For maintainability, using variables is preferred:</p><a id="OEBPS/ch09s03.html.I_4_tt410"></a><pre class="programlisting">类路径 = $(TOPLINK_25_JAR):$(TOPLINKX_25_JAR):...</pre><pre class="programlisting">CLASSPATH = $(TOPLINK_25_JAR):$(TOPLINKX_25_JAR):...</pre><p>但我们可以做得更好。正如您在通用<em class="filename">makefile</em>中看到的
          ，我们可以分两个阶段构建
          <code class="literal">CLASSPATH</code>：首先将路径中的元素列为<em class="command">make</em>变量，然后将这些变量转换为环境变量的字符串值：</p><p>But we can do better than this. As you can see in the generic
          <em class="filename">makefile</em>, we can build the
          <code class="literal">CLASSPATH</code> in two stages: first
          list the elements in the path as <em class="command">make</em> variables, then transform those
          variables into the string value of the environment variable:</p><a id="OEBPS/ch09s03.html.I_4_tt411"></a><pre class="programlisting"># 设置Java类路径
类路径 := 输出目录 \
              XERCES_JAR \
              COMMONS_LOGGING_JAR \
              LOG4J_JAR \
              JUNIT_JAR
...
# 设置类路径
导出 CLASSPATH := $(调用构建类路径，$(class_path))</pre><pre class="programlisting"># Set the Java classpath
class_path := OUTPUT_DIR                \
              XERCES_JAR                \
              COMMONS_LOGGING_JAR       \
              LOG4J_JAR                 \
              JUNIT_JAR
...
# Set the CLASSPATH
export CLASSPATH := $(call build-classpath, $(class_path))</pre><p>（<a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="例 9-1。 Java 的通用 makefile">示例 9-1</a><code class="literal">CLASSPATH</code>中的旨在说明性多于有用性。）编写良好的函数可以解决几个令人烦恼的问题：<a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="例 9-1。 Java 的通用 makefile"></a><code class="function">build-classpath</code></p><p>(The <code class="literal">CLASSPATH</code> in <a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="Example&nbsp;9-1.&nbsp;Generic makefile for Java">Example 9-1</a> is meant to be more
          illustrative than useful.) A well-written <code class="function">build-classpath</code> function solves several
          irritating problems:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p><code class="literal">CLASSPATH</code>组成一个片段是非常容易的。例如，如果使用不同的应用程序服务器，则<code class="literal">CLASSPATH</code>可能需要更改。然后可以将不同版本的版本<code class="literal">CLASSPATH</code>包含在
              各个部分中，并通过设置<em class="command">make</em><code class="literal">ifdef</code>变量来选择
              。<em class="command"></em></p></li><li class="listitem"><p>It is very easy to compose a <code class="literal">CLASSPATH</code> in pieces. For instance, if
              different applications servers are used, the <code class="literal">CLASSPATH</code> might need to change. The
              different versions of the <code class="literal">CLASSPATH</code> could then be enclosed in
              <code class="literal">ifdef</code> sections and selected
              by setting a <em class="command">make</em>
              variable.</p></li><li class="listitem"><p><em class="filename">makefile</em>的临时维护者不必担心嵌入的空白、换行符或行继续，因为
              <code class="function">build-classpath</code>函数会处理它们。</p></li><li class="listitem"><p>Casual maintainers of the <em class="filename">makefile</em> do not have to worry about
              embedded blanks, newlines, or line continuation, because the
              <code class="function">build-classpath</code> function
              handles them.</p></li><li class="listitem"><p>该功能可以自动选择路径分隔符
              <code class="function">build-classpath</code>。因此，无论在Unix还是Windows上运行都是正确的。</p></li><li class="listitem"><p>The path separator can be selected automatically by the
              <code class="function">build-classpath</code> function.
              Thus, it is correct whether run on Unix or Windows.</p></li><li class="listitem"><p>该函数可以验证路径元素的有效性
              <code class="function">build-classpath</code>。特别是，<em class="command">make</em>的一个令人恼火的问题是未定义的变量会崩溃为空字符串而不会出现错误。在大多数情况下，这非常有用，但有时它会产生阻碍。在这种情况下，它会悄悄地为变量生成一个虚假值<code class="literal">CLASSPATH</code>。<sup>[ <a id="OEBPS/ch09s03.html.make3-CHP-9-FNOTE-1" href="#OEBPS/ch09s03.html.ftn.make3-CHP-9-FNOTE-1" class="footnote">1</a> ]</sup>我们可以通过让<code class="function">build-classpath</code>函数检查空值元素并警告我们来解决这个问题。该函数还可以检查每个文件或目录是否存在。</p></li><li class="listitem"><p>The validity of path elements can be verified by the
              <code class="function">build-classpath</code> function.
              In particular, one irritating problem with <em class="command">make</em> is that undefined variables
              collapse to the empty string without an error. In most cases
              this is very useful, but occasionally it gets in the way. In
              this case, it quietly yields a bogus value for the <code class="literal">CLASSPATH</code> variable.<sup>[<a href="#OEBPS/ch09s03.html.ftn.make3-CHP-9-FNOTE-1" class="footnote">1</a>]</sup> We can solve this problem by having the <code class="function">build-classpath</code> function check for
              the empty valued elements and warn us. The function can also
              check that each file or directory exists.</p></li><li class="listitem"><p>最后，拥有一个处理 的钩子<code class="literal">CLASSPATH</code>对于更高级的功能很有用，例如帮助容纳路径名和搜索路径中的嵌入空格。</p></li><li class="listitem"><p>Finally, having a hook to process the <code class="literal">CLASSPATH</code> can be useful for more
              advanced features, such as help accommodating embedded spaces in
              path names and search paths.</p></li></ul></div><p><code class="function">build-classpath</code>这是处理前三个问题的实现：</p><p>Here is an implementation of <code class="function">build-classpath</code> that handles the first
          three issues:</p><a id="OEBPS/ch09s03.html.I_4_tt412"></a><pre class="programlisting"># $(调用构建类路径，变量列表)
定义构建类路径
$(条\
  $(patsubst %:,%, \
    $(替换:,:,\
      $(条\
        $(foreach c,$1,$(调用 get-file,$c):)))))
恩德夫

# $(调用 get-file, 变量名)
定义获取文件
  $(条\
    $($1) \
    $(如果$(调用文件存在-eval,$1),, \
      $(警告变量引用的文件\
                找不到“$1”（$(​​$1))）））
恩德夫

# $(调用文件存在评估，变量名称)
定义文件存在评估
  $(条\
    $(如果 $($1),,$(警告 '$1' 没有值)) \
    $(通配符$($1)))
恩德夫</pre><pre class="programlisting"># $(call build-classpath, variable-list)
define build-classpath
$(strip                                          \
  $(patsubst %:,%,                               \
    $(subst : ,:,                                \
      $(strip                                    \
        $(foreach c,$1,$(call get-file,$c):)))))
endef

# $(call get-file, variable-name)
define get-file
  $(strip                                       \
    $($1)                                       \
    $(if $(call file-exists-eval,$1),,          \
      $(warning The file referenced by variable \
                '$1' ($($1)) cannot be found)))
endef

# $(call file-exists-eval, variable-name)
define file-exists-eval
  $(strip                                        \
    $(if $($1),,$(warning '$1' has no value))    \
    $(wildcard $($1)))
endef</pre><p>这<code class="function">build-classpath</code>
          <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1503" class="indexterm"></a> <a id="OEBPS/ch09s03.html.make3-CHP-9-ITERM-1504" class="indexterm"></a>函数迭代其参数中的单词，验证每个元素并将它们与路径分隔符（在本例中为：）连接起来。现在自动选择路径分隔符很容易。然后，该函数会去除<code class="function">get-file</code>函数和
          <code class="function">foreach</code>循环添加的空格。接下来，它删除 foreach 循环添加的最终分隔符。最后，整个内容被包裹在一个<code class="function">strip</code>由行延续引入的错误空格中被删除。</p><p>The <code class="function">build-classpath</code>
          <a class="indexterm"></a> <a class="indexterm"></a>function iterates through the words in its argument,
          verifying each element and concatenating them with the path
          separator (: in this case). Selecting the path separator
          automatically is easy now. The function then strips spaces added by
          the <code class="function">get-file</code> function and
          <code class="function">foreach</code> loop. Next, it strips
          the final separator added by the foreach loop. Finally, the whole
          thing is wrapped in a <code class="function">strip</code> so
          errant spaces introduced by line continuation are removed.</p><p>该<code class="function">get-file</code>函数返回其文件名参数，然后测试该变量是否引用现有文件。如果不存在，则会生成警告。无论文件是否存在，它都会返回变量的值，因为该值可能对调用者有用。有时，
          <code class="function">get-file</code>可能与将要生成但尚不存在的文件一起使用。</p><p>The <code class="function">get-file</code> function
          returns its filename argument, then tests whether the variable
          refers to an existing file. If it does not, it generates a warning.
          It returns the value of the variable regardless of the existence of
          the file because the value may be useful to the caller. On occasion,
          <code class="function">get-file</code> may be used with a
          file that will be generated, but does not yet exist.</p><p>最后一个函数<code class="function">file-exists-eval</code>接受包含文件引用的变量名。如果变量为空，则发出警告；否则，该<code class="function">wildcard</code>
          函数用于将值解析为文件（或与此相关的文件列表）。</p><p>The last function, <code class="function">file-exists-eval</code>, accepts a variable name
          containing a file reference. If the variable is empty, a warning is
          issued; otherwise, the <code class="function">wildcard</code>
          function is used to resolve the value into a file (or a list of
          files for that matter).</p><p>当该<code class="function">build-classpath</code>
          函数与一些合适的虚假值一起使用时，我们会看到以下错误：</p><p>When the <code class="function">build-classpath</code>
          function is used with some suitable bogus values, we see these
          errors:</p><a id="OEBPS/ch09s03.html.I_4_tt413"></a><pre class="programlisting">Makefile:37: 变量“TOPLINKX_25_JAR”引用的文件
             找不到（/usr/java/toplink-2.5/TopLinkX.jar）
...
Makefile:37: 'XERCES_142_JAR' 没有值
Makefile:37: 变量引用的文件
             找不到“XERCES_142_JAR”( )</pre><pre class="programlisting">Makefile:37: The file referenced by variable 'TOPLINKX_25_JAR'
             (/usr/java/toplink-2.5/TopLinkX.jar) cannot be found
...
Makefile:37: 'XERCES_142_JAR' has no value
Makefile:37: The file referenced by variable
             'XERCES_142_JAR' ( ) cannot be found</pre><p>与我们通过简单方法获得的沉默相比，这代表了一个巨大的改进。</p><p>This represents a great improvement over the silence we would
          get from the simple approach.</p><p>该函数的存在<code class="function">get-file</code>表明我们可以概括输入文件的搜索。</p><p>The existence of the <code class="function">get-file</code> function suggests that we could
          generalize the search for input files.</p><a id="OEBPS/ch09s03.html.I_4_tt414"></a><pre class="programlisting"># $(调用 get-jar, 变量名)
定义 get-jar
  $(条\
    $(如果 $($1),,$(警告 '$1' 为空)) \
    $(如果 $(JAR_PATH),,$(警告 JAR_PATH 为空)) \
    $(foreach d, $(dir $($1)) $(JAR_PATH), \
      $(if $(通配符 $d/$(notdir $($1))), \
        $(如果 $(get-jar-return),, \
          $(eval get-jar-return := $d/$(notdir $($1)))))) \
    $(如果$(get-jar-return), \
      $(get-jar-return) \
      $(eval get-jar-return :=), \
      $($1) \
      $(警告 get-jar: 在 $(JAR_PATH)) 中未找到文件“$1”))
恩德夫</pre><pre class="programlisting"># $(call get-jar, variable-name)
define get-jar
  $(strip                                                     \
    $(if $($1),,$(warning '$1' is empty))                     \
    $(if $(JAR_PATH),,$(warning JAR_PATH is empty))           \
    $(foreach d, $(dir $($1)) $(JAR_PATH),                    \
      $(if $(wildcard $d/$(notdir $($1))),                    \
        $(if $(get-jar-return),,                              \
          $(eval get-jar-return := $d/$(notdir $($1))))))     \
    $(if $(get-jar-return),                                   \
      $(get-jar-return)                                       \
      $(eval get-jar-return :=),                              \
      $($1)                                                   \
      $(warning get-jar: File not found '$1' in $(JAR_PATH))))
endef</pre><p>这里我们定义变量<code class="literal">JAR_PATH</code>来包含文件的搜索路径。返回找到的第一个文件。该函数的参数是一个包含 jar 路径的变量名。我们希望首先在变量给定的路径中查找 jar 文件，然后在<code class="literal">JAR_PATH</code>.jar文件中查找。为了实现这一点，循环中的目录列表<code class="function">foreach</code>由变量中的目录组成，后跟<code class="literal">JAR_PATH</code>.该参数的其他两种用法包含在<code class="function">notdir</code>调用中，因此 jar 名称可以从此列表中的路径组成。请注意，我们无法退出循环<code class="function">foreach</code>。因此，我们使用<code class="function">eval</code>设置一个变量<code class="literal">get-jar-return</code>来记住我们找到的第一个文件。循环结束后，我们返回临时变量的值，或者如果没有找到任何内容，则发出警告。我们必须记住在终止宏之前重置返回值变量。</p><p>Here we define the variable <code class="literal">JAR_PATH</code> to contain a search path for
          files. The first file found is returned. The parameter to the
          function is a variable name containing the path to a jar. We want to
          look for the jar file first in the path given by the variable, then
          in the <code class="literal">JAR_PATH</code>. To accomplish
          this, the directory list in the <code class="function">foreach</code> loop is composed of the directory
          from the variable, followed by the <code class="literal">JAR_PATH</code>. The two other uses of the
          parameter are enclosed in <code class="function">notdir</code> calls so the jar name can be
          composed from a path from this list. Notice that we cannot exit from
          a <code class="function">foreach</code> loop. Instead,
          therefore, we use <code class="function">eval</code> to set a
          variable, <code class="literal">get-jar-return</code>, to
          remember the first file we found. After the loop, we return the
          value of our temporary variable or issue a warning if nothing was
          found. We must remember to reset our return value variable before
          terminating the macro.</p><p>这本质上是<code class="literal">vpath</code>在设置<code class="literal">CLASSPATH</code>.要理解这一点，请回想一下，这是<em class="command">make</em><code class="literal">vpath</code>隐式使用的搜索路径，用于查找无法通过相对路径从当前目录找到的先决条件。在这些情况下，
           <em class="command">make</em>搜索先决条件文件并将完整的路径插入到、和自动变量中。为了设置，我们希望
          <em class="command">make</em>搜索每个 jar 文件的路径并将完整的路径插入到变量中。由于<em class="command">make</em>对此没有内置支持，因此我们添加了自己的支持。当然，您可以简单地使用适当的 jar 文件名扩展 jar 路径变量，然后让 Java 进行搜索，但很快就会变得很长。在某些操作系统上，环境变量空间是有限的，long存在被截断的危险。在 Windows XP 上，单个环境变量的长度限制为 1023 个字符。另外，即使不被截断，Java虚拟机在加载类时也必须搜索the，从而减慢应用程序的速度。<em class="command"></em><em class="command"></em><code class="literal">vpath</code><code class="literal">$^</code><code class="literal">$?</code><code class="literal">$+</code><code class="literal">CLASSPATH</code><em class="command"></em><code class="literal">CLASSPATH</code><em class="command"></em><code class="literal">CLASSPATH</code><code class="literal">CLASSPATH</code><code class="literal">CLASSPATH</code><code class="literal">CLASSPATH</code></p><p>This is essentially reimplementing the <code class="literal">vpath</code> feature in the context of setting
          the <code class="literal">CLASSPATH</code>. To understand
          this, recall that the <code class="literal">vpath</code> is a
          search path used implicitly by <em class="command">make</em> to find prerequisites that cannot be
          found from the current directory by a relative path. In these cases,
          <em class="command">make</em> searches the <code class="literal">vpath</code> for the prerequisite file and
          inserts the completed path into the <code class="literal">$^</code>, <code class="literal">$?</code>,
          and <code class="literal">$+</code> automatic variables. To
          set the <code class="literal">CLASSPATH</code>, we want
          <em class="command">make</em> to search a path for each
          jar file and insert the completed path into the <code class="literal">CLASSPATH</code> variable. Since <em class="command">make</em> has no built-in support for this,
          we've added our own. You could, of course, simply expand the jar
          path variable with the appropriate jar filenames and let Java do the
          searching, but <code class="literal">CLASSPATH</code>s already
          get long quickly. On some operating systems, environment variable
          space is limited and long <code class="literal">CLASSPATH</code>s are in danger of being
          truncated. On Windows XP, there is a limit of 1023 characters for a
          single environment variable. In addition, even if the <code class="literal">CLASSPATH</code> is not truncated, the Java
          virtual machine must search the <code class="literal">CLASSPATH</code> when loading classes, thus
          slowing down the application.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch09s03.html.ftn.make3-CHP-9-FNOTE-1" href="#OEBPS/ch09s03.html.make3-CHP-9-FNOTE-1" class="para">1</a> ]</sup>我们可以尝试使用该
                  <code class="option">—warn-undefined-variables</code>选项来识别这种情况，但这也标记了许多其他需要的空变量。</p><p><sup>[<a href="#OEBPS/ch09s03.html.make3-CHP-9-FNOTE-1" class="para">1</a>] </sup>We could try using the
                  <code class="option">—warn-undefined-variables</code> option to
                  identify this situation, but this also flags many other
                  empty variables that are desirable.</p></div></div></div></div></div>
<div id="OEBPS/ch09s04.html"><div>
<div class="sect1" title="管理罐子"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09s04.html.make3-CHP-9-SECT-4"></a>管理罐子</h1><h1 class="title"><a></a>Managing Jars</h1></div></div></div><p>在 Java 中构建和管理 jar 呈现<a id="OEBPS/ch09s04.html.make3-CHP-9-ITERM-1505" class="indexterm"></a> <a id="OEBPS/ch09s04.html.make3-CHP-9-ITERM-1506" class="indexterm"></a> <a id="OEBPS/ch09s04.html.make3-CHP-9-ITERM-1507" class="indexterm"></a>与 C/C++ 库不同的问题。这有三个原因。首先，jar 的成员包含相对路径，因此必须仔细控制传递给<em class="command">jar</em>程序的精确文件名。其次，在 Java 中存在合并 jar 的趋势，以便可以发布单个 jar 来代表一个程序。最后，jar 包含类之外的其他文件，例如清单、属性文件和 XML。</p><p>Building and managing jars in Java presents <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>different issues from C/C++ libraries. There are three
        reasons for this. First, the members of a jar include a relative path,
        so the precise filenames passed to the <em class="command">jar</em> program must be carefully controlled.
        Second, in Java there is a tendency to merge jars so that a single jar
        can be released to represent a program. Finally, jars include other
        files than classes, such as manifests, property files, and XML.</p><p><acronym class="acronym">在GNU </acronym>
        <em class="command">make</em>中创建 jar 的基本命令是：</p><p>The basic command to create a jar in <acronym class="acronym">GNU</acronym>
        <em class="command">make</em> is:</p><a id="OEBPS/ch09s04.html.I_4_tt415"></a><pre class="programlisting">JAR := 罐子
JARFLAGS := -cf

$(FOO_JAR)：先决条件...
        $(JAR) $(JARFLAGS) $@ $^</pre><pre class="programlisting">JAR      := jar
JARFLAGS := -cf

$(FOO_JAR): prerequisites...
        $(JAR) $(JARFLAGS) $@ $^</pre><p><em class="command">jar</em>程序可以接受目录而不是文件名，在这种情况下，目录树中的所有文件都包含在 jar 中。这非常方便，尤其是与<code class="option">-C</code>更改目录的选项一起使用时：</p><p>The <em class="command">jar</em> program can accept
        directories instead of filenames, in which case, all the files in the
        directory trees are included in the jar. This can be very convenient,
        especially when used with the <code class="option">-C</code> option for changing
        directories:</p><a id="OEBPS/ch09s04.html.I_4_tt416"></a><pre class="programlisting">JAR := 罐子
JARFLAGS := -cf

.PHONY: $(FOO_JAR)
$(FOO_JAR):
        $(JAR) $(JARFLAGS) $@ -C $(OUTPUT_DIR) com</pre><pre class="programlisting">JAR      := jar
JARFLAGS := -cf

.PHONY: $(FOO_JAR)
$(FOO_JAR):
        $(JAR) $(JARFLAGS) $@ -C $(OUTPUT_DIR) com</pre><p>这里声明了 jar 本身<code class="literal">.PHONY</code>。否则，后续运行 makefile
        <em class="filename">将</em>不会重新创建该文件，因为它没有先决条件。与前面章节中描述的<em class="command">ar</em>命令一样，使用更新标志 似乎没有什么意义，
        <code class="option">-u</code>因为它需要与从头开始重新创建 jar 相同或更长的时间，至少对于大多数更新来说是这样。</p><p>Here the jar itself is declared <code class="literal">.PHONY</code>. Otherwise subsequent runs of the
        <em class="filename">makefile</em> would not recreate the
        file, because it has no prerequisites. As with the <em class="command">ar</em> command described in an earlier chapter,
        there seems little point in using the update flag,
        <code class="option">-u</code>, since it takes the same amount of time or longer
        as recreating the jar from scratch, at least for most updates.</p><p>jar 通常包含一个清单，用于标识 jar 实现的供应商、API 和版本号。一个简单的清单可能如下所示：</p><p>A jar often includes a manifest that identifies the vendor, API
        and version number the jar implements. A simple manifest might look
        like:</p><a id="OEBPS/ch09s04.html.I_4_tt417"></a><pre class="programlisting">名称：JAR_NAME
规范标题：SPEC_NAME
实现版本：IMPL_VERSION
规格供应商：Generic Innovative Company, Inc.</pre><pre class="programlisting">Name: JAR_NAME
Specification-Title: SPEC_NAME
Implementation-Version: IMPL_VERSION
Specification-Vendor: Generic Innovative Company, Inc.</pre><p>此清单包含三个占位符 、<code class="literal">JAR_NAME</code>和<code class="literal">SPEC_NAME</code>，<code class="literal">IMPL_VERSION</code>可以在创建 jar 时通过<em class="command">make</em>使用
        <em class="command">sed</em>、<em class="command">m4</em>或您最喜欢的流编辑器来替换它们。这是一个处理清单的函数：</p><p>This manifest includes three placeholders, <code class="literal">JAR_NAME</code>, <code class="literal">SPEC_NAME</code>, and <code class="literal">IMPL_VERSION</code>, that can be replaced at jar
        creation time by <em class="command">make</em> using
        <em class="command">sed</em>, <em class="command">m4</em>, or your favorite stream editor. Here is
        a function to process a manifest:</p><a id="OEBPS/ch09s04.html.I_4_tt418"></a><pre class="programlisting">MANIFEST_TEMPLATE := src/manifests/default.mf
TMP_JAR_DIR := $(调用 make-temp-dir)
TMP_MANIFEST := $(TMP_JAR_DIR)/manifest.mf

# $(调用 add-manifest、jar、jar-name、manifest-file-opt)
定义添加清单
  $(RM) $(目录 $(TMP_MANIFEST))
  $(MKDIR) $(目录 $(TMP_MANIFEST))
  m4 --define=NAME="$(notdir $2)" \
     --define=IMPL_VERSION=$(VERSION_NUMBER) \
     --define=SPEC_VERSION=$(VERSION_NUMBER) \
     $(如果$3,$3,$(MANIFEST_TEMPLATE)) \
     &gt; $(TMP_MANIFEST)
  $(JAR) -ufm $1 $(TMP_MANIFEST)
  $(RM) $(目录 $(TMP_MANIFEST))
恩德夫</pre><pre class="programlisting">MANIFEST_TEMPLATE := src/manifests/default.mf
TMP_JAR_DIR       := $(call make-temp-dir)
TMP_MANIFEST      := $(TMP_JAR_DIR)/manifest.mf

# $(call add-manifest, jar, jar-name, manifest-file-opt)
define add-manifest
  $(RM) $(dir $(TMP_MANIFEST))
  $(MKDIR) $(dir $(TMP_MANIFEST))
  m4 --define=NAME="$(notdir $2)"                       \
     --define=IMPL_VERSION=$(VERSION_NUMBER)            \
     --define=SPEC_VERSION=$(VERSION_NUMBER)            \
     $(if $3,$3,$(MANIFEST_TEMPLATE))                   \
     &gt; $(TMP_MANIFEST)
  $(JAR) -ufm $1 $(TMP_MANIFEST)
  $(RM) $(dir $(TMP_MANIFEST))
endef</pre><p>该<code class="function">add-manifest</code>函数运行<a id="OEBPS/ch09s04.html.make3-CHP-9-ITERM-1508" class="indexterm"></a> <a id="OEBPS/ch09s04.html.make3-CHP-9-ITERM-1509" class="indexterm"></a>类似于前面显示的清单文件。该函数首先创建一个临时目录，然后展开示例清单。接下来，它更新 jar，最后删除临时目录。请注意，该函数的最后一个参数是可选的。如果清单文件路径为空，则该函数使用 中的值<code class="literal">MANIFEST_TEMPLATE</code>。</p><p>The <code class="function">add-manifest</code> function
        operates <a class="indexterm"></a> <a class="indexterm"></a>on a manifest file similar to the one shown previously.
        The function first creates a temporary directory, then expands the
        sample manifest. Next, it updates the jar, and finally deletes the
        temporary directory. Notice that the last parameter to the function is
        optional. If the manifest file path is empty, the function uses the
        value from <code class="literal">MANIFEST_TEMPLATE</code>.</p><p>通用<em class="filename">makefile</em>
        将这些操作捆绑到一个通用函数中，以编写用于创建 jar 的显式规则：</p><p>The generic <em class="filename">makefile</em>
        bundles these operations into a generic function to write an explicit
        rule for creating a jar:</p><a id="OEBPS/ch09s04.html.I_4_tt419"></a><pre class="programlisting"># $(调用 make-jar,jar-variable-prefix)
定义 make-jar
  .PHONY：$1 $$($1_name)
  $1：$($1_名称)
  $$（$1_名称）：
        cd $(OUTPUT_DIR); \
        $(JAR) $(JARFLAGS) $$(notdir $$@) $$($1_packages)
        $$（调用添加清单，$$@，$$（$1_name），$$（$1_manifest））
恩德夫</pre><pre class="programlisting"># $(call make-jar,jar-variable-prefix)
define make-jar
  .PHONY: $1 $$($1_name)
  $1: $($1_name)
  $$($1_name):
        cd $(OUTPUT_DIR); \
        $(JAR) $(JARFLAGS) $$(notdir $$@) $$($1_packages)
        $$(call add-manifest, $$@, $$($1_name), $$($1_manifest))
endef</pre><p><em class="command">它接受一个参数，即make</em>变量的前缀，该参数标识一组描述四个 jar 参数的变量：目标名称、jar 名称、jar 中的包以及 jar 的清单文件。例如，对于名为<em class="filename">ui.jar</em>的 jar ，我们将编写：</p><p>It accepts a single argument, the prefix of a <em class="command">make</em> variable, that identifies a set of
        variables describing four jar parameters: the target name, the jar
        name, the packages in the jar, and the jar's manifest file. For
        example, for a jar named <em class="filename">ui.jar</em>,
        we would write:</p><a id="OEBPS/ch09s04.html.I_4_tt420"></a><pre class="programlisting">ui_jar_name := $(OUTPUT_DIR)/lib/ui.jar
ui_jar_manifest := src/com/company/ui/manifest.mf
ui_jar_packages := src/com/company/ui \
                   src/com/company/lib

$(eval $(调用 make-jar,ui_jar))</pre><pre class="programlisting">ui_jar_name     := $(OUTPUT_DIR)/lib/ui.jar
ui_jar_manifest := src/com/company/ui/manifest.mf
ui_jar_packages := src/com/company/ui \
                   src/com/company/lib

$(eval $(call make-jar,ui_jar))</pre><p>通过使用变量名组合，我们可以缩短函数的调用顺序，并允许非常灵活的函数实现。</p><p>By using variable name composition, we can shorten the calling
        sequence of our function and allow for a very flexible implementation
        of the function.</p><p>如果我们要创建许多 jar 文件，我们可以通过将 jar 名称放入变量中来进一步自动化此操作：</p><p>If we have many jar files to create, we can automate this
        further by placing the jar names in a variable:</p><a id="OEBPS/ch09s04.html.I_4_tt421"></a><pre class="programlisting">jar_list := server_jar ui_jar

.PHONY: jars $(jar_list)
罐子：$(jar_list)

$(foreach j, $(jar_list),\
  $(eval $(调用 make-jar,$j)))</pre><pre class="programlisting">jar_list := server_jar ui_jar

.PHONY: jars $(jar_list)
jars: $(jar_list)

$(foreach j, $(jar_list),\
  $(eval $(call make-jar,$j)))</pre><p>有时，我们需要将 jar 文件扩展到临时目录中。这是一个简单的函数来做到这一点：</p><p>Occasionally, we need to expand a jar file into a temporary
        directory. Here is a simple function to do that:</p><a id="OEBPS/ch09s04.html.I_4_tt422"></a><pre class="programlisting"># $(调用burst-jar, jar-file, 目标目录)
定义burst-jar
  $(调用 make-dir,$2)
  光盘2美元； $(JAR) -xf $1
恩德夫</pre><pre class="programlisting"># $(call burst-jar, jar-file, target-directory)
define burst-jar
  $(call make-dir,$2)
  cd $2; $(JAR) -xf $1
endef</pre></div></div></div>
<div id="OEBPS/ch09s05.html"><div>
<div class="sect1" title="参考树和第三方 Jar"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09s05.html.make3-CHP-9-SECT-5"></a>参考树和第三方 Jar</h1><h1 class="title"><a></a>Reference Trees and Third-Party Jars</h1></div></div></div><p>要使用单个，<a id="OEBPS/ch09s05.html.make3-CHP-9-ITERM-1510" class="indexterm"></a> <a id="OEBPS/ch09s05.html.make3-CHP-9-ITERM-1511" class="indexterm"></a> <a id="OEBPS/ch09s05.html.make3-CHP-9-ITERM-1512" class="indexterm"></a>共享引用树为开发人员支持部分源代码树，只需让夜间构建为项目创建 jar 并将这些 jar 包含在<code class="literal">CLASSPATH</code>Java 编译器中。开发人员可以检查他需要的源树部分并运行编译（假设源文件列表是由<em class="command">find</em>之类的东西动态创建的）。当 Java 编译器需要缺少源文件中的符号时，它将搜索<code class="literal">CLASSPATH</code>并发现
        jar 中的<em class="filename">.class文件。</em></p><p>To use a single, <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>shared reference tree to support partial source trees
        for developers, simply have the nightly build create jars for the
        project and include those jars in the <code class="literal">CLASSPATH</code> of the Java compiler. The
        developer can check out the parts of the source tree he needs and run
        the compile (assuming the source file list is dynamically created by
        something like <em class="command">find</em>). When the Java
        compiler requires symbols from a missing source file, it will search
        the <code class="literal">CLASSPATH</code> and discover the
        <em class="filename">.class</em> file in the jar.</p><p>从参考树中选择第三方 jar 也很简单。只需将 jar 的路径放入<code class="literal">CLASSPATH</code>.如前所述，<em class="filename">makefile</em>是管理此过程的宝贵工具。当然，该<code class="function">get-file</code>功能可以通过简单地设置变量来自动选择 beta 或 stable、本地或远程 jar <code class="literal">JAR_PATH</code>
        。</p><p>Selecting third-party jars from a reference tree is also simple.
        Just place the path to the jar in the <code class="literal">CLASSPATH</code>. The <em class="filename">makefile</em> can be a valuable tool for
        managing this process as previously noted. Of course, the <code class="function">get-file</code> function can be used to
        automatically select beta or stable, local or remote jars by simply
        setting the <code class="literal">JAR_PATH</code>
        variable.</p></div></div></div>
<div id="OEBPS/ch09s06.html"><div>
<div class="sect1" title="企业JavaBean"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch09s06.html.make3-CHP-9-SECT-6"></a>企业JavaBean</h1><h1 class="title"><a></a>Enterprise JavaBeans</h1></div></div></div><p>Enterprise JavaBeans™ 是<a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1513" class="indexterm"></a> <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1514" class="indexterm"></a>在远程方法调用框架中封装和重用业务逻辑的强大技术。 EJB 设置用于实现最终由远程客户端使用的服务器 API 的 Java 类。这些对象和服务是使用基于 XML 的控制文件进行配置的。一旦编写了 Java 类和 XML 控制文件，就必须将它们捆绑在一个 jar 中。然后，一个特殊的 EJB 编译器构建存根和连接来实现 RPC 支持代码。</p><p>Enterprise JavaBeans™ is a <a class="indexterm"></a> <a class="indexterm"></a>powerful technique to encapsulate and reuse business
        logic in the framework of remote method invocation. EJB sets up Java
        classes used to implement server APIs that are ultimately used by
        remote clients. These objects and services are configured using
        XML-based control files. Once the Java classes and XML control files
        are written, they must be bundled together in a jar. Then a special
        EJB compiler builds stubs and ties to implement the RPC support
        code.</p><p>可以将以下代码插入<a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="例 9-1。 Java 的通用 makefile">示例 9-1</a>中以提供通用 EJB 支持：</p><p>The following code can be plugged into <a class="link" href="#OEBPS/ch09s02.html.make3-CHP-9-EX-1" title="Example&nbsp;9-1.&nbsp;Generic makefile for Java">Example 9-1</a> to provide generic EJB
        support:</p><a id="OEBPS/ch09s06.html.I_4_tt423"></a><pre class="programlisting">EJB_TMP_JAR = $(EJB_TMP_DIR)/temp.jar
META_INF = $(EJB_TMP_DIR)/META-INF

# $(调用编译 bean, jar 名称,
# bean-files-wildcard, 清单名称-opt)
定义编译bean
  $(eval EJB_TMP_DIR := $(shell mktemp -d $(TMPDIR)/compile-bean.XXXXXXXXX))
  $(MKDIR) $(META_INF)
  $(if $(过滤器 %.xml, $2),cp $(过滤器 %.xml, $2) $(META_INF))
  cd $(OUTPUT_DIR) &amp;&amp; \
  $(JAR) -cf0 $(EJB_TMP_JAR) \
         $(调用 jar-file-arg,$(META_INF)) \
         $(过滤掉%.xml, $2)
  $(JVM) weblogic.ejbc $(EJB_TMP_JAR) $1
  $(调用 add-manifest,$(if $3,$3,$1),,)
  $(RM) $(EJB_TMP_DIR)
恩德夫

# $(调用 jar-file-arg, jar-file)
jar-file-arg = -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)</pre><pre class="programlisting">EJB_TMP_JAR = $(EJB_TMP_DIR)/temp.jar
META_INF    = $(EJB_TMP_DIR)/META-INF

# $(call compile-bean, jar-name,
#                      bean-files-wildcard, manifest-name-opt)
define compile-bean
  $(eval EJB_TMP_DIR := $(shell mktemp -d $(TMPDIR)/compile-bean.XXXXXXXX))
  $(MKDIR) $(META_INF)
  $(if $(filter %.xml, $2),cp $(filter %.xml, $2) $(META_INF))
  cd $(OUTPUT_DIR) &amp;&amp;                            \
  $(JAR) -cf0 $(EJB_TMP_JAR)                     \
         $(call jar-file-arg,$(META_INF))        \
         $(filter-out %.xml, $2)
  $(JVM) weblogic.ejbc $(EJB_TMP_JAR) $1
  $(call add-manifest,$(if $3,$3,$1),,)
  $(RM) $(EJB_TMP_DIR)
endef

# $(call jar-file-arg, jar-file)
jar-file-arg = -C "$(patsubst %/,%,$(dir $1))" $(notdir $1)</pre><p>功能<code class="function">compile-bean</code>​
        <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1515" class="indexterm"></a> <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1516" class="indexterm"></a>接受三个参数：要创建的 jar 的名称、jar 中的文件列表以及可选的清单文件。该函数首先使用<em class="command">mktemp</em>程序创建一个干净的临时目录，并将目录名称保存在变量 中<code class="literal">EJB_TMP_DIR</code>。通过将分配嵌入到 中<code class="function">eval</code>，我们确保<code class="literal">EJB_TMP_DIR</code>每次扩展 时都会重置到新的临时目录<code class="function">compile-bean</code>。由于<code class="function">compile-bean</code>被用在规则的命令脚本部分，因此只有在执行命令脚本时才会扩展该功能。接下来，它将 bean 文件列表中的所有 XML 文件复制到<em class="filename">META-INF</em>目录中。这是 EJB 配置文件所在的位置。然后，该函数构建一个临时 jar，用作 EJB 编译器的输入。该函数将<em class="filename">dir1/dir2/dir3</em><code class="function">jar-file-arg</code>格式的文件名转换为
        jar 中文件的相对路径是正确的。这是
        向 jar 命令指示<em class="filename">META-INF</em>目录的适当格式。 bean文件列表包含已经放置在<em class="filename">META-INF目录中的</em><em class="filename">.xml</em>文件，因此我们过滤掉这些文件。构建临时 jar 后，将调用 WebLogic EJB 编译器，生成输出 jar。然后将清单添加到编译的 jar 中。最后，我们的临时目录被删除。<em class="filename"></em><code class="literal">-C dir1/dir2 dir3</code><em class="filename"></em><em class="filename"></em><em class="filename"></em></p><p>The <code class="function">compile-bean</code> function
        <a class="indexterm"></a> <a class="indexterm"></a>accepts three parameters: the name of the jar to create,
        the list of files in the jar, and an optional manifest file. The
        function first creates a clean temporary directory using the <em class="command">mktemp</em> program and saves the directory name
        in the variable <code class="literal">EJB_TMP_DIR</code>. By
        embedding the assignment in an <code class="function">eval</code>, we ensure that <code class="literal">EJB_TMP_DIR</code> is reset to a new temporary
        directory once for each expansion of <code class="function">compile-bean</code>. Since <code class="function">compile-bean</code> is used in the command script
        part of a rule, the function is expanded only when the command script
        is executed. Next, it copies any XML files in the bean file list into
        the <em class="filename">META-INF</em> directory. This is
        where EJB configuration files live. Then, the function builds a
        temporary jar that is used as input to the EJB compiler. The <code class="function">jar-file-arg</code> function converts filenames of
        the form <em class="filename">dir1/dir2/dir3</em> into
        <code class="literal">-C dir1/dir2 dir3</code> so the relative
        path to the file in the jar is correct. This is the appropriate format
        for indicating the <em class="filename">META-INF</em>
        directory to the jar command. The bean file list contains <em class="filename">.xml</em> files that have already been placed in
        the <em class="filename">META-INF</em> directory, so we
        filter these files out. After building the temporary jar, the WebLogic
        EJB compiler is invoked, generating the output jar. A manifest is then
        added to the compiled jar. Finally, our temporary directory is
        removed.</p><p>使用新函数非常简单：</p><p>Using the new function is straightforward:</p><a id="OEBPS/ch09s06.html.I_4_tt424"></a><pre class="programlisting">bean_files = com/company/bean/FooInterface.class \
             com/company/bean/FooHome.class \
             src/com/company/bean/ejb-jar.xml \
             src/com/company/bean/weblogic-ejb-jar.xml

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
        $（调用编译bean，$ @，$（bean_files），weblogic.mf）</pre><pre class="programlisting">bean_files = com/company/bean/FooInterface.class       \
             com/company/bean/FooHome.class            \
             src/com/company/bean/ejb-jar.xml          \
             src/com/company/bean/weblogic-ejb-jar.xml

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
        $(call compile-bean, $@, $(bean_files), weblogic.mf)</pre><p>该<code class="literal">bean_files</code>列表有点令人困惑。它引用的<em class="filename">.class文件将相对于</em><em class="filename">classes</em>目录
        进行访问，而<em class="filename">.xml文件将相对于</em><em class="filename">makefile</em>的目录进行访问。</p><p>The <code class="literal">bean_files</code> list is a
        little confusing. The <em class="filename">.class</em>
        files it references will be accessed relative to the <em class="filename">classes</em> directory, while the <em class="filename">.xml</em> files will be accessed relative to the
        directory of the <em class="filename">makefile</em>.</p><p>这很好，但是如果你的 bean jar 中有很多 bean 文件怎么办？我们可以自动构建文件列表吗？当然：</p><p>This is fine, but what if you have lots of bean files in your
        bean jar. Can we build the file list automatically? Certainly:</p><a id="OEBPS/ch09s06.html.I_4_tt425"></a><pre class="programlisting">src_dirs := $(SOURCE_DIR)/com/company/...

bean_files = \
  $(patsubst $(SOURCE_DIR)/%,%, \
    $(addsuffix /*.class, \
      $(排序\
        $(目录\
          $(通配符\
            $(addsuffix /*Home.java,$(src_dirs)))))))
src/com/company/bean/ejb-jar.xml \
src/com/company/bean/weblogic-ejb-jar.xml

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
        $（调用编译bean，$ @，$（bean_files），weblogic.mf）</pre><pre class="programlisting">src_dirs := $(SOURCE_DIR)/com/company/...

bean_files =                                          \
  $(patsubst $(SOURCE_DIR)/%,%,                       \
    $(addsuffix /*.class,                             \
      $(sort                                          \
        $(dir                                         \
          $(wildcard                                  \
            $(addsuffix /*Home.java,$(src_dirs)))))))
src/com/company/bean/ejb-jar.xml \
src/com/company/bean/weblogic-ejb-jar.xml

.PHONY: ejb_jar $(EJB_JAR)
ejb_jar: $(EJB_JAR)
$(EJB_JAR):
        $(call compile-bean, $@, $(bean_files), weblogic.mf)</pre><p>这假定所有具有 EJB 源代码的目录都包含在该<code class="literal">src_dirs</code>变量中（也可能存在不包含 EJB 源代码的目录），并且任何以<em class="filename">Home.java</em>结尾的文件
        都标识包含 EJB 代码的包。设置变量的表达式<code class="literal">bean_files</code>首先将通配符后缀添加到目录，然后调用以收集<em class="filename">Home.java</em>文件<code class="function">wildcard</code>的列表。文件名将被丢弃以保留目录，目录将被排序以删除重复项。添加通配符
        后缀以便 shell 将列表扩展到实际的类文件。最后，源目录前缀（在<em class="filename">类</em>树中无效）被删除。使用 Shell 通配符扩展而不是<em class="command">make 的</em>扩展是因为在编译类文件后我们不能依赖<em class="command">make</em>来执行其扩展。如果<em class="command">make</em>过早评估该函数，它将找不到任何文件，并且目录缓存将阻止它再次查找。源代码树中的是完全安全的，因为（我们假设） <em class="command">make</em>运行时不会添加源文件。<em class="filename"></em><code class="literal">/*.class</code><em class="filename"></em><em class="command"></em><code class="function">wildcard</code><em class="command"></em><em class="command"></em><code class="function">wildcard</code><code class="function">wildcard</code><em class="command"></em></p><p>This assumes that all the directories with EJB source are
        contained in the <code class="literal">src_dirs</code> variable
        (there can also be directories that do not contain EJB source) and
        that any file ending in <em class="filename">Home.java</em>
        identifies a package containing EJB code. The expression for setting
        the <code class="literal">bean_files</code> variable first adds
        the wildcard suffix to the directories, then invokes <code class="function">wildcard</code> to gather the list of <em class="filename">Home.java</em> files. The filenames are
        discarded to leave the directories, which are sorted to remove
        duplicates. The wildcard <code class="literal">/*.class</code>
        suffix is added so that the shell will expand the list to the actual
        class files. Finally, the source directory prefix (which is not valid
        in the <em class="filename">classes</em> tree) is removed.
        Shell wildcard expansion is used instead of <em class="command">make</em>'s <code class="function">wildcard</code> because we can't rely on <em class="command">make</em> to perform its expansion after the
        class files have been compiled. If <em class="command">make</em> evaluated the <code class="function">wildcard</code> function too early it would find
        no files and directory caching would prevent it from ever looking
        again. The <code class="function">wildcard</code> in the source
        tree is perfectly safe because (we assume) no source files will be
        added while <em class="command">make</em> is running.</p><p>当我们的bean jar数量较少时，上面的代码是有效的。另一种开发风格将每个 EJB 放在自己的 jar 中。大型项目可能有几十个 jar。为了自动处理这种情况，我们需要为每个 EJB jar 生成一个显式规则。在此示例中，EJB 源代码是独立的：每个 EJB 及其关联的 XML 文件都位于单个目录中。 EJB 目录可以通过以<em class="filename">Session.java</em>结尾的文件来标识。</p><p>The above code works when we have a small number of bean jars.
        Another style of development places each EJB in its own jar. Large
        projects may have dozens of jars. To handle this case automatically,
        we need to generate an explicit rule for each EJB jar. In this
        example, EJB source code is self-contained: each EJB is located in a
        single directory with its associated XML files. EJB directories can be
        identified by files that end with <em class="filename">Session.java</em>.</p><p>基本方法是在源树中搜索 EJB，然后构建显式规则来创建每个 EJB 并将这些规则写入文件中。然后，EJB 规则文件将包含在我们的<em class="filename">makefile</em>中。 EJB 规则文件的创建是由<em class="command">make</em>自己的包含文件依赖性处理触发的。</p><p>The basic approach is to search the source tree for EJBs, then
        build an explicit rule to create each EJB and write these rules into a
        file. The EJB rules file is then included in our <em class="filename">makefile</em>. The creation of the EJB rules
        file is triggered by <em class="command">make</em>'s own
        dependency handling of include files.</p><a id="OEBPS/ch09s06.html.I_4_tt426"></a><pre class="programlisting"># session_jars - EJB jar 及其相对源路径。
会话罐=
  $(subst .java,.jar, \
    $(通配符\
      $(addsuffix /*Session.java, $(COMPILATION_DIRS))))

# EJBS - 我们需要构建的所有 EJB jar 的列表。
EJBS = $(addprefix $(TMP_DIR)/,$(notdir $(session_jars)))

# ejbs - 创建所有 EJB jar 文件。
.PHONY：ejb
ejb：$(EJBS)
$（EJBS）：
        $(调用编译bean,$@,$^,)</pre><pre class="programlisting"># session_jars - The EJB jars with their relative source path.
session_jars =
  $(subst .java,.jar,                         \
    $(wildcard                                \
      $(addsuffix /*Session.java, $(COMPILATION_DIRS))))

# EJBS - A list of all EJB jars we need to build.
EJBS = $(addprefix $(TMP_DIR)/,$(notdir $(session_jars)))

# ejbs - Create all EJB jar files.
.PHONY: ejbs
ejbs: $(EJBS)
$(EJBS):
        $(call compile-bean,$@,$^,)</pre><p>我们通过在所有编译目录上
        调用 a来找到<em class="filename">Session.java文件。在此示例中，jar 文件是带有</em><em class="filename">.jar</em><code class="function">wildcard</code>后缀的 Session 文件的名称。 jar 本身将被放置在临时二进制目录中。这<em class="filename"></em><code class="literal">EJBS</code> <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1517" class="indexterm"></a> <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518" class="indexterm"></a>变量包含 jar 列表及其二进制目录路径。这些 EJB jar 是我们要更新的目标。实际的命令脚本是我们的<code class="function">compile-bean</code>函数。棘手的部分是文件列表记录在每个 jar 文件的先决条件中。让我们看看它们是如何创建的。</p><p>We find the <em class="filename">Session.java</em>
        files by calling a <code class="function">wildcard</code> on
        all the compilation directories. In this example, the jar file is the
        name of the Session file with the <em class="filename">.jar</em> suffix. The jars themselves will be
        placed in a temporary binary directory. The <code class="literal">EJBS</code> <a class="indexterm"></a> <a class="indexterm"></a>variable contains the list of jars with their binary
        directory path. These EJB jars are the targets we want to update. The
        actual command script is our <code class="function">compile-bean</code> function. The tricky part is
        that the file list is recorded in the prerequisites for each jar file.
        Let's see how they are created.</p><a id="OEBPS/ch09s06.html.I_4_tt427"></a><pre class="programlisting">-包括$(OUTPUT_DIR)/ejb.d

# $(调用 ejb 规则，ejb 名称)
ejb 规则 = $(TMP_DIR)/$(notdir $1): \
            $(addprefix $(OUTPUT_DIR)/, \
              $(subst .java,.class,\
                $(通配符$(dir $1)*.java))) \
            $(通配符$(dir $1)*.xml)

# ejb.d - EJB 依赖项文件。
$(OUTPUT_DIR)/ejb.d：Makefile
        @echo 计算 ejb 依赖项...
        @for f in $(session_jars); \
        做 \
          echo "\$$(调用 ejb-rule,$$f)"; \
        完成 &gt; $@</pre><pre class="programlisting">-include $(OUTPUT_DIR)/ejb.d

# $(call ejb-rule, ejb-name)
ejb-rule = $(TMP_DIR)/$(notdir $1):           \
            $(addprefix $(OUTPUT_DIR)/,       \
              $(subst .java,.class,           \
                $(wildcard $(dir $1)*.java))) \
            $(wildcard $(dir $1)*.xml)

# ejb.d - EJB dependencies file.
$(OUTPUT_DIR)/ejb.d: Makefile
        @echo Computing ejb dependencies...
        @for f in $(session_jars);            \
        do                                    \
          echo "\$$(call ejb-rule,$$f)";      \
        done &gt; $@</pre><p>每个 EJB jar 的依赖项都记录在单独的文件<em class="filename">ejb.d</em>中，该文件包含在<em class="filename">makefile</em>中。第一次
        <em class="command">make</em>查找该包含文件时，它不存在。因此<em class="command">make</em>调用更新包含文件的规则。该规则为每个 EJB 写入一行，类似于：</p><p>The dependencies for each EJB jar are recorded in a separate
        file, <em class="filename">ejb.d</em>, that is included by
        the <em class="filename">makefile</em>. The first time
        <em class="command">make</em> looks for this include file it
        does not exist. So <em class="command">make</em> invokes the
        rule for updating the include file. This rule writes one line for each
        EJB, something like:</p><a id="OEBPS/ch09s06.html.I_4_tt428"></a><pre class="programlisting">$(调用 ejb-rule,src/com/company/foo/FooSession.jar)</pre><pre class="programlisting">$(call ejb-rule,src/com/company/foo/FooSession.jar)</pre><p>功能<code class="function">ejb-rule</code>
        <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1519" class="indexterm"></a> <a id="OEBPS/ch09s06.html.make3-CHP-9-ITERM-1520" class="indexterm"></a>将扩展到目标 jar 及其先决条件列表，例如：</p><p>The function <code class="function">ejb-rule</code>
        <a class="indexterm"></a> <a class="indexterm"></a>will expand to the target jar and its list of
        prerequisites, something like:</p><a id="OEBPS/ch09s06.html.I_4_tt429"></a><pre class="programlisting">类/lib/FooSession.jar：类/com/company/foo/FooHome.class \
            类/com/company/foo/FooInterface.class \
            类/com/company/foo/FooSession.class \
            src/com/company/foo/ejb-jar.xml \
            src/com/company/foo/ejb-weblogic-jar.xml</pre><pre class="programlisting">classes/lib/FooSession.jar: classes/com/company/foo/FooHome.class \
            classes/com/company/foo/FooInterface.class           \
            classes/com/company/foo/FooSession.class             \
            src/com/company/foo/ejb-jar.xml                     \
            src/com/company/foo/ejb-weblogic-jar.xml</pre><p><em class="command">通过这种方式，可以在make</em>中管理大量的 jar ，而不会产生手动维护一组显式规则的开销。</p><p>In this way, a large number of jars can be managed in <em class="command">make</em> without incurring the overhead of
        maintaining a set of explicit rules by hand.</p></div></div></div>
<div id="OEBPS/ch10.html"><div>
<div class="chapter" title="第 10 章提高 make 的性能"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch10.html.make3-CHP-10"></a>第 10 章提高 make 的性能</h1><h1 class="title"><a></a>Chapter&nbsp;10.&nbsp;Improving the Performance of make</h1></div></div></div><p><em class="command">make</em>在开发过程中起着至关重要的作用。它结合了项目的元素来创建应用程序，同时允许开发人员避免由于意外省略构建步骤而导致的细微错误。然而，如果开发人员因为觉得<em class="filename">makefile</em>太慢而避免使用<em class="command">make ，</em><em class="command">那么 make</em>的所有好处都会丧失。因此，确保<em class="filename">makefile 的</em>设计尽可能高效非常重要。<em class="filename"></em><em class="command"></em><em class="filename"></em></p><p><em class="command">make</em> plays a critical role in
      the development process. It combines the elements of a project to create
      an application while allowing the developer to avoid the subtle errors
      caused by accidentally omitting steps of the build. However, if
      developers avoid using <em class="command">make</em>, because
      they feel the <em class="filename">makefile</em> is too slow,
      all the benefits of <em class="command">make</em> are lost. It
      is important, therefore, to ensure that the <em class="filename">makefile</em> be crafted to be as efficient as
      possible.</p><p>性能问题是<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1521" class="indexterm"></a>总是很棘手，但当考虑到用户的感知和代码的不同路径时，情况变得更加棘手。并非<em class="filename">makefile</em>的每个目标都值得优化。根据您的环境，即使是彻底的优化也可能不值得。例如，将操作时间从 90 分钟减少到 45 分钟可能并不重要，因为即使更快的时间也是“去吃午餐”操作。另一方面，如果开发人员在这段时间无所事事，那么将任务从 2 分钟减少到 1 分钟可能会受到欢呼。</p><p>Performance issues are <a class="indexterm"></a>always tricky, but become even more so when the perception
      of users and different paths through the code are considered. Not every
      target of a <em class="filename">makefile</em> is worth
      optimizing. Even radical optimizations might not be worth the effort
      depending on your environment. For instance, reducing the time of an
      operation from 90 minutes to 45 minutes may be immaterial since even the
      faster time is a "go get lunch" operation. On the other hand, reducing a
      task from 2 minutes to 1 might be received with cheers if developers are
      twiddling their thumbs during that time.</p><p>在编写<em class="filename">makefile</em>以实现高效执行时，了解各种操作的成本以及正在执行哪些操作非常重要。在下面的部分中，我们将执行一些简单的基准测试来量化这些一般性评论，并提供帮助识别瓶颈的技术。</p><p>When writing a <em class="filename">makefile</em> for
      efficient execution, it is important to know the costs of various
      operations and to know what operations are being performed. In the
      following sections, we will perform some simple benchmarking to quantify
      these general comments and present techniques to help identify
      bottlenecks.</p><p>提高性能的补充方法是利用并行性和本地网络拓扑。通过一次运行多个命令脚本（即使在单处理器上），可以减少构建时间。</p><p>A complementary approach to improving performance is to take
      advantage of parallelism and local network topology. By running more
      than one command script at a time (even on a uniprocessor), build times
      can be reduced.</p><div class="sect1" title="标杆管理"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch10.html.make3-CHP-10-SECT-1"></a>标杆管理</h1><h1 class="title"><a></a>Benchmarking</h1></div></div></div><p>这里我们测量性能<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1522" class="indexterm"></a> <a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1523" class="indexterm"></a><em class="command">make</em>中的一些基本操作。<a class="link" href="#OEBPS/ch10.html.make3-CHP-10-TABLE-1" title="表 10-1。运营成本">表 10-1</a>显示了这些测量的结果。我们将解释每个测试并建议它们如何影响您编写的<em class="filename">makefile 。</em></p><p>Here we measure the performance <a class="indexterm"></a> <a class="indexterm"></a>of some basic operations in <em class="command">make</em>. <a class="link" href="#OEBPS/ch10.html.make3-CHP-10-TABLE-1" title="Table&nbsp;10-1.&nbsp;Cost of operations">Table 10-1</a> shows the results of
        these measurements. We'll explain each test and suggest how they might
        affect <em class="filename">makefile</em>s you
        write.</p><div class="table"><a id="OEBPS/ch10.html.make3-CHP-10-TABLE-1"></a><p class="title">表 10-1。运营成本</p><p class="title">Table&nbsp;10-1.&nbsp;Cost of operations</p><div class="table-contents"><table summary="Cost of operations" style="border-collapse:collapse;border-top:0.5pt solid;border-bottom:0.5pt solid;border-left:0.5pt solid;border-right:0.5pt solid"><colgroup><col><col><col><col><col><col></colgroup><thead><tr><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>手术</p><p>Operation</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>处决</p><p>Executions</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>每次执行的秒数 (Windows)</p><p>Seconds per execution (Windows)</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>每秒执行次数 (Windows)</p><p>Executions per second (Windows)</p></th><th style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>每次执行的秒数 (Linux)</p><p>Seconds per execution (Linux)</p></th><th style="border-bottom:0.5pt solid"><p>每秒执行次数 (Linux)</p><p>Executions per second (Linux)</p></th></tr></thead><tbody><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">make</code>
                （重击）</p><p> <code class="literal">make</code>
                (bash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0436</p><p>0.0436</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>22</p><p>22</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0162</p><p>0.0162</p></td><td style="border-bottom:0.5pt solid"><p>61</p><p>61</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">make</code>
                （灰）</p><p> <code class="literal">make</code>
                (ash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0413</p><p>0.0413</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>24</p><p>24</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0151</p><p>0.0151</p></td><td style="border-bottom:0.5pt solid"><p>66</p><p>66</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">make</code>
                （嘘）</p><p> <code class="literal">make</code>
                (sh)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0452</p><p>0.0452</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>22</p><p>22</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0159</p><p>0.0159</p></td><td style="border-bottom:0.5pt solid"><p>62</p><p>62</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">assignment</code>
                </p><p> <code class="literal">assignment</code>
                </p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>10,000</p><p>10,000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0001</p><p>0.0001</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>8130</p><p>8130</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0001</p><p>0.0001</p></td><td style="border-bottom:0.5pt solid"><p>10,989</p><p>10,989</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">subst</code>
                （短的）</p><p> <code class="literal">subst</code>
                (short)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>10,000</p><p>10,000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0003</p><p>0.0003</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>3891</p><p>3891</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0003</p><p>0.0003</p></td><td style="border-bottom:0.5pt solid"><p>3846</p><p>3846</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">subst</code>
                （长的）</p><p> <code class="literal">subst</code>
                (long)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>10,000</p><p>10,000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0018</p><p>0.0018</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>第547章</p><p>547</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0014</p><p>0.0014</p></td><td style="border-bottom:0.5pt solid"><p>第704章</p><p>704</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">sed</code>
                （重击）</p><p> <code class="literal">sed</code>
                (bash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>, 1000</p><p>, 1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0910</p><p>0.0910</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>10</p><p>10</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0342</p><p>0.0342</p></td><td style="border-bottom:0.5pt solid"><p>29</p><p>29</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">sed</code>
                （灰）</p><p> <code class="literal">sed</code>
                (ash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0699</p><p>0.0699</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>14</p><p>14</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0069</p><p>0.0069</p></td><td style="border-bottom:0.5pt solid"><p>144</p><p>144</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">sed</code>
                （嘘）</p><p> <code class="literal">sed</code>
                (sh)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0911</p><p>0.0911</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>10</p><p>10</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0139</p><p>0.0139</p></td><td style="border-bottom:0.5pt solid"><p>71</p><p>71</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">shell</code>
                （重击）</p><p> <code class="literal">shell</code>
                (bash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0398</p><p>0.0398</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>25</p><p>25</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0261</p><p>0.0261</p></td><td style="border-bottom:0.5pt solid"><p>38</p><p>38</p></td></tr><tr><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p> <code class="literal">shell</code>
                （灰）</p><p> <code class="literal">shell</code>
                (ash)</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0253</p><p>0.0253</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>39</p><p>39</p></td><td style="border-right:0.5pt solid;border-bottom:0.5pt solid"><p>0.0018</p><p>0.0018</p></td><td style="border-bottom:0.5pt solid"><p>第555章</p><p>555</p></td></tr><tr><td style="border-right:0.5pt solid"><p> <code class="literal">shell</code>
                （嘘）</p><p> <code class="literal">shell</code>
                (sh)</p></td><td style="border-right:0.5pt solid"><p>1000</p><p>1000</p></td><td style="border-right:0.5pt solid"><p>0.0399</p><p>0.0399</p></td><td style="border-right:0.5pt solid"><p>25</p><p>25</p></td><td style="border-right:0.5pt solid"><p>0.0050</p><p>0.0050</p></td><td style=""><p>198</p><p>198</p></td></tr></tbody></table></div></div><p>Windows 测试在运行 Windows XP 的 1.9 GHz Pentium 4（大约 3578 BogoMips）<sup>[ <a id="OEBPS/ch10.html.make3-CHP-10-FNOTE-1" href="#OEBPS/ch10.html.ftn.make3-CHP-10-FNOTE-1" class="footnote">1</a> ]</sup>和 512 MB RAM 上运行。使用了<em class="command">make</em> 3.80的 Cygwin 版本，从<em class="command">rxvt</em>窗口启动。 Linux 测试在运行 Linux RedHat 9、具有 256 MB RAM 的 450 MHz Pentium 2 (891 BogoMips) 上运行。</p><p>The Windows tests were run on a 1.9-GHz Pentium 4 (approximately
        3578 BogoMips)<sup>[<a href="#OEBPS/ch10.html.ftn.make3-CHP-10-FNOTE-1" class="footnote">1</a>]</sup> with 512 MB RAM running Windows XP. The Cygwin version
        of <em class="command">make</em> 3.80 was used, started from
        an <em class="command">rxvt</em> window. The Linux tests
        were run on a 450-MHz Pentium 2 (891 BogoMips) with 256 MB of RAM
        running Linux RedHat 9.</p><p><em class="command">make</em>使用的子shell可以对<em class="filename">makefile</em>的整体性能产生重大影响。 bash shell<em class="command">​</em><a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1524" class="indexterm"></a> <a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1525" class="indexterm"></a>是一个复杂的、功能齐全的 shell，因此很大。<em class="command">ash</em>外壳要小得多，功能也较少，但足以满足大多数任务。更复杂的是，如果从文件名<span class="emphasis"><em>/bin/sh</em></span>调用<em class="command">bash</em>，它会显着改变其行为以更符合标准 shell。在大多数 Linux 系统上，文件<em class="filename">/bin/sh是</em><em class="command">bash</em>的符号链接，而在 Cygwin 中<span class="emphasis"><em>/bin/sh</em></span>实际上是<em class="filename">ash</em>。为了解决这些差异，一些测试运行了三次，每次都使用不同的 shell。使用的外壳在括号中指示。当出现“(sh)”时，表示<em class="command">bash已链接到名为</em><em class="filename">/bin/sh</em>的文件。<span class="emphasis"><em></em></span><em class="filename"></em><em class="command"></em><span class="emphasis"><em></em></span><em class="filename"></em><em class="command"></em><em class="filename"></em></p><p>The subshell used by <em class="command">make</em> can
        have a significant effect on the overall performance of the <em class="filename">makefile</em>. The <em class="command">bash</em> shell <a class="indexterm"></a> <a class="indexterm"></a>is a complex, fully featured shell, and therefore large.
        The <em class="command">ash</em> shell is a much smaller,
        with fewer features but adequate for most tasks. To complicate
        matters, if <em class="command">bash</em> is invoked from
        the filename <span class="emphasis"><em>/bin/sh</em></span>, it alters its behavior
        significantly to conform more closely to the standard shell. On most
        Linux systems the file <em class="filename">/bin/sh</em> is
        a symbolic link to <em class="command">bash</em>, while in
        Cygwin <span class="emphasis"><em>/bin/sh</em></span> is really <em class="filename">ash</em>. To account for these differences, some
        of the tests were run three times, each time using a different shell.
        The shell used is indicated in parentheses. When "(sh)" appears, it
        means that <em class="command">bash</em> was linked to the
        file named <em class="filename">/bin/sh</em>.</p><p>前三个测试（标记为 make）表明无事可做时运行<em class="command">make 的</em>成本有多大。生成<em class="filename">文件</em>包含：</p><p>The first three tests, labeled make, give an indication of how
        expensive it is to run <em class="command">make</em> if
        there is nothing to do. The <em class="filename">makefile</em> contains:</p><a id="OEBPS/ch10.html.I_5_tt430"></a><pre class="programlisting">外壳:= /bin/bash
.假冒：x
X：
        $(MAKE) --no-print-directory --silent --question make-bash.mk; \
        ……<em class="replaceable"><code>this command repeated 99 more times</code></em>​</pre><pre class="programlisting">SHELL := /bin/bash
.PHONY: x
x:
        $(MAKE) --no-print-directory --silent --question make-bash.mk; \
        ...<em class="replaceable"><code>this command repeated 99 more times</code></em>...</pre><p>根据需要将单词“bash”替换为适当的 shell 名称。</p><p>The word "bash" is replaced with the appropriate shell name as
        required.</p><p>我们使用<code class="option">—no-print-directory</code>和
        <code class="option">—silent</code>命令来消除不必要的计算，这些计算可能会影响时序测试，并避免时序输出值与不相关的文本混淆。该<code class="option">—question</code>
        选项告诉<em class="command">make</em>只需检查依赖关系而不执行任何命令，如果文件是最新的，则返回退出状态为零。这使得<em class="command">make</em>可以做尽可能少的工作。此<em class="filename">makefile</em>不会执行任何命令，并且仅存在一个<code class="literal">.PHONY</code>目标的依赖关系。命令脚本执行<em class="command">make</em> 100 次。这个名为<em class="filename">make-bash.mk的</em><em class="filename">makefile由父</em><em class="filename">makefile</em>使用以下代码执行 10 次：<em class="filename"></em><em class="filename"></em></p><p>We use the <code class="option">—no-print-directory</code> and
        <code class="option">—silent</code> commands to eliminate unnecessary computation
        that might skew the timing test and to avoid cluttering the timing
        output values with irrelevant text. The <code class="option">—question</code>
        option tells <em class="command">make</em> to simply check
        the dependencies without executing any commands and return an exit
        status of zero if the files are up to date. This allows <em class="command">make</em> to do as little work as possible. No
        commands will be executed by this <em class="filename">makefile</em> and dependencies exist for only
        one <code class="literal">.PHONY</code> target. The command
        script executes <em class="command">make</em> 100 times.
        This <em class="filename">makefile</em>, called <em class="filename">make-bash.mk</em>, is executed 10 times by a
        parent <em class="filename">makefile</em> with this
        code:</p><a id="OEBPS/ch10.html.I_5_tt431"></a><pre class="programlisting">定义十次
  测试 += 1 美元
  .假货：1美元
  1 美元：
        @echo $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2; \
        时间 $(MAKE) --no-print-directory --silent $2
恩德夫

.PHONY：全部
全部：

$(eval $(调用十次, make-bash, -f make-bash.mk))

全部：$（测试）</pre><pre class="programlisting">define ten-times
  TESTS += $1
  .PHONY: $1
  $1:
        @echo $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2; \
        time $(MAKE) --no-print-directory --silent $2
endef

.PHONY: all
all:

$(eval $(call ten-times, make-bash, -f make-bash.mk))

all: $(TESTS)</pre><p>然后对这 1,000 次执行的时间进行平均。</p><p>The time for these 1,000 executions is then averaged.</p><p>从表中可以看出，Cygwin 的<em class="command">品牌</em>运行了<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1526" class="indexterm"></a> <a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1527" class="indexterm"></a>每秒大约执行 22 次或每次运行 0.044 秒，而 Linux 版本（即使在速度慢得多的 CPU 上）每秒大约执行 61 次或每次运行 0.016 秒。为了验证这些结果，还测试了本机 Windows 版本的<em class="command">make</em>，但没有产生任何显着的加速。结论：虽然 Cygwin
         <em class="command">make中的进程创建比本机 Windows </em><em class="command">make</em>稍慢，但两者都比 Linux 慢得多。它还表明，
        在 Windows 平台上使用递归<em class="command">make的执行速度可能会比在 Linux 上运行相同构建的速度慢得多。</em></p><p>As you can see from the table, the Cygwin <em class="command">make</em> ran <a class="indexterm"></a> <a class="indexterm"></a>at roughly 22 executions per second or 0.044 seconds per
        run, while the Linux version (even on a drastically slower CPU)
        performed roughly 61 executions per second or 0.016 seconds per run.
        To verify these results, the native Windows version of <em class="command">make</em> was also tested and did not yield any
        dramatic speed up. Conclusion: while process creation in Cygwin
        <em class="command">make</em> is slightly slower than a
        native Windows <em class="command">make</em>, both are
        dramatically slower than Linux. It also suggests that use of recursive
        <em class="command">make</em> on a Windows platform may
        perform significantly slower than the same build run on Linux.</p><p>正如您所期望的，此测试中使用的 shell 对执行时间没有影响。由于命令脚本不包含 shell 特殊字符，因此根本不会调用 shell。相反，<em class="command">make</em>直接执行命令。这可以通过将<code class="literal">SHELL</code>变量设置为完全虚假的值并注意测试仍然正确运行来验证。三个 shell 之间的性能差异必须归因于正常的系统差异。</p><p>As you would expect, the shell used in this test had no effect
        on execution time. Because the command script contained no shell
        special characters, the shell was not invoked at all. Rather, <em class="command">make</em> executed the commands directly. This
        can be verified by setting the <code class="literal">SHELL</code> variable to a completely bogus value
        and noting that the test still runs correctly. The difference in
        performance between the three shells must be attributed to normal
        system variance.</p><p>下一个基准措施<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1528" class="indexterm"></a> <a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1529" class="indexterm"></a>变量赋值的速度。这校准了最基本的<em class="command">make</em>操作。 makefile
        称为<em class="filename">allocate.mk </em><em class="filename">，</em>包含：</p><p>The next benchmark measures <a class="indexterm"></a> <a class="indexterm"></a>the speed of variable assignment. This calibrates the
        most elementary <em class="command">make</em> operation. The
        <em class="filename">makefile</em>, called <em class="filename">assign.mk</em>, contains:</p><a id="OEBPS/ch10.html.I_5_tt432"></a><pre class="programlisting"># 10000 个作业
z := 10<em class="replaceable"><code>...repeated 10000 times...</code></em>
.假冒：x
X： ;</pre><pre class="programlisting"># 10000 assignments
z := 10<em class="replaceable"><code>...repeated 10000 times...</code></em>
.PHONY: x
x: ;</pre><p>然后使用父<em class="filename">makefile</em>中的函数运行该<em class="filename">makefile</em>。<code class="function">ten-times</code><em class="filename"></em></p><p>This <em class="filename">makefile</em> is then run
        using our <code class="function">ten-times</code> function in
        the parent <em class="filename">makefile</em>.</p><p>任务显然很快。 Cygwin <em class="command">make</em>每秒将执行 8130 次分配，而 Linux 系统可以执行 10,989 次。我相信 Windows 对于大多数这些操作的性能实际上比基准测试显示的要好，因为创建10 次<em class="command">make</em>进程的成本无法可靠地从时间中扣除。结论：由于平均<em class="filename">makefile</em>不太可能执行 10,000 次赋值，因此平均<em class="filename">makefile</em>中变量赋值的成本
        可以忽略不计。</p><p>The assignment is obviously very fast. Cygwin <em class="command">make</em> will execute 8130 assignments per
        second while the Linux system can do 10,989. I believe the performance
        of Windows for most of these operations is actually better than the
        benchmark indicates because the cost of creating the <em class="command">make</em> process 10 times cannot be reliably
        factored out of the time. Conclusion: because it is unlikely that the
        average <em class="filename">makefile</em> would perform
        10,000 assignments, the cost of variable assignment in an average
        <em class="filename">makefile</em> is negligible.</p><p>接下来的两个基准衡量<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1530" class="indexterm"></a>函数调用的成本<code class="function">subst</code>
        。第一个使用 10 个字符的短字符串，并进行三个替换：</p><p>The next two benchmarks measure the <a class="indexterm"></a>cost of a <code class="function">subst</code>
        function call. The first uses a short 10-character string with three
        substitutions:</p><a id="OEBPS/ch10.html.I_5_tt433"></a><pre class="programlisting"># 10 个字符的字符串上有 10000 个 subst
目录 := ab/cd/ef/g
x := $(subst /, ,$(dir))<em class="replaceable"><code>...repeated 10000 times...</code></em>
.假冒：x
X： ;</pre><pre class="programlisting"># 10000 subst on a 10 char string
dir := ab/cd/ef/g
x := $(subst /, ,$(dir))<em class="replaceable"><code>...repeated 10000 times...</code></em>
.PHONY: x
x: ;</pre><p>此操作大约需要两倍于简单分配的时间，即 Windows 上每秒 3891 次操作。同样，Linux 系统的性能似乎大幅优于 Windows 系统。 （请记住，Linux 系统的运行时钟速度不到 Windows 系统的四分之一。）</p><p>This operation takes roughly twice as long as a simple
        assignment, or 3891 operations per second on Windows. Again, the Linux
        system appears to outperform the Windows system by a wide margin.
        (Remember, the Linux system is running at less than one quarter the
        clock speed of the Windows system.)</p><p>较长的替换对 1000 个字符的字符串进行操作，大约进行 100 次替换：</p><p>The longer substitution operates on a 1000-character string with
        roughly 100 substitutions:</p><a id="OEBPS/ch10.html.I_5_tt434"></a><pre class="programlisting"># 十个字符文件
目录 := ab/cd/ef/g
# 1000 个字符路径
p100 := $(目录);$(目录);$(目录);$(目录);$(目录);...
p1000 := $(p100)$(p100)$(p100)$(p100)$(p100)...

# 1000 个字符的字符串上有 10000 个 subst
x := $(subst ;, ,$(p1000))<em class="replaceable"><code>...repeated 10000 times...</code></em>
.假冒：x
X： ;</pre><pre class="programlisting"># Ten character file
dir := ab/cd/ef/g
# 1000 character path
p100 := $(dir);$(dir);$(dir);$(dir);$(dir);...
p1000 := $(p100)$(p100)$(p100)$(p100)$(p100)...

# 10000 subst on a 1000 char string
x := $(subst ;, ,$(p1000))<em class="replaceable"><code>...repeated 10000 times...</code></em>
.PHONY: x
x: ;</pre><p><em class="command">接下来的三个基准测试使用sed</em>测量相同替换的速度。该基准包含：</p><p>The next three benchmarks measure the speed of the same
        substitution using <em class="command">sed</em>. The
        benchmark contains:</p><a id="OEBPS/ch10.html.I_5_tt435"></a><pre class="programlisting"># 100 使用 bash 的 sed
外壳:= /bin/bash
.PHONY：sed-bash
sed-bash：
        回声'$(p1000)'| sed 's/;/ /g' &gt; /dev/null<em class="replaceable"><code> ...repeated 100 times...</code></em></pre><pre class="programlisting"># 100 sed using bash
SHELL := /bin/bash
.PHONY: sed-bash
sed-bash:
        echo '$(p1000)' | sed 's/;/ /g' &gt; /dev/null<em class="replaceable"><code> ...repeated 100 times...</code></em></pre><p>像往常一样，这个<em class="filename">makefile</em>是使用<code class="function">ten-times</code>
        函数执行的。在 Windows 上，<em class="command">sed 的</em>执行时间比函数长大约 50 倍<code class="function">subst</code>。在我们的 Linux 系统上，
         <em class="command">sed</em>仅慢 24 倍。</p><p>As usual, this <em class="filename">makefile</em> is
        executed using the <code class="function">ten-times</code>
        function. On Windows, <em class="command">sed</em> execution
        takes about 50 times longer than the <code class="function">subst</code> function. On our Linux system,
        <em class="command">sed</em> is only 24 times slower.</p><p>当我们考虑到 shell 的成本时，我们发现Windows 上的<em class="command">ash</em>确实提供了有用的加速。使用<em class="command">ash</em>，<em class="command">sed</em>只比 subst 慢 39 倍！ （眨眼）在 Linux 上，所使用的 shell 具有更深远的影响。使用
        <em class="command">ash</em>，<em class="command">sed</em>仅比 慢五倍<code class="function">subst</code>。在这里我们还注意到将<em class="command">bash</em>重命名为<em class="command">sh</em>的奇怪效果。在 Cygwin 上，名为<em class="command">/bin/bash 的</em><em class="command">bash</em>和名为<em class="command">/bin/sh</em>的 bash之间没有区别，但在 Linux 上，链接到<em class="command">/bin/sh 的</em><em class="command">bash</em>性能明显更好。<em class="command"></em><em class="command"></em><em class="command"></em><em class="command"></em></p><p>When we factor in the cost of the shell, we see that <em class="command">ash</em> on Windows does provide a useful
        speed-up. With <em class="command">ash</em>, the <em class="command">sed</em> is only 39 times slower than subst!
        (wink) On Linux, the shell used has a much more profound effect. Using
        <em class="command">ash</em>, the <em class="command">sed</em> is only five times slower than <code class="function">subst</code>. Here we also notice the curious
        effect of renaming <em class="command">bash</em> to <em class="command">sh</em>. On Cygwin, there is no difference
        between a <em class="command">bash</em> named <em class="command">/bin/bash</em> and one named <em class="command">/bin/sh</em>, but on Linux, a <em class="command">bash</em> linked to <em class="command">/bin/sh</em> performs significantly
        better.</p><p>最终的基准很简单<a id="OEBPS/ch10.html.make3-CHP-10-ITERM-1531" class="indexterm"></a>调用<em class="command">make</em>
        <code class="function">shell</code>命令来评估运行子 shell 的成本。生成<em class="filename">文件</em>包含：</p><p>The final benchmark simply <a class="indexterm"></a>invokes the <em class="command">make</em>
        <code class="function">shell</code> command to evaluate the
        cost of running a subshell. The <em class="filename">makefile</em> contains:</p><a id="OEBPS/ch10.html.I_5_tt436"></a><pre class="programlisting"># 100 $(shell ) 使用 bash
外壳:= /bin/bash
x := $(外壳:)<em class="replaceable"><code>...repeated 100 times...</code></em>
.假冒：x
X： ;</pre><pre class="programlisting"># 100 $(shell ) using bash
SHELL := /bin/bash
x := $(shell :)<em class="replaceable"><code>...repeated 100 times...</code></em>
.PHONY: x
x: ;</pre><p>这里没有什么惊喜。 Windows系统比Linux慢，<em class="command">ash比</em><em class="command">bash</em>有优势
        。<em class="command">ash</em>的性能提升
        更为明显，大约<code class="literal">%</code>快 50 倍。 Linux 系统使用<em class="command">ash</em>时性能最佳，使用<em class="command">bash</em>（当命名为“bash”时）时性能最慢。</p><p>There are no surprises here. The Windows system is slower than
        Linux, with <em class="command">ash</em> having an edge over
        <em class="command">bash</em>. The performance gain of
        <em class="command">ash</em> is more pronounced—about
        50<code class="literal">%</code> faster. The Linux system
        performs best with <em class="command">ash</em> and slowest
        with <em class="command">bash</em> (when named
        "bash").</p><p>基准测试是一项永无止境的任务，但是，我们所做的测量可以提供一些有用的见解。创建尽可能多的变量，只要它们有助于阐明<em class="filename">makefile</em>的结构，因为它们本质上是免费的。即使代码结构要求您重复地重新执行<em class="command">make</em>函数，内置<em class="command">make</em>函数也优于运行命令。避免在 Windows 上进行递归
        <em class="command">make</em>或不必要的进程创建。在 Linux 上，如果要创建许多进程，请使用<em class="command">ash 。</em><em class="command"></em><em class="command"></em><em class="command"></em></p><p>Benchmarking is a never-ending task, however, the measurements
        we've made can provide some useful insight. Create as many variables
        as you like if they help clarify the structure of the <em class="filename">makefile</em> because they are essentially free.
        Built-in <em class="command">make</em> functions are
        preferred over running commands even if you are required by the
        structure of your code to reexecute the <em class="command">make</em> function repeatedly. Avoid recursive
        <em class="command">make</em> or unnecessary process
        creation on Windows. While on Linux, use <em class="command">ash</em> if you are creating many
        processes.</p><p>最后，请记住，在大多数<em class="filename">makefile中， </em><em class="filename">makefile</em>运行所需的时间几乎完全取决于程序运行的成本，而不是<em class="command">make或</em><em class="filename">makefile</em>的结构。通常，减少运行的程序数量对于减少
        <em class="filename">makefile</em>的执行时间最有帮助。</p><p>Finally, remember that in most <em class="filename">makefile</em>s, the time a <em class="filename">makefile</em> takes to run is due almost
        entirely to the cost of the programs run, not <em class="command">make</em> or the structure of the <em class="filename">makefile</em>. Usually, reducing the number of
        programs run will be most helpful in reducing the execution time of a
        <em class="filename">makefile</em>.</p></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch10.html.ftn.make3-CHP-10-FNOTE-1" href="#OEBPS/ch10.html.make3-CHP-10-FNOTE-1" class="para">1</a> ]</sup>请参阅<a class="ulink" href="http://www.clifton.nl/bogomips.html">http://www.clifton.nl/bogomips.html</a>了解 BogoMips 的说明。</p><p><sup>[<a href="#OEBPS/ch10.html.make3-CHP-10-FNOTE-1" class="para">1</a>] </sup>See <a class="ulink" href="http://www.clifton.nl/bogomips.html">http://www.clifton.nl/bogomips.html</a> for an
            explanation of BogoMips.</p></div></div></div></div></div>
<div id="OEBPS/ch10s02.html"><div>
<div class="sect1" title="识别和处理瓶颈"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch10s02.html.make3-CHP-10-SECT-2"></a>识别和处理瓶颈</h1><h1 class="title"><a></a>Identifying and Handling Bottlenecks</h1></div></div></div><p><em class="filename">makefile</em>中出现不必要的延迟<a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1532" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1533" class="indexterm"></a>有几个来源：<em class="filename">makefile</em>的结构不良、依赖性分析不良以及<em class="command">make</em>函数和变量的使用不良。这些问题可以通过<em class="command">make</em>函数来掩盖，例如<code class="function">shell</code>调用命令而不回显命令，从而很难找到延迟的根源。</p><p>Unnecessary delays in <em class="filename">makefile</em>s come <a class="indexterm"></a> <a class="indexterm"></a>from several sources: poor structuring of the <em class="filename">makefile</em>, poor dependency analysis, and
        poor use of <em class="command">make</em> functions and
        variables. These problems can be masked by <em class="command">make</em> functions such as <code class="function">shell</code> that invoke commands without echoing
        them, making it difficult to find the source of the delay.</p><p>依赖性分析是一把双刃剑。一方面，如果执行完整的依赖性分析，则分析本身可能会导致显着的延迟。如果没有特殊的编译器支持（例如<em class="command">gcc</em>或<em class="command">jikes</em>提供的支持），创建依赖文件需要运行另一个程序，这几乎使编译时间增加了一倍。<sup>[ <a id="OEBPS/ch10s02.html.make3-CHP-10-FNOTE-2" href="#OEBPS/ch10s02.html.ftn.make3-CHP-10-FNOTE-2" class="footnote">2</a> ]</sup>完整的依赖分析的优点是它允许<em class="command">make</em>执行更少的编译。不幸的是，开发人员可能不相信这个好处已经实现，并且编写了包含不太完整的依赖信息的<em class="filename">makefile</em> 。这种妥协几乎总是会导致开发问题的增加，导致其他开发人员通过编译比原始完整依赖信息所需的更多代码来进行过度补偿。</p><p>Dependency analysis is a two-edged sword. On the one hand, if
        complete dependency analysis is performed, the analysis itself may
        incur significant delays. Without special compiler support, such as
        supplied by <em class="command">gcc</em> or <em class="command">jikes</em>, creating a dependency file requires
        running another program, nearly doubling compilation time.<sup>[<a href="#OEBPS/ch10s02.html.ftn.make3-CHP-10-FNOTE-2" class="footnote">2</a>]</sup> The advantage of complete dependency analysis is that it
        allows <em class="command">make</em> to perform fewer
        compiles. Unfortunately, developers may not believe this benefit is
        realized and write <em class="filename">makefile</em>s with
        less complete dependency information. This compromise almost always
        leads to an increase in development problems, leading other developers
        to overcompensate by compiling more code than would be required with
        the original, complete dependency information.</p><p>制定依赖关系<a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1534" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1535" class="indexterm"></a>分析策略，首先要了解项目固有的依赖关系。了解完整的依赖关系信息后，您可以选择在
        <em class="filename">makefile</em>中表示多少内容（计算的或硬编码的）以及在构建过程中可以采用哪些快捷方式。虽然这一切都不是那么简单，但它很简单。</p><p>To formulate a dependency <a class="indexterm"></a> <a class="indexterm"></a>analysis strategy, begin by understanding the
        dependencies inherent in the project. Once complete dependency
        information is understood, you can choose how much to represent in the
        <em class="filename">makefile</em> (computed or hardcoded)
        and what shortcuts can be taken during the build. Although none of
        this is exactly simple, it is straightforward.</p><p>一旦确定了<em class="filename">makefile</em>结构和必要的依赖关系，实现高效的<em class="filename">makefile</em>通常就是避免一些简单陷阱的问题。</p><p>Once you've determined your <em class="filename">makefile</em> structure and necessary
        dependencies, implementing an efficient <em class="filename">makefile</em> is usually a matter of avoiding
        some simple pitfalls.</p><div class="sect2" title="简单变量与递归"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch10s02.html.make3-CHP-10-SECT-2.1"></a>简单变量与递归</h2><h2 class="title"><a></a>Simple Variables Versus Recursive</h2></div></div></div><p>最常见的一种<a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1536" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1537" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1538" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1539" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541" class="indexterm"></a>与性能相关的问题是使用递归变量而不是简单变量。例如，由于以下代码使用<code class="literal">=</code>
          运算符而不是，因此每次使用该变量时<code class="literal">:=</code>都会执行<em class="command">date命令：</em><code class="literal">DATE</code></p><p>One of the most common <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>performance-related problems is using recursive
          variables instead of simple variables. For example, because the
          following code uses the <code class="literal">=</code>
          operator instead of <code class="literal">:=</code>, it will
          execute the <em class="command">date</em> command every
          time the <code class="literal">DATE</code> variable is
          used:</p><a id="OEBPS/ch10s02.html.I_5_tt437"></a><pre class="programlisting">日期 = $(外壳日期 +%F)</pre><pre class="programlisting">DATE = $(shell date +%F)</pre><p>该<code class="literal">+%F</code>选项指示
          <em class="command">date</em>以“yyyy-mm-dd”格式返回日期，因此对于大多数用户来说，
          永远不会注意到<em class="command">date</em>的重复执行。当然，在午夜工作的开发人员可能会感到惊讶！</p><p>The <code class="literal">+%F</code> option instructs
          <em class="command">date</em> to return the date in
          "yyyy-mm-dd" format, so for most users the repeated execution of
          <em class="command">date</em> would never be noticed. Of
          course, developers working around midnight might get a
          surprise!</p><p>由于<em class="command">make</em>不会回显从<code class="function">shell</code>函数执行的命令，因此很难确定实际正在运行的内容。通过将<code class="literal">SHELL</code>变量重置为<code class="literal">/bin/sh -x</code>，您可以欺骗<em class="command">make</em>显示它执行的所有命令。</p><p>Because <em class="command">make</em> doesn't echo
          commands executed from the <code class="function">shell</code> function, it can be difficult to
          determine what is actually being run. By resetting the <code class="literal">SHELL</code> variable to <code class="literal">/bin/sh -x</code>, you can trick <em class="command">make</em> into revealing all the commands it
          executes.</p><p>该<em class="filename">makefile</em>在执行任何操作之前创建其输出目录。输出目录的名称由单词“out”和日期组成：</p><p>This <em class="filename">makefile</em> creates its
          output directory before performing any actions. The name of the
          output directory is composed of the word "out" and the date:</p><a id="OEBPS/ch10s02.html.I_5_tt438"></a><pre class="programlisting">日期 = $(外壳日期 +%F)
OUTPUT_DIR = 输出-$(日期)

make-directories := $(shell [ -d $(OUTPUT_DIR) ] || mkdir -p $(OUTPUT_DIR))

全部： ;</pre><pre class="programlisting">DATE = $(shell date +%F)
OUTPUT_DIR = out-$(DATE)

make-directories := $(shell [ -d $(OUTPUT_DIR) ] || mkdir -p $(OUTPUT_DIR))

all: ;</pre><p>当使用调试 shell 运行时，我们可以看到：</p><p>When run with a debugging shell, we can see:</p><a id="OEBPS/ch10s02.html.I_5_tt439"></a><pre class="programlisting">$ make SHELL='/bin/sh -x'
+ 日期 +%F
+ 日期 +%F
+ '[' -d out-2004-03-30 ']'
+ mkdir -p 输出-2004-03-30
make：一切都是最新的。</pre><pre class="programlisting">$ make SHELL='/bin/sh -x'
+ date +%F
+ date +%F
+ '[' -d out-2004-03-30 ']'
+ mkdir -p out-2004-03-30
make: all is up to date.</pre><p>这清楚地向我们表明<em class="command">date</em>命令被执行了两次。如果您需要经常执行这种 shell 跟踪，您可以使用以下命令使其更容易访问：</p><p>This clearly shows us that the <em class="command">date</em> command was executed twice. If you
          need to perform this kind of shell trace often, you can make it
          easier to access with:</p><a id="OEBPS/ch10s02.html.I_5_tt440"></a><pre class="programlisting">ifdef DEBUG_SHELL
  外壳 = /bin/sh -x
万一</pre><pre class="programlisting">ifdef DEBUG_SHELL
  SHELL = /bin/sh -x
endif</pre></div><div class="sect2" title="禁用@"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch10s02.html.make3-CHP-10-SECT-2.2"></a>禁用@</h2><h2 class="title"><a></a>Disabling @</h2></div></div></div><p>命令的另一种方式是<a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1542" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1543" class="indexterm"></a>隐藏是通过使用静默命令修饰符<code class="literal">@</code>.有时能够禁用此功能会很有用。您可以通过定义变量<code class="literal">QUIET</code>来保存 @ 符号并在命令中使用该变量来简化此操作：</p><p>Another way commands are <a class="indexterm"></a> <a class="indexterm"></a>hidden is through the use of the silent command
          modifier, <code class="literal">@</code>. It can be useful at
          times to be able to disable this feature. You can make this easy by
          defining a variable, <code class="literal">QUIET</code>, to
          hold the @ sign and use the variable in commands:</p><a id="OEBPS/ch10s02.html.I_5_tt441"></a><pre class="programlisting">ifndef 详细信息
  安静:=@
万一
...
目标：
        $(QUIET) echo 建立目标...</pre><pre class="programlisting">ifndef VERBOSE
  QUIET := @
endif
...
target:
        $(QUIET) echo Building target...</pre><p>当需要查看静默修饰符隐藏的命令时，只需<code class="literal">VERBOSE</code>
          在命令行上定义：</p><p>When it becomes necessary to see commands hidden by the silent
          modifier, simply define <code class="literal">VERBOSE</code>
          on the command line:</p><a id="OEBPS/ch10s02.html.I_5_tt442"></a><pre class="programlisting">$ 使详细=1
echo 建立目标...
建立目标...</pre><pre class="programlisting">$ make VERBOSE=1
echo Building target...
Building target...</pre></div><div class="sect2" title="延迟初始化"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch10s02.html.make3-CHP-10-SECT-2.3"></a>延迟初始化</h2><h2 class="title"><a></a>Lazy Initialization</h2></div></div></div><p>当简单变量<a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1544" class="indexterm"></a> <a id="OEBPS/ch10s02.html.make3-CHP-10-ITERM-1545" class="indexterm"></a>与函数结合使用<code class="function">shell</code>，<em class="command">make</em><code class="function">shell</code>在读取
          <em class="filename">makefile</em>时评估所有函数调用。如果其中有很多，或者它们执行昂贵的计算，则<em class="command">make</em>可能会感觉缓慢。<em class="command">make</em>的响应能力可以通过在使用不存在的目标调用时计时<em class="command">make</em>来测量
          ：</p><p>When simple variables <a class="indexterm"></a> <a class="indexterm"></a>are used in conjunction with the <code class="function">shell</code> function, <em class="command">make</em> evaluates all the <code class="function">shell</code> function calls as it reads the
          <em class="filename">makefile</em>. If there are many of
          these, or if they perform expensive computations, <em class="command">make</em> can feel sluggish. The responsiveness
          of <em class="command">make</em> can be measured by timing
          <em class="command">make</em> when invoked with a
          nonexistent target:</p><a id="OEBPS/ch10s02.html.I_5_tt443"></a><pre class="programlisting">$<strong class="userinput"><code>time make no-such-target</code></strong>
make: *** 没有规则可以使目标 no-such-target。停止。

实际0m0.058s
用户0m0.062s
系统0m0.015s</pre><pre class="programlisting">$<strong class="userinput"><code>time make no-such-target</code></strong>
make: *** No rule to make target no-such-target.  Stop.

real    0m0.058s
user    0m0.062s
sys     0m0.015s</pre><p><em class="command">此代码乘以make</em>将添加到执行的任何命令（甚至是琐碎或错误的命令）的开销。</p><p>This code times the overhead that <em class="command">make</em> will add to any command executed,
          even trivial or erroneous commands.</p><p>由于递归变量每次扩展时都会重新计算其右侧，因此倾向于将复杂的计算表示为简单变量。但是，这会降低<em class="command">make</em>对所有目标的响应能力。似乎需要另一种变量，其右侧仅在第一次评估变量时评估一次，而不是之前。</p><p>Because recursive variables reevaluate their righthand side
          every time they are expanded, there is a tendency to express complex
          calculations as simple variables. However, this decreases the
          responsiveness of <em class="command">make</em> for all
          targets. It seems that there is a need for another kind of variable,
          one whose righthand side is evaluated only once the first time the
          variable is evaluated, but not before.</p><p>说明此类初始化需求的示例是<a class="link" href="#OEBPS/ch09.html" title="第 9 章 Java">第 9 章</a><a class="link" href="#OEBPS/ch09s03.html.make3-CHP-9-SECT-3.1" title="快速方法：一体化编译">9.3.1 节</a>中
          <code class="function">find-compilation-dirs</code>介绍的函数：<a class="link" href="#OEBPS/ch09s03.html.make3-CHP-9-SECT-3.1" title="快速方法：一体化编译"></a><a class="link" href="#OEBPS/ch09.html" title="第 9 章 Java"></a></p><p>An example illustrating the need for this type of
          initialization is the <code class="function">find-compilation-dirs</code> function introduced
          in the <a class="link" href="#OEBPS/ch09s03.html.make3-CHP-9-SECT-3.1" title="The Fast Approach: All-in-One Compile">Section 9.3.1</a> in
          <a class="link" href="#OEBPS/ch09.html" title="Chapter&nbsp;9.&nbsp;Java">Chapter 9</a>:</p><a id="OEBPS/ch10s02.html.I_5_tt444"></a><pre class="programlisting"># $(调用 find-compilation-dirs, 根目录)
查找编译目录= \
  $(patsubst %/,%, \
    $(排序\
      $(目录\
        $(shell $(FIND) $1 -name '*.java'))))

PACKAGE_DIRS := $(调用 find-compilation-dirs, $(SOURCE_DIR))</pre><pre class="programlisting"># $(call find-compilation-dirs, root-directory)
find-compilation-dirs =                       \
  $(patsubst %/,%,                            \
    $(sort                                    \
      $(dir                                   \
        $(shell $(FIND) $1 -name '*.java'))))

PACKAGE_DIRS := $(call find-compilation-dirs, $(SOURCE_DIR))</pre><p>理想情况下，我们希望每次执行时只执行一次<em class="command">查找</em>操作，但仅在<code class="literal">PACKAGE_DIRS</code>
          实际使用变量时执行。这可能称为<em class="firstterm">延迟初始化</em>。我们可以使用如下方式构建这样的变量
          <code class="function">eval</code>：</p><p>Ideally, we would like to perform this <em class="command">find</em> operation only once per execution,
          but only when the <code class="literal">PACKAGE_DIRS</code>
          variable is actually used. This might be called <em class="firstterm">lazy
          initialization</em>. We can build such a variable using
          <code class="function">eval</code> like this:</p><a id="OEBPS/ch10s02.html.I_5_tt445"></a><pre class="programlisting">PACKAGE_DIRS = $(重新定义包目录) $(PACKAGE_DIRS)

重新定义包目录 = \
   $(eval PACKAGE_DIRS := $(调用 find-compilation-dirs, $(SOURCE_DIR)))</pre><pre class="programlisting">PACKAGE_DIRS = $(redefine-package-dirs) $(PACKAGE_DIRS)

redefine-package-dirs = \
   $(eval PACKAGE_DIRS := $(call find-compilation-dirs, $(SOURCE_DIR)))</pre><p>基本方法是<code class="literal">PACKAGE_DIRS</code>首先将其定义为递归变量。展开时，变量会计算昂贵的函数（此处），<code class="function">find-compilation-dirs</code>并将其自身重新定义为简单变量。最后，（现在很简单）变量值从原始递归变量定义中返回。</p><p>The basic approach is to define <code class="literal">PACKAGE_DIRS</code> first as a recursive
          variable. When expanded, the variable evaluates the expensive
          function, here <code class="function">find-compilation-dirs</code>, and redefines
          itself as a simple variable. Finally, the (now simple) variable
          value is returned from the original recursive variable
          definition.</p><p>让我们详细讨论一下：</p><p>Let's go over this in detail:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>当<em class="command">make</em>读取这些变量时，它只是记录它们的右侧，因为这些变量是递归的。</p></li><li class="listitem"><p>When <em class="command">make</em> reads these
              variables, it simply records their righthand side because the
              variables are recursive.</p></li><li class="listitem"><p>第一次<code class="literal">PACKAGE_DIRS</code>使用该变量时，
               <em class="command">make</em>检索右侧并扩展第一个变量<code class="function">redefine-package-dirs</code>。</p></li><li class="listitem"><p>The first time the <code class="literal">PACKAGE_DIRS</code> variable is used,
              <em class="command">make</em> retrieves the righthand
              side and expands the first variable, <code class="function">redefine-package-dirs</code>.</p></li><li class="listitem"><p>的值<code class="literal">redefine-package-dirs</code>是单个函数调用，<code class="function">eval</code>。</p></li><li class="listitem"><p>The value of <code class="literal">redefine-package-dirs</code> is a single
              function call, <code class="function">eval</code>.</p></li><li class="listitem"><p>函数体<code class="function">eval</code>
              将递归变量 重新定义<code class="literal">PACKAGE_DIRS</code>为一个简单变量，其值是 所返回的目录集<code class="function">find-compilation-dirs</code>。现在<code class="literal">PACKAGE_DIRS</code>已经用目录列表初始化了。</p></li><li class="listitem"><p>The body of the <code class="function">eval</code>
              redefines the recursive variable, <code class="literal">PACKAGE_DIRS</code>, as a simple variable
              whose value is the set of directories returned by <code class="function">find-compilation-dirs</code>. Now <code class="literal">PACKAGE_DIRS</code> has been initialized with
              the directory list.</p></li><li class="listitem"><p>该<code class="function">redefine-package-dirs</code>变量扩展为空字符串（因为 eval 扩展为空字符串）。</p></li><li class="listitem"><p>The <code class="function">redefine-package-dirs</code> variable is
              expanded to the empty string (because eval expands to the empty
              string).</p></li><li class="listitem"><p>现在<em class="command">make</em>继续扩展原来的右侧<code class="literal">PACKAGE_DIRS</code>。剩下要做的唯一一件事就是扩展变量<code class="literal">PACKAGE_DIRS</code>。<em class="command">make</em>查找变量的值，看到一个简单变量，然后返回它的值。</p></li><li class="listitem"><p>Now <em class="command">make</em> continues to
              expand the original righthand side of <code class="literal">PACKAGE_DIRS</code>. The only thing left to
              do is expand the variable <code class="literal">PACKAGE_DIRS</code>. <em class="command">make</em> looks up the value of the
              variable, sees a simple variable, and returns its value.</p></li></ol></div><p>该代码唯一真正棘手的部分是依赖
          <em class="command">make</em>从左到右评估递归变量的右侧。例如，如果
          <em class="command">make</em>决定评估<code class="literal">$(PACKAGE_DIRS)</code>before <code class="literal">$(redefine-package-dirs)</code>，则代码将会失败。</p><p>The only really tricky part of this code is relying on
          <em class="command">make</em> to evaluate the righthand
          side of a recursive variable from left to right. If, for instance,
          <em class="command">make</em> decided to evaluate <code class="literal">$(PACKAGE_DIRS)</code> before <code class="literal">$(redefine-package-dirs)</code>, the code would
          fail.</p><p>我刚才描述的过程可以重构为一个函数<code class="function">lazy-init</code>：</p><p>The procedure I just described can be refactored into a
          function, <code class="function">lazy-init</code>:</p><a id="OEBPS/ch10s02.html.I_5_tt446"></a><pre class="programlisting"># $(调用惰性初始化,变量名,值)
定义惰性初始化
  $1 = $$(重新定义-$1) $$($1)
  重新定义-$1 = $$(eval $1 := $2)
恩德夫

# PACKAGE_DIRS - 目录的惰性列表
$(评估\
  $(调用惰性初始化，PACKAGE_DIRS，\
    $$(调用 find-compilation-dirs,$(SOURCE_DIRS))))</pre><pre class="programlisting"># $(call lazy-init,variable-name,value)
define lazy-init
  $1 = $$(redefine-$1) $$($1)
  redefine-$1 = $$(eval $1 := $2)
endef

# PACKAGE_DIRS - a lazy list of directories
$(eval                           \
  $(call lazy-init,PACKAGE_DIRS, \
    $$(call find-compilation-dirs,$(SOURCE_DIRS))))</pre></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch10s02.html.ftn.make3-CHP-10-FNOTE-2" href="#OEBPS/ch10s02.html.make3-CHP-10-FNOTE-2" class="para">2</a> ]</sup>实际上，编译时间随着输入文本的大小线性增长，并且这个时间几乎总是由磁盘 I/O 主导。同样，使用简单选项计算依赖关系的时间
            <code class="option">-M</code>是线性的，并且受磁盘 I/O 的限制。</p><p><sup>[<a href="#OEBPS/ch10s02.html.make3-CHP-10-FNOTE-2" class="para">2</a>] </sup>In practice, compilation time grows linearly with the size
            of the input text and this time is almost always dominated by disk
            I/O. Similarly, the time to compute dependencies using the simple
            <code class="option">-M</code> option is linear and bound by disk I/O.</p></div></div></div></div></div>
<div id="OEBPS/ch10s03.html"><div>
<div class="sect1" title="并行制作"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch10s03.html.make3-CHP-10-SECT-3"></a>并行制作</h1><h1 class="title"><a></a>Parallel make</h1></div></div></div><p>另一种方式<a id="OEBPS/ch10s03.html.make3-CHP-10-ITERM-1546" class="indexterm"></a> <a id="OEBPS/ch10s03.html.make3-CHP-10-ITERM-1547" class="indexterm"></a>提高构建的性能是利用 makefile<em class="filename">正在</em>解决的问题中固有的并行性。大多数<em class="filename">makefile</em>执行许多可以轻松并行执行的任务，例如将 C 源代码编译为目标文件或从目标文件创建库。此外，编写良好的<em class="filename">makefile</em>的结构本身提供了自动控制并发进程所需的所有信息。</p><p>Another way to <a class="indexterm"></a> <a class="indexterm"></a>improve the performance of a build is to take advantage
        of the parallelism inherent in the problem the <em class="filename">makefile</em> is solving. Most <em class="filename">makefile</em>s perform many tasks that are
        easily carried out in parallel, such as compiling C source to object
        files or creating libraries out of object files. Furthermore, the very
        structure of a well-written <em class="filename">makefile</em> provides all the information
        necessary to automatically control the concurrent processes.</p><p><a class="link" href="#OEBPS/ch10s03.html.make3-CHP-10-EX-1" title="例10-1。当 —jobs = 2 时 make 的输出">示例 10-1</a>显示了
        <code class="literal">mp3_player</code>使用 jobs 选项<code class="option">—jobs</code> <code class="literal">=2</code>（或<code class="option">-j</code> <code class="literal">2</code>）执行的程序。<a class="link" href="#OEBPS/ch10s03.html.make3-CHP-10-FIG-1" title="图 10-1。当 —jobs = 2 时 make 的示意图">图 10-1</a>显示了伪 UML 序列图中相同的
        <em class="command">make</em>运行。使用<code class="option">—jobs</code>=2 告诉<em class="command">make</em>在可能的情况下并行更新两个目标。当<em class="command">make</em>并行更新目标时，它会按照命令的执行顺序回显命令，并将它们交错在输出中。这会使读取并行输出<em class="command">变得</em>更加困难。让我们更仔细地看看这个输出。</p><p><a class="link" href="#OEBPS/ch10s03.html.make3-CHP-10-EX-1" title="Example&nbsp;10-1.&nbsp;Output of make when —jobs = 2">Example 10-1</a> shows our
        <code class="literal">mp3_player</code> program executed with
        the jobs option, <code class="option">—jobs</code> <code class="literal">=2</code> (or <code class="option">-j</code> <code class="literal">2</code>). <a class="link" href="#OEBPS/ch10s03.html.make3-CHP-10-FIG-1" title="Figure&nbsp;10-1.&nbsp;Diagram of make when —jobs = 2">Figure 10-1</a> shows the same
        <em class="command">make</em> run in a pseudo UML sequence
        diagram. Using <code class="option">—jobs</code>=2 tells <em class="command">make</em> to update two targets in parallel when
        that is possible. When <em class="command">make</em> updates
        targets in parallel, it echos commands in the order in which they are
        executed, interleaving them in the output. This can make reading the
        output from parallel <em class="command">make</em> more
        difficult. Let's look at this output more carefully.</p><div class="example"><a id="OEBPS/ch10s03.html.make3-CHP-10-EX-1"></a><p class="title">例10-1。当 —jobs = 2 时 make 的输出</p><p class="title">Example&nbsp;10-1.&nbsp;Output of make when —jobs = 2</p><div class="example-contents"><pre class="programlisting">  $<strong class="userinput"><code>make -f ../ch07-separate-binaries/makefile --jobs=2</code></strong>

野牛 -y --定义 ../ch07-separate-binaries/lib/db/playlist.y

flex -t ../ch07-separate-binaries/lib/db/scanner.l &gt; lib/db/scanner.c

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/app/player/play_mp3.c | \
    sed 's,\(play_mp3\.o\) *:,app/player/\1 app/player/play_mp3.d: ,' &gt; app/player/
play_mp3.d.tmp

mv -f y.tab.c lib/db/playlist.c

mv -f y.tab.h lib/db/playlist.h

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/lib/codec/codec.c | -M ../ch07-separate-binaries/lib/codec/codec.c | \
    sed 's,\(codec\.o\) *:,lib/codec/\1 lib/codec/codec.d: ,' &gt; lib/codec/codec.d.tmp

mv -f 应用程序/播放器/play_mp3.d.tmp 应用程序/播放器/play_mp3.d

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M lib/db/playlist.c | | -M lib/db/playlist.c | \
    sed 's,\(playlist\.o\) *:,lib/db/\1 lib/db/playlist.d: ,' &gt; lib/db/playlist.d.tmp

mv -f lib/codec/codec.d.tmp lib/codec/codec.d

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/lib/ui/ui.c | \
    sed 's,\(ui\.o\) *:,lib/ui/\1 lib/ui/ui.d: ,' &gt; lib/ui/ui.d.tmp

mv -f lib/db/playlist.d.tmp lib/db/playlist.d

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M lib/db/scanner.c | -M lib/db/scanner.c | \
    sed 's,\(scanner\.o\) *:,lib/db/\1 lib/db/scanner.d: ,' &gt; lib/db/scanner.d.tmp

mv -f lib/ui/ui.d.tmp lib/ui/ui.d

mv -f lib/db/scanner.d.tmp lib/db/scanner.d

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o 应用程序/播放器/play_mp3.o ../ch07-separate-binaries/应用程序/播放器/play_mp3.c

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/codec/codec.o ../ch07-separate-binaries/lib/codec/codec.c

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/db/playlist.o lib/db/playlist.c

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/db/scanner.o lib/db/scanner.c
    ../ch07-separate-binaries/lib/db/scanner.l：在函数 yylex 中：
    ../ch07-separate-binaries/lib/db/scanner.l:9：警告：返回使整数来自
不带强制转换的指针

gcc -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/ui/ui.o ../ch07-separate-binaries/lib/ui/ui.c

ar rv lib/codec/libcodec.a lib/codec/codec.o
    ar：创建 lib/codec/libcodec.a
    a - lib/codec/codec.o

ar rv lib/db/libdb.a lib/db/playlist.o lib/db/scanner.o
    ar：创建 lib/db/libdb.a
    a - lib/db/playlist.o
    a-lib/db/scanner.o

ar rv lib/ui/libui.a lib/ui/ui.o
    ar：创建 lib/ui/libui.a
    a-lib/ui/ui.o

gcc app/player/play_mp3.o lib/codec/libcodec.a lib/db/libdb.a lib/ui/libui.a -o app/
播放器/play_mp3</pre><pre class="programlisting">  $<strong class="userinput"><code>make -f ../ch07-separate-binaries/makefile --jobs=2</code></strong>

bison -y  --defines ../ch07-separate-binaries/lib/db/playlist.y

flex  -t ../ch07-separate-binaries/lib/db/scanner.l &gt; lib/db/scanner.c

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/app/player/play_mp3.c | \
    sed 's,\(play_mp3\.o\) *:,app/player/\1 app/player/play_mp3.d: ,' &gt; app/player/
play_mp3.d.tmp

mv -f y.tab.c lib/db/playlist.c

mv -f y.tab.h lib/db/playlist.h

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/lib/codec/codec.c | \
    sed 's,\(codec\.o\) *:,lib/codec/\1 lib/codec/codec.d: ,' &gt; lib/codec/codec.d.tmp

mv -f app/player/play_mp3.d.tmp app/player/play_mp3.d

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M lib/db/playlist.c | \
    sed 's,\(playlist\.o\) *:,lib/db/\1 lib/db/playlist.d: ,' &gt; lib/db/playlist.d.tmp

mv -f lib/codec/codec.d.tmp lib/codec/codec.d

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M ../ch07-separate-binaries/lib/ui/ui.c | \
    sed 's,\(ui\.o\) *:,lib/ui/\1 lib/ui/ui.d: ,' &gt; lib/ui/ui.d.tmp

mv -f lib/db/playlist.d.tmp lib/db/playlist.d

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-M lib/db/scanner.c | \
    sed 's,\(scanner\.o\) *:,lib/db/\1 lib/db/scanner.d: ,' &gt; lib/db/scanner.d.tmp

mv -f lib/ui/ui.d.tmp lib/ui/ui.d

mv -f lib/db/scanner.d.tmp lib/db/scanner.d

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o app/player/play_mp3.o ../ch07-separate-binaries/app/player/play_mp3.c

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/codec/codec.o ../ch07-separate-binaries/lib/codec/codec.c

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/db/playlist.o lib/db/playlist.c

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/db/scanner.o lib/db/scanner.c
    ../ch07-separate-binaries/lib/db/scanner.l: In function yylex:
    ../ch07-separate-binaries/lib/db/scanner.l:9: warning: return makes integer from 
pointer without a cast

gcc  -I lib -I ../ch07-separate-binaries/lib -I ../ch07-separate-binaries/include  
-c -o lib/ui/ui.o ../ch07-separate-binaries/lib/ui/ui.c

ar rv lib/codec/libcodec.a lib/codec/codec.o
    ar: creating lib/codec/libcodec.a
    a - lib/codec/codec.o

ar rv lib/db/libdb.a lib/db/playlist.o lib/db/scanner.o
    ar: creating lib/db/libdb.a
    a - lib/db/playlist.o
    a - lib/db/scanner.o

ar rv lib/ui/libui.a lib/ui/ui.o
    ar: creating lib/ui/libui.a
    a - lib/ui/ui.o

gcc   app/player/play_mp3.o lib/codec/libcodec.a lib/db/libdb.a lib/ui/libui.a   -o app/
player/play_mp3</pre></div></div><div class="figure"><a id="OEBPS/ch10s03.html.make3-CHP-10-FIG-1"></a><div class="figure-contents"><div class="mediaobject"><a id="OEBPS/ch10s03.html.I_5_tt447"></a><img src="data:image/png;base64,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" width="213" alt="当 —jobs = 2 时 make 的示意图"></div></div><p class="title">图 10-1。当 —jobs = 2 时 make 的示意图</p><p class="title">Figure&nbsp;10-1.&nbsp;Diagram of make when —jobs = 2</p></div><p>首先，<em class="command">make</em>必须构建生成的源文件和依赖文件。生成的两个源文件是<em class="command">yacc</em>和<em class="command">lex</em>的输出。这说明了命令 1 和 2。第三个命令生成<em class="filename">play_mp3.c</em>的依赖文件，并且显然是在<em class="filename">playlist.c</em>或<em class="filename">Scanner.c</em>的依赖文件完成之前开始的（通过命令 4、5、8、9、12）和 14)。因此，即使命令行选项请求两个作业，此<em class="command">make也会并行运行三个作业。</em></p><p>First, <em class="command">make</em> must build the
        generated source and dependency files. The two generated source files
        are the output of <em class="command">yacc</em> and <em class="command">lex</em>. This accounts for commands 1 and 2. The
        third command generates the dependency file for <em class="filename">play_mp3.c</em> and is clearly begun before the
        dependency files for either <em class="filename">playlist.c</em> or <em class="filename">scanner.c</em> are completed (by commands 4, 5,
        8, 9, 12, and 14). Therefore, this <em class="command">make</em> is running three jobs in parallel, even
        though the command-line option requests two jobs.</p><p><em class="command">mv</em>命令4 和 5 完成从命令 1 开始的<em class="filename">playlist.c</em>源代码生成。命令 6 开始另一个依赖文件。每个命令脚本始终由单个
        <em class="command">make</em>执行，但每个目标和先决条件形成一个单独的作业。因此，命令 7（依赖项生成脚本的第二个命令）由与命令 3 相同的<em class="command">make</em>进程执行。而命令 6 可能由执行命令 1 的<em class="command">make</em>完成后立即生成的<em class="command">make</em>执行。 -4-5（处理<em class="command">yacc</em>语法），但在命令 8 中生成依赖文件之前。<em class="command"></em><em class="command"></em></p><p>The <em class="command">mv</em> commands, 4 and 5,
        complete the <em class="filename">playlist.c</em> source
        code generation started with command 1. Command 6 begins another
        dependency file. Each command script is always executed by a single
        <em class="command">make</em>, but each target and
        prerequisite forms a separate job. Therefore, command 7, which is the
        second command of the dependency generation script, is being executed
        by the same <em class="command">make</em> process as command
        3. While command 6 is probably being executed by a <em class="command">make</em> spawned immediately following the
        completion of the <em class="command">make</em> that
        executed commands 1-4-5 (processing the <em class="command">yacc</em> grammar), but before the generation of
        the dependency file in command 8.</p><p>依赖项生成以这种方式继续，直到命令 14。所有依赖项文件必须先完成，然后<em class="command">make</em>才能进入下一个处理阶段，重新读取<em class="filename">makefile</em>。这形成了一个自然的同步点，<em class="command">使人</em>
        自动服从。</p><p>The dependency generation continues in this fashion until
        command 14. All dependency files must be complete before <em class="command">make</em> can move on to the next phase of
        processing, re-reading the <em class="filename">makefile</em>. This forms a natural
        synchronization point that <em class="command">make</em>
        automatically obeys.</p><p>一旦使用依赖信息重新读取<em class="filename">makefile ， </em><em class="command">make</em>就可以再次并行地继续构建过程。这次<em class="command">make</em>
        选择在构建每个归档库之前编译所有目标文件。这个顺序是不确定的。也就是说，如果
        再次运行<em class="filename">makefile ，则可能会在编译</em><em class="filename">playlist.c</em>之前构建<em class="filename">libcodec.a</em>库，因为该库不需要除
        <em class="filename">codec.o</em>之外的任何对象。因此，该示例代表了多种可能的执行顺序中的一种。<em class="filename"></em><em class="filename"></em></p><p>Once the <em class="filename">makefile</em> is reread
        with the dependency information, <em class="command">make</em> can continue the build process in
        parallel again. This time <em class="command">make</em>
        chooses to compile all the object files before building each of the
        archive libraries. This order is nondeterministic. That is, if the
        <em class="filename">makefile</em> is run again, it may be
        that the <em class="filename">libcodec.a</em> library might
        be built before the <em class="filename">playlist.c</em> is
        compiled, since that library doesn't require any objects other than
        <em class="filename">codec.o</em>. Thus, the example
        represents one possible execution order amongst many.</p><p>最后将程序链接起来。对于这个<em class="filename">makefile</em>，链接阶段也是一个自然的同步点，并且总是最后发生。但是，如果目标不是单个程序而是许多程序或库，则最后执行的命令也可能会有所不同。</p><p>Finally, the program is linked. For this <em class="filename">makefile</em>, the link phase is also a natural
        synchronization point and will always occur last. If, however, the
        goal was not a single program but many programs or libraries, the last
        command executed might also vary.</p><p>在多处理器上运行多个作业显然是有意义的，但在单处理器上运行多个作业也非常有用。这是因为大多数系统上的磁盘 I/O 延迟和大量缓存所致。例如，如果一个进程（例如
        <em class="command">gcc</em>）空闲等待磁盘 I/O，则另一个任务（例如<em class="command">mv</em>、<em class="command">yacc</em>或<em class="command">ar ）</em>的数据当前可能位于内存中。在这种情况下，最好允许具有可用数据的任务继续进行。一般来说，在单处理器上运行带有两个作业的<em class="command">make</em>
        几乎总是比运行一个作业快，并且三个甚至四个任务比两个任务快的情况并不罕见。</p><p>Running multiple jobs on a multiprocessor obviously makes sense,
        but running more than one job on a uniprocessor can also be very
        useful. This is because of the latency of disk I/O and the large
        amount of cache on most systems. For instance, if a process, such as
        <em class="command">gcc</em>, is idle waiting for disk I/O
        it may be that data for another task such as <em class="command">mv</em>, <em class="command">yacc</em>,
        or <em class="command">ar</em> is currently in memory. In
        this case, it would be good to allow the task with available data to
        proceed. In general, running <em class="command">make</em>
        with two jobs on a uniprocessor is almost always faster than running
        one job, and it is not uncommon for three or even four tasks to be
        faster than two.</p><p>该<code class="option">—jobs</code>选项无需编号即可使用。如果是这样，<em class="command">make</em>将产生与要更新的目标一样多的作业。这通常是一个坏主意，因为大量作业通常会淹没处理器，并且运行速度可能比单个作业慢得多。</p><p>The <code class="option">—jobs</code> option can be used without a number.
        If so, <em class="command">make</em> will spawn as many jobs
        as there are targets to be updated. This is usually a bad idea,
        because a large number of jobs will usually swamp a processor and can
        run much slower than even a single job.</p><p>管理多个作业的另一种方法是使用系统平均负载作为指导。平均负载是一段时间内（通常为 1 分钟、5 分钟和 15 分钟）内平均的可运行进程数。负载平均值以浮点数表示。<code class="option">—load-average</code>(或
        <code class="option">-l</code>) 选项给出了一个<em class="command">阈</em>值，超过该阈值就无法生成新作业。例如，命令：</p><p>Another way to manage multiple jobs is to use the system load
        average as a guide. The load average is the number of runnable
        processes averaged over some period of time, typically 1 minute, 5
        minutes, and 15 minutes. The load average is expressed as a floating
        point number. The <code class="option">—load-average</code> (or
        <code class="option">-l</code>) option gives <em class="command">make</em> a threshold above which new jobs cannot
        be spawned. For example, the command:</p><a id="OEBPS/ch10s03.html.I_5_tt448"></a><pre class="programlisting">$ make --load-average=3.5</pre><pre class="programlisting">$ make --load-average=3.5</pre><p>告诉<em class="command">make</em>仅当平均负载小于或等于 3.5 时才生成新作业。如果平均负载较大，<em class="command">则 make 会</em>等待，直到平均负载低于此数字，或者直到所有其他作业完成。</p><p>tells <em class="command">make</em> to spawn new jobs
        only when the load average is less than or equal to 3.5. If the load
        average is greater, <em class="command">make</em> waits
        until the average drops below this number, or until all the other jobs
        finish.</p><p>在编写并行执行的<em class="filename">makefile</em>时，注意适当的先决条件更为重要。如前所述，当<code class="option">—jobs</code>为 1 时，通常会从左到右评估先决条件列表。当<code class="option">—jobs</code>大于 1 时，可以并行评估这些先决条件。因此，并行运行时，由默认的从左到右计算顺序隐式处理的任何依赖关系都必须明确。</p><p>When writing a <em class="filename">makefile</em> for
        parallel execution, attention to proper prerequisites is even more
        important. As mentioned previously, when <code class="option">—jobs</code> is 1,
        a list of prerequisites will usually be evaluated from left to right.
        When <code class="option">—jobs</code> is greater than 1, these prerequisites may
        be evaluated in parallel. Therefore, any dependency relationship that
        was implicitly handled by the default left to right evaluation order
        must be made explicit when run in parallel.</p><p><em class="command">并行make</em>的另一个危害是共享中间文件的问题。例如，如果一个目录同时包含<em class="filename">foo.y</em>和<em class="filename">bar.y</em>，则并行运行<em class="command">yacc</em>两次可能会导致其中一个获得另一个<em class="filename">y.tab.c</em>或<em class="filename">y.tab.h</em>的实例，或者两者都移动到自己的 中
        <em class="filename">。 c</em>或<em class="filename">.h</em>文件。对于将临时信息存储在具有固定名称的临时文件中的任何过程，您都会面临类似的危险。</p><p>Another hazard of parallel <em class="command">make</em> is the problem of shared intermediate
        files. For example, if a directory contains both <em class="filename">foo.y</em> and <em class="filename">bar.y</em>, running <em class="command">yacc</em> twice in parallel could result in one
        of them getting the other's instance of <em class="filename">y.tab.c</em> or <em class="filename">y.tab.h</em> or both moved into its own
        <em class="filename">.c</em> or <em class="filename">.h</em> file. You face a similar hazard with any
        procedure that stores temporary information in a scratch file that has
        a fixed name.</p><p>阻碍并行执行的另一个常见习惯用法是从 shell
         <em class="command">for</em>循环调用递归<em class="command">make ：</em><em class="command"></em></p><p>Another common idiom that hinders parallel execution is invoking
        a recursive <em class="command">make</em> from a shell
        <em class="command">for</em> loop:</p><a id="OEBPS/ch10s03.html.I_5_tt449"></a><pre class="programlisting">目录：
        对于 $(SUBDIRS) 中的 d； \
        做 \
          $(MAKE) --目录=$$d; \
        完毕</pre><pre class="programlisting">dir:
        for d in $(SUBDIRS);       \
        do                         \
          $(MAKE) --directory=$$d; \
        done</pre><p><a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目">正如第 6</a><a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="递归make">章 6.1 节</a>所述，make<em class="command">无法</em>并行执行这些递归调用。要实现并行执行，请声明目录并使它们成为目标：<a class="link" href="#OEBPS/ch06.html" title="第 6 章管理大型项目"></a><em class="command"></em><code class="literal">.PHONY</code></p><p>As mentioned in <a class="link" href="#OEBPS/ch06.html.make3-CHP-6-SECT-1" title="Recursive make">Section
        6.1</a> in <a class="link" href="#OEBPS/ch06.html" title="Chapter&nbsp;6.&nbsp;Managing Large Projects">Chapter 6</a>, <em class="command">make</em> cannot execute these recursive
        invocations in parallel. To achieve parallel execution, declare the
        directories <code class="literal">.PHONY</code> and make them
        targets:</p><a id="OEBPS/ch10s03.html.I_5_tt450"></a><pre class="programlisting">.PHONY: $(子目录)
$（子目录）：
        $(MAKE) --目录=$@</pre><pre class="programlisting">.PHONY: $(SUBDIRS)
$(SUBDIRS):
        $(MAKE) --directory=$@</pre></div></div></div>
<div id="OEBPS/ch10s04.html"><div>
<div class="sect1" title="分布式制作"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch10s04.html.make3-CHP-10-SECT-4"></a>分布式制作</h1><h1 class="title"><a></a>Distributed make</h1></div></div></div><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>
        支持一点<a id="OEBPS/ch10s04.html.make3-CHP-10-ITERM-1548" class="indexterm"></a> <a id="OEBPS/ch10s04.html.make3-CHP-10-ITERM-1549" class="indexterm"></a>用于管理通过网络使用多个系统的构建的已知（且仅经过轻微测试）构建选项。该功能依赖于随<em class="command">Pmake</em>分发的 Customs 库。<em class="command">Pmake</em>是Adam de Boor 于 1989 年左右为 Sprite 操作系统编写的<em class="command">make</em>的替代版本（此后由 Andreas Stolcke 维护）。 Customs 库有助于在多台机器上并行分发<em class="command">make</em>执行。从版本 3.77 开始，<acronym class="acronym">GNU </acronym> <em class="command">make已包含对用于分发</em><em class="command">make 的</em>Customs 库的支持。</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em>
        supports a little <a class="indexterm"></a> <a class="indexterm"></a>known (and only slightly tested) build option for
        managing builds that uses multiple systems over a network. The feature
        relies upon the Customs library distributed with <em class="command">Pmake</em>. <em class="command">Pmake</em> is an alternate version of <em class="command">make</em> written in about 1989 by Adam de Boor
        (and maintained ever since by Andreas Stolcke) for the Sprite
        operating system. The Customs library helps to distribute a <em class="command">make</em> execution across many machines in
        parallel. As of version 3.77, <acronym class="acronym">GNU</acronym> <em class="command">make</em> has included support for the Customs
        library for distributing <em class="command">make</em>.</p><p>要启用 Customs 库支持，您必须从源重建<em class="command">make</em> 。此过程的说明位于<em class="command">make发行版的</em><em class="filename">README.customs</em>
        文件中。首先，您必须下载并构建<em class="command">pmake</em>发行版（URL 位于 README 中），然后使用该
        选项构建<em class="command">make</em>。<em class="command"></em><em class="command"></em><em class="command"></em><code class="option">—with-customs</code></p><p>To enable Customs library support, you must rebuild <em class="command">make</em> from sources. The instructions for this
        process are in the <em class="filename">README.customs</em>
        file in the <em class="command">make</em> distribution.
        First, you must download and build the <em class="command">pmake</em> distribution (the URL is in the
        README), then build <em class="command">make</em> with the
        <code class="option">—with-customs</code> option.</p><p>Customs 库的核心是在参与分布式<em class="command">make</em>网络的每个主机上运行的 Customs 守护进程。这些主机必须共享文件系统的公共视图，例如 NFS 提供的。海关守护进程的一个实例被指定为主进程。 Master 监控参与主机列表中的主机，并将作业分配给每个成员。当<em class="command">make</em><code class="option">—jobs</code>以大于 1 的标志运行
        时， <em class="command">make</em>会联系 master，它们一起在网络中的可用主机上生成作业。</p><p>The heart of the Customs library is the customs daemon that runs
        on each host participating in the distributed <em class="command">make</em> network. These hosts must all share a
        common view of the filesystem, such as NFS provides. One instance of
        the customs daemon is designated the master. The master monitors hosts
        in the participating hosts list and allocates jobs to each member.
        When <em class="command">make</em> is run with the
        <code class="option">—jobs</code> flag greater than 1, <em class="command">make</em> contacts the master and together they
        spawn jobs on available hosts in the network.</p><p>Customs 库支持多种功能。主机可以按体系结构分组并进行性能评级。可以将任意属性分配给主机，并且可以基于属性和布尔运算符的组合将作业分配给主机。此外，在处理作业时，还可以考虑主机状态，例如空闲时间、可用磁盘空间、可用交换空间和当前平均负载。</p><p>The Customs library supports a wide range of features. Hosts can
        be grouped by architecture and rated for performance. Arbitrary
        attributes can be assigned to hosts and jobs can be allocated to hosts
        based on combinations of attributes and boolean operators.
        Additionally, host status such as idle time, free disk space, free
        swap space, and current load average can also be accounted for when
        processing jobs.</p><p>如果您的项目是用 C、C++ 或 Objective-C 实现的，您还应该考虑使用<em class="command">distcc</em> ( <a class="ulink" href="http://distcc.samba.org/">http://distcc.samba.org</a> ) 在多个主机上分发编译。<em class="command">distcc</em>是由 Martin Pool 和其他人编写的，旨在加速 Samba 构建。对于用 C、C++ 或 Objective-C 编写的项目来说，它是一个强大且完整的解决方案。使用该工具只需将 C 编译器替换为<em class="command">distcc</em>程序即可：</p><p>If your project is implemented in C, C++, or Objective-C you
        should also consider <em class="command">distcc</em> (<a class="ulink" href="http://distcc.samba.org">http://distcc.samba.org</a>) for distributing compiles
        across several hosts. <em class="command">distcc</em> was
        written by Martin Pool and others to speedup Samba builds. It is a
        robust and complete solution for projects written in C, C++, or
        Objective-C. The tool is used by simply replacing the C compiler with
        the <em class="command">distcc</em> program:</p><a id="OEBPS/ch10s04.html.I_5_tt451"></a><pre class="programlisting">$<strong class="userinput"><code>make --jobs=8 CC=distcc</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>make --jobs=8 CC=distcc</code></strong></pre><p>对于每次编译，<em class="command">distcc</em>
        使用本地编译器来预处理输出，然后将扩展源发送到可用的远程计算机进行编译。最后，远程主机将生成的目标文件返回给主机。这种方法消除了共享文件系统的必要性，极大地简化了安装和配置。</p><p>For each compilation, <em class="command">distcc</em>
        uses the local compiler to preprocess the output, then ships the
        expanded source to an available remote machine for compilation.
        Finally, the remote host returns the resulting object file to the
        master. This approach removes the necessity for having a shared
        filesystem, greatly simplifying installation and configuration.</p><p>可以通过多种方式指定工作人员或<em class="firstterm">志愿者</em>主机集。最简单的方法是在启动<em class="command">distcc</em>之前在环境变量中列出志愿者主机：</p><p>The set of worker or <em class="firstterm">volunteer</em> hosts can
        be specified in several ways. The simplest is to list the volunteer
        hosts in an environment variable before starting <em class="command">distcc</em>:</p><a id="OEBPS/ch10s04.html.I_5_tt452"></a><pre class="programlisting">$<strong class="userinput"><code>export DISTCC_HOSTS='localhost wasatch oops'</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>export DISTCC_HOSTS='localhost wasatch oops'</code></strong></pre><p><em class="command">distcc</em>是非常可配置的，具有用于处理主机列表、与本机编译器集成、管理压缩、搜索路径以及处理故障和恢复的选项。</p><p><em class="command">distcc</em> is very configurable
        with options for handling host lists, integrating with the native
        compiler, managing compression, search paths, and handling failure and
        recovery.</p><p><em class="command">ccache</em>是另一个提高编译性能的工具，由 Samba 项目负责人 Andrew Tridgell 编写。想法很简单，缓存之前编译的结果。在执行编译之前，检查缓存是否已包含生成的目标文件。这不需要多个主机，甚至不需要网络。作者报告说，普通编译的速度提高了 5 到 10 倍。使用<em class="command">ccache</em>最简单的方法是在编译器命令前加上<em class="command">ccache</em>前缀：</p><p><em class="command">ccache</em> is another tool for
        improving compilation performance, written by Samba project leader
        Andrew Tridgell. The idea is simple, cache the results of previous
        compiles. Before performing a compile, check if the cache already
        contains the resulting object files. This does not require multiple
        hosts, or even a network. The author reports a 5 to 10 times speed up
        in common compilations. The easiest way to use <em class="command">ccache</em> is to prefix your compiler command
        with <em class="command">ccache</em>:</p><a id="OEBPS/ch10s04.html.I_5_tt453"></a><pre class="programlisting">$<strong class="userinput"><code>make CC='ccache gcc'</code></strong></pre><pre class="programlisting">$<strong class="userinput"><code>make CC='ccache gcc'</code></strong></pre><p><em class="command">ccache可以与</em><em class="command">distcc</em>一起使用，以实现更大的性能改进。此外，这两个工具都可以在 Cygwin 工具集中使用。</p><p><em class="command">ccache</em> can be used together
        with <em class="command">distcc</em> for even greater
        performance improvements. In addition, both tools are available in the
        Cygwin tool set.</p></div></div></div>
<div id="OEBPS/ch11.html"><div>
<div class="chapter" title="第 11 章 Makefile 示例"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch11.html.make3-CHP-11"></a>第 11 章 Makefile 示例</h1><h1 class="title"><a></a>Chapter&nbsp;11.&nbsp;Example Makefiles</h1></div></div></div><p>本书中显示的makefile具有工业强度，非常适合适应您最高级的需求<em class="filename">。</em>但仍然值得查看现实项目中的一些<em class="filename">makefile</em> ，看看人们在提供可交付成果的压力下使用<em class="command">make</em>做了什么。在这里，我们详细讨论几个示例<em class="filename">makefile</em> 。第一个示例是
      构建本书的<em class="filename">makefile</em> 。第二个是用于构建 2.6.7 Linux 内核的<em class="filename">makefile 。</em></p><p>The <em class="filename">makefile</em>s shown
      throughout this book are industrial strength and quite suitable for
      adapting to your most advanced needs. But it's still worthwhile looking
      at some <em class="filename">makefile</em>s from real-life
      projects to see what people have done with <em class="command">make</em> under the stress of providing
      deliverables. Here, we discuss several example <em class="filename">makefile</em>s in detail. The first example is the
      <em class="filename">makefile</em> to build this book. The
      second is the <em class="filename">makefile</em> used to
      build the 2.6.7 Linux kernel.</p><div class="sect1" title="本书 Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch11.html.make3-CHP-11-SECT-1"></a>本书 Makefile</h1><h1 class="title"><a></a>The Book Makefile</h1></div></div></div><p>写一本关于编程的书是在<a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1550" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1551" class="indexterm"></a>本身就是构建系统的一个有趣的练习。本书的文本由许多文件组成，每个文件都需要各种预处理步骤。这些示例是真实的程序，应该运行，并收集其输出、进行后处理并包含在正文中（这样就不必剪切和粘贴它们，从而避免引入错误的风险）。在撰写过程中，能够以不同格式查看文本非常有用。最后，运送材料需要包装。当然，所有这些都必须是可重复的并且相对易于维护。</p><p>Writing a book on programming is in <a class="indexterm"></a> <a class="indexterm"></a>itself an interesting exercise in building systems. The
        text of the book consists of many files, each of which needs various
        preprocessing steps. The examples are real programs that should be run
        and their output collected, post-processed, and included in the main
        text (so that they don't have to be cut and pasted, with the risk of
        introducing errors). During composition, it is useful to be able to
        view the text in different formats. Finally, delivering the material
        requires packaging. Of course, all of this must be repeatable and
        relatively easy to maintain.</p><p><em class="command">听起来像是一份make</em>的工作！这是<em class="command">make</em>的一大优点。它可以应用于解决各种各样的问题。本书以 DocBook 格式（即 XML）编写。使用<em class="command">make</em>到 TEX、LATEX 或<em class="command">troff</em>是使用这些工具时的标准程序。</p><p>Sounds like a job for <em class="command">make</em>!
        This is one of the great beauties of <em class="command">make</em>. It can be applied to an amazing
        variety of problems. This book was written in DocBook format (i.e.,
        XML). Applying <em class="command">make</em> to TEX, LATEX,
        or <em class="command">troff</em> is standard procedure when
        using those tools.</p><p><a class="link" href="#OEBPS/ch11.html.make3-CHP-11-EX-1" title="例11-1。构建本书的 makefile">例 11-1</a>显示了本书的整个<em class="filename">makefile</em> 。它大约有 440 行长。 makefile分为以下基本任务<em class="filename">：</em></p><p><a class="link" href="#OEBPS/ch11.html.make3-CHP-11-EX-1" title="Example&nbsp;11-1.&nbsp;The makefile to build the book">Example 11-1</a> shows the
        entire <em class="filename">makefile</em> for the book. It
        is about 440 lines long. The <em class="filename">makefile</em> is divided into these basic
        tasks:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>管理示例</p></li><li class="listitem"><p>Managing the examples</p></li><li class="listitem"><p>预处理 XML</p></li><li class="listitem"><p>Preprocessing the XML</p></li><li class="listitem"><p>生成各种输出格式</p></li><li class="listitem"><p>Generating various output formats</p></li><li class="listitem"><p>验证来源</p></li><li class="listitem"><p>Validating the source</p></li><li class="listitem"><p>基本维护</p></li><li class="listitem"><p>Basic maintenance</p></li></ul></div><div class="example"><a id="OEBPS/ch11.html.make3-CHP-11-EX-1"></a><p class="title">例11-1。构建本书的 makefile</p><p class="title">Example&nbsp;11-1.&nbsp;The makefile to build the book</p><div class="example-contents"><pre class="programlisting"># 制作这本书！
#
# 该文件中的主要目标是：
#
# show_pdf 生成 pdf 并启动查看器
# pdf 生成 pdf
# print 打印pdf
# show_html 生成 html 并启动查看器
# html 生成 html
# xml 生成 xml
#release 制作一个发布 tarball
# clean 清理生成的文件
#

BOOK_DIR := /测试/书
SOURCE_DIR := 文本
OUTPUT_DIR := 输出
Examples_DIR := 示例

安静=@

外壳 = bash
AWK := awk
CP := CP
EGREP := egrep
HTML_VIEWER := cygstart
杀死 := /bin/kill
M4 := m4
MV := MV
PDF_VIEWER := cygstart
RM := rm -f
MKDIR := mkdir -p
LNDIR := lndir
SED := sed
排序 := 排序
触摸 := 触摸
XMLTO := xmlto
XMLTO_FLAGS = -o $(OUTPUT_DIR) $(XML_VERBOSE)
进程 pgm := bin/进程包含
make-depend := bin/make-depend

m4-宏 := 文本/宏.m4

# $(调用过程-包含、输入文件、输出文件)
# 删除选项卡、展开宏并处理包含指令。
定义流程包括
  展开 $1 | \
  $(M4) --prefix-builtins --include=text $(m4-宏) - | \
  $(进程-PGM) &gt; $2
恩德夫

# $(调用文件存在，文件名)
# 如果文件存在则返回非空。
文件存在= $(通配符$1)

# $(调用 Maybe-mkdir, 目录名称-opt)
# 如果目录不存在则创建一个。
# 如果省略了directory-name-opt，则使用$@ 作为目录名。
也许-mkdir = $(如果$(调用文件存在，\
                     $(如果 $1,$1,$(dir $@))),, \
                $(MKDIR) $(如果 $1,$1,$(dir $@)))

# $(kill-acroread)
# 终止 acrobat reader。
定义kill-acroread
  $(安静) ps -W | \
  $(AWK) '开始 { FieldWIDTHS = "9 47 100" } \
          /AcroRd32/ { \
                       打印“杀死”$$3； \
                       系统(“$(KILL)-f”$$1)\
                     }'
恩德夫

# $(调用源到输出，文件名)
# 将源树引用转换为输出树引用。
定义源到输出
$(subst $(SOURCE_DIR),$(OUTPUT_DIR),$1)
恩德夫

# $(调用运行脚本示例、脚本名称、输出文件)
# 运行示例 makefile。
定义运行脚本示例
  ( cd $(dir $1); \
    $(notdir $1) 2&gt;&amp;1 | $(notdir $1) 2&gt;&amp;1 | \
    if $(EGREP) --silent '\$$\(MAKE\)' [mM]akefile; \
    然后 \
      $(SED) -e 's/^++*/$$/'; \
    别的 \
      $(SED) -e 's/^++*/$$/' \
             -e '/ing 目录 /d' \
             -e 's/\[[0-9]\]//'; \
    ）\
  &gt; $(TMP)/out.$$$$ &amp; \
  $(MV) $(TMP)/输出。$$$$ $2
恩德夫

# $(调用通用程序示例，示例目录)
# 创建规则来构建通用示例。
定义通用程序示例
  $(eval $1_dir := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out := $($1_dir)/run.out)
  $(eval $1_clean := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run := $($1_dir)/run-run)
  $(eval $1_sources := $(过滤出 %/CVS, $(通配符 $(EXAMPLES_DIR)/$1/*)))

  $($1_run_out): $($1_make_out) $($1_run_run)
        $$(调用运行脚本示例，$($1_run_run)，$$@)

  $($1_make_out): $($1_clean) $($1_run_make)
        $$(调用运行脚本示例，$($1_run_make)，$$@)

  $($1_clean): $($1_sources) Makefile
        $(RM) -r $($1_dir)
        $(MKDIR) $($1_dir)
        $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
        $（触摸）$$@

  $($1_run_make):
        printf "#! /bin/bash -x\nmake\n" &gt; $$@
恩德夫


# 书籍输出格式。
BOOK_XML_OUT := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT := $(subst xml,html,$(BOOK_XML_OUT))
BOOK_FO_OUT := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC := $(通配符 $(SOURCE_DIR)/*.xml)
ALL_XML_OUT := $(调用源到输出,$(ALL_XML_SRC))
DEPENDENCY_FILES := $(调用源到输出,$(subst .xml,.d,$(ALL_XML_SRC)))


# xml/html/pdf - 为本书生成所需的输出格式。
.PHONY：xml html pdf
xml: $(OUTPUT_DIR)/验证
html: $(BOOK_HTML_OUT)
pdf：$(BOOK_PDF_OUT)

# show_pdf - 生成 pdf 文件并显示它。
.PHONY：show_pdf show_html 打印
显示_pdf：$(BOOK_PDF_OUT)
        $(kill-acroread)
        $(PDF_VIEWER) $(BOOK_PDF_OUT)

# show_html - 生成 html 文件并显示它。
show_html：$（BOOK_HTML_OUT）
        $(HTML_VIEWER) $(BOOK_HTML_OUT)

# print - 打印书中的指定页面。
打印：$(BOOK_FO_OUT)
        $(kill-acroread)
        java -Dstart=15 -Dend=15 $(FOP) $&lt; -print &gt; /dev/null

# $(BOOK_PDF_OUT) - 生成 pdf 文件。
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) 生成文件

# $(BOOK_HTML_OUT) - 生成 html 文件。
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/验证 Makefile

# $(BOOK_FO_OUT) - 生成 fo 中间输出文件。
.INTERMEDIATE：$(BOOK_FO_OUT)
$(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/验证 Makefile

# $(BOOK_XML_OUT) - 处理所有 xml 输入文件。
$(BOOK_XML_OUT): 生成文件

#################################################### ##############
# FOP 支持
#
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - 定义它以查看 fop 处理器输出。
ifndef 调试_FOP
  FOP_FLAGS := -q
  FOP_输出：= | $(SED) -e '/未实现/d' \
                         -e '/相对对齐/d' \
                         -e '/xsl-脚注分隔符/d'
万一

# CLASSPATH - 为 fop 计算适当的 CLASSPATH。
导出类路径
类路径 = $(patsubst %;,%, \
              $(subst ; ,;, \
                $(addprefix c:/usr/xslt-process-2.2/java/, \
                  $(添加后缀.jar;,\
                    夏兰\
                    xercesImpl \
                    蜡染\
                    福普\
                    吉米-1.0 \
                    Avalon-framework-cvs-20020315))))

# %.pdf - 从 fo 输入生成 pdf 输出的模式规则。
%.pdf: %.fo
        $(kill-acroread)
        java -Xmx128M $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)

# %.fo - 从 xml 输入生成 fo 输出的模式规则。
PAPER_SIZE := 字母
%.fo: %.xml
        XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
        $(XMLTO) $(XMLTO_FLAGS) fo $&lt;

# %.html - 从 xml 输入生成 html 输出的模式规则。
%.html: %.xml
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;

# fop_help - 显示 fop 处理器帮助文本。
.PHONY：fop_help
fop_帮助：
        -java org.apache.fop.apps.Fop -help
        -java org.apache.fop.apps.Fop -打印帮助

#################################################### ##############
# release - 制作本书的版本。
#
RELEASE_TAR := mpwm-$(shell 日期 +%F).tar.gz
RELEASE_FILES := README Makefile *.pdf bin 示例输出文本

.PHONY：发布
发布：$(BOOK_PDF_OUT)
        ln -sf $(BOOK_PDF_OUT) 。
        焦油——创建\
            --gzip\
            --file=$(RELEASE_TAR) \
            --排除=CVS \
            --exclude=semantic.cache \
            --排除=*~ \
            $(RELEASE_FILES)
        ls -l $(RELEASE_TAR)

#################################################### ##############
# 第 1 章示例的规则。
#

# 这是所有示例目录。
例子:= \
                ch01-伪造标签 \
                ch01-cw1 \
                ch01-你好\
                ch01-cw2 \
                ch01-cw2a \
                ch02-cw3 \
                ch02-cw4 \
                ch02-cw4a \
                ch02-cw5 \
                ch02-cw5a \
                ch02-cw5b \
                ch02-cw6 \
                ch02-make-clean \
                ch03-断言-非空 \
                ch03-调试-跟踪 \
                ch03-调试-跟踪-1 \
                ch03-调试-跟踪-2 \
                ch03-过滤器故障 \
                ch03-查找程序-1 \
                ch03-查找程序-2 \
                ch03-findstring-1 \
                ch03-grep \
                ch03-包括\
                ch03-无效变量 \
                ch03-kill-acroread \
                ch03-kill-程序 \
                ch03-字母 \
                ch03-程序变量-1 \
                ch03-程序变量-2 \
                ch03-程序变量-3 \
                ch03-程序变量-5 \
                ch03-范围问题 \
                ch03-外壳 \
                ch03-尾随空格 \
                ch04-范围 \
                ch04-for-loop-1 \
                ch04-for-loop-2 \
                ch04-for-loop-3 \
                ch06-简单 \
                appb-defstruct \
                appb 算术

# 我真的很想使用这个 foreach 循环，但是 3.80 中有一个错误
# 产生致命错误。
#$(foreach e,$(示例),$(eval $(调用通用程序示例,$e)))

# 相反，我在这里手动扩展了 foreach。
$(eval $(调用通用程序示例，ch01-bogus-tab))
$(eval $(调用通用程序示例，ch01-cw1))
$(eval $(调用通用程序示例，ch01-hello))
$(eval $(调用通用程序示例，ch01-cw2))
$(eval $(调用通用程序示例，ch01-cw2a))
$(eval $(调用通用程序示例，ch02-cw3))
$(eval $(调用通用程序示例，ch02-cw4))
$(eval $(调用通用程序示例，ch02-cw4a))
$(eval $(调用通用程序示例，ch02-cw5))
$(eval $(调用通用程序示例，ch02-cw5a))
$(eval $(调用通用程序示例，ch02-cw5b))
$(eval $(调用通用程序示例，ch02-cw6))
$(eval $(调用通用程序示例，ch02-make-clean))
$(eval $(调用通用程序示例，ch03-assert-not-null))
$(eval $(调用通用程序示例，ch03-调试跟踪))
$(eval $(调用通用程序示例，ch03-debug-trace-1))
$(eval $(调用通用程序示例，ch03-debug-trace-2))
$(eval $(调用通用程序示例，ch03-过滤器失败))
$(eval $(调用通用程序示例，ch03-find-program-1))
$(eval $(调用通用程序示例，ch03-find-program-2))
$(eval $(调用通用程序示例，ch03-findstring-1))
$(eval $(调用通用程序示例，ch03-grep))
$(eval $(调用通用程序示例，ch03-include))
$(eval $(调用通用程序示例，ch03-无效变量))
$(eval $(调用通用程序示例，ch03-kill-acroread))
$(eval $(调用通用程序示例，ch03-kill-program))
$(eval $(调用通用程序示例，ch03-字母))
$(eval $(调用通用程序示例，ch03-程序变量-1))
$(eval $(调用通用程序示例，ch03-程序变量-2))
$(eval $(调用通用程序示例，ch03-程序变量-3))
$(eval $(调用通用程序示例，ch03-程序变量-5))
$(eval $(调用通用程序示例，ch03-范围问题))
$(eval $(调用通用程序示例，ch03-shell))
$(eval $(调用通用程序示例，ch03-尾随空格))
$(eval $(调用通用程序示例，ch04-范围))
$(eval $(调用通用程序示例，ch04-for-loop-1))
$(eval $(调用通用程序示例，ch04-for-loop-2))
$(eval $(调用通用程序示例，ch04-for-loop-3))
$(eval $(调用通用程序示例，ch06-简单))
$(eval $(调用通用程序示例，ch10-echo-bash))
$(eval $(调用通用程序示例，appb-defstruct))
$(eval $(调用通用程序示例，appb-算术))


#################################################### ##############
＃ 证实
#
# 检查 1) 未展开的 m4 宏； b) 标签； c) FIXME 意见； d)
# RM：对安迪的回应； e) 重复的 m4 宏
#
validation_checks := $(OUTPUT_DIR)/chk_macros_tabs \
                     $(OUTPUT_DIR)/chk_fixme \
                     $(OUTPUT_DIR)/chk_duplicate_macros \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY：仅验证
仅验证：$(OUTPUT_DIR)/验证
$(OUTPUT_DIR)/验证：$(validation_checks)
        $（触摸）$@

$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
        # 寻找宏和选项卡...
        $（安静）！ $(EGREP) --忽略大小写 \
                           - 电话号码 \
                           --regexp='\b(m4_|mp_)' \
                           --regexp='\011' \
                           $^
        $（触摸）$@

$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
        # 寻找 RM: 和 FIXME...
        $（安静）$（AWK）\
                '/FIXME/ { printf "%s:%s: %s\n", 文件名, NR, $$0 } \
                 /^ *RM:/ { \
                           if ( $$0 !~ /RM: 完成/ ) \
                           printf "%s:%s: %s\n", 文件名, NR, $$0 \
                         }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^)
        $（触摸）$@

$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
        # 寻找重复的宏...
        $（安静）！ $(EGREP) --仅匹配 \
              "\`[^']+'," $&lt; | \
        $（排序）| \
        uniq-c| \
        $(AWK) '$$1 &gt; 1 { printf "$&lt;:0: %s\n", $$0 }' | \
        $(EGREP)“^”
        $（触摸）$@

ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
        $(安静)$(AWK) -F/ '/(示例|输出)_DIR/ { print $$3 }' \
                $(过滤%.d,$^) | \
        $(排序) -u | \
        通讯 -13 - $(过滤掉 %.d,$^)
        $（触摸）$@

.INTERMEDIATE：$(ALL_EXAMPLES)
$（所有示例）：
        # 寻找未使用的示例...
        $(安静) ls -p $(EXAMPLES_DIR) | \
        $(AWK) '/CVS/ { 下一个 } \
                /\// { print substr($$0, 1, 长度 - 1) }' &gt; $@

#################################################### ##############
＃ 干净的
#
干净的：
        $(kill-acroread)
        $(RM) -r $(OUTPUT_DIR)
        $(RM) $(SOURCE_DIR)/*~ $(SOURCE_DIR)/*.log语义.cache
        $(RM) 书.pdf

#################################################### ##############
# 依赖管理
#
# 如果我们正在进行清理，请不要阅读或重制包含内容。
#
ifneq "$(MAKECMDGOALS)" "干净"
  -包括$(DEPENDENCY_FILES)
万一

vpath%.xml $(SOURCE_DIR)
vpath%.tif $(SOURCE_DIR)
vpath %.eps $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
        $(调用过程-包括, $&lt;, $@)

$(OUTPUT_DIR)/%.tif: %.tif
        $(CP) $&lt; $@

$(OUTPUT_DIR)/%.eps: %.eps
        $(CP) $&lt; $@

$(OUTPUT_DIR)/%.d: %.xml $(make-depend)
        $(make-depend) $&lt; &gt; $@

#################################################### ##############
# 创建输出目录
#
# 如有必要，创建输出目录。
#
DOCBOOK_IMAGES := $(OUTPUT_DIR)/release/images
DRAFT_PNG := /usr/share/docbook-xsl/images/draft.png

ifneq "$(MAKECMDGOALS)" "干净"
  _CREATE_OUTPUT_DIR := \
    $(外壳\
      $(MKDIR) $(DOCBOOK_IMAGES) &amp; \
      $(CP) $(DRAFT_PNG) $(DOCBOOK_IMAGES); \
      如果 ！ [[ $(foreach d, \
                $(非目录\
                  $(通配符$(EXAMPLES_DIR)/ch*)), \
                -e $(OUTPUT_DIR)/$d &amp;) -e 。 ]]; \
      然后 \
        echo 链接示例... &gt; /dev/stderr; \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      菲)
万一</pre><pre class="programlisting"># Build the book!
#
# The primary targets in this file are:
#
# show_pdf      Generate the pdf and start a viewer
# pdf           Generate the pdf
# print         Print the pdf
# show_html     Generate the html and start a viewer
# html          Generate the html
# xml           Generate the xml
# release       Make a release tarball
# clean         Clean up generated files
#

BOOK_DIR     := /test/book
SOURCE_DIR   := text
OUTPUT_DIR   := out
EXAMPLES_DIR := examples

QUIET            = @

SHELL            =  bash
AWK              := awk
CP               := cp
EGREP            := egrep
HTML_VIEWER      := cygstart
KILL             := /bin/kill
M4               := m4
MV               := mv
PDF_VIEWER       := cygstart
RM               := rm -f
MKDIR            := mkdir -p
LNDIR            := lndir
SED              := sed
SORT             := sort
TOUCH            := touch
XMLTO            := xmlto
XMLTO_FLAGS      =  -o $(OUTPUT_DIR) $(XML_VERBOSE)
process-pgm      := bin/process-includes
make-depend      := bin/make-depend

m4-macros        := text/macros.m4

# $(call process-includes, input-file, output-file)
#   Remove tabs, expand macros, and process include directives.
define process-includes
  expand $1 |                                                   \
  $(M4) --prefix-builtins --include=text $(m4-macros) - |       \
  $(process-pgm) &gt; $2
endef

# $(call file-exists, file-name)
#   Return non-null if a file exists.
file-exists = $(wildcard $1)

# $(call maybe-mkdir, directory-name-opt)
#   Create a directory if it doesn't exist.
#   If directory-name-opt is omitted use $@ for the directory-name.
maybe-mkdir = $(if $(call file-exists,          \
                     $(if $1,$1,$(dir $@))),,   \
                $(MKDIR) $(if $1,$1,$(dir $@)))

# $(kill-acroread)
#   Terminate the acrobat reader.
define kill-acroread
  $(QUIET) ps -W |                                      \
  $(AWK) 'BEGIN { FIELDWIDTHS = "9 47 100" }            \
          /AcroRd32/ {                                  \
                       print "Killing " $$3;            \
                       system( "$(KILL) -f " $$1 )      \
                     }'
endef

# $(call source-to-output, file-name)
#   Transform a source tree reference to an output tree reference.
define source-to-output
$(subst $(SOURCE_DIR),$(OUTPUT_DIR),$1)
endef

# $(call run-script-example, script-name, output-file)
#   Run an example makefile.
define run-script-example
  ( cd $(dir $1);                                       \
    $(notdir $1) 2&gt;&amp;1 |                                 \
    if $(EGREP) --silent '\$$\(MAKE\)' [mM]akefile;     \
    then                                                \
      $(SED) -e 's/^++*/$$/';                           \
    else                                                \
      $(SED) -e 's/^++*/$$/'                            \
             -e '/ing directory /d'                     \
             -e 's/\[[0-9]\]//';                        \
    fi )                                                \
  &gt; $(TMP)/out.$$$$ &amp;                                  \
  $(MV) $(TMP)/out.$$$$ $2
endef

# $(call generic-program-example,example-directory)
#   Create the rules to build a generic example.
define generic-program-example
  $(eval $1_dir      := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out  := $($1_dir)/run.out)
  $(eval $1_clean    := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run  := $($1_dir)/run-run)
  $(eval $1_sources  := $(filter-out %/CVS, $(wildcard $(EXAMPLES_DIR)/$1/*)))

  $($1_run_out): $($1_make_out) $($1_run_run)
        $$(call run-script-example, $($1_run_run), $$@)

  $($1_make_out): $($1_clean) $($1_run_make)
        $$(call run-script-example, $($1_run_make), $$@)

  $($1_clean): $($1_sources) Makefile
        $(RM) -r $($1_dir)
        $(MKDIR) $($1_dir)
        $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
        $(TOUCH) $$@

  $($1_run_make):
        printf "#! /bin/bash -x\nmake\n" &gt; $$@
endef


# Book output formats.
BOOK_XML_OUT     := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT    := $(subst xml,html,$(BOOK_XML_OUT))
BOOK_FO_OUT      := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT     := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC      := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT      := $(call source-to-output,$(ALL_XML_SRC))
DEPENDENCY_FILES := $(call source-to-output,$(subst .xml,.d,$(ALL_XML_SRC)))


# xml/html/pdf - Produce the desired output format for the book.
.PHONY: xml html pdf
xml:  $(OUTPUT_DIR)/validate
html: $(BOOK_HTML_OUT)
pdf:  $(BOOK_PDF_OUT)

# show_pdf - Generate a pdf file and display it.
.PHONY: show_pdf show_html print
show_pdf: $(BOOK_PDF_OUT)
        $(kill-acroread)
        $(PDF_VIEWER) $(BOOK_PDF_OUT)

# show_html - Generate an html file and display it.
show_html: $(BOOK_HTML_OUT)
        $(HTML_VIEWER) $(BOOK_HTML_OUT)

# print - Print specified pages from the book.
print: $(BOOK_FO_OUT)
        $(kill-acroread)
        java -Dstart=15 -Dend=15 $(FOP) $&lt; -print &gt; /dev/null

# $(BOOK_PDF_OUT) - Generate the pdf file.
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) Makefile

# $(BOOK_HTML_OUT) - Generate the html file.
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# $(BOOK_FO_OUT) - Generate the fo intermediate output file.
.INTERMEDIATE: $(BOOK_FO_OUT)
$(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# $(BOOK_XML_OUT) - Process all the xml input files.
$(BOOK_XML_OUT): Makefile

#################################################################
# FOP Support
#
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - Define this to see fop processor output.
ifndef DEBUG_FOP
  FOP_FLAGS  := -q
  FOP_OUTPUT := | $(SED) -e '/not implemented/d'        \
                         -e '/relative-align/d'         \
                         -e '/xsl-footnote-separator/d'
endif

# CLASSPATH - Compute the appropriate CLASSPATH for fop.
export CLASSPATH
CLASSPATH = $(patsubst %;,%,                                    \
              $(subst ; ,;,                                     \
                $(addprefix c:/usr/xslt-process-2.2/java/,      \
                  $(addsuffix .jar;,                            \
                    xalan                                       \
                    xercesImpl                                  \
                    batik                                       \
                    fop                                         \
                    jimi-1.0                                    \
                    avalon-framework-cvs-20020315))))

# %.pdf - Pattern rule to produce pdf output from fo input.
%.pdf: %.fo
        $(kill-acroread)
        java -Xmx128M $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)

# %.fo - Pattern rule to produce fo output from xml input.
PAPER_SIZE := letter
%.fo: %.xml
        XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
        $(XMLTO) $(XMLTO_FLAGS) fo $&lt;

# %.html - Pattern rule to produce html output from xml input.
%.html: %.xml
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;

# fop_help - Display fop processor help text.
.PHONY: fop_help
fop_help:
        -java org.apache.fop.apps.Fop -help
        -java org.apache.fop.apps.Fop -print help

#################################################################
# release - Produce a release of the book.
#
RELEASE_TAR   := mpwm-$(shell date +%F).tar.gz
RELEASE_FILES := README Makefile *.pdf bin examples out text

.PHONY: release
release: $(BOOK_PDF_OUT)
        ln -sf $(BOOK_PDF_OUT) .
        tar --create                            \
            --gzip                              \
            --file=$(RELEASE_TAR)               \
            --exclude=CVS                       \
            --exclude=semantic.cache            \
            --exclude=*~                        \
            $(RELEASE_FILES)
        ls -l $(RELEASE_TAR)

#################################################################
# Rules for Chapter 1 examples.
#

# Here are all the example directories.
EXAMPLES :=                                     \
                ch01-bogus-tab                  \
                ch01-cw1                        \
                ch01-hello                      \
                ch01-cw2                        \
                ch01-cw2a                       \
                ch02-cw3                        \
                ch02-cw4                        \
                ch02-cw4a                       \
                ch02-cw5                        \
                ch02-cw5a                       \
                ch02-cw5b                       \
                ch02-cw6                        \
                ch02-make-clean                 \
                ch03-assert-not-null            \
                ch03-debug-trace                \
                ch03-debug-trace-1              \
                ch03-debug-trace-2              \
                ch03-filter-failure             \
                ch03-find-program-1             \
                ch03-find-program-2             \
                ch03-findstring-1               \
                ch03-grep                       \
                ch03-include                    \
                ch03-invalid-variable           \
                ch03-kill-acroread              \
                ch03-kill-program               \
                ch03-letters                    \
                ch03-program-variables-1        \
                ch03-program-variables-2        \
                ch03-program-variables-3        \
                ch03-program-variables-5        \
                ch03-scoping-issue              \
                ch03-shell                      \
                ch03-trailing-space             \
                ch04-extent                     \
                ch04-for-loop-1                 \
                ch04-for-loop-2                 \
                ch04-for-loop-3                 \
                ch06-simple                     \
                appb-defstruct                  \
                appb-arithmetic

# I would really like to use this foreach loop, but a bug in 3.80
# generates a fatal error.
#$(foreach e,$(EXAMPLES),$(eval $(call generic-program-example,$e)))

# Instead I expand the foreach by hand here.
$(eval $(call generic-program-example,ch01-bogus-tab))
$(eval $(call generic-program-example,ch01-cw1))
$(eval $(call generic-program-example,ch01-hello))
$(eval $(call generic-program-example,ch01-cw2))
$(eval $(call generic-program-example,ch01-cw2a))
$(eval $(call generic-program-example,ch02-cw3))
$(eval $(call generic-program-example,ch02-cw4))
$(eval $(call generic-program-example,ch02-cw4a))
$(eval $(call generic-program-example,ch02-cw5))
$(eval $(call generic-program-example,ch02-cw5a))
$(eval $(call generic-program-example,ch02-cw5b))
$(eval $(call generic-program-example,ch02-cw6))
$(eval $(call generic-program-example,ch02-make-clean))
$(eval $(call generic-program-example,ch03-assert-not-null))
$(eval $(call generic-program-example,ch03-debug-trace))
$(eval $(call generic-program-example,ch03-debug-trace-1))
$(eval $(call generic-program-example,ch03-debug-trace-2))
$(eval $(call generic-program-example,ch03-filter-failure))
$(eval $(call generic-program-example,ch03-find-program-1))
$(eval $(call generic-program-example,ch03-find-program-2))
$(eval $(call generic-program-example,ch03-findstring-1))
$(eval $(call generic-program-example,ch03-grep))
$(eval $(call generic-program-example,ch03-include))
$(eval $(call generic-program-example,ch03-invalid-variable))
$(eval $(call generic-program-example,ch03-kill-acroread))
$(eval $(call generic-program-example,ch03-kill-program))
$(eval $(call generic-program-example,ch03-letters))
$(eval $(call generic-program-example,ch03-program-variables-1))
$(eval $(call generic-program-example,ch03-program-variables-2))
$(eval $(call generic-program-example,ch03-program-variables-3))
$(eval $(call generic-program-example,ch03-program-variables-5))
$(eval $(call generic-program-example,ch03-scoping-issue))
$(eval $(call generic-program-example,ch03-shell))
$(eval $(call generic-program-example,ch03-trailing-space))
$(eval $(call generic-program-example,ch04-extent))
$(eval $(call generic-program-example,ch04-for-loop-1))
$(eval $(call generic-program-example,ch04-for-loop-2))
$(eval $(call generic-program-example,ch04-for-loop-3))
$(eval $(call generic-program-example,ch06-simple))
$(eval $(call generic-program-example,ch10-echo-bash))
$(eval $(call generic-program-example,appb-defstruct))
$(eval $(call generic-program-example,appb-arithmetic))


#################################################################
# validate
#
# Check for 1) unexpanded m4 macros; b) tabs; c) FIXME comments; d)
# RM: responses to Andy; e) duplicate m4 macros
#
validation_checks := $(OUTPUT_DIR)/chk_macros_tabs              \
                     $(OUTPUT_DIR)/chk_fixme                    \
                     $(OUTPUT_DIR)/chk_duplicate_macros         \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY: validate-only
validate-only: $(OUTPUT_DIR)/validate
$(OUTPUT_DIR)/validate: $(validation_checks)
        $(TOUCH) $@

$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
        # Looking for macros and tabs...
        $(QUIET)! $(EGREP) --ignore-case                                \
                           --line-number                                \
                           --regexp='\b(m4_|mp_)'                       \
                           --regexp='\011'                              \
                           $^
        $(TOUCH) $@

$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
        # Looking for RM: and FIXME...
        $(QUIET)$(AWK)                                                  \
                '/FIXME/ { printf "%s:%s: %s\n", FILENAME, NR, $$0 }    \
                 /^ *RM:/  {                                            \
                           if ( $$0 !~ /RM: Done/ )                     \
                           printf "%s:%s: %s\n", FILENAME, NR, $$0      \
                         }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^)
        $(TOUCH) $@

$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
        # Looking for duplicate macros...
        $(QUIET)! $(EGREP) --only-matching              \
              "\`[^']+'," $&lt; |                          \
        $(SORT) |                                       \
        uniq -c |                                       \
        $(AWK) '$$1 &gt; 1 { printf "$&lt;:0: %s\n", $$0 }' | \
        $(EGREP) "^"
        $(TOUCH) $@

ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
        $(QUIET)$(AWK) -F/ '/(EXAMPLES|OUTPUT)_DIR/ { print $$3 }'      \
                $(filter %.d,$^) |                                      \
        $(SORT) -u |                                                    \
        comm -13 - $(filter-out %.d,$^)
        $(TOUCH) $@

.INTERMEDIATE: $(ALL_EXAMPLES)
$(ALL_EXAMPLES):
        # Looking for unused examples...
        $(QUIET) ls -p $(EXAMPLES_DIR) |        \
        $(AWK) '/CVS/ { next }                  \
                /\//  { print substr($$0, 1, length - 1) }' &gt; $@

#################################################################
# clean
#
clean:
        $(kill-acroread)
        $(RM) -r $(OUTPUT_DIR)
        $(RM) $(SOURCE_DIR)/*~ $(SOURCE_DIR)/*.log semantic.cache
        $(RM) book.pdf

#################################################################
# Dependency Management
#
# Don't read or remake includes if we are doing a clean.
#
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(DEPENDENCY_FILES)
endif

vpath %.xml $(SOURCE_DIR)
vpath %.tif $(SOURCE_DIR)
vpath %.eps $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
        $(call process-includes, $&lt;, $@)

$(OUTPUT_DIR)/%.tif: %.tif
        $(CP) $&lt; $@

$(OUTPUT_DIR)/%.eps: %.eps
        $(CP) $&lt; $@

$(OUTPUT_DIR)/%.d: %.xml $(make-depend)
        $(make-depend) $&lt; &gt; $@

#################################################################
# Create Output Directory
#
# Create the output directory if necessary.
#
DOCBOOK_IMAGES := $(OUTPUT_DIR)/release/images
DRAFT_PNG      := /usr/share/docbook-xsl/images/draft.png

ifneq "$(MAKECMDGOALS)" "clean"
  _CREATE_OUTPUT_DIR :=                                                 \
    $(shell                                                             \
      $(MKDIR) $(DOCBOOK_IMAGES) &amp;                                     \
      $(CP) $(DRAFT_PNG) $(DOCBOOK_IMAGES);                             \
      if ! [[ $(foreach d,                                              \
                $(notdir                                                \
                  $(wildcard $(EXAMPLES_DIR)/ch*)),                     \
                -e $(OUTPUT_DIR)/$d &amp;) -e . ]];                        \
      then                                                              \
        echo Linking examples... &gt; /dev/stderr;                         \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      fi)
endif</pre></div></div><p>makefile被编写为在 Cygwin 下运行<em class="filename">，</em>并没有认真尝试可移植到 Unix。尽管如此，我相信与 Unix 的不兼容性很少（如果有的话）无法通过重新定义变量或可能引入附加变量来解决。</p><p>The <em class="filename">makefile</em> is written to
        run under Cygwin with no serious attempt at portability to Unix.
        Nevertheless, I believe there are few, if any, incompatibilities with
        Unix that cannot be resolved by redefining a variable or possibly
        introducing an additional variable.</p><p>全局变量部分首先定义了根目录的位置以及文本、示例的相对位置，
        <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1552" class="indexterm"></a>
        <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1553" class="indexterm"></a>和输出目录。<em class="filename">makefile</em>使用的每个重要程序都被定义为变量。</p><p>The global variables section first defines the location of the
        root directory and the relative locations of the text, examples,
        <a class="indexterm"></a>
        <a class="indexterm"></a>and output directories.
        Each nontrivial program used by the <em class="filename">makefile</em> is defined as a variable.</p><div class="sect2" title="管理示例"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11.html.make3-CHP-11-SECT-1.1"></a>管理示例</h2><h2 class="title"><a></a>Managing Examples</h2></div></div></div><p>第一个任务是管理示例，它是最复杂的。每个示例都存储在<em class="filename">book/examples/ch </em>
          <em class="filename">-&lt;title&gt;</em>下自己的目录中。示例由
          <em class="filename">makefile</em>以及任何支持文件和目录组成。为了处理示例，我们首先创建一个指向输出树的符号链接目录并在那里工作，以便在源树中不会留下运行<em class="filename">makefile</em>的工件。此外，大多数示例需要将当前工作目录设置为<em class="filename">makefile</em>的工作目录，以便生成预期的输出。对源代码进行符号链接后，我们执行 shell 脚本<em class="command">run-make</em>，以
          使用适当的参数调用<em class="filename">makefile</em> 。如果源代码树中不存在 shell 脚本，我们可以生成默认版本。<em class="command">run-make</em>脚本的输出保存在<em class="filename">make.out</em>中。某些示例会生成可执行文件，也必须运行该可执行文件。这是通过运行脚本<em class="command">run-run</em>并将其输出保存在文件<em class="filename">run.out</em>中来完成的。<em class="replaceable"><code>n</code></em> <em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em><em class="filename"></em><em class="command"></em><em class="filename"></em></p><p>The first task, managing the examples, is the most complex.
          Each example is stored in its own directory under <em class="filename">book/examples/ch</em>
          <em class="replaceable"><code>n</code></em> <em class="filename">-&lt;title&gt;</em>. Examples consist of a
          <em class="filename">makefile</em> along with any
          supporting files and directories. To process an example we first
          create a directory of symbolic links to the output tree and work
          there so that no artifacts of running the <em class="filename">makefile</em> are left in the source tree.
          Furthermore, most of the examples require setting the current
          working directory to that of the <em class="filename">makefile</em>, in order to generate the
          expected output. After symlinking the source, we execute a shell
          script, <em class="command">run-make</em>, to invoke the
          <em class="filename">makefile</em> with the appropriate
          arguments. If no shell script is present in the source tree, we can
          generate a default version. The output of the <em class="command">run-make</em> script is saved in <em class="filename">make.out</em>. Some examples produce an
          executable, which must also be run. This is accomplished by running
          the script <em class="command">run-run</em> and saving its
          output in the file <em class="filename">run.out</em>.</p><p><em class="filename">创建符号链接树是由makefile</em>末尾的以下代码执行的：</p><p>Creating the tree of symbolic links is performed by this code
          at the end of the <em class="filename">makefile</em>:</p><a id="OEBPS/ch11.html.I_6_tt454"></a><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "干净"
  _CREATE_OUTPUT_DIR := \
    $(外壳\
      ...
      如果 ！ [[ $(foreach d, \
                $(非目录\
                  $(通配符$(EXAMPLES_DIR)/ch*)), \
                -e $(OUTPUT_DIR)/$d &amp;&amp;) -e 。 ]]; \
      然后 \
        echo 链接示例... &gt; /dev/stderr; \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      菲)
万一</pre><pre class="programlisting">ifneq "$(MAKECMDGOALS)" "clean"
  _CREATE_OUTPUT_DIR :=                                                 \
    $(shell                                                             \
      ...
      if ! [[ $(foreach d,                                              \
                $(notdir                                                \
                  $(wildcard $(EXAMPLES_DIR)/ch*)),                     \
                -e $(OUTPUT_DIR)/$d &amp;&amp;) -e . ]];                        \
      then                                                              \
        echo Linking examples... &gt; /dev/stderr;                         \
        $(LNDIR) $(BOOK_DIR)/$(EXAMPLES_DIR) $(BOOK_DIR)/$(OUTPUT_DIR); \
      fi)
endif</pre><p>该代码由包裹在条件中的单个简单变量赋值组成<code class="literal">ifneq</code>。条件是为了防止<em class="command">make</em>在<code class="literal">make clean</code>.实际变量是一个虚拟变量，其值从未被使用过。然而，当<em class="command">make</em>读取<em class="filename">makefile</em><code class="function">shell</code>时，右侧的函数会立即执行。该函数检查输出树中是否存在每个示例目录。如果缺少任何一个，则调用<em class="command">lndir</em>命令来更新符号链接树。<em class="command"></em><em class="filename"></em><code class="function">shell</code><em class="command"></em></p><p>The code consists of a single, simple variable assignment
          wrapped in an <code class="literal">ifneq</code> conditional.
          The conditional is there to prevent <em class="command">make</em> from creating the output directory
          structure during a <code class="literal">make clean</code>.
          The actual variable is a dummy whose value is never used. However,
          the <code class="function">shell</code> function on the
          right-hand side is executed immediately when <em class="command">make</em> reads the <em class="filename">makefile</em>. The <code class="function">shell</code> function checks if each example
          directory exists in the output tree. If any is missing, the <em class="command">lndir</em> command is invoked to update the
          tree of symbolic links.</p><p>所使用的测试<code class="function">if</code>
          值得更仔细地研究。测试本身由
          <code class="literal">-e</code>每个示例目录的一个测试（即文件是否存在？）组成。实际的代码是这样的： use<code class="function">wildcard</code>确定所有示例并用 剥离它们的目录部分
          <code class="function">notdir</code>，然后为每个示例目录生成文本。现在，连接所有这些部分，并将它们嵌入到<em class="command">bash</em>测试中。最后对结果进行否定。包含一个额外的测试.，以允许
          循环简单地添加到每个子句。<code class="literal">-e</code>
          <code class="literal">$(OUTPUT_DIR)/</code>
          <em class="replaceable"><code>dir</code></em> <code class="literal">&amp;&amp;</code><em class="command"></em>
          <code class="literal">[[...]]</code><code class="literal">-e </code><code class="function">foreach</code><code class="literal">&amp;&amp;</code></p><p>The test used by the <code class="function">if</code>
          is worth examining more closely. The test itself consists of one
          <code class="literal">-e</code> test (i.e., does the file
          exist?) for each example directory. The actual code goes something
          like this: use <code class="function">wildcard</code> to
          determine all the examples and strip their directory part with
          <code class="function">notdir</code>, then for each example
          directory produce the text <code class="literal">-e</code>
          <code class="literal">$(OUTPUT_DIR)/</code>
          <em class="replaceable"><code>dir</code></em> <code class="literal">&amp;&amp;</code>. Now, concatenate all these
          pieces, and embed them in a <em class="command">bash</em>
          <code class="literal">[[...]]</code> test. Finally, negate the
          result. One extra test, <code class="literal">-e </code>., is
          included to allow the <code class="function">foreach</code>
          loop to simply add <code class="literal">&amp;&amp;</code> to
          every clause.</p><p>这足以确保在发现新目录时始终将其添加到构建中。</p><p>This is sufficient to ensure that new directories are always
          added to the build when they are discovered.</p><p>下一步是创建将更新两个输出文件<em class="filename">make.out</em>和
          <em class="filename">run.out</em>的规则。这是使用用户定义函数对每个示例<em class="filename">.out文件完成的：</em></p><p>The next step is to create rules that will update the two
          output files, <em class="filename">make.out</em> and
          <em class="filename">run.out</em>. This is done for each
          example <em class="filename">.out</em> file with a
          user-defined function:</p><a id="OEBPS/ch11.html.I_6_tt455"></a><pre class="programlisting"># $(调用通用程序示例，示例目录)
# 创建规则来构建通用示例。
定义通用程序示例
  $(eval $1_dir := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out := $($1_dir)/run.out)
  $(eval $1_clean := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run := $($1_dir)/run-run)
  $(eval $1_sources := $(过滤出 %/CVS, $(通配符 $(EXAMPLES_DIR)/$1/*)))

  $($1_run_out): $($1_make_out) $($1_run_run)
        $$(调用运行脚本示例，$($1_run_run)，$$@)

  $($1_make_out): $($1_clean) $($1_run_make)
        $$(调用运行脚本示例，$($1_run_make)，$$@)

  $($1_clean): $($1_sources) Makefile
        $(RM) -r $($1_dir)
        $(MKDIR) $($1_dir)
        $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
        $（触摸）$$@

  $($1_run_make):
        printf "#! /bin/bash -x\nmake\n" &gt; $$@
恩德夫</pre><pre class="programlisting"># $(call generic-program-example,example-directory)
#   Create the rules to build a generic example.
define generic-program-example
  $(eval $1_dir      := $(OUTPUT_DIR)/$1)
  $(eval $1_make_out := $($1_dir)/make.out)
  $(eval $1_run_out  := $($1_dir)/run.out)
  $(eval $1_clean    := $($1_dir)/clean)
  $(eval $1_run_make := $($1_dir)/run-make)
  $(eval $1_run_run  := $($1_dir)/run-run)
  $(eval $1_sources  := $(filter-out %/CVS, $(wildcard $(EXAMPLES_DIR)/$1/*)))

  $($1_run_out): $($1_make_out) $($1_run_run)
        $$(call run-script-example, $($1_run_run), $$@)

  $($1_make_out): $($1_clean) $($1_run_make)
        $$(call run-script-example, $($1_run_make), $$@)

  $($1_clean): $($1_sources) Makefile
        $(RM) -r $($1_dir)
        $(MKDIR) $($1_dir)
        $(LNDIR) -silent ../../$(EXAMPLES_DIR)/$1 $($1_dir)
        $(TOUCH) $$@

  $($1_run_make):
        printf "#! /bin/bash -x\nmake\n" &gt; $$@
endef</pre><p>该函数旨在为每个示例目录调用一次：</p><p>This function is intended to be invoked once for each example
          directory:</p><a id="OEBPS/ch11.html.I_6_tt456"></a><pre class="programlisting">$(eval $(调用通用程序示例，ch01-bogus-tab))
$(eval $(调用通用程序示例，ch01-cw1))
$(eval $(调用通用程序示例，ch01-hello))
$(eval $(调用通用程序示例，ch01-cw2))</pre><pre class="programlisting">$(eval $(call generic-program-example,ch01-bogus-tab))
$(eval $(call generic-program-example,ch01-cw1))
$(eval $(call generic-program-example,ch01-hello))
$(eval $(call generic-program-example,ch01-cw2))</pre><p>函数开头的变量定义主要是为了方便和提高可读性。进一步的改进来自于执行内部赋值，<code class="function">eval</code>因此宏可以立即使用它们的值，而无需额外引用。</p><p>The variable definitions at the beginning of the function are
          mostly for convenience and to improve readability. Further
          improvement comes from performing the assignments inside <code class="function">eval</code> so their value can be used
          immediately by the macro without extra quoting.</p><p>该函数的核心是前两个目标：<code class="literal">$($1_run_out)</code>和<code class="literal">$($1_make_out)</code>。它们分别更新每个示例的<em class="filename">run.out</em>和<em class="filename">make.out</em>目标。变量名称由示例目录名称和指示的后缀<em class="filename">_run_out</em>或<em class="filename">_make_out</em>组成。</p><p>The heart of the function is the first two targets: <code class="literal">$($1_run_out)</code> and <code class="literal">$($1_make_out)</code>. These update the <em class="filename">run.out</em> and <em class="filename">make.out</em> targets for each example,
          respectively. The variable names are composed from the example
          directory name and the indicated suffix, <em class="filename">_run_out</em> or <em class="filename">_make_out</em>.</p><p>第一条规则表示<em class="filename">run.out</em>取决于<em class="filename">make.out</em>和<em class="filename">run-run</em>脚本。也就是说，如果<em class="command">make</em>已运行或<em class="filename">运行-运行</em>控制脚本已更新，则重新运行示例程序。使用以下函数更新目标<code class="function">run-script-example</code>：</p><p>The first rule says that <em class="filename">run.out</em> depends upon <em class="filename">make.out</em> and the <em class="filename">run-run</em> script. That is, rerun the
          example program if <em class="command">make</em> has been
          run or the <em class="filename">run-run</em> control
          script has been updated. The target is updated with the <code class="function">run-script-example</code> function:</p><a id="OEBPS/ch11.html.I_6_tt457"></a><pre class="programlisting"># $(调用运行脚本示例、脚本名称、输出文件)
# 运行示例 makefile。
定义运行脚本示例
  ( cd $(dir $1); \
    $(notdir $1) 2&gt;&amp;1 | $(notdir $1) 2&gt;&amp;1 | \
    if $(EGREP) --silent '\$$\(MAKE\)' [mM]akefile; \
    然后 \
      $(SED) -e 's/^++*/$$/'; \
    别的 \
      $(SED) -e 's/^++*/$$/' \
             -e '/ing 目录 /d' \
             -e 's/\[[0-9]\]//'; \
    ）\
  &gt; $(TMP)/out.$$$$ &amp;&amp; \
  $(MV) $(TMP)/输出。$$$$ $2
恩德夫</pre><pre class="programlisting"># $(call run-script-example, script-name, output-file)
#   Run an example makefile.
define run-script-example
  ( cd $(dir $1);                                       \
    $(notdir $1) 2&gt;&amp;1 |                                 \
    if $(EGREP) --silent '\$$\(MAKE\)' [mM]akefile;     \
    then                                                \
      $(SED) -e 's/^++*/$$/';                           \
    else                                                \
      $(SED) -e 's/^++*/$$/'                            \
             -e '/ing directory /d'                     \
             -e 's/\[[0-9]\]//';                        \
    fi )                                                \
  &gt; $(TMP)/out.$$$$ &amp;&amp;                                  \
  $(MV) $(TMP)/out.$$$$ $2
endef</pre><p>此函数需要脚本的路径和输出文件名。它更改到脚本的目录并运行脚本，通过过滤器传输标准输出和错误输出以清理它们。<sup>[ <a id="OEBPS/ch11.html.make3-CHP-11-FNOTE-1" href="#OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-1" class="footnote">1</a> ]</sup></p><p>This function requires the path to the script and the output
          filename. It changes to the script's directory and runs the script,
          piping both the standard output and error output through a filter to
          clean them up.<sup>[<a href="#OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-1" class="footnote">1</a>]</sup></p><p><em class="filename">make.out</em>目标类似，但增加了复杂性。如果将新文件添加到示例中，我们希望检测情况并重建示例。仅当发现新目录时，代码<code class="literal">_CREATE_OUTPUT_DIR</code>
          才会重建符号链接，而不是在添加新文件时。为了检测这种情况，我们在每个示例目录中放置一个时间戳文件，指示最后一次
          <em class="command">lndir</em>执行的时间。目标<code class="literal">$($1_clean)</code>更新此时间戳文件，并取决于示例目录中的实际源文件（而不是输出目录中的符号链接）。如果<em class="command">make的依赖性分析在示例目录中发现比</em><em class="filename">干净</em>时间戳文件更新的文件，则命令脚本将删除符号链接输出目录，重新创建它，并删除新的<em class="filename">干净</em>时间戳文件。当<em class="filename">makefile</em>本身被修改时也会执行此操作。</p><p>The <em class="filename">make.out</em> target is
          similar but has an added complication. If new files are added to an
          example, we would like to detect the situation and rebuild the
          example. The <code class="literal">_CREATE_OUTPUT_DIR</code>
          code rebuilds symlinks only if a new directory is discovered, not
          when new files are added. To detect this situation, we drop a
          timestamp file in each example directory indicating when the last
          <em class="command">lndir</em> was performed. The <code class="literal">$($1_clean)</code> target updates this timestamp
          file and depends upon the actual source files in the examples
          directory (not the symlinks in the output directory). If <em class="command">make</em>'s dependency analysis discovers a
          newer file in the examples directory than the <em class="filename">clean</em> timestamp file, the command script
          will delete the symlinked output directory, recreate it, and drop a
          new <em class="filename">clean</em> timestamp file. This
          action is also performed when the <em class="filename">makefile</em> itself is modified.</p><p>最后，<em class="filename">run-make</em> 
          shell脚本<a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1554" class="indexterm"></a>调用来运行<em class="filename">makefile</em>通常是一个两行脚本。</p><p>Finally, the <em class="filename">run-make</em>
          shell script <a class="indexterm"></a>invoked to run the <em class="filename">makefile</em> is typically a two-line
          script.</p><a id="OEBPS/ch11.html.I_6_tt458"></a><pre class="programlisting">#！ /bin/bash -x
制作</pre><pre class="programlisting">#! /bin/bash -x
make</pre><p>生成这些样板脚本很快就变得乏味，因此<code class="literal">$($1_run_make)</code>
          添加目标作为<code class="literal">$($1_make_out)</code>创建它的先决条件。如果缺少先决条件，<em class="filename">makefile</em>将在输出树中生成它。</p><p>It quickly became tedious to produce these boilerplate
          scripts, so the <code class="literal">$($1_run_make)</code>
          target was added as a prerequisite to <code class="literal">$($1_make_out)</code> to create it. If the
          prerequisite is missing, the <em class="filename">makefile</em> generates it in the output
          tree.</p><p>当为每个示例目录执行该<code class="function">generic-program-example</code>函数时，它会创建用于运行示例并准备输出以包含在 XML 文件中的所有规则。这些规则由<em class="filename">makefile</em>中包含的计算依赖关系触发。例如，<a class="link" href="#OEBPS/ch01.html" title="第 1 章 如何编写简单的 Makefile">第 1 章</a>的依赖文件
          是：</p><p>The <code class="function">generic-program-example</code> function, when
          executed for each example directory, creates all the rules for
          running examples and preparing the output for inclusion in the XML
          files. These rules are triggered by computed dependencies included
          in the <em class="filename">makefile</em>. For example,
          the dependency file for <a class="link" href="#OEBPS/ch01.html" title="Chapter&nbsp;1.&nbsp;How to Write a Simple Makefile">Chapter 1</a>
          is:</p><a id="OEBPS/ch11.html.I_6_tt459"></a><pre class="programlisting">out/ch01.xml: $(EXAMPLES_DIR)/ch01-hello/Makefile
out/ch01.xml: $(OUTPUT_DIR)/ch01-hello/make.out
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/count_words.c
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/lexer.l
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/Makefile
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw1/make.out
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw2/lexer.l
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw2/make.out
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw2/run.out
out/ch01.xml: $(OUTPUT_DIR)/ch01-bogus-tab/make.out</pre><pre class="programlisting">out/ch01.xml: $(EXAMPLES_DIR)/ch01-hello/Makefile
out/ch01.xml: $(OUTPUT_DIR)/ch01-hello/make.out
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/count_words.c
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/lexer.l
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw1/Makefile
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw1/make.out
out/ch01.xml: $(EXAMPLES_DIR)/ch01-cw2/lexer.l
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw2/make.out
out/ch01.xml: $(OUTPUT_DIR)/ch01-cw2/run.out
out/ch01.xml: $(OUTPUT_DIR)/ch01-bogus-tab/make.out</pre><p>这些依赖项是由一个简单的<em class="command">awk</em>脚本生成的，富有想象力地命名为<em class="command">make-depend</em>：</p><p>These dependencies are generated by a simple <em class="command">awk</em> script, imaginatively named <em class="command">make-depend</em>:</p><a id="OEBPS/ch11.html.I_6_tt460"></a><pre class="programlisting">#！ /bin/awk -f

函数generate_dependency（先决条件）
{
  文件名 = 文件名
  子（/文本/，“输出”，文件名）
  打印文件名“：”先决条件
}

/^ *包含程序/ {
  generate_dependency(“$(EXAMPLES_DIR)/”$2)
}

/^ *mp_program\(/ {
  匹配( $0, /\((.*)\)/, 名称 )
  generate_dependency( "$(EXAMPLES_DIR)/" 名称[1] )
}

/^ *包含输出/ {
  生成_依赖（“$（OUTPUT_DIR）/”$ 2）
}

/^ *mp_output\(/ {
  匹配( $0, /\((.*)\)/, 名称 )
  generate_dependency( "$(OUTPUT_DIR)/" 名称[1] )
}

/图形文件参考/ {
  匹配( $0, /"(.*)"/, out_file )
  生成依赖（out_file[1]）；
}</pre><pre class="programlisting">#! /bin/awk -f

function generate_dependency( prereq )
{
  filename = FILENAME
  sub( /text/, "out", filename )
  print filename ": " prereq
}

/^ *include-program/ {
  generate_dependency( "$(EXAMPLES_DIR)/" $2 )
}

/^ *mp_program\(/ {
  match( $0, /\((.*)\)/, names )
  generate_dependency( "$(EXAMPLES_DIR)/" names[1] )
}

/^ *include-output/ {
  generate_dependency( "$(OUTPUT_DIR)/" $2 )
}

/^ *mp_output\(/ {
  match( $0, /\((.*)\)/, names )
  generate_dependency( "$(OUTPUT_DIR)/" names[1] )
}

/graphic fileref/ {
  match( $0, /"(.*)"/, out_file )
  generate_dependency( out_file[1] );
}</pre><p>该脚本搜索如下模式：</p><p>The script searches for patterns like:</p><a id="OEBPS/ch11.html.I_6_tt461"></a><pre class="programlisting">mp_program(ch01-hello/Makefile)
mp_output(ch01-hello/make.out)</pre><pre class="programlisting">mp_program(ch01-hello/Makefile)
mp_output(ch01-hello/make.out)</pre><p>（<code class="literal">mp_program</code>宏使用程序列表格式，而<code class="literal">mp_output</code>宏使用程序输出格式。）脚本根据源文件名和文件名参数生成依赖项。</p><p>(The <code class="literal">mp_program</code> macro uses
          the program listing format, while the <code class="literal">mp_output</code> macro uses the program output
          format.) The script generates the dependency from the source
          filename and the filename parameter.</p><p>最后，依赖文件的生成由
          <em class="command">make</em> include 语句以通常的方式触发：</p><p>Finally, the generation of dependency files is triggered by a
          <em class="command">make</em> include statement, in the
          usual fashion:</p><a id="OEBPS/ch11.html.I_6_tt462"></a><pre class="programlisting"># $(调用源到输出，文件名)
# 将源树引用转换为输出树引用。
定义源到输出
$(subst $(SOURCE_DIR),$(OUTPUT_DIR),$1)
恩德夫
 。 。 。
ALL_XML_SRC := $(通配符 $(SOURCE_DIR)/*.xml)
DEPENDENCY_FILES := $(调用源到输出,$(subst .xml,.d,$(ALL_XML_SRC)))
 。 。 。
ifneq "$(MAKECMDGOALS)" "干净"
  -包括$(DEPENDENCY_FILES)
万一

vpath%.xml $(SOURCE_DIR)
 。 。 。
$(OUTPUT_DIR)/%.d: %.xml $(make-depend)
        $(make-depend) $&lt; &gt; $@</pre><pre class="programlisting"># $(call source-to-output, file-name)
#   Transform a source tree reference to an output tree reference.
define source-to-output
$(subst $(SOURCE_DIR),$(OUTPUT_DIR),$1)
endef
 . . . 
ALL_XML_SRC      := $(wildcard $(SOURCE_DIR)/*.xml)
DEPENDENCY_FILES := $(call source-to-output,$(subst .xml,.d,$(ALL_XML_SRC)))
 . . . 
ifneq "$(MAKECMDGOALS)" "clean"
  -include $(DEPENDENCY_FILES)
endif

vpath %.xml $(SOURCE_DIR)
 . . . 
$(OUTPUT_DIR)/%.d: %.xml $(make-depend)
        $(make-depend) $&lt; &gt; $@</pre><p>这样就完成了处理示例的代码。大多数复杂性源于希望包含
          <em class="filename">makefile</em>的实际源以及<em class="command">make</em>和示例程序的实际输出。我怀疑这里也有一点“要么忍受，要么闭嘴”综合症。如果我相信<em class="command">make</em>如此强大，它应该能够处理这个复杂的任务，天哪，它确实可以。</p><p>This completes the code for handling examples. Most of the
          complexity stems from the desire to include the actual source of the
          <em class="filename">makefile</em>s as well as the actual
          output from <em class="command">make</em> and the example
          programs. I suspect there is also a little bit of the "put up or
          shut up" syndrome here. If I believe <em class="command">make</em> is so great, it should be able to
          handle this complex task and, by golly, it can.</p></div><div class="sect2" title="XML预处理"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11.html.make3-CHP-11-SECT-1.2"></a>XML预处理</h2><h2 class="title"><a></a>XML Preprocessing</h2></div></div></div><p>冒着品牌风险<a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1555" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1556" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1557" class="indexterm"></a>作为后世的庸人，我必须承认我不太喜欢 XML。我觉得它很尴尬而且冗长。因此，当我发现手稿必须用 DocBook 编写时，我寻找更传统的工具来帮助减轻痛苦。<em class="command">m4</em>宏处理器
          和<em class="command">awk</em>是两个有很大帮助的工具。</p><p>At the risk of branding <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>myself as a philistine for all posterity, I must admit
          I don't like XML very much. I find it awkward and verbose. So, when
          I discovered that the manuscript must be written in DocBook, I
          looked for more traditional tools that would help ease the pain. The
          <em class="command">m4</em> macro processor and <em class="command">awk</em> were two tools that helped
          immensely.</p><p><em class="command">m4</em>非常适合解决DocBook 和 XML 的两个问题：避免 XML 的冗长语法和管理交叉引用中使用的 XML 标识符。例如，要强调 DocBook 中的某个单词，您必须编写：</p><p>There were two problems with DocBook and XML that <em class="command">m4</em> was perfect for: avoiding the verbose
          syntax of XML and managing the XML identifiers used in
          cross-referencing. For instance, to emphasize a word in DocBook, you
          must write:</p><a id="OEBPS/ch11.html.I_6_tt463"></a><pre class="programlisting">&lt;强调&gt;不是&lt;/强调&gt;</pre><pre class="programlisting">&lt;emphasis&gt;not&lt;/emphasis&gt;</pre><p>使用<em class="command">m4</em>，我编写了一个简单的宏，它允许我编写：</p><p>Using <em class="command">m4</em>, I wrote a simple
          macro that allowed me to instead write:</p><a id="OEBPS/ch11.html.I_6_tt464"></a><pre class="programlisting">mp_em（不是）</pre><pre class="programlisting">mp_em(not)</pre><p>啊，这样感觉好多了。此外，我还介绍了许多适合该材料的符号格式样式，例如
          <code class="literal">mp_variable</code>和<code class="literal">mp_target</code>。这使我能够选择一种简单的格式，例如文字，并稍后将其更改为生产部门喜欢的任何格式，而无需执行全局搜索和替换。</p><p>Ahh, that feels better. In addition, I introduced many
          symbolic formatting styles appropriate for the material, such as
          <code class="literal">mp_variable</code> and <code class="literal">mp_target</code>. This allowed me to select a
          trivial format, such as literal, and change it later to whatever the
          production department preferred without having to perform a global
          search and replace.</p><p>我确信 XML 爱好者可能会向我发送大量电子邮件，告诉我如何使用实体或类似的东西来做到这一点，但请记住 Unix 是用手头的工具完成工作，正如 Larry Wall 喜欢说的，“有不止一种方法可以做到这一点。”此外，我担心学太多 XML 会腐蚀我的大脑。</p><p>I'm sure the XML aficionados will probably send me boat loads
          of email telling me how to do this with entities or some such, but
          remember Unix is about getting the job done now with the tools at
          hand, and as Larry Wall loves to say, "there's more than one way to
          do it." Besides, I'm afraid learning too much XML will rot my
          brain.</p><p><em class="command">m4</em>的第二个任务是
          <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1558" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1559" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1560" class="indexterm"></a>处理用于交叉引用的 XML 标识符。每个章节、示例和表格都标有标识符：</p><p>The second task for <em class="command">m4</em> was
          <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>handling the XML identifiers used for
          cross-referencing. Each chapter, section, example, and table is
          labeled with an identifier:</p><a id="OEBPS/ch11.html.I_6_tt465"></a><pre class="programlisting">&lt;sect1 id="MPWM-CH-7-SECT-1"&gt;</pre><pre class="programlisting">&lt;sect1 id="MPWM-CH-7-SECT-1"&gt;</pre><p>对章节的引用必须使用此标识符。从编程的角度来看，这显然是一个问题。标识符是散布在整个“代码”中的复杂常量。此外，符号本身没有任何意义。我不知道
          <a class="link" href="#OEBPS/ch07.html" title="第 7 章可移植 Makefile">第 7 章</a>第 1 节是关于什么的。通过使用<em class="command">m4</em>，我可以避免重复复杂的文字，并提供更有意义的名称：</p><p>References to a chapter must use this identifier. This is
          clearly an issue from a programming standpoint. The identifiers are
          complex constants sprinkled throughout the "code." Furthermore, the
          symbols themselves have no meaning. I have no idea what section 1 of
          <a class="link" href="#OEBPS/ch07.html" title="Chapter&nbsp;7.&nbsp;Portable Makefiles">Chapter 7</a> might have been about.
          By using <em class="command">m4</em>, I could avoid
          duplicating complex literals, and provide a more meaningful
          name:</p><a id="OEBPS/ch11.html.I_6_tt466"></a><pre class="programlisting">&lt;sect1 id="mp_se_makedepend"&gt;</pre><pre class="programlisting">&lt;sect1 id="mp_se_makedepend"&gt;</pre><p>最重要的是，如果章节发生变化（就像很多次一样），可以通过更改单个文件中的一些常量来更新文本。当章节中的章节重新编号时，优势最为明显。如果我没有使用符号引用，这样的操作可能需要对所有文件进行六次全局搜索和替换操作。</p><p>Most importantly, if chapters or sections shift, as they did
          many times, the text could be updated by changing a few constants in
          a single file. The advantage was most noticeable when sections were
          renumbered in a chapter. Such an operation might require a half
          dozen global search and replace operations across all files if I
          hadn't used symbolic references.</p><p><em class="command">下面是几个m4</em>宏的示例<sup>[ <a id="OEBPS/ch11.html.make3-CHP-11-FNOTE-2" href="#OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-2" class="footnote">2</a> ]</sup>：</p><p>Here is an example of several <em class="command">m4</em> macros<sup>[<a href="#OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-2" class="footnote">2</a>]</sup>:</p><a id="OEBPS/ch11.html.I_6_tt467"></a><pre class="programlisting">m4_define(`mp_tag', `&lt;$1&gt;`$2'&lt;/$1&gt;')
m4_define(`mp_lit', `mp_tag(文字, `$1')')

m4_define(`mp_cmd', `mp_tag(命令,`$1')')
m4_define(`mp_target', `mp_lit($1)')

m4_define(`mp_all', `mp_target(全部)')
m4_define(`mp_bash', `mp_cmd(bash)')

m4_define(`mp_ch_examples', `MPWM-CH-11')
m4_define(`mp_se_book', `MPWM-CH-11.1')
m4_define(`mp_ex_book_makefile',`MPWM-CH-11-EX-1')</pre><pre class="programlisting">m4_define(`mp_tag',    `&lt;$1&gt;`$2'&lt;/$1&gt;')
m4_define(`mp_lit',    `mp_tag(literal, `$1')')

m4_define(`mp_cmd',    `mp_tag(command,`$1')')
m4_define(`mp_target', `mp_lit($1)')

m4_define(`mp_all',    `mp_target(all)')
m4_define(`mp_bash',   `mp_cmd(bash)')

m4_define(`mp_ch_examples',     `MPWM-CH-11')
m4_define(`mp_se_book',         `MPWM-CH-11.1')
m4_define(`mp_ex_book_makefile',`MPWM-CH-11-EX-1')</pre><p>另一个预处理任务是在前面讨论的示例文本中实现包含功能。该文本需要将其制表符转换为空格（因为 O'Reilly 的 DocBook 转换器无法处理制表符，并且<em class="filename">makefile</em>有很多制表符！），必须用 a 包裹<code class="literal">[CDATA[...]]</code>以保护特殊字符，最后，必须修剪多余的换行符示例的开头和结尾。我用另一个<em class="command">awk</em>小程序完成了这个任务<code class="literal">process-includes</code>：</p><p>The other preprocessing task was to implement an include
          feature for slurping in the example text previously discussed. This
          text needed to have its tabs converted to spaces (since O'Reilly's
          DocBook converter cannot handle tabs and <em class="filename">makefile</em>s have lots of tabs!), must be
          wrapped in a <code class="literal">[CDATA[...]]</code> to
          protect special characters, and finally, has to trim the extra
          newlines at the beginning and end of examples. I accomplished this
          with another little <em class="command">awk</em> program
          called <code class="literal">process-includes</code>:</p><a id="OEBPS/ch11.html.I_6_tt468"></a><pre class="programlisting">#！ /usr/bin/awk -f
函数 Expand_cdata( 目录 )
{
  start_place = match( $1, "include-" )
  如果（起始位置&gt; 0）
  {
    前缀 = substr( $1, 1, 起始位置 - 1 )
  }
  别的
  {
    print "伪造的 include '" $0 "'" &gt; "/dev/stderr"
  }

  end_place = match( $2, "(&lt;/(programlisting|screen)&gt;.*)$", 标签 )
  如果（结束地点 &gt; 0）
  {
    文件 = dir substr( $2, 1, end_place - 1 )
  }
  别的
  {
    print "伪造的 include '" $0 "'" &gt; "/dev/stderr"
  }

  命令=“展开”文件

  printf "%s&gt;&amp;33;&amp;91;CDATA[", 前缀
  尾部 = 0
  前一行=“”
  while ( (命令 | getline 行) &gt; 0 )
  {
    如果（尾部）
      打印前一行；

    尾部 = 1
    前一行 = 行
  }

  printf "%s&amp;93;&amp;93;&amp;62;%s\n", previous_line, tag[1]
  关闭（命令）
}

/包括程序/ {
  Expand_cdata(“示例/”)
  下一个;
}

/包括输出/ {
  展开_cdata(“输出/”)
  下一个;
}

/&lt;(节目列表|屏幕)&gt; *$/ {
  # 找到当前的缩进。
  偏移 = 匹配( $0, "&lt;(节目列表|屏幕)&gt;" )

  # 从标签中删除换行符。
  打印 $0

  # 阅读程序...
  尾部 = 0
  前一行=“”
  while ( (getline 行) &gt; 0 )
  {
    if ( line ~ "&lt;/(programlisting|screen)&gt;" )
    {
      gsub( /^ */, "", 行 )
      休息
    }

    如果（尾部）
      打印前一行

    尾部 = 1
    previous_line = substr( 行，偏移量 + 1 )
  }

  printf "%s%s\n", previous_line, 行

  下一个
}

{
  打印
}</pre><pre class="programlisting">#! /usr/bin/awk -f
function expand_cdata( dir )
{
  start_place = match( $1, "include-" )
  if ( start_place &gt; 0 )
  {
    prefix = substr( $1, 1, start_place - 1 )
  }
  else
  {
    print "Bogus include '" $0 "'" &gt; "/dev/stderr"
  }

  end_place = match( $2, "(&lt;/(programlisting|screen)&gt;.*)$", tag )
  if ( end_place &gt; 0 )
  {
    file = dir substr( $2, 1, end_place - 1 )
  }
  else
  {
    print "Bogus include '" $0 "'" &gt; "/dev/stderr"
  }

  command = "expand " file

  printf "%s&gt;&amp;33;&amp;91;CDATA[", prefix
  tail = 0
  previous_line = ""
  while ( (command | getline line) &gt; 0 )
  {
    if ( tail )
      print previous_line;

    tail = 1
    previous_line = line
  }

  printf "%s&amp;93;&amp;93;&amp;62;%s\n", previous_line, tag[1]
  close( command )
}

/include-program/ {
  expand_cdata( "examples/" )
  next;
}

/include-output/ {
  expand_cdata( "out/" )
  next;
}

/&lt;(programlisting|screen)&gt; *$/ {
  # Find the current indentation.
  offset = match( $0, "&lt;(programlisting|screen)&gt;" )

  # Strip newline from tag.
  printf $0

  # Read the program...
  tail = 0
  previous_line = ""
  while ( (getline line) &gt; 0 )
  {
    if ( line ~ "&lt;/(programlisting|screen)&gt;" )
    {
      gsub( /^ */, "", line )
      break
    }

    if ( tail )
      print previous_line

    tail = 1
    previous_line = substr( line, offset + 1 )
  }

  printf "%s%s\n", previous_line, line

  next
}

{
  print
}</pre><p>在<em class="filename">makefile</em>中，我们将 XML 文件从源树复制到输出树，并在此过程中转换选项卡、宏和包含文件：</p><p>In the <em class="filename">makefile</em>, we copy
          the XML files from the source tree to the output tree, transforming
          tabs, macros, and include files in the process:</p><a id="OEBPS/ch11.html.I_6_tt469"></a><pre class="programlisting">进程 pgm := bin/进程包含
m4-宏 := 文本/宏.m4

# $(调用过程-包含、输入文件、输出文件)
# 删除选项卡、展开宏并处理包含指令。
定义流程包括
  展开 $1 | \
  $(M4) --prefix-builtins --include=text $(m4-宏) - | \
  $(进程-PGM) &gt; $2
恩德夫

vpath%.xml $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
        $(调用过程-包括, $&lt;, $@)</pre><pre class="programlisting">process-pgm := bin/process-includes
m4-macros   := text/macros.m4

# $(call process-includes, input-file, output-file)
#   Remove tabs, expand macros, and process include directives.
define process-includes
  expand $1 |                                             \
  $(M4) --prefix-builtins --include=text $(m4-macros) - | \
  $(process-pgm) &gt; $2
endef

vpath %.xml $(SOURCE_DIR)

$(OUTPUT_DIR)/%.xml: %.xml $(process-pgm) $(m4-macros)
        $(call process-includes, $&lt;, $@)</pre><p>模式规则指示如何将 XML 文件从源树获取到输出树。它还表示，如果宏或包含处理器发生更改，则应重新生成所有输出 XML 文件。</p><p>The pattern rule indicates how to get an XML file from the
          source tree into the output tree. It also says that all the output
          XML files should be regenerated if the macros or the include
          processor change.</p></div><div class="sect2" title="生成输出"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11.html.make3-CHP-11-SECT-1.3"></a>生成输出</h2><h2 class="title"><a></a>Generating Output</h2></div></div></div><p>到目前为止，我们所涵盖的内容都没有<a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1561" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1562" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1563" class="indexterm"></a>实际上格式化任何文本或创建任何可以打印或显示的内容。显然，如果<em class="filename">makefile</em>是格式化一本书，那么这是一个非常重要的功能。我对两种格式感兴趣：HTML 和 PDF。</p><p>So far, nothing we've covered has<a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> actually formatted any text or created anything that
          can be printed or displayed. Obviously, a very important feature if
          the <em class="filename">makefile</em> is to format a
          book. There were two formats that I was interested in: HTML and
          PDF.</p><p>我先弄清楚如何格式化为 HTML。有一个很棒的小程序<em class="command">xsltproc</em>及其帮助程序脚本<em class="command">xmlto</em>，我用它来完成这项工作。使用这些工具，过程相当简单：</p><p>I figured out how to format to HTML first. There's a great
          little program, <em class="command">xsltproc</em>, and its
          helper script, <em class="command">xmlto</em>, that I used
          to do the job. Using these tools, the process was fairly
          simple:</p><a id="OEBPS/ch11.html.I_6_tt470"></a><pre class="programlisting"># 书籍输出格式。
BOOK_XML_OUT := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT := $(subst xml,html,$(BOOK_XML_OUT))
ALL_XML_SRC := $(通配符 $(SOURCE_DIR)/*.xml)
ALL_XML_OUT := $(调用源到输出,$(ALL_XML_SRC))

# html - 为本书生成所需的输出格式。
.PHONY：html
html: $(BOOK_HTML_OUT)

# show_html - 生成 html 文件并显示它。
.PHONY：show_html
show_html：$（BOOK_HTML_OUT）
        $(HTML_VIEWER) $(BOOK_HTML_OUT)

# $(BOOK_HTML_OUT) - 生成 html 文件。
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/验证 Makefile

# %.html - 从 xml 输入生成 html 输出的模式规则。
%.html: %.xml
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;</pre><pre class="programlisting"># Book output formats.
BOOK_XML_OUT     := $(OUTPUT_DIR)/book.xml
BOOK_HTML_OUT    := $(subst xml,html,$(BOOK_XML_OUT))
ALL_XML_SRC      := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT      := $(call source-to-output,$(ALL_XML_SRC))

# html - Produce the desired output format for the book.
.PHONY: html
html: $(BOOK_HTML_OUT)

# show_html - Generate an html file and display it.
.PHONY: show_html
show_html: $(BOOK_HTML_OUT)
        $(HTML_VIEWER) $(BOOK_HTML_OUT)

# $(BOOK_HTML_OUT) - Generate the html file.
$(BOOK_HTML_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# %.html - Pattern rule to produce html output from xml input.
%.html: %.xml
        $(XMLTO) $(XMLTO_FLAGS) html-nochunks $&lt;</pre><p>模式规则完成将 XML 文件转换为 HTML 文件的大部分工作。这本书被组织为一个顶级文件<em class="filename">book.xml</em>，其中包括每一章。顶级文件由 表示<code class="literal">BOOK_XML_OUT</code>。 HTML 对应项是
          <code class="literal">BOOK_HTML_OUT</code>，它是一个目标。该<code class="literal">BOOK_HTML_OUT</code>文件具有其包含的 XML 文件的先决条件。为了方便起见，有两个虚假目标<code class="literal">html</code>和<code class="literal">show_html</code>，分别创建 HTML 文件并将其显示在本地浏览器中。</p><p>The pattern rule does most of the work of converting an XML
          file into an HTML file. The book is organized as a single top-level
          file, <em class="filename">book.xml</em>, that includes
          each chapter. The top-level file is represented by <code class="literal">BOOK_XML_OUT</code>. The HTML counterpart is
          <code class="literal">BOOK_HTML_OUT</code>, which is a target.
          The <code class="literal">BOOK_HTML_OUT</code> file has its
          included XML files a prerequisites. For convenience, there are two
          phony targets, <code class="literal">html</code> and <code class="literal">show_html</code>, that create the HTML file and
          display it in the local browser, respectively.</p><p>虽然原则上很简单，但生成 PDF 却要复杂得多。<em class="command">xsltproc</em>程序
          能够直接生成 PDF，但我无法让它工作。所有这些工作都是在 Windows 上使用 Cygwin 完成的， <em class="command">xsltproc</em>的 Cygwin 版本需要 POSIX 路径。我使用的是 DocBook 的自定义版本，手稿本身包含 Windows 特定的路径。我相信，这种差异使<em class="command">xsltproc</em>感到无法平息。相反，我选择使用<em class="command">xsltproc</em>生成 XML 格式化对象，并使用 Java 程序 FOP ( <a class="ulink" href="http://xml.apache.org/fop">http://xml.apache.org/fop</a> ) 生成 PDF。</p><p>Although easy in principle, generating PDF was considerably
          more complex. The <em class="command">xsltproc</em>
          program is able to produce PDF directly, but I was unable to get it
          to work. All this work was done on Windows with Cygwin and the
          Cygwin version of <em class="command">xsltproc</em> wanted
          POSIX paths. The custom version of DocBook I was using and the
          manuscript itself contained Windows-specific paths. This difference,
          I believe, gave <em class="command">xsltproc</em> fits
          that I could not quell. Instead, I chose to use <em class="command">xsltproc</em> to generate XML formatting
          objects and the Java program FOP (<a class="ulink" href="http://xml.apache.org/fop">http://xml.apache.org/fop</a>) for generating the
          PDF.</p><p>因此，生成 PDF 的代码有点长：</p><p>Thus, the code to generate PDF is somewhat longer:</p><a id="OEBPS/ch11.html.I_6_tt471"></a><pre class="programlisting"># 书籍输出格式。
BOOK_XML_OUT := $(OUTPUT_DIR)/book.xml
BOOK_FO_OUT := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC := $(通配符 $(SOURCE_DIR)/*.xml)
ALL_XML_OUT := $(调用源到输出,$(ALL_XML_SRC))

# pdf - 为书籍生成所需的输出格式。
.PHONY：pdf
pdf：$(BOOK_PDF_OUT)

# show_pdf - 生成 pdf 文件并显示它。
.PHONY：show_pdf
显示_pdf：$(BOOK_PDF_OUT)
        $(kill-acroread)
        $(PDF_VIEWER) $(BOOK_PDF_OUT)

# $(BOOK_PDF_OUT) - 生成 pdf 文件。
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) 生成文件

# $(BOOK_FO_OUT) - 生成 fo 中间输出文件。
.INTERMEDIATE：$(BOOK_FO_OUT)
$(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/验证 Makefile

# FOP 支持
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - 定义它以查看 fop 处理器输出。
ifndef 调试_FOP
  FOP_FLAGS := -q
  FOP_输出：= | $(SED) -e '/未实现/d' \
                         -e '/相对对齐/d' \
                         -e '/xsl-脚注分隔符/d'
万一

# CLASSPATH - 为 fop 计算适当的 CLASSPATH。
导出类路径
类路径 = $(patsubst %;,%, \
              $(subst ; ,;, \
                $(addprefix c:/usr/xslt-process-2.2/java/, \
                  $(添加后缀.jar;,\
                    夏兰\
                    xercesImpl \
                    蜡染\
                    福普\
                    吉米-1.0 \
                    Avalon-framework-cvs-20020315))))

# %.pdf - 从 fo 输入生成 pdf 输出的模式规则。
%.pdf: %.fo
        $(kill-acroread)
        java -Xmx128M $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)

# %.fo - 从 xml 输入生成 fo 输出的模式规则。
PAPER_SIZE := 字母
%.fo: %.xml
        XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
        $(XMLTO) $(XMLTO_FLAGS) fo $&lt;

# fop_help - 显示 fop 处理器帮助文本。
.PHONY：fop_help
fop_帮助：
        -java org.apache.fop.apps.Fop -help
        -java org.apache.fop.apps.Fop -打印帮助</pre><pre class="programlisting"># Book output formats.
BOOK_XML_OUT     := $(OUTPUT_DIR)/book.xml
BOOK_FO_OUT      := $(subst xml,fo,$(BOOK_XML_OUT))
BOOK_PDF_OUT     := $(subst xml,pdf,$(BOOK_XML_OUT))
ALL_XML_SRC      := $(wildcard $(SOURCE_DIR)/*.xml)
ALL_XML_OUT      := $(call source-to-output,$(ALL_XML_SRC))

# pdf - Produce the desired output format for the book.
.PHONY: pdf
pdf:  $(BOOK_PDF_OUT)

# show_pdf - Generate a pdf file and display it.
.PHONY: show_pdf
show_pdf: $(BOOK_PDF_OUT)
        $(kill-acroread)
        $(PDF_VIEWER) $(BOOK_PDF_OUT)

# $(BOOK_PDF_OUT) - Generate the pdf file.
$(BOOK_PDF_OUT): $(BOOK_FO_OUT) Makefile

# $(BOOK_FO_OUT) - Generate the fo intermediate output file.
.INTERMEDIATE: $(BOOK_FO_OUT)
$(BOOK_FO_OUT): $(ALL_XML_OUT) $(OUTPUT_DIR)/validate Makefile

# FOP Support
FOP := org.apache.fop.apps.Fop

# DEBUG_FOP - Define this to see fop processor output.
ifndef DEBUG_FOP
  FOP_FLAGS  := -q
  FOP_OUTPUT := | $(SED) -e '/not implemented/d'        \
                         -e '/relative-align/d'         \
                         -e '/xsl-footnote-separator/d'
endif

# CLASSPATH - Compute the appropriate CLASSPATH for fop.
export CLASSPATH
CLASSPATH = $(patsubst %;,%,                                    \
              $(subst ; ,;,                                     \
                $(addprefix c:/usr/xslt-process-2.2/java/,      \
                  $(addsuffix .jar;,                            \
                    xalan                                       \
                    xercesImpl                                  \
                    batik                                       \
                    fop                                         \
                    jimi-1.0                                    \
                    avalon-framework-cvs-20020315))))

# %.pdf - Pattern rule to produce pdf output from fo input.
%.pdf: %.fo
        $(kill-acroread)
        java -Xmx128M $(FOP) $(FOP_FLAGS) $&lt; $@ $(FOP_OUTPUT)

# %.fo - Pattern rule to produce fo output from xml input.
PAPER_SIZE := letter
%.fo: %.xml
        XSLT_FLAGS="--stringparam paper.type $(PAPER_SIZE)" \
        $(XMLTO) $(XMLTO_FLAGS) fo $&lt;

# fop_help - Display fop processor help text.
.PHONY: fop_help
fop_help:
        -java org.apache.fop.apps.Fop -help
        -java org.apache.fop.apps.Fop -print help</pre><p>正如您所看到的，现在有两个模式规则反映了我使用的两阶段过程。 .xml<em class="filename">到</em><em class="filename">.fo</em>规则调用<em class="command">xmlto</em>。<em class="filename">.fo</em>到<em class="filename">.pdf</em>规则首先终止所有正在运行的 Acrobat 阅读器（因为该程序锁定 PDF 文件，阻止 FOP 写入该文件），然后运行 ​​FOP。 FOP 是一个非常啰嗦的程序，滚动浏览数百行毫无意义的警告很快就会过时，因此我添加了一个简单的<em class="command">sed</em>
          过滤器<code class="literal">FOP_OUTPUT</code>来删除恼人的警告。然而，有时这些警告中包含一些真实数据，因此我添加了一个调试功能<code class="literal">DEBUG_FOP</code>来禁用我的过滤器。最后，与 HTML 版本一样，我添加了两个便利目标<code class="literal">pdf</code>和<code class="literal">show_pdf</code>，以启动整个过程。</p><p>As you can see, there are now two pattern rules reflecting the
          two-stage process I used. The <em class="filename">.xml</em> to <em class="filename">.fo</em> rule invokes <em class="command">xmlto</em>. The <em class="filename">.fo</em> to <em class="filename">.pdf</em> rule first kills any running Acrobat
          reader (because the program locks the PDF file, preventing FOP from
          writing the file), then runs FOP. FOP is a very chatty program, and
          scrolling through hundreds of lines of pointless warnings got old
          fast, so I added a simple <em class="command">sed</em>
          filter, <code class="literal">FOP_OUTPUT</code>, to remove the
          irritating warnings. Occasionally, however, those warnings had some
          real data in them, so I added a debugging feature, <code class="literal">DEBUG_FOP</code>, to disable my filter. Finally,
          like the HTML version, I added two convenience targets, <code class="literal">pdf</code> and <code class="literal">show_pdf</code>, to kick the whole thing
          off.</p></div><div class="sect2" title="验证来源"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11.html.make3-CHP-11-SECT-1.4"></a>验证来源</h2><h2 class="title"><a></a>Validating the Source</h2></div></div></div><p>DocBook 对什么过敏<a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1564" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1565" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1566" class="indexterm"></a> <a id="OEBPS/ch11.html.make3-CHP-11-ITERM-1567" class="indexterm"></a>选项卡、宏处理器、包含文件和编辑器的注释，确保源文本正确且完整并不容易。为了提供帮助，我实现了四个验证目标来检查各种形式的正确性。</p><p>What with DocBook's allergy to <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>tabs, macro processors, include files and comments
          from editors, making sure the source text is correct and complete is
          not easy. To help, I implemented four validation targets that check
          for various forms of correctness.</p><a id="OEBPS/ch11.html.I_6_tt472"></a><pre class="programlisting">validation_checks := $(OUTPUT_DIR)/chk_macros_tabs \
                     $(OUTPUT_DIR)/chk_fixme \
                     $(OUTPUT_DIR)/chk_duplicate_macros \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY：仅验证
仅验证：$(OUTPUT_DIR)/验证
$(OUTPUT_DIR)/验证：$(validation_checks)
        $（触摸）$@</pre><pre class="programlisting">validation_checks := $(OUTPUT_DIR)/chk_macros_tabs         \
                     $(OUTPUT_DIR)/chk_fixme               \
                     $(OUTPUT_DIR)/chk_duplicate_macros    \
                     $(OUTPUT_DIR)/chk_orphaned_examples

.PHONY: validate-only
validate-only: $(OUTPUT_DIR)/validate
$(OUTPUT_DIR)/validate: $(validation_checks)
        $(TOUCH) $@</pre><p>每个目标都会生成一个时间戳文件，它们都是顶级时间戳文件<em class="filename">validate</em>的先决条件。</p><p>Each target generates a timestamp file, and they are all
          prerequisites of a top-level timestamp file, <em class="filename">validate</em>.</p><a id="OEBPS/ch11.html.I_6_tt473"></a><pre class="programlisting">$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
        # 寻找宏和选项卡...
        $（安静）！ $(EGREP) --忽略大小写 \
                           - 电话号码 \
                           --regexp='\b(m4_|mp_)' \
                           --regexp='\011' \
                           $^
        $（触摸）$@</pre><pre class="programlisting">$(OUTPUT_DIR)/chk_macros_tabs: $(ALL_XML_OUT)
        # Looking for macros and tabs...
        $(QUIET)! $(EGREP) --ignore-case            \
                           --line-number            \
                           --regexp='\b(m4_|mp_)'   \
                           --regexp='\011'          \
                           $^
        $(TOUCH) $@</pre><p>第一个检查查找在预处理期间未扩展的<em class="command">m4</em>宏。这表示宏拼写错误或宏从未定义过。该检查还会扫描制表符。当然，这两种情况都不应该发生，但它们确实发生了！命令脚本中一个有趣的地方是 后面的感叹号<code class="literal">$(QUIET)</code>。目的是取消<em class="command">egrep</em>的退出状态。也就是说，
          如果<em class="command">egrep</em><span class="emphasis"><em>确实</em></span>找到了其中一种模式，那么<em class="command">make</em>应该认为该命令失败。<em class="command"></em>
          <span class="emphasis"><em></em></span></p><p>This first check looks for <em class="command">m4</em> macros that were not expanded during
          preprocessing. This indicates either a misspelled macro or a macro
          that has never been defined. The check also scans for tab
          characters. Of course, neither of these situations should ever
          happen, but they did! One interesting bit in the command script is
          the exclamation point after <code class="literal">$(QUIET)</code>. The purpose is to negate the
          exit status of <em class="command">egrep</em>. That is,
          <em class="command">make</em> should consider the command
          a failure if <em class="command">egrep</em>
          <span class="emphasis"><em>does</em></span> find one of the patterns.</p><a id="OEBPS/ch11.html.I_6_tt474"></a><pre class="programlisting">$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
        # 寻找 RM: 和 FIXME...
        $（安静）$（AWK）\
                '/FIXME/ { printf "%s:%s: %s\n", 文件名, NR, $$0 } \
                 /^ *RM:/ { \
                           if ( $$0 !~ /RM: 完成/ ) \
                           printf "%s:%s: %s\n", 文件名, NR, $$0 \
                         }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^)
        $（触摸）$@</pre><pre class="programlisting">$(OUTPUT_DIR)/chk_fixme: $(ALL_XML_OUT)
        # Looking for RM: and FIXME...
        $(QUIET)$(AWK)                                                  \
                '/FIXME/ { printf "%s:%s: %s\n", FILENAME, NR, $$0 }    \
                 /^ *RM:/  {                                            \
                           if ( $$0 !~ /RM: Done/ )                     \
                           printf "%s:%s: %s\n", FILENAME, NR, $$0      \
                         }' $(subst $(OUTPUT_DIR)/,$(SOURCE_DIR)/,$^)
        $(TOUCH) $@</pre><p>这张支票是为了给我自己留下未解决的笔记。显然，任何带有标签的文本都<code class="literal">FIXME</code>应该被修复并删除标签。此外，任何出现<code class="literal">RM</code>: 且后面没有紧跟着的 :
          的情况都<code class="literal">Done</code>应该被标记。请注意<em class="command">printf</em>函数的格式如何
          遵循编译器错误的标准格式。这样，识别编译器错误的标准工具将正确处理这些警告。</p><p>This check is for unresolved notes to myself. Obviously, any
          text labeled <code class="literal">FIXME</code> should be
          fixed and the label removed. In addition, any occurrence of <code class="literal">RM</code>: that is not followed immediately by
          <code class="literal">Done</code> should be flagged. Notice
          how the format of the <em class="command">printf</em>
          function follows the standard format for compiler errors. This way,
          standard tools that recognize compiler errors will properly process
          these warnings.</p><a id="OEBPS/ch11.html.I_6_tt475"></a><pre class="programlisting">$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
        # 寻找重复的宏...
        $（安静）！ $(EGREP) --仅匹配 \
              "\[^]+'," $&lt; | \
        $（排序）| \
        uniq-c| \
        $(AWK) '$$1 &gt; 1 { printf "$&gt;:0: %s\n", $$0 }' | \
        $(EGREP)“^”
        $（触摸）$@</pre><pre class="programlisting">$(OUTPUT_DIR)/chk_duplicate_macros: $(SOURCE_DIR)/macros.m4
        # Looking for duplicate macros...
        $(QUIET)! $(EGREP) --only-matching              \
              "\[^]+'," $&lt; |                            \
        $(SORT) |                                       \
        uniq -c |                                       \
        $(AWK) '$$1 &gt; 1 { printf "$&gt;:0: %s\n", $$0 }' | \
        $(EGREP) "^"
        $(TOUCH) $@</pre><p>这会检查<em class="command">m4</em>宏文件中是否存在重复的宏定义。<em class="command">m4</em>处理器不认为重定义是一个错误，所以我添加了一个特殊的检查。管道是这样的：抓取每个宏中定义的符号，排序，计算重复项，过滤掉计数为 1 的所有行，然后最后一次使用 e <em class="command">grep</em>纯粹是为了其退出状态。再次注意，仅当发现某些内容时，退出状态才会产生<em class="command">make错误。</em></p><p>This checks for duplicate macro definitions in the <em class="command">m4</em> macro file. The <em class="command">m4</em> processor does not consider
          redefinition to be an error, so I added a special check. The
          pipeline goes like this: grab the defined symbol in each macro,
          sort, count duplicates, filter out all lines with a count of one,
          then use e<em class="command">grep</em> one last time
          purely for its exit status. Again, note the negation of the exit
          status to produce a <em class="command">make</em> error
          only when something is found.</p><a id="OEBPS/ch11.html.I_6_tt476"></a><pre class="programlisting">ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
        $(安静)$(AWK) -F/ '/(示例|输出)_DIR/ { print $$3 }' \
                $(过滤%.d,$^) | \
        $(排序) -u | \
        通讯 -13 - $(过滤掉 %.d,$^)
        $（触摸）$@

.INTERMEDIATE：$(ALL_EXAMPLES)
$（所有示例）：
        # 寻找未使用的示例...
        $(安静) ls -p $(EXAMPLES_DIR) | \
        $(AWK) '/CVS/ { 下一个 } \
                /\// { print substr($$0, 1, 长度 - 1) }' &gt; $@</pre><pre class="programlisting">ALL_EXAMPLES := $(TMP)/all_examples

$(OUTPUT_DIR)/chk_orphaned_examples: $(ALL_EXAMPLES) $(DEPENDENCY_FILES)
        $(QUIET)$(AWK) -F/ '/(EXAMPLES|OUTPUT)_DIR/ { print $$3 }' \
                $(filter %.d,$^) |                                 \
        $(SORT) -u |                                               \
        comm -13 - $(filter-out %.d,$^)
        $(TOUCH) $@

.INTERMEDIATE: $(ALL_EXAMPLES)
$(ALL_EXAMPLES):
        # Looking for unused examples...
        $(QUIET) ls -p $(EXAMPLES_DIR) |        \
        $(AWK) '/CVS/ { next }                  \
                /\//  { print substr($$0, 1, length - 1) }' &gt; $@</pre><p>最终检查会查找文本中未引用的示例。这个目标使用了一个有趣的技巧。它需要两组输入文件：所有示例目录和所有 XML 依赖文件。先决条件列表使用<code class="function">filter</code>和分为这两组
          <code class="function">filter-out</code>。示例目录列表是通过使用<em class="command">ls</em> <code class="option">-p</code>（这会向每个目录附加斜杠）并扫描斜杠来生成的。管道首先从先决条件列表中获取 XML 依赖项文件，输出在其中找到的示例目录，并删除所有重复项。这些是文本中实际引用的示例。该列表被提供给<em class="command">comm</em>的标准输入，而所有已知示例目录的列表被作为第二个文件提供。该<code class="option">-13</code>选项指示<em class="command">comm</em>应仅打印第二列中找到的行（即未从依赖文件引用的目录）。</p><p>The final check looks for examples that are not referenced in
          the text. This target uses a funny trick. It requires two sets of
          input files: all the example directories, and all the XML dependency
          files. The prerequisites list is separated into these two sets using
          <code class="function">filter</code> and <code class="function">filter-out</code>. The list of example
          directories is generated by using <em class="command">ls</em> <code class="option">-p</code> (this appends a
          slash to each directory) and scanning for slashes. The pipeline
          first grabs the XML dependency files from the prerequisite list,
          outputs the example directories it finds in them, and removes any
          duplicates. These are the examples actually referenced in the text.
          This list is fed to <em class="command">comm</em>'s
          standard input, while the list of all known example directories is
          fed as the second file. The <code class="option">-13</code> option indicates
          that <em class="command">comm</em> should print only lines
          found in column two (that is, directories that are not referenced
          from a dependency file).</p></div></div><div class="footnotes"><br><br><hr><div class="footnote"><p><sup>[ <a id="OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-1" href="#OEBPS/ch11.html.make3-CHP-11-FNOTE-1" class="para">1</a> ]</sup>清洁过程变得复杂。 run <em class="filename">-run</em>和<em class="filename">run-make</em>脚本通常用于<code class="literal">bash -x</code>允许回显实际的<em class="command">make</em>命令行。该
              <code class="option">-x</code>选项放在<code class="literal">++</code>输出中每个命令之前，清理脚本将其转换为<code class="literal">$</code>表示 shell 提示符的简单形式。但是，命令并不是输出中出现的唯一信息。因为<em class="command">make</em>正在运行该示例并最终启动另一个<em class="command">make</em>，所以简单的<em class="filename">makefile</em>包含额外的、不需要的输出，例如 messages <code class="literal">Entering
              directory</code>。 。 。和<code class="literal">Leaving</code> <code class="literal">directory</code>。 。 。以及在消息中显示<em class="command">制造</em>级别编号。对于不递归调用<em class="command">make 的简单</em><em class="filename">makefile ，我们会删除此不适当的输出，以呈现</em><em class="command">make</em>的输出，就好像它是从顶级 shell 运行一样。<em class="command"></em><em class="command"></em></p><p><sup>[<a href="#OEBPS/ch11.html.make3-CHP-11-FNOTE-1" class="para">1</a>] </sup>The cleaning process gets complex. The <em class="filename">run-run</em> and <em class="filename">run-make</em> scripts often use <code class="literal">bash -x</code> to allow the actual <em class="command">make</em> command line to be echoed. The
              <code class="option">-x</code> option puts <code class="literal">++</code> before each command in the output,
              which the cleaning script transforms into a simple <code class="literal">$</code> representing the shell prompt.
              However, commands are not the only information to appear in the
              output. Because <em class="command">make</em> is
              running the example and eventually starts another <em class="command">make</em>, simple <em class="filename">makefile</em>s include extra, unwanted
              output such as the messages <code class="literal">Entering
              directory</code> . . . and <code class="literal">Leaving</code> <code class="literal">directory</code> . . . as well as displaying
              a <em class="command">make</em> level number in
              messages. For simple <em class="filename">makefile</em>s that do not recursively
              invoke <em class="command">make</em>, we strip this
              inappropriate output to present the output of <em class="command">make</em> as if it were run from a
              top-level shell.</p></div><div class="footnote"><p><sup>[ <a id="OEBPS/ch11.html.ftn.make3-CHP-11-FNOTE-2" href="#OEBPS/ch11.html.make3-CHP-11-FNOTE-2" class="para">2</a> ]</sup>前缀<code class="literal">mp</code>代表管理项目（书名）、宏处理器或 make beautiful。随你挑选。</p><p><sup>[<a href="#OEBPS/ch11.html.make3-CHP-11-FNOTE-2" class="para">2</a>] </sup>The <code class="literal">mp</code> prefix stands
              for Managing Projects (the book's title), macro processor, or
              make pretty. Take your pick.</p></div></div></div></div></div>
<div id="OEBPS/ch11s02.html"><div>
<div class="sect1" title="Linux 内核 Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch11s02.html.make3-CHP-11-SECT-2"></a>Linux 内核 Makefile</h1><h1 class="title"><a></a>The Linux Kernel Makefile</h1></div></div></div><p>Linux 内核<em class="filename">makefile</em>
        是一个<a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1568" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1569" class="indexterm"></a>在复杂的构建环境中使用<em class="command">make</em>的绝佳示例。虽然解释 Linux 内核是如何构造和构建的超出了本书的范围，但我们可以研究
        内核构建系统所使用的<em class="command">make</em>的几个有趣的用法。
        有关 2.5/2.6 内核构建过程及其从 2.4 方法的演变的更完整讨论，请参阅<a class="ulink" href="http://archive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf">http://archive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf 。</a></p><p>The Linux kernel <em class="filename">makefile</em>
        is an <a class="indexterm"></a> <a class="indexterm"></a>excellent example of using <em class="command">make</em> in a complex build environment. While
        it is beyond the scope of this book to explain how the Linux kernel is
        structured and built, we can examine several interesting uses of
        <em class="command">make</em> employed by the kernel build
        system. See <a class="ulink" href="http://archive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf">http://archive.linuxsymposium.org/ols2003/Proceedings/All-Reprints/Reprint-Germaschewski-OLS2003.pdf</a>
        for a more complete discussion of the 2.5/2.6 kernel build process and
        its evolution from the 2.4 approach.</p><p>由于<em class="filename">makefile</em>有很多方面，我们将仅讨论适用于各种应用程序的几个功能。首先，我们将了解如何使用单字母
        <em class="command">make</em>变量来模拟单字母命令行选项。我们将看到如何以允许用户从源树调用<em class="command">make</em>的方式分离源树和二叉树
        。接下来，我们将检查<em class="filename">makefile</em>控制输出详细程度的方式。然后我们将回顾最有趣的用户定义函数，并了解它们如何减少代码重复、提高可读性并提供封装。最后，我们将了解<em class="filename">makefile</em>实现简单帮助工具的方式。</p><p>Since the <em class="filename">makefile</em> has so
        many facets, we will discuss just a few features that are applicable
        to a variety of applications. First, we'll look at how single-letter
        <em class="command">make</em> variables are used to simulate
        single-letter command-line options. We'll see how the source and
        binary trees are separated in a way that allows users to invoke
        <em class="command">make</em> from the source tree. Next,
        we'll examine the way the <em class="filename">makefile</em> controls the verboseness of the
        output. Then we'll review the most interesting user-defined functions
        and see how they reduce code duplication, improve readability, and
        provide encapsulation. Finally, we'll look at the way the <em class="filename">makefile</em> implements a simple help
        facility.</p><p>Linux 内核构建遵循我最自由的软件所使用的熟悉的配置、构建、安装模式。虽然许多免费和开放的软件包使用单独的<em class="filename">配置脚本（通常由</em><em class="command">autoconf</em>构建
        ），但 Linux 内核
        <em class="filename">makefile使用</em><em class="command">make</em>来实现配置，间接调用脚本和帮助程序。</p><p>The Linux kernel build follows the familiar configure, build,
        install pattern used by my most free software. While many free and
        open software packages use a separate <em class="filename">configure</em> script (typically built by
        <em class="command">autoconf</em>), the Linux kernel
        <em class="filename">makefile</em> implements configuration
        with <em class="command">make</em>, invoking scripts and
        helper programs indirectly.</p><p>配置阶段完成后，简单的<em class="command">make</em>或<em class="command">make </em> <em class="command">all</em>
        将构建裸内核、所有模块，并生成压缩的内核映像（分别是<code class="literal">vmlinux</code>、<code class="literal">modules</code>和<code class="literal">bzImage</code>目标）。每个内核版本在链接到内核的文件<em class="filename">version.o</em>中都有一个唯一的版本号。该编号（以及<em class="filename">version.o文件）由</em><em class="filename">makefile</em>本身更新
        。</p><p>When the configuration phase is complete, a simple <em class="command">make</em> or <em class="command">make</em> <em class="command">all</em>
        will build the bare kernel, all the modules, and produce a compressed
        kernel image (these are the <code class="literal">vmlinux</code>, <code class="literal">modules</code>, and <code class="literal">bzImage</code> targets, respectively). Each kernel
        build is given a unique version number in the file <em class="filename">version.o</em> linked into the kernel. This
        number (and the <em class="filename">version.o</em> file)
        are updated by the <em class="filename">makefile</em>
        itself.</p><p>您可能希望适应自己的<em class="filename">makefile 的</em>一些<em class="filename">makefile</em>功能包括：处理命令行选项、分析命令行目标、在构建之间保存构建状态以及管理<em class="command">make</em>的输出。<em class="filename"></em><em class="command"></em></p><p>Some <em class="filename">makefile</em> features you
        might want to adapt to your own <em class="filename">makefile</em> are: the handling of command line
        options, analyzing command-line goals, saving build status between
        builds, and managing the output of <em class="command">make</em>.</p><div class="sect2" title="命令行选项"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11s02.html.make3-CHP-11-SECT-2.1"></a>命令行选项</h2><h2 class="title"><a></a>Command-Line Options</h2></div></div></div><p>第一部分<a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1570" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1572" class="indexterm"></a><em class="filename">makefile</em>的
          包含用于从命令行设置常见构建选项的代码。以下是控制详细标志的摘录：</p><p>The first part <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>of the <em class="filename">makefile</em>
          contains code for setting common build options from the command
          line. Here is an excerpt that controls the verbose flag:</p><a id="OEBPS/ch11s02.html.I_6_tt477"></a><pre class="programlisting"># 为了更加关注警告，默认情况下不要那么冗长
# 使用“make V=1”查看完整命令
如果定义V
  ifeq("$(origin V)","命令行")
    KBUILD_VERBOSE = $(V)
  万一
万一
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
万一</pre><pre class="programlisting"># To put more focus on warnings, be less verbose as default
# Use 'make V=1' to see the full commands
ifdef V
  ifeq ("$(origin V)", "command line")
    KBUILD_VERBOSE = $(V)
  endif
endif
ifndef KBUILD_VERBOSE
  KBUILD_VERBOSE = 0
endif</pre><p>嵌套的<code class="literal">ifdef</code>/<code class="literal">ifeq</code>对确保仅当在命令行上设置<code class="literal">KBUILD_VERBOSE</code>时才设置变量
          。环境或
          <em class="filename">makefile</em><code class="literal">V</code>中的设置没有效果。如果尚未设置，以下条件将关闭详细选项。要从环境或<em class="filename">makefile</em>设置详细选项，您必须设置and not 。<code class="literal">V</code><em class="filename"></em><code class="literal">ifndef</code><code class="literal">KBUILD_VERBOSE</code><em class="filename"></em><code class="literal">KBUILD_VERBOSE</code><code class="literal">V</code></p><p>The nested <code class="literal">ifdef</code>/<code class="literal">ifeq</code> pair ensures that the <code class="literal">KBUILD_VERBOSE</code> variable is set only if
          <code class="literal">V</code> is set on the command line.
          Setting <code class="literal">V</code> in the environment or
          <em class="filename">makefile</em> has no effect. The
          following <code class="literal">ifndef</code> conditional will
          then turn off the verbose option if <code class="literal">KBUILD_VERBOSE</code> has not yet been set. To
          set the verbose option from either the environment or <em class="filename">makefile</em>, you must set <code class="literal">KBUILD_VERBOSE</code> and not <code class="literal">V</code>.</p><p>但请注意，<code class="literal">KBUILD_VERBOSE</code>直接在命令行上进行设置是允许的，并且可以按预期工作。这在编写 shell 脚本（或别名）来调用<em class="filename">makefile</em>时非常有用。这些脚本将更加自记录，类似于使用<acronym class="acronym">GNU</acronym>长选项。</p><p>Notice, however, that setting <code class="literal">KBUILD_VERBOSE</code> directly on the command
          line is allowed and works as expected. This can be useful when
          writing shell scripts (or aliases) to invoke the <em class="filename">makefile</em>. These scripts would then be
          more self-documenting, similar to using <acronym class="acronym">GNU</acronym> long
          options.</p><p>其他命令行选项，稀疏检查 ( <code class="option">C</code>) 和外部模块 ( <code class="option">M</code>)，都使用相同的仔细检查以避免在<em class="filename">makefile</em>中意外设置它们。</p><p>The other command-line options, sparse checking
          (<code class="option">C</code>) and external modules (<code class="option">M</code>), both
          use the same careful checking to avoid accidentally setting them
          from within the <em class="filename">makefile</em>.</p><p><em class="filename">makefile</em>的下一部分处理输出目录选项 ( <code class="option">O</code>)。这是一段相当复杂的代码。为了突出其结构，我们用省略号替换了此摘录的某些部分：</p><p>The next section of the <em class="filename">makefile</em> handles the output directory
          option (<code class="option">O</code>). This is a fairly involved piece of
          code. To highlight its structure, we've replaced some parts of this
          excerpt with ellipses:</p><a id="OEBPS/ch11s02.html.I_6_tt478"></a><pre class="programlisting"># kbuild 支持将输出文件保存在单独的目录中。
# 要在单独的目录中定位输出文件，支持两种语法。
# 在这两种情况下，工作目录必须是内核 src 的根目录。
# 1) O=
# 使用“make O=dir/to/store/output/files/”
#
# 2) 设置 KBUILD_OUTPUT
# 设置环境变量KBUILD_OUTPUT指向该目录
# 输出文件应放置的位置。
# 导出 KBUILD_OUTPUT=dir/to/store/output/files/
＃ 制作
#
# O= 分配优先于 KBUILD_OUTPUT 环境变量。
# KBUILD_SRC 在 OBJ 目录中调用 make 时设置
# KBUILD_SRC 不适合普通用户使用（目前）
ifeq ($(KBUILD_SRC),)

  # OK，在内核src所在目录中调用Make
  # 我们是否想将输出文件放置在单独的目录中？
  如果定义O
    ifeq("$(原点O)","命令行")
      KBUILD_输出 := $(O)
    万一
  万一
  ...
  ifneq ($(KBUILD_OUTPUT),)
    ...
    .PHONY：$(MAKECMDGOALS)

    $（过滤掉_all，$（MAKECMDGOALS））_all：
            $(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT) \
            KBUILD_SRC=$(CURDIR) KBUILD_VERBOSE=$(KBUILD_VERBOSE) \
            KBUILD_CHECK=$(KBUILD_CHECK) KBUILD_EXTMOD="$(KBUILD_EXTMOD)" \
            -f $(CURDIR)/Makefile $@
    # 将处理留给上面的 make 调用
    跳过生成文件 := 1
  endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)

# 如果这是 make 的最终调用，我们将处理 Makefile 的其余部分
ifeq ($(跳过 makefile),)
  ……<em class="replaceable"><code>the rest of the makefile here</code></em>​
endif # 跳过 makefile</pre><pre class="programlisting"># kbuild supports saving output files in a separate directory.
# To locate output files in a separate directory two syntax'es are supported.
# In both cases the working directory must be the root of the kernel src.
# 1) O=
# Use "make O=dir/to/store/output/files/"
#
# 2) Set KBUILD_OUTPUT
# Set the environment variable KBUILD_OUTPUT to point to the directory
# where the output files shall be placed.
# export KBUILD_OUTPUT=dir/to/store/output/files/
# make
#
# The O= assigment takes precedence over the KBUILD_OUTPUT environment variable.
# KBUILD_SRC is set on invocation of make in OBJ directory
# KBUILD_SRC is not intended to be used by the regular user (for now)
ifeq ($(KBUILD_SRC),)

  # OK, Make called in directory where kernel src resides
  # Do we want to locate output files in a separate directory?
  ifdef O
    ifeq ("$(origin O)", "command line")
      KBUILD_OUTPUT := $(O)
    endif
  endif
  ...
  ifneq ($(KBUILD_OUTPUT),)
    ...
    .PHONY: $(MAKECMDGOALS)

    $(filter-out _all,$(MAKECMDGOALS)) _all:
            $(if $(KBUILD_VERBOSE:1=),@)$(MAKE) -C $(KBUILD_OUTPUT)        \
            KBUILD_SRC=$(CURDIR)         KBUILD_VERBOSE=$(KBUILD_VERBOSE)  \
            KBUILD_CHECK=$(KBUILD_CHECK) KBUILD_EXTMOD="$(KBUILD_EXTMOD)"  \
            -f $(CURDIR)/Makefile $@
    # Leave processing to above invocation of make
    skip-makefile := 1
  endif # ifneq ($(KBUILD_OUTPUT),)
endif # ifeq ($(KBUILD_SRC),)

# We process the rest of the Makefile if this is the final invocation of make
ifeq ($(skip-makefile),)
  ...<em class="replaceable"><code>the rest of the makefile here</code></em>...
endif   # skip-makefile</pre><p>本质上，这表示如果<code class="literal">KBUILD_OUTPUT</code>设置了，则在 . 定义的输出目录中递归调用<em class="command">make</em><code class="literal">KBUILD_OUTPUT</code>。设置
          为最初执行<em class="command">make 的</em><code class="literal">KBUILD_SRC</code>目录
          ，并从那里获取<em class="filename">makefile 。 </em><em class="filename">make 文件的</em>其余部分将不会被<em class="command">make</em>
          看到，因为
          将被设置。递归<em class="command">make</em>将再次重新读取同一个<em class="filename">makefile</em>，只有这一次会被设置，因此
          将是未定义的，并且<em class="filename">makefile</em>的其余部分
          将被读取和处理。<em class="command"></em><em class="filename"></em><em class="filename"></em><em class="command"></em><code class="literal">skip-makefile</code><em class="command"></em><em class="filename"></em><code class="literal">KBUILD_SRC</code><code class="literal">skip-makefile</code><em class="filename"></em></p><p>Essentially, this says that if <code class="literal">KBUILD_OUTPUT</code> is set, invoke <em class="command">make</em> recursively in the output directory
          defined by <code class="literal">KBUILD_OUTPUT</code>. Set
          <code class="literal">KBUILD_SRC</code> to the directory where
          <em class="command">make</em> was originally executed, and
          grab the <em class="filename">makefile</em> from there as
          well. The rest of the <em class="filename">makefile</em>
          will not be seen by <em class="command">make</em>, since
          <code class="literal">skip-makefile</code> will be set. The
          recursive <em class="command">make</em> will reread this
          same <em class="filename">makefile</em> again, only this
          time <code class="literal">KBUILD_SRC</code> will be set, so
          <code class="literal">skip-makefile</code> will be undefined,
          and the rest of the <em class="filename">makefile</em>
          will be read and processed.</p><p>命令行选项的处理到此结束。<em class="filename">生成文件</em>的大部分内容在本<code class="literal">ifeq ($(skip-makefile),)</code>
          节中。</p><p>This concludes the processing of command-line options. The
          bulk of the <em class="filename">makefile</em> follows in
          the <code class="literal">ifeq ($(skip-makefile),)</code>
          section.</p></div><div class="sect2" title="配置与构建"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11s02.html.make3-CHP-11-SECT-2.2"></a>配置与构建</h2><h2 class="title"><a></a>Configuration Versus Building</h2></div></div></div><p>makefile<em class="filename">包含</em>配置<a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1573" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1575" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1576" class="indexterm"></a>目标和构建目标。配置目标的形式为<code class="literal">menuconfig</code>、
          <code class="literal">defconfig</code>等。维护目标<code class="literal">clean</code>也被视为配置目标。其他目标（例如<code class="literal">all</code>、<code class="literal">vmlinux</code>和 ）<code class="literal">modules</code>是构建目标。调用配置目标的主要结果是两个文件：<em class="filename">.config</em>和<em class="filename">.config.cmd</em>。这两个文件包含在构建目标的<em class="filename">makefile</em>中，但不包含在配置目标中（因为配置目标创建了它们）。还可以在单​​个<em class="command">make</em>调用中混合配置目标和构建目标，例如：</p><p>The <em class="filename">makefile</em> contains
          configuration <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>targets and build targets. The configuration targets
          have the form <code class="literal">menuconfig</code>,
          <code class="literal">defconfig</code>, etc. Maintenance
          targets like <code class="literal">clean</code> are treated as
          configuration targets as well. Other targets such as <code class="literal">all</code>, <code class="literal">vmlinux</code>, and <code class="literal">modules</code> are build targets. The primary
          result of invoking a configuration target is two files: <em class="filename">.config</em> and <em class="filename">.config.cmd</em>. These two files are included
          by the <em class="filename">makefile</em> for build
          targets but are not included for configuration targets (since the
          configuration target creates them). It is also possible to mix both
          configuration targets and build targets on a single <em class="command">make</em> invocation, such as:</p><a id="OEBPS/ch11s02.html.I_6_tt479"></a><pre class="programlisting">$ 全部设置oldconfig</pre><pre class="programlisting">$ make oldconfig all</pre><p>在这种情况下，<em class="filename">makefile</em>会递归地调用自身来单独处理每个目标，从而将配置目标与构建目标分开处理。</p><p>In this case, the <em class="filename">makefile</em> invokes itself recursively
          handling each target individually, thus handling configuration
          targets separately from build targets.</p><p>控制配置、构建和混合目标的代码开头为：</p><p>The code controlling configuration, build, and mixed targets
          begins with:</p><a id="OEBPS/ch11s02.html.I_6_tt480"></a><pre class="programlisting"># 确保我们不包含任何 *config 目标的 .config
# 尽早捕获它们，并将它们交给scripts/kconfig/Makefile
# 调用make时允许指定更多目标，包括
# 混合*配置目标和构建目标。
# 例如'make oldconfig all'。
# 检测何时指定混合目标，并进行第二次调用
# of make so .config 也不包含在这种情况下（对于 *config）。
no-dot-config-targets := clean mrproper distclean \
                         cscope TAGS 标签帮助%docs check%

配置目标 := 0
混合目标 := 0
点配置 := 1</pre><pre class="programlisting"># To make sure we do not include .config for any of the *config targets
# catch them early, and hand them over to scripts/kconfig/Makefile
# It is allowed to specify more targets when calling make, including
# mixing *config targets and build targets.
# For example 'make oldconfig all'.
# Detect when mixed targets is specified, and make a second invocation
# of make so .config is not included in this case either (for *config).
no-dot-config-targets := clean mrproper distclean \
                         cscope TAGS tags help %docs check%

config-targets := 0
mixed-targets  := 0
dot-config     := 1</pre><p>该变量<code class="literal">no-dot-config-targets</code>列出了不需要<em class="filename">.config</em>文件的其他目标。然后代码初始化<code class="literal">config-targets</code>、<code class="literal">mixed-targets</code>和<code class="literal">dot-config</code>变量。<code class="literal">config-targets</code>如果命令行上有任何配置目标，则该变量为 1。<code class="literal">dot-config</code>如果命令行上有构建目标，则该变量为 1。最后，<code class="literal">mixed-targets</code>如果同时存在配置和构建目标，则为 1。</p><p>The variable <code class="literal">no-dot-config-targets</code> lists additional
          targets that do not require a <em class="filename">.config</em> file. The code then initializes
          the <code class="literal">config-targets</code>, <code class="literal">mixed-targets</code>, and <code class="literal">dot-config</code> variables. The <code class="literal">config-targets</code> variable is 1 if there are
          any configuration targets on the command line. The <code class="literal">dot-config</code> variable is 1 if there are
          build targets on the command line. Finally, <code class="literal">mixed-targets</code> is 1 if there are both
          configuration and build targets.</p><p>要设置的代码<code class="literal">dot-config</code>
          是：</p><p>The code to set <code class="literal">dot-config</code>
          is:</p><a id="OEBPS/ch11s02.html.I_6_tt481"></a><pre class="programlisting">ifneq ($(过滤器 $(no-dot-config-targets), $(MAKECMDGOALS)),)
  ifeq ($(过滤掉 $(no-dot-config-targets), $(MAKECMDGOALS)),)
    点配置 := 0
  万一
万一</pre><pre class="programlisting">ifneq ($(filter $(no-dot-config-targets), $(MAKECMDGOALS)),)
  ifeq ($(filter-out $(no-dot-config-targets), $(MAKECMDGOALS)),)
    dot-config := 0
  endif
endif</pre><p>如果 中存在配置目标，则表达式<code class="function">filter</code>非空<code class="literal">MAKECMDGOALS</code>。如果表达式不为空，则该<code class="literal">ifneq</code>部分为 true 。<code class="function">filter</code>该代码很难理解，部分原因是它包含双重否定。如果仅包含配置目标，则表达式
          <code class="literal">ifeq</code>为 true
           。<code class="literal">MAKECMDGOALS</code>因此，<code class="literal">dot-config</code>如果 .conf 中有配置目标并且只有配置目标，则将设置为 0 <code class="literal">MAKECMDGOALS</code>。更详细的实现可能会使这两个条件的含义更加清晰：</p><p>The <code class="function">filter</code> expression is
          non-empty if there are configuration targets in <code class="literal">MAKECMDGOALS</code>. The <code class="literal">ifneq</code> part is true if the <code class="function">filter</code> expression is not empty. The code
          is hard to follow partly because it contains a double negative. The
          <code class="literal">ifeq</code> expression is true if
          <code class="literal">MAKECMDGOALS</code> contains only
          configuration targets. So, <code class="literal">dot-config</code> will be set to 0 if there are
          configuration targets and only configuration targets in <code class="literal">MAKECMDGOALS</code>. A more verbose
          implementation might make the meaning of these two conditionals more
          clear:</p><a id="OEBPS/ch11s02.html.I_6_tt482"></a><pre class="programlisting">配置目标列表 := clean mrproper distclean \
                         cscope TAGS 标签帮助%docs check%

配置目标目标 := $(过滤器 $(配置目标列表), $(MAKECMDGOALS))
构建目标目标 := $(过滤出 $(config-target-list), $(MAKECMDGOALS))

ifdef 配置目标目标
  ifndef 构建目标
    点配置 := 0
  万一
万一</pre><pre class="programlisting">config-target-list := clean mrproper distclean \
                         cscope TAGS tags help %docs check%

config-target-goal := $(filter $(config-target-list), $(MAKECMDGOALS))
build-target-goal := $(filter-out $(config-target-list), $(MAKECMDGOALS))

ifdef config-target-goal
  ifndef build-target-goal
    dot-config := 0
  endif
endif</pre><p>可以使用 的形式<code class="literal">ifdef</code>代替<code class="literal">ifneq</code>，因为空变量被视为未定义，但必须注意确保变量不只包含一串空格（这将导致它被定义）。</p><p>The <code class="literal">ifdef</code> form can be used
          instead of <code class="literal">ifneq</code>, because empty
          variables are treated as undefined, but care must be taken to ensure
          a variable does not contain merely a string of blanks (which would
          cause it to be defined).</p><p><code class="literal">config-targets</code>和
          变量<code class="literal">mixed-targets</code>在下一个代码块中设置：</p><p>The <code class="literal">config-targets</code> and
          <code class="literal">mixed-targets</code> variables are set
          in the next code block:</p><a id="OEBPS/ch11s02.html.I_6_tt483"></a><pre class="programlisting">ifeq ($(KBUILD_EXTMOD),)
  ifneq ($(过滤器配置%config,$(MAKECMDGOALS)),)
    配置目标 := 1
    ifneq ($(过滤掉配置%config,$(MAKECMDGOALS)),)
      混合目标 := 1
    万一
  万一
万一</pre><pre class="programlisting">ifeq ($(KBUILD_EXTMOD),)
  ifneq ($(filter config %config,$(MAKECMDGOALS)),)
    config-targets := 1
    ifneq ($(filter-out config %config,$(MAKECMDGOALS)),)
      mixed-targets := 1
    endif
  endif
endif</pre><p><code class="literal">KBUILD_EXTMOD</code>在构建外部模块时将为非空，但在正常构建期间不会。当
          包含带有后缀的目标时，第一个<code class="literal">ifneq</code>
          为真
          。当也包含非配置目标时，第二个也是如此。<code class="literal">MAKECMDGOALS</code><code class="literal">config</code><code class="literal">ifneq</code><code class="literal">MAKECMDGOALS</code></p><p><code class="literal">KBUILD_EXTMOD</code> will be
          non-empty when external modules are being built, but not during
          normal builds. The first <code class="literal">ifneq</code>
          will be true when <code class="literal">MAKECMDGOALS</code>
          contains a goal with the <code class="literal">config</code>
          suffix. The second <code class="literal">ifneq</code> will be
          true when <code class="literal">MAKECMDGOALS</code> contains
          nonconfig targets, too.</p><p>一旦设置了变量，它们就会在具有四个分支的链中<code class="function">if</code>使用<code class="literal">else</code>。该代码经过压缩和缩进以突出其结构：</p><p>Once the variables are set, they are used in an <code class="function">if</code>-<code class="literal">else</code> chain with four branches. The code
          has been condensed and indented to highlight its structure:</p><a id="OEBPS/ch11s02.html.I_6_tt484"></a><pre class="programlisting">ifeq ($(混合目标),1)
  # 我们被称为混合目标（*配置和构建目标）。
  # 一一处理。
  ％：： 力量
        $(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
别的
  ifeq ($(配置目标),1)
    # *仅配置目标 - 确保先决条件已更新，然后下降
    # 在scripts/kconfig 中创建*config 目标
    ％config：scripts_basic FORCE
            $(Q)$(MAKE) $(build)=脚本/kconfig $@
  别的
    # 仅构建目标 - 这包括 vmlinux、arch 特定目标、clean
    # 目标和其他。一般来说，除 *config 目标之外的所有目标。
    ...
    ifeq ($(点配置),1)
      # 在本节中，我们需要.config
      # 读取所有 Kconfig* 文件的依赖关系，确保运行
      # oldconfig 如果检测到更改。
      -包括.config.cmd
      包含.config

      # 如果.config需要更新，将通过依赖项完成
      # autoconf 在 .config 中。
      # 为了避免出现任何隐式规则，请定义一个空命令
      .config: ;

      # 如果 .config 比 include/linux/autoconf.h 新，有人修改了
      # 使用它并忘记运行 make oldconfig
      包含/linux/autoconf.h：.config
              $(Q)$(MAKE) -f $(srctree)/Makefilesilentoldconfig
    别的
      # 需要虚拟目标，因为用作先决条件
      包括/linux/autoconf.h: ;
    万一

    包括$(srctree)/arch/$(ARCH)/Makefile<em class="replaceable"><code>... lots more make code ...</code></em>
  endif #ifeq ($(配置目标),1)
endif #ifeq ($(混合目标),1)</pre><pre class="programlisting">ifeq ($(mixed-targets),1)
  # We're called with mixed targets (*config and build targets).
  # Handle them one by one.
  %:: FORCE
        $(Q)$(MAKE) -C $(srctree) KBUILD_SRC= $@
else
  ifeq ($(config-targets),1)
    # *config targets only - make sure prerequisites are updated, and descend
    # in scripts/kconfig to make the *config target
    %config: scripts_basic FORCE
            $(Q)$(MAKE) $(build)=scripts/kconfig $@
  else
    # Build targets only - this includes vmlinux, arch specific targets, clean
    # targets and others. In general all targets except *config targets.
    ...
    ifeq ($(dot-config),1)
      # In this section, we need .config
      # Read in dependencies to all Kconfig* files, make sure to run
      # oldconfig if changes are detected.
      -include .config.cmd
      include .config

      # If .config needs to be updated, it will be done via the dependency
      # that autoconf has on .config.
      # To avoid any implicit rule to kick in, define an empty command
      .config: ;

      # If .config is newer than include/linux/autoconf.h, someone tinkered
      # with it and forgot to run make oldconfig
      include/linux/autoconf.h: .config
              $(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
    else
      # Dummy target needed, because used as prerequisite
      include/linux/autoconf.h: ;
    endif

    include $(srctree)/arch/$(ARCH)/Makefile<em class="replaceable"><code>... lots more make code ...</code></em>
  endif #ifeq ($(config-targets),1)
endif #ifeq ($(mixed-targets),1)</pre><p>第一个分支<code class="literal">ifeq
          ($(mixed-targets),1)</code>处理混合命令行参数。该分支中的唯一目标是完全通用的模式规则。由于没有处理目标的特定规则（这些规则位于另一个条件分支中），因此每个目标都会调用模式规则一次。这就是具有配置目标和构建目标的命令行被分成更简单的命令行的方式。通用模式规则的命令脚本对每个目标递归调用<em class="command">make</em>，导致应用相同的逻辑，只是这次没有混合命令行目标。使用先决<code class="literal">FORCE</code>条件而不是
          <code class="literal">.PHONY</code>，因为模式规则如下：</p><p>The first branch, <code class="literal">ifeq
          ($(mixed-targets),1)</code>, handles mixed command-line
          arguments. The only target in this branch is a completely generic
          pattern rule. Since there are no specific rules to handle targets
          (those rules are in another conditional branch), each target invokes
          the pattern rule once. This is how a command line with both
          configuration targets and build targets is separated into a simpler
          command line. The command script for the generic pattern rule
          invokes <em class="command">make</em> recursively for each
          target, causing this same logic to be applied, only this time with
          no mixed command-line targets. The <code class="literal">FORCE</code> prerequisite is used instead of
          <code class="literal">.PHONY</code>, because pattern rules
          like:</p><a id="OEBPS/ch11s02.html.I_6_tt485"></a><pre class="programlisting">％：： 力量</pre><pre class="programlisting">%:: FORCE</pre><p>不能申报<code class="literal">.PHONY</code>。因此，在任何地方一致使用似乎是合理的<code class="literal">FORCE</code>。</p><p>cannot be declared <code class="literal">.PHONY</code>.
          So it seems reasonable to use <code class="literal">FORCE</code> consistently everywhere.</p><p>当命令行上只有配置目标时，将调用<code class="function">if</code>-<code class="literal">else</code>链的第二个分支。<code class="literal">ifeq</code> <code class="literal">($(config-targets),1)</code>这里分支中的主要目标是模式规则<code class="literal">%config</code>（其他目标已被省略）。命令脚本
          在<em class="filename">scripts/kconfig子目录中递归调用</em><em class="command">make</em>并传递目标。这个奇怪的构造是在<em class="filename">makefile</em>的末尾定义的：<em class="filename"></em><code class="literal">$(build)</code><em class="filename"></em></p><p>The second branch of the <code class="function">if</code>-<code class="literal">else</code> chain, <code class="literal">ifeq</code> <code class="literal">($(config-targets),1)</code>, is invoked when
          there are only configuration targets on the command line. Here the
          primary target in the branch is the pattern rule <code class="literal">%config</code> (other targets have been omitted).
          The command script invokes <em class="command">make</em>
          recursively in the <em class="filename">scripts/kconfig</em> subdirectory and passes
          along the target. The curious <code class="literal">$(build)</code> construct is defined at the end
          of the <em class="filename">makefile</em>:</p><a id="OEBPS/ch11s02.html.I_6_tt486"></a><pre class="programlisting"># $(Q)$(MAKE) -f scripts/Makefile.build obj=dir 的简写
＃ 用法：
# $(Q)$(MAKE) $(build)=dir
构建 := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj</pre><pre class="programlisting"># Shorthand for $(Q)$(MAKE) -f scripts/Makefile.build obj=dir
# Usage:
# $(Q)$(MAKE) $(build)=dir
build := -f $(if $(KBUILD_SRC),$(srctree)/)scripts/Makefile.build obj</pre><p>如果<code class="literal">KBUILD_SRC</code>设置，则为该
          <code class="option">-f</code>选项提供<em class="filename">脚本</em> <em class="filename">makefile</em>的完整路径，否则使用简单的相对路径。接下来，<code class="literal">obj</code>
          变量被设置到等号的右侧。</p><p>If <code class="literal">KBUILD_SRC</code> is set, the
          <code class="option">-f</code> option is given a full path to the <em class="filename">scripts</em> <em class="filename">makefile</em>, otherwise a simple relative
          path is used. Next, the <code class="literal">obj</code>
          variable is set to the righthand side of the equals sign.</p><p>第三个分支<code class="literal">ifeq</code>
          <code class="literal">($(dot-config),1)</code>处理需要包含两个生成的配置文件<em class="filename">.config</em>和<em class="filename">.config.cmd 的</em>构建目标。最后一个分支仅包含<em class="filename">autoconf.h</em>的虚拟目标，以允许将其用作先决条件，即使它不存在。</p><p>The third branch, <code class="literal">ifeq</code>
          <code class="literal">($(dot-config),1)</code>, handles build
          targets that require including the two generated configuration
          files, <em class="filename">.config</em> and <em class="filename">.config.cmd</em>. The final branch merely
          includes a dummy target for <em class="filename">autoconf.h</em> to allow it to be used as a
          prerequisite, even if it doesn't exist.</p><p><em class="filename">makefile</em>的其余部分大部分遵循第三和第四分支。它包含构建内核和模块的代码。</p><p>Most of the remainder of the <em class="filename">makefile</em> follows the third and fourth
          branches. It contains the code for building the kernel and
          modules.</p></div><div class="sect2" title="管理命令回显"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11s02.html.make3-CHP-11-SECT-2.3"></a>管理命令回显</h2><h2 class="title"><a></a>Managing Command Echo</h2></div></div></div><p>内核<em class="filename">makefile</em>使用新颖<a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1577" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578" class="indexterm"></a>用于管理命令响应的详细程度的技术。每项重要任务都以详细版本和安静版本表示。详细版本只是以其自然形式执行的命令，并存储在名为 的变量中
          <code class="literal">cmd_</code>
          <em class="replaceable"><code>action</code></em>。简短版本是描述操作的短消息，存储在名为 的变量中
          <code class="literal">quiet_cmd_</code>
          <em class="replaceable"><code>action</code></em>。例如，生成<em class="command">emacs</em>标签的命令是：</p><p>The kernel <em class="filename">makefile</em>s use
          a novel <a class="indexterm"></a> <a class="indexterm"></a>technique for managing the level of detail echoed by
          commands. Each significant task is represented in both a verbose and
          a quiet version. The verbose version is simply the command to be
          executed in its natural form and is stored in a variable named
          <code class="literal">cmd_</code>
          <em class="replaceable"><code>action</code></em>. The brief version is a short
          message describing the action and is stored in a variable named
          <code class="literal">quiet_cmd_</code>
          <em class="replaceable"><code>action</code></em>. For example, the command to
          produce <em class="command">emacs</em> tags is:</p><a id="OEBPS/ch11s02.html.I_6_tt487"></a><pre class="programlisting">Quiet_cmd_TAGS = 制作 $@
      cmd_TAGS = $(所有来源) |电子标签-</pre><pre class="programlisting">quiet_cmd_TAGS = MAKE $@
      cmd_TAGS = $(all-sources) | etags -</pre><p>通过调用函数来执行命令<code class="function">cmd</code>：</p><p>A command is executed by calling the <code class="function">cmd</code> function:</p><a id="OEBPS/ch11s02.html.I_6_tt488"></a><pre class="programlisting"># 如果设置了安静，则仅打印命令的简短版本
cmd = @$(如果$($(安静)cmd_$(1)),\
         echo ' $($(quiet)cmd_$(1))' &amp;&amp;) $(cmd_$(1))</pre><pre class="programlisting"># If quiet is set, only print short version of command
cmd = @$(if $($(quiet)cmd_$(1)),\
         echo '  $($(quiet)cmd_$(1))' &amp;&amp;) $(cmd_$(1))</pre><p><em class="command">要调用构建emacs</em>标签的代码，<em class="filename">makefile</em>将包含：</p><p>To invoke the code for building <em class="command">emacs</em> tags, the <em class="filename">makefile</em> would contain:</p><a id="OEBPS/ch11s02.html.I_6_tt489"></a><pre class="programlisting">标签：
        $(调用cmd,标签)</pre><pre class="programlisting">TAGS:
        $(call cmd,TAGS)</pre><p>请注意，该<code class="function">cmd</code>函数以 开头<code class="literal">@</code>，因此该函数回显的唯一文本是来自<em class="command">echo</em>命令的文本。在正常模式下，变量
          为空，并且 , ,<code class="literal">quiet</code>中的测试扩展为。由于该变量不为空，因此整个函数扩展为：<code class="function">if</code><code class="literal">$($(quiet)cmd_$(1))</code><code class="literal">$(cmd_TAGS)</code></p><p>Notice the <code class="function">cmd</code> function
          begins with an <code class="literal">@</code>, so the only
          text echoed by the function is text from the <em class="command">echo</em> command. In normal mode, the variable
          <code class="literal">quiet</code> is empty, and the test in
          the <code class="function">if</code>, <code class="literal">$($(quiet)cmd_$(1))</code>, expands to <code class="literal">$(cmd_TAGS)</code>. Since this variable is not
          empty, the entire function expands to:</p><a id="OEBPS/ch11s02.html.I_6_tt490"></a><pre class="programlisting">echo ' $(所有来源) | etags -' &amp;&amp; $(所有来源) |电子标签-</pre><pre class="programlisting">echo '  $(all-sources) | etags -' &amp;&amp; $(all-sources) | etags -</pre><p>如果需要安静版本，变量<code class="literal">quiet</code>包含值<code class="literal">quiet_</code>并且函数扩展为：</p><p>If the quiet version is desired, the variable <code class="literal">quiet</code> contains the value <code class="literal">quiet_</code> and the function expands to:</p><a id="OEBPS/ch11s02.html.I_6_tt491"></a><pre class="programlisting">echo ' MAKE $@' &amp;&amp; $(所有来源) |电子标签-</pre><pre class="programlisting">echo '  MAKE $@' &amp;&amp; $(all-sources) | etags -</pre><p>该变量也可以设置为<code class="literal">silent_</code>。由于没有 command
           <code class="literal">silent_cmd_TAGS</code>，该值导致<code class="function">cmd</code>函数根本不回显任何内容。</p><p>The variable can also be set to <code class="literal">silent_</code>. Since there is no command
          <code class="literal">silent_cmd_TAGS</code>, this value
          causes the <code class="function">cmd</code> function to echo
          nothing at all.</p><p>回显命令有时会变得更加复杂，特别是当命令包含单引号时。在这些情况下，
           <em class="filename">makefile</em>包含以下代码：</p><p>Echoing the command sometimes becomes more complex,
          particularly if commands contain single quotes. In these cases, the
          <em class="filename">makefile</em> contains this
          code:</p><a id="OEBPS/ch11s02.html.I_6_tt492"></a><pre class="programlisting">$(if $($(quiet)cmd_$(1)),echo ' $(subst ','\'',$($(quiet)cmd_$(1)))';)</pre><pre class="programlisting">$(if $($(quiet)cmd_$(1)),echo '  $(subst ','\'',$($(quiet)cmd_$(1)))';)</pre><p>这里的<em class="command">echo</em>命令包含一个替换，用转义的单引号替换单引号，以允许它们正确地回显。</p><p>Here the <em class="command">echo</em> command
          contains a substitution that replaces single quotes with escaped
          single quotes to allow them to be properly echoed.</p><p>不保证编写麻烦的次要命令
          <code class="literal">cmd_</code>和<code class="literal">quiet_cmd_</code>变量以 为前缀
          <code class="literal">$(Q)</code>，其中不包含任何内容或<code class="literal">@</code>：</p><p>Minor commands that do not warrant the trouble of writing
          <code class="literal">cmd_</code> and <code class="literal">quiet_cmd_</code> variables are prefixed with
          <code class="literal">$(Q)</code>, which contains either
          nothing or <code class="literal">@</code>:</p><a id="OEBPS/ch11s02.html.I_6_tt493"></a><pre class="programlisting">ifeq ($(KBUILD_VERBOSE),1)
  安静=
  Q=
别的
  安静=安静_
  问=@
万一

# 如果用户正在运行 make -s （静默模式），则抑制回显
# 命令

ifneq ($(findstring s,$(MAKEFLAGS)),)
  安静=安静_
万一</pre><pre class="programlisting">ifeq ($(KBUILD_VERBOSE),1)
  quiet =
  Q =
else
  quiet=quiet_
  Q = @
endif

# If the user is running make -s (silent mode), suppress echoing of
# commands

ifneq ($(findstring s,$(MAKEFLAGS)),)
  quiet=silent_
endif</pre></div><div class="sect2" title="用户定义函数"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch11s02.html.make3-CHP-11-SECT-2.4"></a>用户定义函数</h2><h2 class="title"><a></a>User-Defined Functions</h2></div></div></div><p>内核<em class="filename">makefile</em>
          定义了一个<a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1579" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581" class="indexterm"></a> <a id="OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582" class="indexterm"></a>功能数量。在这里我们介绍最有趣的。代码已重新格式化以提高可读性。</p><p>The kernel <em class="filename">makefile</em>
          defines a <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>number of functions. Here we cover the most
          interesting ones. The code has been reformatted to improve
          readability.</p><p>该<code class="function">check_gcc</code>函数用于选择<em class="command">gcc</em>命令行选项。</p><p>The <code class="function">check_gcc</code> function is
          used to select a <em class="command">gcc</em> command-line
          option.</p><a id="OEBPS/ch11s02.html.I_6_tt494"></a><pre class="programlisting"># $(调用 check_gcc,首选选项,备用选项)
检查_gcc = \
    $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null \
               -xc /dev/null &gt; /dev/null 2&gt;&amp;1; \
            然后 \
              回显“$（1）”； \
            别的 \
              回显“$（2）”； \
            菲 ;)</pre><pre class="programlisting"># $(call check_gcc,preferred-option,alternate-option)
check_gcc =                                         \
    $(shell if $(CC) $(CFLAGS) $(1) -S -o /dev/null \
               -xc /dev/null &gt; /dev/null 2&gt;&amp;1;      \
            then                                    \
              echo "$(1)";                          \
            else                                    \
              echo "$(2)";                          \
            fi ;)</pre><p>该函数的工作原理是使用首选命令行选项在空输入文件上调用<em class="command">gcc</em> 。输出文件、标准输出和标准错误文件将被丢弃。如果<em class="command">gcc</em>命令成功，则意味着首选命令行选项对此体系结构有效，并由函数返回。否则，该选项无效并返回备用选项。可以在<em class="filename">arch/i386/Makefile</em>中找到示例使用
          ：</p><p>The function works by invoking <em class="command">gcc</em> on a null input file with the
          preferred command-line option. The output file, standard output, and
          standard error files are discarded. If the <em class="command">gcc</em> command succeeds, it means the
          preferred command-line option is valid for this architecture and is
          returned by the function. Otherwise, the option is invalid and the
          alternate option is returned. An example use can be found in
          <em class="filename">arch/i386/Makefile</em>:</p><a id="OEBPS/ch11s02.html.I_6_tt495"></a><pre class="programlisting"># 防止 gcc 保持堆栈 16 字节对齐
CFLAGS += $(调用 check_gcc,-mpreferred-stack-boundary=2,)</pre><pre class="programlisting"># prevent gcc from keeping the stack 16 byte aligned
CFLAGS += $(call check_gcc,-mpreferred-stack-boundary=2,)</pre><p>该<code class="function">if_changed_dep</code>
          函数使用一种出色的技术生成依赖性信息。</p><p>The <code class="function">if_changed_dep</code>
          function generates dependency information using a remarkable
          technique.</p><a id="OEBPS/ch11s02.html.I_6_tt496"></a><pre class="programlisting"># 执行命令并进行后处理生成
# .d 依赖文件
if_changed_dep = \
    $(如果\
      $(去掉$?\
        $(过滤掉 FORCE $(通配符 $^),$^) \
        $(过滤掉$(cmd_$(1)),$(cmd_$@)) \
        $(过滤掉$(cmd_$@),$(cmd_$(1)))), \
      @设置-e； \
      $(如果$($(安静)cmd_$(1)), \
        echo ' $(subst ','\'',$($(quiet)cmd_$(1)))';) \
      $(cmd_$(1)); \
      脚本/基本/fixdep \
         $(depfile) \
         $@\
         '$(subst $$,$$$$,$(subst ','\'',$(cmd_$(1))))' \
         &gt; $(@D)/.$(@F).tmp; \
      rm -f $(depfile); \
      mv -f $(@D)/.$(@F).tmp $(@D)/.$(@F).cmd)</pre><pre class="programlisting"># execute the command and also postprocess generated
# .d dependencies file
if_changed_dep =                                        \
    $(if                                                \
      $(strip $?                                        \
        $(filter-out FORCE $(wildcard $^),$^)           \
        $(filter-out $(cmd_$(1)),$(cmd_$@))             \
        $(filter-out $(cmd_$@),$(cmd_$(1)))),           \
      @set -e;                                          \
      $(if $($(quiet)cmd_$(1)),                         \
        echo '  $(subst ','\'',$($(quiet)cmd_$(1)))';)  \
      $(cmd_$(1));                                      \
      scripts/basic/fixdep                              \
         $(depfile)                                     \
         $@                                             \
         '$(subst $$,$$$$,$(subst ','\'',$(cmd_$(1))))' \
         &gt; $(@D)/.$(@F).tmp;                            \
      rm -f $(depfile);                                 \
      mv -f $(@D)/.$(@F).tmp $(@D)/.$(@F).cmd)</pre><p>该函数由一个<code class="function">if</code>子句组成。测试的细节相当模糊，但很明显，如果应该重新生成依赖文件，则其意图是非空。正常的依赖信息与文件的修改时间戳有关。内核构建系统给这个任务增加了另一个难题。内核构建使用多种编译器选项来控制组件的构造和行为。为了确保在构建过程中正确考虑命令行选项，实现了<em class="filename">makefile</em>，以便如果用于特定目标的命令行选项发生更改，则重新编译该文件。让我们看看这是如何实现的。</p><p>The function consists of a single <code class="function">if</code> clause. The details of the test are
          pretty obscure, but it is clear the intent is to be non-empty if the
          dependency file should be regenerated. Normal dependency information
          is concerned with the modification timestamps on files. The kernel
          build system adds another wrinkle to this task. The kernel build
          uses a wide variety of compiler options to control the construction
          and behavior of components. To ensure that command-line options are
          properly accounted for during a build, the <em class="filename">makefile</em> is implemented so that if
          command-line options used for a particular target change, the file
          is recompiled. Let's see how this is accomplished.</p><p>本质上，用于编译内核中每个文件的命令都保存在<em class="filename">.cmd</em>文件中。当执行后续构建时，<em class="command">make</em>会读取<em class="filename">.cmd</em>文件并将当前编译命令与最后一个命令进行比较。如果它们不同，则
          重新生成<em class="filename">.cmd</em>依赖文件，从而导致重建目标文件。<em class="filename">.cmd</em>文件通常包含两项：表示目标文件的实际文件的依赖项和记录命令行选项的单个变量。例如，文件<em class="filename">arch/i386/kernel/cpu/mtrr/if.c</em>生成以下（缩写）文件：</p><p>In essence, the command used to compile each file in the
          kernel is saved in a <em class="filename">.cmd</em> file.
          When a subsequent build is executed, <em class="command">make</em> reads the <em class="filename">.cmd</em> files and compares the current
          compile command with the last command. If they are different, the
          <em class="filename">.cmd</em> dependency file is
          regenerated causing the object file to be rebuilt. The <em class="filename">.cmd</em> file usually contains two items: the
          dependencies that represent actual files for the target file and a
          single variable recording the command-line options. For example, the
          file <em class="filename">arch/i386/kernel/cpu/mtrr/if.c</em> yields
          this (abbreviated) file:</p><a id="OEBPS/ch11s02.html.I_6_tt497"></a><pre class="programlisting">cmd_arch/i386/kernel/cpu/mtrr/if.o := gcc -Wp,-MD ...;如果c

deps_arch/i386/kernel/cpu/mtrr/if.o := \
  拱门/i386/内核/cpu/mtrr/if.c \
  ...

拱门/i386/内核/cpu/mtrr/if.o: $(deps_arch/i386/kernel/cpu/mtrr/if.o)
$(deps_arch/i386/kernel/cpu/mtrr/if.o):</pre><pre class="programlisting">cmd_arch/i386/kernel/cpu/mtrr/if.o := gcc -Wp,-MD ...; if.c

deps_arch/i386/kernel/cpu/mtrr/if.o := \
  arch/i386/kernel/cpu/mtrr/if.c \
  ...

arch/i386/kernel/cpu/mtrr/if.o: $(deps_arch/i386/kernel/cpu/mtrr/if.o)
$(deps_arch/i386/kernel/cpu/mtrr/if.o):</pre><p>回到<code class="function">if_changed_dep</code>函数，第一个参数<code class="function">strip</code>只是比目标更新的先决条件（如果有）。第二个参数<code class="function">strip</code>是除 files 和空 target 之外的所有先决条件<code class="literal">FORCE</code>。真正晦涩的部分是最后两个<code class="function">filter-out</code>调用：</p><p>Getting back to the <code class="function">if_changed_dep</code> function, the first
          argument to the <code class="function">strip</code> is simply
          the prerequisites that are newer than the target, if any. The second
          argument to <code class="function">strip</code> is all the
          prerequisites other than files and the empty target <code class="literal">FORCE</code>. The really obscure bit is the last
          two <code class="function">filter-out</code> calls:</p><a id="OEBPS/ch11s02.html.I_6_tt498"></a><pre class="programlisting">$(过滤掉$(cmd_$(1)),$(cmd_$@))
$(过滤掉$(cmd_$@),$(cmd_$(1)))</pre><pre class="programlisting">$(filter-out $(cmd_$(1)),$(cmd_$@))
$(filter-out $(cmd_$@),$(cmd_$(1)))</pre><p>如果命令行选项已更改，则这些调用中的一个或两个将扩展为非空字符串。宏<code class="literal">$(cmd_$(1))</code>是当前命令，也
          <code class="literal">$(cmd_$@)</code>将是上一个命令，例如<code class="literal">cmd_arch/i386/kernel/cpu/mtrr/if.o</code>刚刚显示的变量。如果新命令包含其他选项，第一个
          <code class="function">filter-out</code>将为空，第二个将扩展到新选项。如果新命令包含的选项较少，则第一个命令将包含已删除的选项，第二个命令将为空。有趣的是，由于<code class="function">filter-out</code>接受单词列表（每个单词被视为独立模式），因此选项的顺序可以更改，并且<code class="function">filter-out</code>仍然可以准确地识别添加或删除的选项。相当漂亮。</p><p>One or both of these calls will expand to a non-empty string
          if the command-line options have changed. The macro <code class="literal">$(cmd_$(1))</code> is the current command and
          <code class="literal">$(cmd_$@)</code> will be the previous
          command, for instance the variable <code class="literal">cmd_arch/i386/kernel/cpu/mtrr/if.o</code> just
          shown. If the new command contains additional options, the first
          <code class="function">filter-out</code> will be empty, and
          the second will expand to the new options. If the new command
          contains fewer options, the first command will contain the deleted
          options and the second will be empty. Interestingly, since <code class="function">filter-out</code> accepts a list of words (each
          treated as an independent pattern), the order of options can change
          and the <code class="function">filter-out</code> will still
          accurately identify added or removed options. Pretty nifty.</p><p>命令脚本中的第一条语句设置 shell 选项以在出错时立即退出。这可以防止多行脚本在出现问题时损坏文件。对于简单的脚本，实现此效果的另一种方法是使用分号
          <code class="literal">&amp;&amp;</code>而不是连接语句。</p><p>The first statement in the command script sets a shell option
          to exit immediately on error. This prevents the multiline script
          from corrupting files in the event of problems. For simple scripts
          another way to achieve this effect is to connect statements with
          <code class="literal">&amp;&amp;</code> rather than
          semicolons.</p><p>下一条语句是使用本章前面<a class="link" href="#OEBPS/ch11s02.html.make3-CHP-11-SECT-2.3" title="管理命令回显">第 11.2.3 节</a>中描述的技术编写的<em class="command">echo</em>命令，后面是依赖项生成命令本身。该命令写入，然后由
          <em class="command">script/basic/fixdep</em>进行转换。<em class="command">fixdep</em>命令行中的嵌套
          函数首先转义单引号，然后转义(shell 语法中的当前进程号) 的出现。<a class="link" href="#OEBPS/ch11s02.html.make3-CHP-11-SECT-2.3" title="管理命令回显"></a><code class="literal">$(depfile)</code><em class="command"></em><code class="function">subst</code><em class="command"></em><code class="literal">$$</code></p><p>The next statement is an <em class="command">echo</em> command written using the techniques
          described in <a class="link" href="#OEBPS/ch11s02.html.make3-CHP-11-SECT-2.3" title="Managing Command Echo">Section
          11.2.3</a> earlier in this chapter, followed by the dependency
          generating command itself. The command writes <code class="literal">$(depfile)</code>, which is then transformed by
          <em class="command">scripts/basic/fixdep</em>. The nested
          <code class="function">subst</code> function in the <em class="command">fixdep</em> command line first escapes single
          quotes, then escapes occurrences of <code class="literal">$$</code> (the current process number in shell
          syntax).</p><p>最后，如果没有发生错误，则
          <code class="literal">$(depfile)</code>删除中间文件，并将生成的依赖文件（带有<em class="filename">.cmd</em>后缀）移动到位。</p><p>Finally, if no errors have occurred, the intermediate file
          <code class="literal">$(depfile)</code> is removed and the
          generated dependency file (with its <em class="filename">.cmd</em> suffix) is moved into place.</p><p>下一个函数<code class="function">if_changed_rule</code>，使用相同的比较技术来<code class="function">if_changed_dep</code>控制命令的执行：</p><p>The next function, <code class="function">if_changed_rule</code>, uses the same comparison
          technique as <code class="function">if_changed_dep</code> to
          control the execution of a command:</p><a id="OEBPS/ch11s02.html.I_6_tt499"></a><pre class="programlisting"># 用法：$(call if_changed_rule,foo)
# 将检查 $(cmd_foo) 是否更改，或者任何先决条件是否更改，
# 如果是的话将执行 $(rule_foo)

if_changed_rule = \
    $(如果$(剥离$?\
           $(过滤掉$(cmd_$(1)),$(cmd_$(@F))) \
           $(过滤掉$(cmd_$(@F)),$(cmd_$(1)))), \
      @$(规则_$(1)))</pre><pre class="programlisting"># Usage: $(call if_changed_rule,foo)
# will check if $(cmd_foo) changed, or any of the prequisites changed,
# and if so will execute $(rule_foo)

if_changed_rule =                                   \
    $(if $(strip $?                                 \
           $(filter-out $(cmd_$(1)),$(cmd_$(@F)))   \
           $(filter-out $(cmd_$(@F)),$(cmd_$(1)))), \
      @$(rule_$(1)))</pre><p>在最顶层的<em class="filename">makefile</em>中，该函数用于将内核与这些宏链接：</p><p>In the topmost <em class="filename">makefile</em>,
          this function is used to link the kernel with these macros:</p><a id="OEBPS/ch11s02.html.I_6_tt500"></a><pre class="programlisting"># 这有点棘手：如果我们需要重新链接 vmlinux，我们需要
# 版本号增加，意味着重新编译init/version.o
# 并重新链接 init/init.o。但是，我们不能在
# 正常的下降到子目录阶段，从那时起
# 我们还不知道是否需要重新链接 vmlinux。
# 所以我们再次进入 vmlinux 规则内的 init/ 。
...

Quiet_cmd_vmlinux_ _ = LD $@
定义cmd_vmlinux__
  $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) \
    ...
恩德夫

# set -e 使规则在出错时立即退出

定义rule_vmlinux__
  +设置-e； \
  $(如果$(过滤器.tmp_kallsyms%,$^),, \
    echo 'GEN.版本'; \
    。 $(srctree)/scripts/mkversion &gt; .tmp_version; \
    mv -f .tmp_version .版本； \
    $(MAKE) $(build)=init;) \
  $(如果$($(安静)cmd_vmlinux_ _), \
    echo ' $($(quiet)cmd_vmlinux_ _)' &amp;&amp;) \
  $(cmd_vmlinux_ _); \
  echo 'cmd_$@ := $(cmd_vmlinux_ _)' &gt; $(@D)/.$(@F).cmd
恩德夫

定义rule_vmlinux
  $(rule_vmlinux_ _); \
  $(新米) $@ | \
  grep -v '\(已编译\)\|...' | \
  排序&gt;系统.map
恩德夫</pre><pre class="programlisting"># This is a bit tricky: If we need to relink vmlinux, we want
# the version number incremented, which means recompile init/version.o
# and relink init/init.o. However, we cannot do this during the
# normal descending-into-subdirs phase, since at that time
# we cannot yet know if we will need to relink vmlinux.
# So we descend into init/ inside the rule for vmlinux again.
...

quiet_cmd_vmlinux_ _ = LD $@
define cmd_vmlinux_ _
  $(LD) $(LDFLAGS) $(LDFLAGS_vmlinux) \
    ...
endef

# set -e makes the rule exit immediately on error

define rule_vmlinux_ _
  +set -e;                                              \
  $(if $(filter .tmp_kallsyms%,$^),,                    \
    echo '  GEN     .version';                          \
    . $(srctree)/scripts/mkversion &gt; .tmp_version;      \
    mv -f .tmp_version .version;                        \
    $(MAKE) $(build)=init;)                             \
  $(if $($(quiet)cmd_vmlinux_ _),                        \
    echo '  $($(quiet)cmd_vmlinux_ _)' &amp;&amp;)               \
  $(cmd_vmlinux_ _);                                     \
  echo 'cmd_$@ := $(cmd_vmlinux_ _)' &gt; $(@D)/.$(@F).cmd
endef

define rule_vmlinux
  $(rule_vmlinux_ _);          \
  $(NM) $@ |                  \
  grep -v '\(compiled\)\|...' | \
  sort &gt; System.map
endef</pre><p>该<code class="function">if_changed_rule</code>
          函数用于调用<code class="function">rule_vmlinux</code>，后者执行链接并构建最终的<em class="filename">System.map</em>。正如<em class="filename">makefile</em>中的注释所
          指出的，该函数必须在重新链接<em class="filename">vmlinux</em>之前
          <code class="function">rule_vmlinux_ _</code>
          重新生成内核版本文件并重新链接
          <em class="filename">init.o</em>。这是由第一个控制的。第二个控制链接命令的回显。链接命令之后，实际执行的命令会记录在
          <em class="filename">.cmd</em>文件中，以便下次构建时进行比较。<em class="filename"></em><code class="function">if</code><code class="function">rule_vmlinux_ _</code><code class="function">if</code><code class="literal">$(cmd_vmlinux_ _)</code><em class="filename"></em></p><p>The <code class="function">if_changed_rule</code>
          function is used to invoke <code class="function">rule_vmlinux</code>, which performs the link and
          builds the final <em class="filename">System.map</em>. As
          the comment in the <em class="filename">makefile</em>
          notes, the <code class="function">rule_vmlinux_ _</code>
          function must regenerate the kernel version file and relink
          <em class="filename">init.o</em> before relinking
          <em class="filename">vmlinux</em>. This is controlled by
          the first <code class="function">if</code> in <code class="function">rule_vmlinux_ _</code>. The second <code class="function">if</code> controls the echoing of the link
          command, <code class="literal">$(cmd_vmlinux_ _)</code>. After
          the link command, the actual command executed is recorded in a
          <em class="filename">.cmd</em> file for comparison in the
          next build.</p></div></div></div></div>
<div id="OEBPS/ch12.html"><div>
<div class="chapter" title="第 12 章调试 Makefile"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch12.html.make3-CHP-12"></a>第 12 章调试 Makefile</h1><h1 class="title"><a></a>Chapter&nbsp;12.&nbsp;Debugging Makefiles</h1></div></div></div><p>调试<em class="filename">makefile</em>有点像魔术。不幸的是，没有像
      <em class="filename">makefile</em>调试器这样的东西来检查如何评估特定规则或如何扩展变量。相反，大多数调试是通过简单的打印语句和检查<em class="filename">makefile</em>来执行的。
       <acronym class="acronym">GNU </acronym> <em class="command">make</em>提供了一些有关各种内置函数和命令行选项的帮助。</p><p>Debugging <em class="filename">makefile</em>s is
      somewhat of a black art. Unfortunately, there is no such thing as a
      <em class="filename">makefile</em> debugger to examine how a
      particular rule is being evaluated or a variable expanded. Instead, most
      debugging is performed with simple print statements and by inspection of
      the <em class="filename">makefile</em>.
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> provides
      some help with various built-in functions and command-line
      options.</p><p><em class="filename">调试makefile 的</em>最佳方法之一是添加调试挂钩并使用防御性编程技术，当出现问题时可以依靠这些技术。我将介绍一些我认为最有帮助的基本调试技术和防御性编码实践。</p><p>One of the best ways to debug a <em class="filename">makefile</em> is to add debugging hooks and use
      defensive programming techniques that you can fall back on when things
      go awry. I'll present a few basic debugging techniques and defensive
      coding practices I've found most helpful.</p><div class="sect1" title="make 的调试功能"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1"></a>make 的调试功能</h1><h1 class="title"><a></a>Debugging Features of make</h1></div></div></div><p>功能<code class="function">warning</code>很<a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1583" class="indexterm"></a>对于调试任性的<em class="filename">makefile</em>很有用。因为<code class="function">warning</code>函数<a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1584" class="indexterm"></a> <a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1585" class="indexterm"></a>扩展为空字符串，它可以放置在<em class="filename">makefile</em>中的任何位置：顶层、目标或先决条件列表以及命令脚本中。这允许您在最方便检查变量的地方打印变量的值。例如：</p><p>The <code class="function">warning</code> function is
        very <a class="indexterm"></a>useful for debugging wayward <em class="filename">makefile</em>s. Because the <code class="function">warning</code> function<a class="indexterm"></a> <a class="indexterm"></a> expands to the empty string, it can be placed anywhere
        in a <em class="filename">makefile</em>: at the top-level,
        in target or prerequisite lists, and in command scripts. This allows
        you to print the value of variables wherever it is most convenient to
        inspect them. For example:</p><a id="OEBPS/ch12.html.I_7_tt501"></a><pre class="programlisting">$(警告 顶级警告)

FOO := $(警告简单变量的右侧)bar
BAZ = $(警告递归变量的右侧)boo

$(警告 A 目标)target: $(警告在先决条件列表中)makefile $(BAZ)
        $（命令脚本中的警告）
        LS
$（巴兹）：</pre><pre class="programlisting">$(warning A top-level warning)

FOO := $(warning Right-hand side of a simple variable)bar
BAZ = $(warning Right-hand side of a recursive variable)boo

$(warning A target)target: $(warning In a prerequisite list)makefile $(BAZ)
        $(warning In a command script)
        ls
$(BAZ):</pre><p>产生输出：</p><p>yields the output:</p><a id="OEBPS/ch12.html.I_7_tt502"></a><pre class="programlisting">$ 制作
makefile:1：顶级警告
makefile:2：简单变量的右侧
makefile:5：目标
makefile:5：在先决条件列表中
makefile:5：递归变量的右侧
makefile:8：递归变量的右侧
makefile:6：在命令脚本中
LS
生成文件</pre><pre class="programlisting">$ make
makefile:1: A top-level warning
makefile:2: Right-hand side of a simple variable
makefile:5: A target
makefile:5: In a prerequisite list
makefile:5: Right-hand side of a recursive variable
makefile:8: Right-hand side of a recursive variable
makefile:6: In a command script
ls
makefile</pre><p>请注意，函数的评估遵循立即评估和延迟评估的<code class="function">warning</code>正常
        <em class="command">make</em>算法。尽管 的分配<code class="literal">BAZ</code>包含，但只有在先决条件列表中进行评估<code class="function">warning</code>后才会打印该消息
        。<code class="literal">BAZ</code></p><p>Notice that the evaluation of the <code class="function">warning</code> function follows the normal
        <em class="command">make</em> algorithm for immediate and
        deferred evaluation. Although the assignment to <code class="literal">BAZ</code> contains a <code class="function">warning</code>, the message does not print until
        <code class="literal">BAZ</code> is evaluated in the
        prerequisites list.</p><p>在任何地方注入调用的能力<code class="function">warning</code>使其成为必不可少的调试工具。</p><p>The ability to inject a <code class="function">warning</code> call anywhere makes it an essential
        debugging tool.</p><div class="sect2" title="命令行选项"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1.1"></a>命令行选项</h2><h2 class="title"><a></a>Command-Line Options</h2></div></div></div><p>有三种<a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1586" class="indexterm"></a> <a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1587" class="indexterm"></a>我发现对于调试最有用的命令行选项：(
           )、
           <code class="option">—just-print</code>( ) 和
          .<code class="option">-n</code><code class="option">—print-data-base</code><code class="option">-p</code><code class="option">—warn-undefined-variables</code></p><p>There are three <a class="indexterm"></a> <a class="indexterm"></a>command-line options I find most useful for debugging:
          <code class="option">—just-print</code> (<code class="option">-n</code>),
          <code class="option">—print-data-base</code> (<code class="option">-p</code>), and
          <code class="option">—warn-undefined-variables</code>.</p><div class="sect3" title="—只需打印"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1.1.1"></a>—只需打印</h3><h3 class="title"><a></a>—just-print</h3></div></div></div><p>我执行的第一个测试<a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1588" class="indexterm"></a>在新的<em class="filename">makefile</em>目标上的方法是使用( )选项
            调用<em class="command">make</em>。这会导致<em class="command">make</em>读取
            <em class="filename">makefile</em>并打印它通常会执行以更新目标的每个命令，但不执行它们。为了方便起见，<acronym class="acronym">GNU </acronym><em class="command">make</em>还将回显标有静音修饰符 ( ) 的命令。<code class="option">—just-print</code><code class="option">-n</code><em class="command"></em><em class="filename"></em><acronym class="acronym"></acronym> <em class="command"></em><code class="literal">@</code></p><p>The first test I perform <a class="indexterm"></a>on a new <em class="filename">makefile</em> target is to invoke <em class="command">make</em> with the
            <code class="option">—just-print</code> (<code class="option">-n</code>) option. This
            causes <em class="command">make</em> to read the
            <em class="filename">makefile</em> and print every
            command it would normally execute to update the target but without
            executing them. As a convenience, <acronym class="acronym">GNU</acronym> <em class="command">make</em> will also echo commands marked with
            the silent modifier (<code class="literal">@</code>).</p><p>该选项应该抑制所有命令的执行。虽然这在某种意义上可能是正确的，但实际上，您必须小心。虽然<em class="command">make</em>不会执行命令脚本，但它将评估<code class="function">shell</code>直接上下文中发生的函数调用。例如：</p><p>The option is supposed to suppress all command execution.
            While this may be true in one sense, practically speaking, you
            must take care. While <em class="command">make</em> will
            not execute command scripts, it will evaluate <code class="function">shell</code> function calls that occur within
            an immediate context. For instance:</p><a id="OEBPS/ch12.html.I_7_tt503"></a><pre class="programlisting">REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS); \
             做 \
               [[ -d $$d ]] || mkdir -p $$d; \
             完毕）

$(对象) : $(源)</pre><pre class="programlisting">REQUIRED_DIRS = ...
_MKDIRS := $(shell for d in $(REQUIRED_DIRS); \
             do                               \
               [[ -d $$d ]] || mkdir -p $$d;  \
             done)

$(objects) : $(sources)</pre><p>正如我们之前所看到的，简单变量的目的<code class="literal">_MKDIRS</code>是触发基本目录的创建。当用 执行时
            ，shell 命令将在读取<em class="filename">makefile</em><code class="option">—just-print</code>时照常执行。然后<em class="command">make</em>将回显（不执行）更新文件列表所需的每个编译命令。<em class="filename"></em><em class="command"></em><code class="literal">$(objects)</code></p><p>As we've seen before, the purpose of the <code class="literal">_MKDIRS</code> simple variable is to trigger
            the creation of essential directories. When this is executed with
            <code class="option">—just-print</code>, the shell command will be executed
            as usual when the <em class="filename">makefile</em> is
            read. Then <em class="command">make</em> will echo
            (without executing) each compilation command required to update
            the <code class="literal">$(objects)</code> file
            list.</p></div><div class="sect3" title="—打印数据库"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1.1.2"></a>—打印数据库</h3><h3 class="title"><a></a>—print-data-base</h3></div></div></div><p>选项<code class="option">—print-data-base</code>​<code class="option">-p</code>​<a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1589" class="indexterm"></a>是您会经常使用的另一种。它执行
            <em class="filename">makefile</em>，显示
            <acronym class="acronym">GNU版权，然后显示由</acronym><em class="command">make</em>运行的命令，然后它将转储其内部数据库。数据被收集到值组中：变量、目录、隐式规则、特定于模式的变量、文件（显式规则）和 vpath 搜索路径：</p><p>The <code class="option">—print-data-base</code> (<code class="option">-p</code>)
            option <a class="indexterm"></a>is another one you'll use often. It executes the
            <em class="filename">makefile</em>, displaying the
            <acronym class="acronym">GNU</acronym> copyright followed by the commands as they
            are run by <em class="command">make</em>, then it will
            dump its internal database. The data is collected into groups of
            values: variables, directories, implicit rules, pattern-specific
            variables, files (explicit rules), and the vpath search
            path:</p><a id="OEBPS/ch12.html.I_7_tt504"></a><pre class="programlisting"># GNU Make 3.80
# 版权所有 (C) 2002 自由软件基金会，Inc.
# 这是免费软件；请参阅复制条件的来源。
# 没有任何保证；甚至不考虑适销性或适用性
＃ 特殊用途。<em class="replaceable"><code>normal command execution occurs here</code></em>

# 制作数据库，打印于 Thu Apr 29 20:58:13 2004

# 变量
...
# 目录
...
# 隐式规则
...
# 特定于模式的变量值
...
# 文件
...
# VPATH 搜索路径</pre><pre class="programlisting"># GNU Make 3.80
# Copyright (C) 2002  Free Software Foundation, Inc.
# This is free software; see the source for copying conditions.
# There is NO warranty; not even for MERCHANTABILITY or FITNESS FOR A
# PARTICULAR PURPOSE.<em class="replaceable"><code>normal command execution occurs here</code></em>

# Make data base, printed on Thu Apr 29 20:58:13 2004

# Variables
...
# Directories
...
# Implicit Rules
...
# Pattern-specific variable values
...
# Files
...
# VPATH Search Paths</pre><p>让我们更详细地研究这些部分。</p><p>Let's examine these sections in more detail.</p><p>变量部分列出了每个变量以及描述性注释：</p><p>The variables section lists each variable along with a
            descriptive comment:</p><a id="OEBPS/ch12.html.I_7_tt505"></a><pre class="programlisting">＃ 自动的
&lt;D = $(patsubst %/,%,$(dir $&lt;))
＃ 环境
EMACS_DIR = C:/usr/emacs-21.3.50.7
＃ 默认
CWEAVE = 编织
# makefile（来自“../mp3_player/makefile”，第 35 行）
CPPFLAGS = $(addprefix -I ,$(include_dirs))
# makefile（来自“../ch07-separate-binaries/makefile”，第 44 行）
RM := rm -f
# makefile（来自“../mp3_player/makefile”，第 14 行）
定义 make-library
  图书馆 += $1
  来源 += $2

  $1: $(调用源到对象,$2)
        $(AR) $(ARFLAGS) $$@ $$^
恩德夫</pre><pre class="programlisting"># automatic
&lt;D = $(patsubst %/,%,$(dir $&lt;))
# environment
EMACS_DIR = C:/usr/emacs-21.3.50.7
# default
CWEAVE = cweave
# makefile (from `../mp3_player/makefile', line 35)
CPPFLAGS = $(addprefix -I ,$(include_dirs))
# makefile (from `../ch07-separate-binaries/makefile', line 44)
RM := rm -f
# makefile (from `../mp3_player/makefile', line 14)
define make-library
  libraries += $1
  sources   += $2

  $1: $(call source-to-object,$2)
        $(AR) $(ARFLAGS) $$@ $$^
endef</pre><p>自动变量不会被打印，但从它们派生的便利变量<code class="literal">$(&lt;D)</code>会被打印。注释指示函数返回的变量的类型<code class="function">origin</code>（参见<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>中的<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.5" title="不太重要的杂项功能">4.2.5 节</a>）。如果变量是在文件中定义的，则给出定义的文件名和行号。简单变量和递归变量通过赋值运算符来区分。简单变量的值将显示为右侧的计算形式。<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a></p><p>Automatic variables are not printed, but convenience
            variables derived from them like <code class="literal">$(&lt;D)</code> are. The comment indicates the
            type of the variable as returned by the <code class="function">origin</code> function (see the <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.5" title="Less Important Miscellaneous Functions">Section 4.2.5</a> in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>). If the variable is
            defined in a file, the filename and line number of the definition
            is given. Simple and recursive variables are distinguished by the
            assignment operator. The value of a simple variable will be
            displayed as the evaluated form of the righthand side.</p><p>下一部分标记为“目录”，对于
            <em class="command">培养</em>开发人员比
            <em class="command">培养</em>用户更有用。它列出了<em class="command">make</em>检查的目录，包括可能存在但通常不存在的 SCCS 和 RCS 子目录。对于每个目录，<em class="command">make</em>显示实现详细信息，例如设备号、inode 和文件模式匹配的统计信息。</p><p>The next section, labeled Directories, is more useful to
            <em class="command">make</em> developers than to
            <em class="command">make</em> users. It lists the
            directories being examined by <em class="command">make</em>, including SCCS and RCS
            subdirectories that might exist, but usually do not. For each
            directory, <em class="command">make</em> displays
            implementation details, such as the device number, inode, and
            statistics on file pattern matches.</p><p>隐含规则部分如下。它包含<em class="command">make</em>数据库中的所有内置和用户定义的模式规则。同样，对于文件中定义的规则，注释指示文件和行号：</p><p>The Implicit Rules section follows. This contains all the
            built-in and user-defined pattern rules in <em class="command">make</em>'s database. Again, for those rules
            defined in a file, a comment indicates the file and line
            number:</p><a id="OEBPS/ch12.html.I_7_tt506"></a><pre class="programlisting">%.c %.h: %.y
# 要执行的命令（来自“../mp3_player/makefile”，第 73 行）：
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

％： ％。C
# 要执行的命令（内置）：
        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@

%.o: %.c
# 要执行的命令（内置）：
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting">%.c %.h: %.y
# commands to execute (from `../mp3_player/makefile', line 73):
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h

%: %.c
#  commands to execute (built-in):
        $(LINK.c) $^ $(LOADLIBES) $(LDLIBS) -o $@

%.o: %.c
#  commands to execute (built-in):
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>检查本节是熟悉<em class="command">make</em>内置规则的多样性和结构的好方法。当然，并非所有内置规则都作为模式规则实现。如果您没有找到您要查找的规则，请检查列出了旧式后缀规则的“文件”部分。</p><p>Examining this section is a great way to become familiar
            with the variety and structure of <em class="command">make</em>'s built-in rules. Of course, not
            all built-in rules are implemented as pattern rules. If you don't
            find the rule you're looking for, check in the Files section where
            the old-style suffix rules are listed.</p><p>下一节对<em class="filename">makefile</em>中定义的特定于模式的变量进行分类。回想一下，特定于模式的变量是变量定义，其范围恰好是其关联模式规则的执行时间。例如，模式变量<code class="literal">YYLEXFLAG</code>，定义为：</p><p>The next section catalogs the pattern-specific variables
            defined in the <em class="filename">makefile</em>.
            Recall that pattern-specific variables are variable definitions
            whose scope is precisely the execution time of their associated
            pattern rule. For example, the pattern variable <code class="literal">YYLEXFLAG</code>, defined as:</p><a id="OEBPS/ch12.html.I_7_tt507"></a><pre class="programlisting">%.c %.h: YYLEXFLAG := -d
%.c %.h: %.y
        $(YACC.y) --定义$&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h</pre><pre class="programlisting">%.c %.h: YYLEXFLAG := -d
%.c %.h: %.y
        $(YACC.y) --defines $&lt;
        $(MV) y.tab.c $*.c
        $(MV) y.tab.h $*.h</pre><p>将显示为：</p><p>would be displayed as:</p><a id="OEBPS/ch12.html.I_7_tt508"></a><pre class="programlisting"># 特定于模式的变量值

％。C ：
# makefile（来自“Makefile”，第 1 行）
# YYLEXFLAG := -d
# 变量集哈希表统计信息：
# 负载=1/16=6%，重新散列=0，碰撞=0/1=0%

％。H ：
# makefile（来自“Makefile”，第 1 行）
# YYLEXFLAG := -d
# 变量集哈希表统计信息：
# 负载=1/16=6%，重新散列=0，碰撞=0/1=0%

# 2 个特定于模式的变量值</pre><pre class="programlisting"># Pattern-specific variable values

%.c :
# makefile (from `Makefile', line 1)
# YYLEXFLAG := -d
# variable set hash-table stats:
# Load=1/16=6%, Rehash=0, Collisions=0/1=0%

%.h :
# makefile (from `Makefile', line 1)
# YYLEXFLAG := -d
# variable set hash-table stats:
# Load=1/16=6%, Rehash=0, Collisions=0/1=0%

# 2 pattern-specific variable values</pre><p>文件部分随后列出了与特定文件相关的所有显式规则和后缀规则：</p><p>The Files section follows and lists all the explicit and
            suffix rules that relate to specific files:</p><a id="OEBPS/ch12.html.I_7_tt509"></a><pre class="programlisting"># 不是目标：
.po:
# 隐式规则搜索尚未完成。
# 修改时间从未检查过。
# 文件尚未更新。
# 要执行的命令（内置）：
        $(COMPILE.p) $(OUTPUT_OPTION) $&lt;

lib/ui/libui.a: lib/ui/ui.o
# 隐式规则搜索尚未完成。
# 最后修改时间 2004-04-01 22:04:09.515625
# 文件已更新。
＃ 成功更新。
# 要执行的命令（来自 `../mp3_player/lib/ui/module.mk'，第 3 行）：
        房车 $@ $^

lib/codec/codec.o: ../mp3_player/lib/codec/codec.c ../mp3_player/lib/codec/codec.c ../
mp3_player/include/codec/codec.h
# 隐式规则搜索已完成。
# 隐式/静态模式主干：`lib/codec/codec'
# 最后修改时间 2004-04-01 22:04:08.40625
# 文件已更新。
＃ 成功更新。
# 要执行的命令（内置）：
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><pre class="programlisting"># Not a target:
.p.o:
#  Implicit rule search has not been done.
#  Modification time never checked.
#  File has not been updated.
#  commands to execute (built-in):
        $(COMPILE.p) $(OUTPUT_OPTION) $&lt;

lib/ui/libui.a: lib/ui/ui.o
#  Implicit rule search has not been done.
#  Last modified 2004-04-01 22:04:09.515625
#  File has been updated.
#  Successfully updated.
#  commands to execute (from `../mp3_player/lib/ui/module.mk', line 3):
        ar rv $@ $^

lib/codec/codec.o: ../mp3_player/lib/codec/codec.c ../mp3_player/lib/codec/codec.c ../
mp3_player/include/codec/codec.h
#  Implicit rule search has been done.
#  Implicit/static pattern stem: `lib/codec/codec'
#  Last modified 2004-04-01 22:04:08.40625
#  File has been updated.
#  Successfully updated.
#  commands to execute (built-in):
        $(COMPILE.c) $(OUTPUT_OPTION) $&lt;</pre><p>中间文件和后缀规则被标记为“不是目标”；其余的是目标。每个文件都包含指示<em class="command">make</em>如何处理规则的注释。通过正常搜索找到的文件
            <code class="literal">vpath</code>会显示其解析路径。</p><p>Intermediate files and suffix rules are labeled "Not a
            target"; the remainder are targets. Each file includes comments
            indicating how <em class="command">make</em> has
            processed the rule. Files that are found through the normal
            <code class="literal">vpath</code> search have their
            resolved path displayed.</p><p>最后一部分标记为 VPATH 搜索路径，并列出 的值<code class="literal">VPATH</code>和所有
            <code class="literal">vpath</code>模式。</p><p>The last section is labeled VPATH Search Paths and lists the
            value of <code class="literal">VPATH</code> and all the
            <code class="literal">vpath</code> patterns.</p><p>对于广泛使用用户定义函数并创建复杂变量和规则的<em class="filename">makefile</em><code class="function">eval</code>，检查此输出通常是验证宏扩展是否已生成预期值的唯一方法。</p><p>For <em class="filename">makefile</em>s that make
            extensive use of user-defined functions and <code class="function">eval</code> to create complex variables and
            rules, examining this output is often the only way to verify that
            macro expansion has generated the expected values.</p></div><div class="sect3" title="—警告未定义变量"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1.1.3"></a>—警告未定义变量</h3><h3 class="title"><a></a>—warn-undefined-variables</h3></div></div></div><p>该选项导致<em class="command">make</em>
            <a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1590" class="indexterm"></a>每当扩展未定义的变量时显示警告。由于未定义的变量会扩展为空字符串，因此变量名称中的拼写错误很容易长时间未被检测到。这个选项的问题是，许多内置规则都包含未定义的变量作为用户定义值的挂钩，这也是我很少使用它的原因。因此，使用此选项运行
            <em class="command">make</em>将不可避免地产生许多警告，这些警告不是错误，并且与用户的<em class="filename">makefile</em>没有任何有用的关系。例如：</p><p>This option causes <em class="command">make</em>
            <a class="indexterm"></a>to display a warning whenever an undefined variable
            is expanded. Since undefined variables expand to the empty string,
            it is common for typographical errors in variable names to go
            undetected for long periods. The problem with this option, and why
            I use it only rarely, is that many built-in rules include
            undefined variables as hooks for user-defined values. So running
            <em class="command">make</em> with this option will
            inevitably produce many warnings that are not errors and have no
            useful relationship to the user's <em class="filename">makefile</em>. For example:</p><a id="OEBPS/ch12.html.I_7_tt510"></a><pre class="programlisting">$<strong class="userinput"><code>make --warn-undefined-variables -n</code></strong>
makefile:35: 警告: 未定义变量 MAKECMDGOALS
makefile:45: 警告: 未定义的变量 CFLAGS
makefile:45: 警告: 未定义变量 TARGET_ARCH
...
makefile:35: 警告: 未定义变量 MAKECMDGOALS
make：警告：未定义的变量 CFLAGS
make：警告：未定义变量 TARGET_ARCH
make：警告：未定义的变量 CFLAGS
make：警告：未定义变量 TARGET_ARCH
...
make：警告：未定义的变量LDFLAGS
make：警告：未定义变量 TARGET_ARCH
make：警告：未定义变量 LOADLIBES
make：警告：未定义变量 LDLIBS</pre><pre class="programlisting">$<strong class="userinput"><code>make --warn-undefined-variables -n</code></strong>
makefile:35: warning: undefined variable MAKECMDGOALS
makefile:45: warning: undefined variable CFLAGS
makefile:45: warning: undefined variable TARGET_ARCH
...
makefile:35: warning: undefined variable MAKECMDGOALS
make: warning: undefined variable CFLAGS
make: warning: undefined variable TARGET_ARCH
make: warning: undefined variable CFLAGS
make: warning: undefined variable TARGET_ARCH
...
make: warning: undefined variable LDFLAGS
make: warning: undefined variable TARGET_ARCH
make: warning: undefined variable LOADLIBES
make: warning: undefined variable LDLIBS</pre><p>尽管如此，该命令有时对于捕获此类错误非常有价值。</p><p>Nevertheless, this command can be extremely valuable on
            occasion in catching these kinds of errors.</p></div></div><div class="sect2" title="—debug 选项"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12.html.make3-CHP-12-SECT-1.2"></a>—debug 选项</h2><h2 class="title"><a></a>The —debug Option</h2></div></div></div><p>当你需要知道如何<em class="command">制作时</em> <a id="OEBPS/ch12.html.make3-CHP-12-ITERM-1591" class="indexterm"></a>分析您的依赖关系图，使用该
          <code class="option">—debug</code>选项。除了运行调试器之外，这还提供了最详细的可用信息。有五个调试选项和一个修饰符：分别为<code class="literal">basic</code>、<code class="literal">verbose</code>、<code class="literal">implicit</code>、<code class="literal">jobs</code>、<code class="literal">all</code>和<code class="literal">makefile</code>。</p><p>When you need to know how <em class="command">make</em> <a class="indexterm"></a>analyzes your dependency graph, use the
          <code class="option">—debug</code> option. This provides the most detailed
          information available other than by running a debugger. There are
          five debugging options and one modifier: <code class="literal">basic</code>, <code class="literal">verbose</code>, <code class="literal">implicit</code>, <code class="literal">jobs</code>, <code class="literal">all</code>, and <code class="literal">makefile</code>, respectively.</p><p>如果调试选项指定为
          <code class="option">—debug</code>，则使用基本调试。如果调试选项指定为<code class="option">-d</code>,<code class="literal">all</code>则使用。要选择其他选项组合，请使用逗号分隔列表<sub>1</sub> , <sub>2</sub>，其中选项可以是以下单词之一（实际上，<em class="command">make</em>
          仅查看第一个字母）：<code class="option">—debug=</code>
          <em class="replaceable"><code>option</code></em>
          <sub></sub><em class="replaceable"><code>option</code></em>
          <sub></sub><em class="command"></em></p><p>If the debugging option is specified as
          <code class="option">—debug</code>, basic debugging is used. If the debugging
          option is given as <code class="option">-d</code>, <code class="literal">all</code> is used. To select other combinations
          of options, use a comma separated list <code class="option">—debug=</code>
          <em class="replaceable"><code>option</code></em>
          <sub>1</sub>,<em class="replaceable"><code>option</code></em>
          <sub>2</sub> where the option can be one of the
          following words (actually, <em class="command">make</em>
          looks only at the first letter):</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">basic</code></span></dt><dt><span class="term"><code class="literal">basic</code></span></dt><dd><p>基本调试是最不详细的。启用后，
                 <em class="command">make 会</em>打印每个发现过期的目标以及更新操作的状态。示例输出如下所示：</p><a id="OEBPS/ch12.html.I_7_tt511"></a><pre class="programlisting">文件全部不存在。
  文件 app/player/play_mp3 不存在。
    文件 app/player/play_mp3.o 不存在。
   必须重新制作目标 app/player/play_mp3.o。
海湾合作委员会 ... ../mp3_player/app/player/play_mp3.c
   成功重制目标文件app/player/play_mp3.o。</pre></dd><dd><p>Basic debugging is the least detailed. When enabled,
                <em class="command">make</em> prints each target
                that is found to be out-of-date and the status of the update
                action. Sample output looks like:</p><a></a><pre class="programlisting">File all does not exist.
  File app/player/play_mp3 does not exist.
    File app/player/play_mp3.o does not exist.
   Must remake target app/player/play_mp3.o.
gcc ... ../mp3_player/app/player/play_mp3.c
   Successfully remade target file app/player/play_mp3.o.</pre></dd><dt><span class="term"><code class="literal">verbose</code></span></dt><dt><span class="term"><code class="literal">verbose</code></span></dt><dd><p>此选项设置<code class="literal">basic</code>选项并包含有关解析哪些文件、不需要重建的先决条件等的附加信息：</p><a id="OEBPS/ch12.html.I_7_tt512"></a><pre class="programlisting">文件全部不存在。
 考虑目标文件 app/player/play_mp3。
  文件 app/player/play_mp3 不存在。
   考虑目标文件app/player/play_mp3.o。
    文件 app/player/play_mp3.o 不存在。
     修剪文件../mp3_player/app/player/play_mp3.c。
     修剪文件../mp3_player/app/player/play_mp3.c。
     修剪文件../mp3_player/include/player/play_mp3.h。
    完成了目标文件 app/player/play_mp3.o 的先决条件。
   必须重新制作目标 app/player/play_mp3.o。
海湾合作委员会 ... ../mp3_player/app/player/play_mp3.c
   成功重制目标文件app/player/play_mp3.o。
   修剪文件 app/player/play_mp3.o。</pre></dd><dd><p>This option sets the <code class="literal">basic</code> option and includes additional
                information about which files where parsed, prerequisites that
                did not need to be rebuilt, etc.:</p><a></a><pre class="programlisting">File all does not exist.
 Considering target file app/player/play_mp3.
  File app/player/play_mp3 does not exist.
   Considering target file app/player/play_mp3.o.
    File app/player/play_mp3.o does not exist.
     Pruning file ../mp3_player/app/player/play_mp3.c.
     Pruning file ../mp3_player/app/player/play_mp3.c.
     Pruning file ../mp3_player/include/player/play_mp3.h.
    Finished prerequisites of target file app/player/play_mp3.o.
   Must remake target app/player/play_mp3.o.
gcc ... ../mp3_player/app/player/play_mp3.c
   Successfully remade target file app/player/play_mp3.o.
   Pruning file app/player/play_mp3.o.</pre></dd><dt><span class="term"><code class="literal">implicit</code></span></dt><dt><span class="term"><code class="literal">implicit</code></span></dt><dd><p>此选项设置<code class="literal">basic</code>选项并包含有关每个目标的隐式规则搜索的附加信息：</p><a id="OEBPS/ch12.html.I_7_tt513"></a><pre class="programlisting">文件全部不存在。
  文件 app/player/play_mp3 不存在。
  寻找 app/player/play_mp3 的隐式规则。
  尝试使用 Stem play_mp3 的模式规则。
  尝试隐式先决条件 app/player/play_mp3.o。
  发现 app/player/play_mp3 的隐式规则。
    文件 app/player/play_mp3.o 不存在。
    寻找 app/player/play_mp3.o 的隐式规则。
    尝试使用 Stem play_mp3 的模式规则。
    尝试隐式先决条件 app/player/play_mp3.c。
    找到先决条件 app/player/play_mp3.c 作为 VPATH ../mp3_player/app/player/play_mp3.c
    发现 app/player/play_mp3.o 的隐式规则。
   必须重新制作目标 app/player/play_mp3.o。
海湾合作委员会 ... ../mp3_player/app/player/play_mp3.c
   成功重制目标文件app/player/play_mp3.o。</pre></dd><dd><p>This option sets the <code class="literal">basic</code> option and includes additional
                information about implicit rule searches for each
                target:</p><a></a><pre class="programlisting">File all does not exist.
  File app/player/play_mp3 does not exist.
  Looking for an implicit rule for app/player/play_mp3.
  Trying pattern rule with stem play_mp3.
  Trying implicit prerequisite app/player/play_mp3.o.
  Found an implicit rule for app/player/play_mp3.
    File app/player/play_mp3.o does not exist.
    Looking for an implicit rule for app/player/play_mp3.o.
    Trying pattern rule with stem play_mp3.
    Trying implicit prerequisite app/player/play_mp3.c.
    Found prerequisite app/player/play_mp3.c as VPATH ../mp3_player/app/player/play_mp3.c
    Found an implicit rule for app/player/play_mp3.o.
   Must remake target app/player/play_mp3.o.
gcc ... ../mp3_player/app/player/play_mp3.c
   Successfully remade target file app/player/play_mp3.o.</pre></dd><dt><span class="term"><code class="literal">jobs</code></span></dt><dt><span class="term"><code class="literal">jobs</code></span></dt><dd><p><em class="command">此选项打印make</em>调用的子进程的详细信息。它不启用该<code class="literal">basic</code>选项。</p><a id="OEBPS/ch12.html.I_7_tt514"></a><pre class="programlisting">收到 SIGCHLD； 1 未收割的孩子。
海湾合作委员会 ... ../mp3_player/app/player/play_mp3.c
将子进程 0x10033800 (app/player/play_mp3.o) PID 576 放到链上。
活孩子 0x10033800 (app/player/play_mp3.o) PID 576
收到 SIGCHLD； 1 未收割的孩子。
收割获胜孩子 0x10033800 PID 576
正在从链中删除子进程 0x10033800 PID 576。</pre></dd><dd><p>This options prints the details of subprocesses invoked
                by <em class="command">make</em>. It does not enable
                the <code class="literal">basic</code> option.</p><a></a><pre class="programlisting">Got a SIGCHLD; 1 unreaped children.
gcc ... ../mp3_player/app/player/play_mp3.c
Putting child 0x10033800 (app/player/play_mp3.o) PID 576 on the chain.
Live child 0x10033800 (app/player/play_mp3.o) PID 576
Got a SIGCHLD; 1 unreaped children.
Reaping winning child 0x10033800 PID 576
Removing child 0x10033800 PID 576 from chain.</pre></dd><dt><span class="term"><code class="literal">all</code></span></dt><dt><span class="term"><code class="literal">all</code></span></dt><dd><p>这将启用之前的所有选项，并且是使用该<code class="option">-d</code>选项时的默认选项。</p></dd><dd><p>This enables all the previous options and is the default
                when using the <code class="option">-d</code> option.</p></dd><dt><span class="term"><code class="literal">makefile</code></span></dt><dt><span class="term"><code class="literal">makefile</code></span></dt><dd><p>通常，在更新 makefile<em class="filename">后</em>才会启用调试信息。这包括更新任何包含的文件，例如依赖项列表。当您使用此修饰符时，<em class="command">make将在重建</em><em class="filename">makefile</em>和包含文件时打印所选信息。该选项启用该<code class="literal">basic</code>
                选项，也由该选项启用<code class="literal">all</code>。</p></dd><dd><p>Normally, debugging information is not enabled until
                after the <em class="filename">makefile</em>s have
                been updated. This includes updating any included files, such
                as lists of dependencies. When you use this modifier, <em class="command">make</em> will print the selected
                information while rebuilding <em class="filename">makefile</em>s and include files. This
                option enables the <code class="literal">basic</code>
                option and is also enabled by the <code class="literal">all</code> option.</p></dd></dl></div></div></div></div></div></div>
<div id="OEBPS/ch12s02.html"><div>
<div class="sect1" title="编写调试代码"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch12s02.html.make3-CHP-12-SECT-2"></a>编写调试代码</h1><h1 class="title"><a></a>Writing Code for Debugging</h1></div></div></div><p>正如您所看到的，没有太多用于调试
        <em class="filename">makefile 的</em>工具，只有几种转储<em class="command">make</em>内部数据结构的方法和一些打印语句。归根结底，您需要以尽量减少错误机会或提供自己的脚手架来帮助调试错误的方式编写<em class="filename">makefile 。</em></p><p>As you can see, there aren't too many tools for debugging
        <em class="filename">makefile</em>s, just a few ways to
        dump <em class="command">make</em>'s internal data
        structures and a couple of print statements. When it comes right down
        to it, it is up to you to write your <em class="filename">makefile</em>s in ways that either minimize the
        chance of errors or provide your own scaffolding to help debug
        them.</p><p>本节中的建议在编码实践、防御性编码和调试技术方面有些随意。虽然特定项目（例如检查命令的退出状态）可以放置在良好编码实践部分或防御性编码部分中，但这三个类别反映了适当的偏见。专注于对你的<em class="filename">makefile</em>进行良好的编码，不要走太多捷径。包括大量的防御性编码，以保护<em class="filename">makefile</em>免受意外事件和环境条件的影响。最后，当错误确实出现时，使用你能找到的一切技巧来消除它们。</p><p>The suggestions in this section are laid out somewhat
        arbitrarily as coding practices, defensive coding, and debugging
        techniques. While specific items, such as checking the exit status of
        commands, could be placed in either the good coding practice section
        or the defensive coding section, the three categories reflect the
        proper bias. Focus on coding your <em class="filename">makefile</em>s well without cutting too many
        corners. Include plenty of defensive coding to protect the <em class="filename">makefile</em> against unexpected events and
        environmental conditions. Finally, when bugs do arise, use every trick
        you can find to squash them.</p><p>“保持简单”原则 ( <a class="ulink" href="http://www.catb.org/~esr/jargon/html/K/KISS-Principle.html">http://www.catb.org/~esr/jargon/html/K/KISS-Principle.html</a> ) 是所有优秀设计的核心。正如您在前面的章节中所看到的，即使对于诸如依赖项生成之类的普通任务，makefile 也会很快变得复杂<em class="filename">。</em>抵制在构建系统中包含越来越多功能的趋势。你会失败，但不会像你简单地包含你想到的每一个功能那样严重。</p><p>The "Keep It Simple" Principle (<a class="ulink" href="http://www.catb.org/~esr/jargon/html/K/KISS-Principle.html">http://www.catb.org/~esr/jargon/html/K/KISS-Principle.html</a>)
        is at the heart of all good design. As you've seen in previous
        chapters, <em class="filename">makefile</em>s can quickly
        become complex, even for mundane tasks, such as dependency generation.
        Fight the tendency to include more and more features in your build
        system. You'll fail, but not as badly as you would if you simply
        include every feature that occurs to you.</p><div class="sect2" title="良好的编码实践"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s02.html.make3-CHP-12-SECT-2.1"></a>良好的编码实践</h2><h2 class="title"><a></a>Good Coding Practices</h2></div></div></div><p>根据我的经验，大多数<a id="OEBPS/ch12s02.html.make3-CHP-12-ITERM-1592" class="indexterm"></a> <a id="OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593" class="indexterm"></a>程序员并不将编写<em class="filename">makefile</em>视为编程，因此不会像用 C++ 或 Java 编写时那样小心谨慎。但<em class="command">make</em>语言是一种完全的非过程语言。如果构建系统的可靠性和可维护性很重要，请小心编写并尽可能使用最佳编码实践。</p><p>In my experience, most <a class="indexterm"></a> <a class="indexterm"></a>programmers do not see writing <em class="filename">makefile</em>s as programming and, therefore,
          do not take the same care as they do when writing in C++ or Java.
          But the <em class="command">make</em> language is a
          complete nonprocedural language. If the reliability and
          maintainability of your build system is important, write it with
          care and use the best coding practices you can.</p><p><em class="filename">编写健壮的makefile</em>的最重要方面之一
          是检查命令的返回状态。当然，<em class="command">make</em>会自动检查简单命令，但是<em class="filename">makefile</em>通常包含可能会悄悄失败的复合命令：</p><p>One of the most important aspects of programming robust
          <em class="filename">makefile</em>s is to check the
          return status of commands. Of course, <em class="command">make</em> will check simple commands
          automatically, but <em class="filename">makefile</em>s
          often include compound commands that can fail quietly:</p><a id="OEBPS/ch12s02.html.I_7_tt515"></a><pre class="programlisting">做：
        cd 我-不存在； \
        回显*.c</pre><pre class="programlisting">do:
        cd i-dont-exist; \
        echo *.c</pre><p>运行时，此<em class="filename">makefile</em>
          不会因错误状态而终止，尽管肯定会发生错误：</p><p>When run, this <em class="filename">makefile</em>
          does not terminate with an error status, although an error most
          definitely occurs:</p><a id="OEBPS/ch12s02.html.I_7_tt516"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
cd 我-不存在； \
回显*.c
/bin/sh: 第 1 行: cd: i-dont-exist: 没有这样的文件或目录
*。C</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
cd i-dont-exist; \
echo *.c
/bin/sh: line 1: cd: i-dont-exist: No such file or directory
*.c</pre><p>此外，通配表达式无法找到任何
          <em class="filename">.c</em>文件，因此它会悄悄地返回通配表达式。哎呀。编写此命令脚本的更好方法是使用 shell 的功能来检查和防止错误：</p><p>Furthermore, the globbing expression fails to find any
          <em class="filename">.c</em> files, so it quietly returns
          the globbing expression. Oops. A better way to code this command
          script is to use the shell's features for checking and preventing
          errors:</p><a id="OEBPS/ch12s02.html.I_7_tt517"></a><pre class="programlisting">外壳=/bin/bash
做：
        cd 我不存在 &amp;&amp; \
        shopt -s nullglob &amp;&amp;\
        回显*.c</pre><pre class="programlisting">SHELL = /bin/bash
do:
        cd i-dont-exist &amp;&amp; \
        shopt -s nullglob &amp;&amp;\
        echo *.c</pre><p>现在<em class="command">cd</em>错误已正确传输到<em class="command">make</em>，
           <em class="command">echo</em>命令永远不会执行，并且
          <em class="command">make</em>以错误状态终止。此外，设置<em class="command">bash</em><code class="option">nullglob</code>选项
          会导致通配模式在未找到文件时返回空字符串。 （当然，您的特定应用程序可能更喜欢通配模式。）<em class="command"></em></p><p>Now the <em class="command">cd</em> error is
          properly transmitted to <em class="command">make</em>, the
          <em class="command">echo</em> command never executes, and
          <em class="command">make</em> terminates with an error
          status. In addition, setting the <code class="option">nullglob</code> option of
          <em class="command">bash</em> causes the globbing pattern
          to return the empty string if no files are found. (Of course, your
          particular application may prefer the globbing pattern.)</p><a id="OEBPS/ch12s02.html.I_7_tt518"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
cd 我不存在 &amp;&amp; \
回显*.c
/bin/sh: 第 1 行: cd: i-dont-exist: 没有这样的文件或目录
make: *** [do] 错误 1</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
cd i-dont-exist &amp;&amp; \
echo *.c
/bin/sh: line 1: cd: i-dont-exist: No such file or directory
make: *** [do] Error 1</pre><p>另一个好的编码实践是格式化代码以获得最大的可读性。我看到的大多数<em class="filename">makefile</em>的格式都很糟糕，因此难以阅读。您觉得哪个更容易阅读？</p><p>Another good coding practice is formatting your code for
          maximum readability. Most <em class="filename">makefile</em>s I see are poorly formatted and,
          consequently, difficult to read. Which do you find easier to
          read?</p><a id="OEBPS/ch12s02.html.I_7_tt519"></a><pre class="programlisting">_MKDIRS := $(shell for d in $(REQUIRED_DIRS); do [[ -d $$d \
]] || mkdir -p $$d;完毕）</pre><pre class="programlisting">_MKDIRS := $(shell for d in $(REQUIRED_DIRS); do [[ -d $$d \
]] || mkdir -p $$d; done)</pre><p>或者：</p><p>or:</p><a id="OEBPS/ch12s02.html.I_7_tt520"></a><pre class="programlisting">_MKDIRS := $(外壳\
             for d in $(REQUIRED_DIRS); \
             做 \
               [[ -d $$d ]] || mkdir -p $$d; \
             完毕）</pre><pre class="programlisting">_MKDIRS := $(shell                            \
             for d in $(REQUIRED_DIRS);       \
             do                               \
               [[ -d $$d ]] || mkdir -p $$d;  \
             done)</pre><p>如果您像大多数人一样，您会发现第一个更难以解析，分号更难找到，并且语句的数量更难以计数。这些都不是小事。在命令脚本中遇到的语法错误很大一部分是由于缺少分号、反斜杠或其他分隔符（例如管道符和逻辑运算符）造成的。</p><p>If you're like most people, you'll find the first more
          difficult to parse, the semicolons harder to find, and the number of
          statements more difficult to count. These are not trivial concerns.
          A significant percentage of the syntax errors you will encounter in
          command scripts will be due to missing semicolons, backslashes, or
          other separators, such as pipe and logical operators.</p><p>另请注意，并非所有丢失的分隔符都会生成错误。例如，以下错误都不会产生 shell 语法错误：</p><p>Also, note that not all missing separators will generate an
          error. For instance, neither of the following errors will produce a
          shell syntax error:</p><a id="OEBPS/ch12s02.html.I_7_tt521"></a><pre class="programlisting">标签：
        光盘源文件\
        ctags--递归

磁盘空闲：
        echo“正在检查可用磁盘空间...”\
        df 。 | awk '{ 打印 $$4 }'</pre><pre class="programlisting">TAGS:
        cd src \
        ctags --recurse

disk_free:
        echo "Checking free disk space..." \
        df . | awk '{ print $$4 }'</pre><p>格式化命令以提高可读性将使此类错误更容易捕获。当格式化用户定义函数时，缩进代码。有时，生成的宏扩展中的额外空格会导致问题。如果是这样，请将格式化包装在
          <code class="function">strip</code>函数调用中。当格式化长值列表时，将每个值分隔在自己的行上。在每个目标之前添加注释，给出简要说明，并记录参数列表。</p><p>Formatting commands for readability will make these kinds of
          errors easier to catch. When formatting user-defined functions,
          indent the code. Occasionally, the extra spaces in the resulting
          macro expansion cause problems. If so, wrap the formatting in a
          <code class="function">strip</code> function call. When
          formatting long lists of values, separate each value on its own
          line. Add a comment before each target, give a brief explanation,
          and document the parameter list.</p><p>下一个好的编码实践是自由使用变量来保存共同的值。与任何程序一样，无限制地使用文字值会导致代码重复并导致维护问题和错误。变量的另一个巨大优点是，您可以在执行期间<em class="command">显示</em>它们以进行调试。我在本章后面的<a class="link" href="#OEBPS/ch12s02.html.make3-CHP-12-SECT-2.3" title="调试技巧">12.2.3 节</a>中展示了一个很好的命令行界面。</p><p>The next good coding practice is the liberal use of variables
          to hold common values. As in any program, the unrestrained use of
          literal values creates code duplication and leads to maintenance
          problems and bugs. Another great advantage of variables is that you
          can get <em class="command">make</em> to display them for
          debugging purposes during execution. I show a nice command line
          interface in <a class="link" href="#OEBPS/ch12s02.html.make3-CHP-12-SECT-2.3" title="Debugging Techniques">Section
          12.2.3</a>, later in this chapter.</p></div><div class="sect2" title="防御性编码"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s02.html.make3-CHP-12-SECT-2.2"></a>防御性编码</h2><h2 class="title"><a></a>Defensive Coding</h2></div></div></div><p>防御性代码是可以<a id="OEBPS/ch12s02.html.make3-CHP-12-ITERM-1594" class="indexterm"></a> <a id="OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595" class="indexterm"></a>仅当您的假设或期望之一错误时才执行 -<code class="function">if</code>
          永远不正确的测试、<code class="function">assert</code>永远不会失败的函数或跟踪代码。当然，这段从不执行的代码的价值在于，偶尔（通常是在您最意想不到的时候），它确实会运行并产生警告或错误，或者您选择启用跟踪代码以允许您查看<em class="command">make</em>的内部工作原理。</p><p>Defensive code is code that can <a class="indexterm"></a> <a class="indexterm"></a>execute only if one of your assumptions or
          expectations is wrong — an <code class="function">if</code>
          test that is never true, an <code class="function">assert</code> function that never fails, or
          tracing code. Of course, the value of this code that never executes
          is that occasionally (usually when you least expect it), it does run
          and produce a warning or error, or you choose to enable tracing code
          to allow you to view the inner workings of <em class="command">make</em>.</p><p>您已经在其他上下文中看到过此代码的大部分内容，但为了方便起见，这里重复一下。</p><p>You've already seen most of this code in other contexts, but
          for convenience it is repeated here.</p><p>验证检查是防御性代码的一个很好的例子。此代码示例验证当前执行的<em class="command">make</em>版本
          是否为 3.80：</p><p>Validation checking is a great example of defensive code. This
          code sample verifies that the currently executing version of
          <em class="command">make</em> is 3.80:</p><a id="OEBPS/ch12s02.html.I_7_tt522"></a><pre class="programlisting">需要版本：= 3.80
$(如果$(过滤$(NEED_VERSION),$(MAKE_VERSION)),, \
  $(错误您必须运行 make 版本 $(NEED_VERSION)。))</pre><pre class="programlisting">NEED_VERSION := 3.80
$(if $(filter $(NEED_VERSION),$(MAKE_VERSION)),,              \
  $(error You must be running make version $(NEED_VERSION).))</pre><p>对于 Java 应用程序，在<code class="literal">CLASSPATH</code>.</p><p>For Java applications, it is useful to include a check for
          files in the <code class="literal">CLASSPATH</code>.</p><p>验证代码还可以简单地确保某些内容是真实的。上一节中的目录创建代码就是这种性质。</p><p>Validation code can also simply ensure that something is true.
          The directory creation code from the previous section is of this
          nature.</p><p>另一种很棒的防御性编码技术是使用
          <a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a><a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4" title="流量控制">4.2.4 节</a>中<code class="function">assert</code>定义的函数
          。这里有几个版本：<a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4" title="流量控制"></a><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数"></a></p><p>Another great defensive coding technique is to use the
          <code class="function">assert</code> functions defined in
          <a class="link" href="#OEBPS/ch04s02.html.make3-CHP-4-SECT-2.4" title="Flow Control">Section 4.2.4</a> in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>. Here are several
          versions:</p><a id="OEBPS/ch12s02.html.I_7_tt523"></a><pre class="programlisting"># $(调用断言,条件,消息)
定义断言
  $(如果 $1,,$(错误断言失败: $2))
恩德夫

# $(调用断言文件存在，通配符模式)
定义断言文件存在
  $(调用断言,$(通配符$1),$1不存在)
恩德夫

# $(调用断言非空，make-variable)
定义断言非空
  $(调用断言,$($1),变量“$1”为空)
恩德夫</pre><pre class="programlisting"># $(call assert,condition,message)
define assert
  $(if $1,,$(error Assertion failed: $2))
endef

# $(call assert-file-exists,wildcard-pattern)
define assert-file-exists
  $(call assert,$(wildcard $1),$1 does not exist)
endef

# $(call assert-not-null,make-variable)
define assert-not-null
  $(call assert,$($1),The variable "$1" is null)
endef</pre><p>我发现在<em class="filename">makefile</em><code class="function">assert</code>
          周围进行少量调用是检测丢失和拼写错误的参数以及违反其他假设的情况的一种廉价而有效的方法。<em class="filename"></em></p><p>I find sprinkling <code class="function">assert</code>
          calls around the <em class="filename">makefile</em> to be
          a cheap and effective way of detecting missing and misspelled
          parameters as well as violations of other assumptions.</p><p>在<a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">第 4 章</a>中，我们编写了一对函数来跟踪用户定义函数的扩展：</p><p>In <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>, we wrote a
          pair of functions to trace the expansion of user-defined
          functions:</p><a id="OEBPS/ch12s02.html.I_7_tt524"></a><pre class="programlisting"># $(调试输入)
调试输入 = $(如果 $(debug_trace),\
                $(警告输入$0($(echo-args))))

# $(调试离开)
debug-leave = $(if $(debug_trace),$(警告离开 $0))

逗号 := ,
echo-args = $(subst ' ','$(逗号) ',\
                $(foreach a,1 2 3 4 5 6 7 8 9,'$($a)'))</pre><pre class="programlisting"># $(debug-enter)
debug-enter = $(if $(debug_trace),\
                $(warning Entering $0($(echo-args))))

# $(debug-leave)
debug-leave = $(if $(debug_trace),$(warning Leaving $0))

comma := ,
echo-args   = $(subst ' ','$(comma) ',\
                $(foreach a,1 2 3 4 5 6 7 8 9,'$($a)'))</pre><p>您可以将这些宏调用添加到您自己的函数中，并使其保持禁用状态，直到需要进行调试为止。要启用它们，请设置<code class="literal">debug_trace</code>为任何非空值：</p><p>You can add these macro calls to your own functions and leave
          them disabled until they are required for debugging. To enable them,
          set <code class="literal">debug_trace</code> to any nonempty
          value:</p><a id="OEBPS/ch12s02.html.I_7_tt525"></a><pre class="programlisting">$ 使 debug_trace=1</pre><pre class="programlisting">$ make debug_trace=1</pre><p><a class="link" href="#OEBPS/ch04.html" title="第 4 章函数">正如第 4 章</a>所述，这些跟踪宏本身也有许多问题，但对于跟踪错误仍然很有用。</p><p>As noted in <a class="link" href="#OEBPS/ch04.html" title="Chapter&nbsp;4.&nbsp;Functions">Chapter 4</a>,
          these trace macros have a number of problems of their own but can
          still be useful in tracking down bugs.</p><p>最后的防御性编程技术只是<code class="literal">@</code>通过<em class="command">make</em>
          变量使用它来轻松禁用命令修饰符，而不是字面意思：</p><p>The final defensive programming technique is simply to make
          disabling the <code class="literal">@</code> command modifier
          easy by using it through a <em class="command">make</em>
          variable, rather than literally:</p><a id="OEBPS/ch12s02.html.I_7_tt526"></a><pre class="programlisting">安静:=@
...
目标：
        $（安静）<em class="replaceable"><code>some command</code></em></pre><pre class="programlisting">QUIET := @
...
target:
        $(QUIET)<em class="replaceable"><code>some command</code></em></pre><p><code class="literal">QUIET</code>使用这种技术，您可以通过在命令行上重新定义来查看静默命令的执行情况：</p><p>Using this technique, you can see the execution of the silent
          command by redefining <code class="literal">QUIET</code> on
          the command line:</p><a id="OEBPS/ch12s02.html.I_7_tt527"></a><pre class="programlisting">$ 保持安静=</pre><pre class="programlisting">$ make QUIET=</pre></div><div class="sect2" title="调试技巧"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s02.html.make3-CHP-12-SECT-2.3"></a>调试技巧</h2><h2 class="title"><a></a>Debugging Techniques</h2></div></div></div><p>本节讨论<a id="OEBPS/ch12s02.html.make3-CHP-12-ITERM-1596" class="indexterm"></a>一般调试技术和问题。最终，调试是适合您情况的任何东西的一个抓包。这些技术对我很有效，而且我已经开始依赖它们来调试最简单的<em class="filename">makefile</em>问题。也许他们也会帮助你。</p><p>This section discusses <a class="indexterm"></a>general debugging techniques and issues. Ultimately,
          debugging is a grab-bag of whatever works for your situation. These
          techniques have worked for me, and I've come to rely on them to
          debug even the simplest <em class="filename">makefile</em> problems. Maybe they'll help
          you, too.</p><p>3.80 中非常烦人的错误之一是，当<em class="command">make报告</em><em class="filename">makefile</em>中的问题并包含行号时，我通常会发现行号是错误的。我还没有调查问题是否是由于包含文件、多行变量赋值或用户定义的宏引起的，但确实如此。通常，<em class="command">生成</em>报告的行号大于实际行号。在复杂的<em class="filename">makefile</em>中，行号相差了 20 行之多。</p><p>One of the very annoying bugs in 3.80 is that when <em class="command">make</em> reports problems in <em class="filename">makefile</em>s and includes a line number, I
          usually find that the line number is wrong. I haven't investigated
          whether the problem is due to include files, multiline variable
          assignments, or user-defined macros, but there it is. Usually the
          line number <em class="command">make</em> reports is
          larger than the actual line number. In complex <em class="filename">makefile</em>s, I've had the line number be
          off by as much as 20 lines.</p><p><em class="command">通常，查看make</em>变量值的最简单方法是在目标执行期间打印它。尽管使用添加打印语句
          很简单，
          但从长远来看，<code class="function">warning</code>添加用于打印变量的通用目标的额外工作可以节省大量时间。<code class="literal">debug</code>这是一个示例<code class="literal">debug</code>
          目标：</p><p>Often the easiest way to see the value of a <em class="command">make</em> variable is to print it during the
          execution of a target. Although adding print statements using
          <code class="function">warning</code> is simple, the extra
          effort of adding a generic <code class="literal">debug</code>
          target for printing variables can save lots of time in the long run.
          Here is a sample <code class="literal">debug</code>
          target:</p><a id="OEBPS/ch12s02.html.I_7_tt528"></a><pre class="programlisting">调试：
        $(对于 v,$(V), \
          $(警告$v = $($v)))</pre><pre class="programlisting">debug:
        $(for v,$(V), \
          $(warning $v = $($v)))</pre><p>要使用它，只需设置要在命令行上打印的变量列表，并包含目标<code class="literal">debug</code>：</p><p>To use it, just set the list of variables to print on the
          command line, and include the <code class="literal">debug</code> target:</p><a id="OEBPS/ch12s02.html.I_7_tt529"></a><pre class="programlisting">$ make V="USERNAME SHELL" 调试
makefile:2: 用户名 = 所有者
makefile:2: SHELL = /bin/sh.exe
make：调试是最新的。</pre><pre class="programlisting">$ make V="USERNAME SHELL" debug
makefile:2: USERNAME = Owner
makefile:2: SHELL = /bin/sh.exe
make: debug is up to date.</pre><p>如果你想变得非常棘手，你可以使用变量<code class="literal">MAKECMDGOALS</code>来避免给变量赋值<code class="literal">V</code>：</p><p>If you want to get really tricky, you can use the <code class="literal">MAKECMDGOALS</code> variable to avoid the
          assignment to the variable <code class="literal">V</code>:</p><a id="OEBPS/ch12s02.html.I_7_tt530"></a><pre class="programlisting">调试：
        $(对于 v,$(V) $(MAKECMDGOALS), \
          $(如果$(过滤器调试,$v),,$(警告$v = $($v))))</pre><pre class="programlisting">debug:
        $(for v,$(V) $(MAKECMDGOALS), \
          $(if $(filter debug,$v),,$(warning $v = $($v))))</pre><p>现在，您只需在命令行上列出变量即可打印变量。不过，我不推荐这种技术，因为您还会收到令人困惑的<em class="command">make</em>
          警告，表明它不知道如何更新变量（因为它们被列为目标）：</p><p>Now you can print variables by simply listing them on the
          command line. I don't recommend this technique, though, because
          you'll also get confusing <em class="command">make</em>
          warnings indicating it doesn't know how to update the variables
          (since they are listed as targets):</p><a id="OEBPS/ch12s02.html.I_7_tt531"></a><pre class="programlisting">$<strong class="userinput"><code>make debug USERNAME SHELL</code></strong>
makefile:2: 用户名 = 所有者
makefile:2: SHELL = /bin/sh.exe
make：调试是最新的。
make: *** 没有规则可以创建目标用户名。停止。</pre><pre class="programlisting">$<strong class="userinput"><code>make debug USERNAME SHELL</code></strong>
makefile:2: USERNAME = Owner
makefile:2: SHELL = /bin/sh.exe
make: debug is up to date.
make: *** No rule to make target USERNAME.  Stop.</pre><p>在<a class="link" href="#OEBPS/ch10.html" title="第 10 章提高 make 的性能">第 10 章中，我简要提到了使用调试 shell 来帮助理解</a><em class="command">make</em>在幕后执行的一些活动。虽然<em class="command">make</em><code class="function">shell</code>在执行命令脚本中的命令之前对其进行回显，但它不会回显在函数中执行的命令。通常，这些命令是微妙且复杂的，特别是因为它们可能会立即执行或以延迟的方式执行（如果它们出现在递归变量赋值中）。查看这些命令执行的一种方法是请求子 shell 启用调试打印：</p><p>In <a class="link" href="#OEBPS/ch10.html" title="Chapter&nbsp;10.&nbsp;Improving the Performance of make">Chapter 10</a>, I briefly
          mentioned using a debugging shell to help understand some of the
          activities <em class="command">make</em> performs behind
          the scenes. While <em class="command">make</em> echos
          commands in command scripts before they are executed, it does not
          echo the commands executed in <code class="function">shell</code> functions. Often these commands are
          subtle and complex, particularly since they may be executed
          immediately or in a deferred fashion, if they occur in a recursive
          variable assignment. One way to see these commands execute is to
          request that the subshell enable debug printing:</p><a id="OEBPS/ch12s02.html.I_7_tt532"></a><pre class="programlisting">日期 := $(外壳日期 +%F)
OUTPUT_DIR = 输出-$(日期)

make-directories := $(shell [ -d $(OUTPUT_DIR) ] || mkdir -p $(OUTPUT_DIR))

全部： ;</pre><pre class="programlisting">DATE := $(shell date +%F)
OUTPUT_DIR = out-$(DATE)

make-directories := $(shell [ -d $(OUTPUT_DIR) ] || mkdir -p $(OUTPUT_DIR))

all: ;</pre><p><em class="command">当使用sh</em>的调试选项运行时，我们看到：</p><p>When run with <em class="command">sh</em>'s
          debugging option, we see:</p><a id="OEBPS/ch12s02.html.I_7_tt533"></a><pre class="programlisting">$ 使 SHELL="sh -x"
+ 日期 +%F
+ '[' -d out-2004-05-11 ']'
+ mkdir -p 输出-2004-05-11</pre><pre class="programlisting">$ make SHELL="sh -x"
+ date +%F
+ '[' -d out-2004-05-11 ']'
+ mkdir -p out-2004-05-11</pre><p>这甚至提供了
          <em class="command">make</em> <code class="function">warning</code>语句之外的附加调试信息，因为使用此选项，shell 还显示变量和表达式的值。</p><p>This even provides additional debugging information beyond
          <em class="command">make</em> <code class="function">warning</code> statements, since with this
          option the shell also displays the value of variables and
          expressions.</p><p><code class="literal">PATH</code>本书中的许多示例都是用深层嵌套表达式编写的，例如检查Windows/Cygwin 系统上的变量的示例：</p><p>Many of the examples in this book are written as deeply nested
          expressions, such as this one that checks the <code class="literal">PATH</code> variable on a Windows/Cygwin
          system:</p><a id="OEBPS/ch12s02.html.I_7_tt534"></a><pre class="programlisting">$(如果 $(findstring /bin/, \
       $(第一个单词\
         $(通配符\
           $(addsuffix /sort$(if $(COMSPEC),.exe), \
             $(subst :, ,$(PATH)))))),, \
  $(error 你的路径错误，c:/usr/cygwin/bin 应该 \
    位于 c:/WINDOWS/system32)) 之前</pre><pre class="programlisting">$(if $(findstring /bin/,                               \
       $(firstword                                     \
         $(wildcard                                    \
           $(addsuffix /sort$(if $(COMSPEC),.exe),     \
             $(subst :, ,$(PATH)))))),,                \
  $(error Your PATH is wrong, c:/usr/cygwin/bin should \
    precede c:/WINDOWS/system32))</pre><p>没有好的方法来调试这些表达式。一种合理的方法是展开它们，并打印每个子表达式：</p><p>There is no good way to debug these expressions. One
          reasonable approach is to unroll them, and print each
          subexpression:</p><a id="OEBPS/ch12s02.html.I_7_tt535"></a><pre class="programlisting">$(警告$(subst :, ,$(PATH)))
$(警告/排序$(如果$(COMSPEC),.exe))
$(警告$(addsuffix /sort$(if $(COMSPEC),.exe), \
             $(替换:,,$(路径))))
$(警告$(通配符\
            $(addsuffix /sort$(if $(COMSPEC),.exe), \
              $(替换:,,$(路径)))))</pre><pre class="programlisting">$(warning $(subst :, ,$(PATH)))
$(warning /sort$(if $(COMSPEC),.exe))
$(warning $(addsuffix /sort$(if $(COMSPEC),.exe),     \
             $(subst :, ,$(PATH))))
$(warning $(wildcard                                   \
            $(addsuffix /sort$(if $(COMSPEC),.exe),    \
              $(subst :, ,$(PATH)))))</pre><p>虽然有点乏味，但没有真正的调试器，这是确定各种子表达式的值的最佳方法（有时是唯一的方法）。</p><p>Although a bit tedious, without a real debugger, this is the
          best way (and sometimes the only way) to determine the value of
          various subexpressions.</p></div></div></div></div>
<div id="OEBPS/ch12s03.html"><div>
<div class="sect1" title="常见错误消息"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3"></a>常见错误消息</h1><h1 class="title"><a></a>Common Error Messages</h1></div></div></div><p>3.81 <acronym class="acronym">GNU </acronym> <em class="command">make</em>手册<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1597" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1598" class="indexterm"></a>包括一个很好的部分，列出了<em class="command">make</em>错误消息及其原因。我们在这里回顾一些最常见的。所描述的一些问题并不是严格意义上的<em class="command">make</em>
        错误，例如命令脚本中的语法错误，但对于开发人员来说仍然是常见问题。有关<em class="command">make</em>错误的完整列表，请参阅<em class="command">make</em>手册。</p><p>The 3.81 <acronym class="acronym">GNU</acronym> <em class="command">make</em> manual <a class="indexterm"></a> <a class="indexterm"></a>includes an excellent section listing <em class="command">make</em> error messages and their causes. We
        review a few of the most common ones here. Some of the issues
        described are not strictly <em class="command">make</em>
        errors, such as syntax errors in command scripts, but are nonetheless
        common problems for developers. For a complete list of <em class="command">make</em> errors, see the <em class="command">make</em> manual.</p><p><em class="command">make</em>打印的错误消息具有标准格式：</p><p>Error messages printed by <em class="command">make</em> have a standard format:</p><a id="OEBPS/ch12s03.html.I_7_tt536"></a><pre class="programlisting"><em class="replaceable"><code>makefile</code></em>: <em class="replaceable"><code>n</code></em>: *** <em class="replaceable"><code>message</code></em>。停止。</pre><pre class="programlisting"><em class="replaceable"><code>makefile</code></em>:<em class="replaceable"><code>n</code></em>: *** <em class="replaceable"><code>message</code></em>. Stop.</pre><p>或者：</p><p>or:</p><a id="OEBPS/ch12s03.html.I_7_tt537"></a><pre class="programlisting">制作：<em class="replaceable"><code>n</code></em>： *** <em class="replaceable"><code>message</code></em>。停止。</pre><pre class="programlisting">make:<em class="replaceable"><code>n</code></em>: *** <em class="replaceable"><code>message</code></em>. Stop.</pre><p>该部分是发生错误的<em class="filename">makefile</em><em class="replaceable"><code>makefile</code></em>或 include 文件的名称
        。下一部分是发生错误的行号，后跟三个星号，最后是错误消息。<em class="filename"></em></p><p>The <em class="replaceable"><code>makefile</code></em> part is the name of the
        <em class="filename">makefile</em> or include file in which
        the error occurred. The next part is the line number where the error
        occurred, followed by three asterisks and, finally, the error
        message.</p><p>请注意，运行其他程序是<em class="command">make的工作，如果发生错误， </em><em class="filename">makefile</em>中的问题很可能会在这些其他程序中表现为错误。例如，shell 错误可能是由格式错误的命令脚本引起的，或者是由不正确的命令行参数引起的编译器错误。找出哪个程序产生了错误消息是解决问题的首要任务。幸运的是，<em class="command">make</em>的错误消息是相当不言而喻的。</p><p>Note that it is <em class="command">make</em>'s job to
        run other programs and that, if errors occur, it is very likely that
        problems in your <em class="filename">makefile</em> will
        manifest themselves as errors in these other programs. For instance,
        shell errors may result from badly formed command scripts, or compiler
        errors from incorrect command-line arguments. Figuring out what
        program produced the error message is your first task in solving the
        problem. Fortunately, <em class="command">make</em>'s error
        messages are fairly self-evident.</p><div class="sect2" title="语法错误"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.1"></a>语法错误</h2><h2 class="title"><a></a>Syntax Errors</h2></div></div></div><p>这些通常是<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1599" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1600" class="indexterm"></a>印刷错误：缺少括号、使用空格而不是制表符等。</p><p>These are usually <a class="indexterm"></a> <a class="indexterm"></a>typographical errors: missing parentheses, using
          spaces instead of tabs, etc.</p><p><em class="command">对于新的make</em>用户来说，最常见的错误之一是省略变量名称周围的括号：</p><p>One of the most common errors for new <em class="command">make</em> users is omitting parentheses around
          variable names:</p><a id="OEBPS/ch12s03.html.I_7_tt538"></a><pre class="programlisting">富：
        对于 $SOURCES 中的 f； \
        做 \
           ... \
        完毕</pre><pre class="programlisting">foo:
        for f in $SOURCES; \
        do                 \
           ...               \
        done</pre><p>这可能会导致<em class="command">make</em>扩展<code class="literal">$S</code>为空，并且 shell 仅执行一次循环，且<code class="literal">f</code>值为<code class="literal">OURCES</code>。根据您的操作<code class="literal">f</code>，您可能会收到一条不错的 shell 错误消息，例如：</p><p>This will likely result in <em class="command">make</em> expanding <code class="literal">$S</code> to nothing, and the shell executing the
          loop only once with <code class="literal">f</code> having a
          value of <code class="literal">OURCES</code>. Depending on
          what you do with <code class="literal">f</code>, you may get a
          nice shell error message like:</p><a id="OEBPS/ch12s03.html.I_7_tt539"></a><pre class="programlisting">来源：没有这样的文件或目录</pre><pre class="programlisting">OURCES: No such file or directory</pre><p>但您也可能很容易根本收不到任何消息。请记住用括号将<em class="command">make变量括起来。</em></p><p>but you might just as easily get no message at all. Remember
          to surround your <em class="command">make</em> variables
          with parentheses.</p><div class="sect3" title="缺少分隔符"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.1.1"></a>缺少分隔符</h3><h3 class="title"><a></a>missing separator</h3></div></div></div><p>这<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1601" class="indexterm"></a>信息：</p><p>The <a class="indexterm"></a>message:</p><a id="OEBPS/ch12s03.html.I_7_tt540"></a><pre class="programlisting">makefile:2:缺少分隔符。停止。</pre><pre class="programlisting">makefile:2:missing separator. Stop.</pre><p>或者：</p><p>or:</p><a id="OEBPS/ch12s03.html.I_7_tt541"></a><pre class="programlisting">makefile:2:缺少分隔符（您的意思是 TAB 而不是 8 个空格？）。停止。</pre><pre class="programlisting">makefile:2:missing separator (did you mean TAB instead of 8 spaces?).  Stop.</pre><p>通常意味着您有一个使用空格而不是制表符的命令脚本。</p><p>usually means you have a command script that is using spaces
            instead of tabs.</p><p>更字面的解释是<em class="command">make</em>正在寻找<em class="command">make</em>分隔符，例如 :、<code class="literal">=</code>或制表符，但没有找到。相反，它发现了一些它不理解的东西。</p><p>The more literal interpretation is that <em class="command">make</em> was looking for a <em class="command">make</em> separator such as :, <code class="literal">=</code>, or a tab, and didn't find one.
            Instead, it found something it didn't understand.</p></div><div class="sect3" title="命令在第一个目标之前开始"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.1.2"></a>命令在第一个目标之前开始</h3><h3 class="title"><a></a>commands commence before first target</h3></div></div></div><p>制表符敲击<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1602" class="indexterm"></a>再次！</p><p>The tab character strikes <a class="indexterm"></a>again!</p><p>该错误消息首先在<a class="link" href="#OEBPS/ch05.html" title="第 5 章命令">第 5 章的</a><a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1" title="解析命令">5.1 节</a>中介绍。当命令脚本外部的行以制表符开头时，此错误似乎最常出现在<em class="filename">makefile</em>的中间。 <em class="command">make</em>会尽力消除这种情况的歧义，但如果该行无法识别为变量赋值、条件表达式或多行宏定义，
             <em class="command">make</em>会认为它是一个放错位置的命令。<a class="link" href="#OEBPS/ch05.html" title="第 5 章命令"></a><em class="filename"></em><em class="command"></em><em class="command"></em></p><p>This error message was first covered in <a class="link" href="#OEBPS/ch05.html.make3-CHP-5-SECT-1" title="Parsing Commands">Section 5.1</a> in <a class="link" href="#OEBPS/ch05.html" title="Chapter&nbsp;5.&nbsp;Commands">Chapter 5</a>. This error seems to appear
            most often in the middle of <em class="filename">makefile</em>s when a line outside of a
            command script begins with a tab character. <em class="command">make</em> does its best to disambiguate this
            situation, but if the line cannot be identified as a variable
            assignment, conditional expression, or multiline macro definition,
            <em class="command">make</em> considers it a misplaced
            command.</p></div><div class="sect3" title="未终止的变量引用"><div class="titlepage"><div><div><h3 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.1.3"></a>未终止的变量引用</h3><h3 class="title"><a></a>unterminated variable reference</h3></div></div></div><p>这是一个简单但<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603" class="indexterm"></a>常见错误。这意味着您未能使用正确数量的括号关闭变量引用或函数调用。通过深度嵌套的函数调用和变量引用，<em class="command">make</em>文件可以开始看起来像 Lisp！一个能够进行括号匹配的优秀编辑器（例如 Emacs）是避免此类错误的最可靠方法。</p><p>This is a simple but <a class="indexterm"></a>common error. It means you failed to close a
            variable reference or function call with the proper number of
            parentheses. With deeply nested function calls and variable
            references, <em class="command">make</em> files can
            begin to look like Lisp! A good editor that does parenthesis
            matching, such as Emacs, is the surest way to avoid these types of
            errors.</p></div></div><div class="sect2" title="命令脚本中的错误"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.2"></a>命令脚本中的错误</h2><h2 class="title"><a></a>Errors in Command Scripts</h2></div></div></div><p>常见的有以下三种类型<a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1604" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1605" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1606" class="indexterm"></a>命令脚本中的错误：多行命令中缺少分号、路径变量不完整或不正确，或者命令在运行时遇到问题。</p><p>There are three common types of <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>errors in command scripts: a missing semicolon in
          multiline commands, an incomplete or incorrect path variable, or a
          command that simply encounters a problem when run.</p><p>我们在<a class="link" href="#OEBPS/ch12s02.html.make3-CHP-12-SECT-2.1" title="良好的编码实践">第 12.2.1 节</a>中讨论了缺少分号的问题，因此这里不再详细说明。</p><p>We discussed missing semicolons in <a class="link" href="#OEBPS/ch12s02.html.make3-CHP-12-SECT-2.1" title="Good Coding Practices">Section 12.2.1</a>, so we won't
          elaborate further here.</p><p>经典的错误信息：</p><p>The classic error message:</p><a id="OEBPS/ch12s03.html.I_7_tt542"></a><pre class="programlisting">bash: foo: 未找到命令</pre><pre class="programlisting">bash: foo: command not found</pre><p>当 shell 找不到命令<em class="command">foo</em>时显示。也就是说，shell 已在<code class="literal">PATH</code>变量中的每个目录中搜索可执行文件，但没有找到匹配项。要更正此错误，您必须更新<code class="literal">PATH</code>变量，通常在<em class="filename">.profile</em> 
          (Bourne shell)、. <em class="filename">bashrc</em> (bash) 或<em class="filename">.cshrc</em> (C shell) 中。当然，也可以<code class="literal">PATH</code>在<em class="filename">makefile</em>本身中设置变量，然后<code class="literal">PATH</code>从<em class="command">make</em>导出该变量。</p><p>is displayed when the shell cannot find the command <em class="command">foo</em>. That is, the shell has searched each
          directory in the <code class="literal">PATH</code> variable
          for the executable and found no match. To correct this error, you
          must update your <code class="literal">PATH</code> variable,
          usually in your <em class="filename">.profile</em>
          (Bourne shell), <em class="filename">.bashrc</em> (bash),
          or <em class="filename">.cshrc</em> (C shell). Of course,
          it is also possible to set the <code class="literal">PATH</code> variable in the <em class="filename">makefile</em> itself, and export the <code class="literal">PATH</code> variable from <em class="command">make</em>.</p><p>最后，当 shell 命令失败时，它会以非零退出状态终止。在这种情况下，<em class="command">make 会</em>报告失败并显示以下消息：</p><p>Finally, when a shell command fails, it terminates with a
          nonzero exit status. In this case, <em class="command">make</em> reports the failure with the
          message:</p><a id="OEBPS/ch12s03.html.I_7_tt543"></a><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
触摸/foo/bar
touch：创建/foo/bar：没有这样的文件或目录
make: *** [全部] 错误 1</pre><pre class="programlisting">$<strong class="userinput"><code>make</code></strong>
touch /foo/bar
touch: creating /foo/bar: No such file or directory
make: *** [all] Error 1</pre><p>这里失败的命令是<em class="command">touch</em>，它打印自己的错误消息来解释失败。下一行是<em class="command">make</em>的错误摘要。失败的
          <em class="filename">makefile</em>目标显示在方括号中，后跟失败程序的退出值。有时，如果程序由于信号而退出，那么<em class="command">make会打印更详细的消息，而不是简单地打印非零退出状态。</em></p><p>Here the failing command is <em class="command">touch</em>, which prints its own error message
          explaining the failure. The next line is <em class="command">make</em>'s summary of the error. The failing
          <em class="filename">makefile</em> target is shown in
          square brackets followed by the exit value of the failing program.
          Sometimes <em class="command">make</em> will print a more
          verbose message if the program exits due to a signal, rather than
          simply a nonzero exit status.</p><p>另请注意，使用修饰符静默执行的命令<code class="literal">@</code>也可能会失败。在这些情况下，所显示的错误消息可能不知从何而来。</p><p>Note also that commands executed silently with the <code class="literal">@</code> modifier can also fail. In these cases,
          the error message presented may appear as if from nowhere.</p><p>在这两种情况下，错误都源于正在运行的程序<em class="command">make</em>，而不是<em class="command">make</em>本身。</p><p>In either of these cases, the error originates with the
          program <em class="command">make</em> is running, rather
          than <em class="command">make</em> itself.</p></div><div class="sect2" title="没有规则可以制定目标"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.3"></a>没有规则可以制定目标</h2><h2 class="title"><a></a>No Rule to Make Target</h2></div></div></div><p>该消息有两种形式：</p><p>This message has two forms:</p><a id="OEBPS/ch12s03.html.I_7_tt544"></a><pre class="programlisting">make: *** 没有规则可以创建目标 XXX。停止。</pre><pre class="programlisting">make: *** No rule to make target XXX. Stop.</pre><p>和：</p><p>and:</p><a id="OEBPS/ch12s03.html.I_7_tt545"></a><pre class="programlisting">make: *** 没有规则可以创建 YYY 需要的目标 XXX。停止。</pre><pre class="programlisting">make: *** No rule to make target XXX, needed by YYY. Stop.</pre><p>这意味着<em class="command">make</em>决定需要更新文件<em class="filename">XXX ，但</em><em class="command">make</em>找不到任何规则来执行该作业。<em class="command">make</em>
          将在放弃并打印消息之前搜索其数据库中的所有隐式和显式规则。</p><p>It means that <em class="command">make</em> decided
          the file <em class="filename">XXX</em> needed to be
          updated, but <em class="command">make</em> could not find
          any rule to perform the job. <em class="command">make</em>
          will search all the implicit and explicit rules in its database
          before giving up and printing the message.</p><p>导致此错误的可能原因有以下三种：</p><p>There are three possible reasons for this error:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>您的<em class="filename">makefile</em>缺少更新文件所需的规则。在这种情况下，您必须添加描述如何构建目标的规则。</p></li><li class="listitem"><p>Your <em class="filename">makefile</em> is
              missing a rule required to update the file. In this case, you
              will have to add the rule describing how to build the
              target.</p></li><li class="listitem"><p><em class="filename">makefile</em>中有一个拼写错误。要么<em class="command">make</em>正在查找错误的文件，要么更新文件的规则指定了错误的文件。由于使用了<em class="command">make</em>变量，因此很难在<em class="filename">makefile</em>中找到拼写错误。有时，真正确定复杂文件名的值的唯一方法是通过直接打印变量或检查
              <em class="command">make</em>的内部数据库来打印它。<em class="command"></em><em class="command"></em></p></li><li class="listitem"><p>There is a typo in the <em class="filename">makefile</em>. Either <em class="command">make</em> is looking for the wrong file or
              the rule to update the file specifies the wrong file. Typos can
              be hard to find in <em class="filename">makefile</em>s due to the use of <em class="command">make</em> variables. Sometimes the only way
              to really be sure of the value of a complex filename is to print
              it out either by printing the variable directly or examining
              <em class="command">make</em>'s internal
              database.</p></li><li class="listitem"><p>该文件应该存在，但<em class="command">make</em>也找不到它，因为它丢失了或者因为<em class="command">make</em>
              不知道在哪里查找。当然，有时<em class="command">make</em>是绝对正确的。文件丢失 — 也许您忘记从 CVS 中检出它。更常见的是，<em class="command">make</em>根本找不到该文件，因为源代码被放置在其他地方。有时源位于单独的源树中，或者文件可能是由另一个程序生成的并且生成的文件位于二进制树中。</p></li><li class="listitem"><p>The file should exist but <em class="command">make</em> cannot find it either, because it
              is missing or because <em class="command">make</em>
              doesn't know where to look. Of course, sometimes <em class="command">make</em> is absolutely correct. The file
              is missing—perhaps you forgot to check it out of CVS. More
              often, <em class="command">make</em> simply can't find
              the file, because the source is placed somewhere else. Sometimes
              the source is in a separate source tree, or maybe the file is
              generated by another program and the generated file is in the
              binary tree.</p></li></ul></div></div><div class="sect2" title="覆盖目标命令"><div class="titlepage"><div><div><h2 class="title"><a id="OEBPS/ch12s03.html.make3-CHP-12-SECT-3.4"></a>覆盖目标命令</h2><h2 class="title"><a></a>Overriding Commands for Target</h2></div></div></div><p><em class="command">make</em>只允许一个
          <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608" class="indexterm"></a> <a id="OEBPS/ch12s03.html.make3-CHP-12-ITERM-1609" class="indexterm"></a>目标的命令脚本（双冒号规则除外，很少使用）。如果给一个目标多个命令脚本，<em class="command">make</em>会打印警告：</p><p><em class="command">make</em> allows only one
          <a class="indexterm"></a> <a class="indexterm"></a> <a class="indexterm"></a>command script for a target (except for double-colon
          rules, which are rarely used). If a target is given more than one
          command script, <em class="command">make</em> prints the
          warning:</p><a id="OEBPS/ch12s03.html.I_7_tt546"></a><pre class="programlisting">makefile:5: 警告: 覆盖目标 foo 的命令</pre><pre class="programlisting">makefile:5: warning: overriding commands for target foo</pre><p>它还可能显示警告：</p><p>It may also display the warning:</p><a id="OEBPS/ch12s03.html.I_7_tt547"></a><pre class="programlisting">makefile:2: 警告：忽略目标 foo 的旧命令</pre><pre class="programlisting">makefile:2: warning: ignoring old commands for target foo</pre><p>第一个警告指示找到第二个命令脚本的行，而第二个警告指示被覆盖的原始命令脚本的位置。</p><p>The first warning indicates the line at which the second
          command script is found, while the second warning indicates the
          location of the original command script that is being
          overridden.</p><p>在复杂的<em class="filename">makefile</em>中，目标通常会被多次指定，每个目标都会添加自己的先决条件。其中一个目标通常包含一个命令脚本，但在开发或调试过程中，很容易添加另一个命令脚本，而没有意识到您实际上正在覆盖一组现有的命令。</p><p>In complex <em class="filename">makefile</em>s,
          targets are often specified many times, each adding its own
          prerequisites. One of these targets usually includes a command
          script, but during development or debugging it is easy to add
          another command script without realizing you are actually overriding
          an existing set of commands.</p><p>例如，我们可以在包含文件中定义通用目标：</p><p>For example, we might define a generic target in an include
          file:</p><a id="OEBPS/ch12s03.html.I_7_tt548"></a><pre class="programlisting"># 创建一个 jar 文件。
$(jar_file):
        $(JAR) $(JARFLAGS) -f $@ $^</pre><pre class="programlisting"># Create a jar file.
$(jar_file):
        $(JAR) $(JARFLAGS) -f $@ $^</pre><p>并允许多个单独的<em class="filename">makefile</em>添加自己的先决条件。然后在<em class="filename">makefile</em>中我们可以这样写：</p><p>and allow several separate <em class="filename">makefile</em>s to add their own prerequisites.
          Then in a <em class="filename">makefile</em> we could
          write:</p><a id="OEBPS/ch12s03.html.I_7_tt549"></a><pre class="programlisting"># 设置创建 jar 的目标并添加先决条件
jar_file = 解析器.jar
$(jar_file): $(class_files)</pre><pre class="programlisting"># Set the target for creating the jar and add prerequisites
jar_file = parser.jar
$(jar_file): $(class_files)</pre><p>如果我们无意中将命令脚本添加到此
          <em class="filename">makefile</em>文本中，<em class="command">make</em>将产生最重要的警告。</p><p>If we were to inadvertently add a command script to this
          <em class="filename">makefile</em> text, <em class="command">make</em> would produce the overriding
          warning.</p></div></div></div></div>
<div id="OEBPS/pt03.html"><div>
<div class="part" title="第三部分。附录"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/pt03.html.make3-PART-3"></a>第三部分。附录</h1><h1 class="title"><a></a>Part&nbsp;III.&nbsp;Appendixes</h1></div></div></div><div class="partintro" title="附录" id="OEBPS/pt03.html.id3177073"><div></div><p>本书的最后一部分包含的信息与本书的目标无关，但您可能会发现它对于异常情况很有用。<a class="link" href="#OEBPS/apa.html" title="附录 A. 运行 make">附录 A</a><code class="literal">make</code>列出了 GNU命令在命令行上接受的选项。您会发现
      <a class="link" href="#OEBPS/apb.html" title="附录 B. 外部限制">附录 B</a><code class="literal">make</code>很有趣，而且可能很有用，它可以充当具有数据结构和算术运算的通用编程语言。
      <a class="link" href="#OEBPS/apc.html" title="附录 C. GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)">附录 C</a>包含本书的免费许可证。</p><p>The final section of this book contains information that is not
      central to the goals ofthe book, but you might find it useful for
      unusual situations. <a class="link" href="#OEBPS/apa.html" title="Appendix&nbsp;A.&nbsp;Running make">Appendix A</a> lists
      the options that the GNU <code class="literal">make</code> command
      accepts on the command line. <a class="link" href="#OEBPS/apb.html" title="Appendix&nbsp;B.&nbsp;The Outer Limits">Appendix
      B</a>, which you will find amusing and possibly useful, stretches
      <code class="literal">make</code> to act as a general-purpose
      programming language with data structures and arithmetic operations.
      <a class="link" href="#OEBPS/apc.html" title="Appendix&nbsp;C.&nbsp;GNU Free Documentation License—GNU Project—Free Software Foundation (FSF)">Appendix C</a> contains the free license
      for the book.</p><p><a class="link" href="#OEBPS/apa.html" title="附录 A. 运行 make">附录 A</a>，运行 make Makefile</p><p><a class="link" href="#OEBPS/apa.html" title="Appendix&nbsp;A.&nbsp;Running make">Appendix A</a>, Running make
      Makefile</p><p><a class="link" href="#OEBPS/apb.html" title="附录 B. 外部限制">附录B</a>，外部限制</p><p><a class="link" href="#OEBPS/apb.html" title="Appendix&nbsp;B.&nbsp;The Outer Limits">Appendix B</a>, The Outer
      Limits</p><p><a class="link" href="#OEBPS/apc.html" title="附录 C. GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)">附录 C</a>，GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)</p><p><a class="link" href="#OEBPS/apc.html" title="Appendix&nbsp;C.&nbsp;GNU Free Documentation License—GNU Project—Free Software Foundation (FSF)">Appendix C</a>, GNU Free
      Documentation License—GNU Project—Free Software Foundation (FSF)</p></div></div></div></div>
<div id="OEBPS/apa.html"><div>
<div class="appendix" title="附录 A. 运行 make"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apa.html.make3-APP-A"></a>附录 A. 运行 make</h1><h1 class="title"><a></a>Appendix&nbsp;A.&nbsp;Running make</h1></div></div></div><p><acronym class="acronym">GNU </acronym> <em class="command">make</em>有一组令人印象深刻的命令行选项。大多数命令行选项包括短形式和长形式。短命令用单破折号后跟单个字符表示，而长选项以双破折号开头，通常后跟由破折号分隔的整个单词。这些命令的语法是：</p><p><acronym class="acronym">GNU</acronym> <em class="command">make</em> has
      an impressive set of command-line options. Most command-line options
      include a short form and a long form. Short commands are indicated with
      a single dash followed by a single character, while long options begin
      with a double dash usually followed by whole words separated by dashes.
      The syntax of these commands is:</p><a id="OEBPS/apa.html.I__tt550"></a><pre class="programlisting">-o <em class="replaceable"><code>argument</code></em>
--选项字=<em class="replaceable"><code>argument</code></em></pre><pre class="programlisting">-o<em class="replaceable"><code>argument</code></em>
--option-word=<em class="replaceable"><code>argument</code></em></pre><p>以下是最常用的<em class="command">make</em>选项。有关完整列表，请参阅
      <acronym class="acronym">GNU </acronym> <em class="command">make</em>手册或输入<code class="literal">make --help</code>。</p><p>The following are the most commonly used options to <em class="command">make</em>. For a complete listing, see the
      <acronym class="acronym">GNU</acronym> <em class="command">make</em> manual or
      type <code class="literal">make --help</code>.</p><div class="variablelist"><dl><dt><span class="term"><code class="option">—always-make</code></span></dt><dt><span class="term"><code class="option">—always-make</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-B</code></span></dt><dt><span class="term"><code class="option">-B</code></span></dt><dd><p>假设所有目标都已完成<a id="OEBPS/apa.html.make3-APP-A-ITERM-1610" class="indexterm"></a>日期并全部更新。</p></dd><dd><p>Assume every target is out <a class="indexterm"></a>of date and update them all.</p></dd><dt><span class="term"><code class="option">—directory=</code>
          <em class="replaceable"><code>directory</code></em></span></dt><dt><span class="term"><code class="option">—directory=</code>
          <em class="replaceable"><code>directory</code></em></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-C </code>
          <em class="replaceable"><code>directory</code></em></span></dt><dt><span class="term"><code class="option">-C </code>
          <em class="replaceable"><code>directory</code></em></span></dt><dd><p>更改为给定的<a id="OEBPS/apa.html.make3-APP-A-ITERM-1611" class="indexterm"></a>搜索<em class="filename">makefile</em>或执行任何工作之前的目录。这也将变量设置<code class="literal">CURDIR</code>
            为<em class="replaceable"><code>directory</code></em>。</p></dd><dd><p>Change to the given <a class="indexterm"></a>directory before searching for a <em class="filename">makefile</em> or performing any work. This
            also sets the variable <code class="literal">CURDIR</code>
            to <em class="replaceable"><code>directory</code></em>.</p></dd><dt><span class="term"><code class="option">—environment-overrides</code></span></dt><dt><span class="term"><code class="option">—environment-overrides</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-e</code></span></dt><dt><span class="term"><code class="option">-e</code></span></dt><dd><p>喜欢环境<a id="OEBPS/apa.html.make3-APP-A-ITERM-1612" class="indexterm"></a>当有选择时，变量到<em class="filename">makefile</em>变量。对于特定变量，可以使用该指令在<em class="filename">makefile</em>中覆盖此命令行选项
            <code class="function">override</code>
            。</p></dd><dd><p>Prefer environment <a class="indexterm"></a>variables to <em class="filename">makefile</em> variables when there is a
            choice. This command-line option can be overridden in the
            <em class="filename">makefile</em> for particular
            variables with the <code class="function">override</code>
            directive.</p></dd><dt><span class="term"><code class="option">—file=</code>
          <em class="replaceable"><code>makefile</code></em></span></dt><dt><span class="term"><code class="option">—file=</code>
          <em class="replaceable"><code>makefile</code></em></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-f </code>
          <em class="replaceable"><code>makefile</code></em></span></dt><dt><span class="term"><code class="option">-f </code>
          <em class="replaceable"><code>makefile</code></em></span></dt><dd><p>读取给定的文件<a id="OEBPS/apa.html.make3-APP-A-ITERM-1613" class="indexterm"></a>作为<em class="filename">makefile</em>
            而不是任何默认名称（即<em class="filename">makefile</em>、<em class="filename">Makefile</em>或<em class="filename">GNUMakefile</em>）。</p></dd><dd><p>Read the given file <a class="indexterm"></a>as the <em class="filename">makefile</em>
            rather than any of the default names (i.e., <em class="filename">makefile</em>, <em class="filename">Makefile</em>, or <em class="filename">GNUMakefile</em>).</p></dd><dt><span class="term"><code class="option">—help</code></span></dt><dt><span class="term"><code class="option">—help</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-h</code></span></dt><dt><span class="term"><code class="option">-h</code></span></dt><dd><p>打印简介<a id="OEBPS/apa.html.make3-APP-A-ITERM-1614" class="indexterm"></a>命令行选项的摘要。</p></dd><dd><p>Print a brief <a class="indexterm"></a>summary of the command-line options.</p></dd><dt><span class="term"><code class="option">—include-dir=</code>
          <em class="replaceable"><code>directory</code></em></span></dt><dt><span class="term"><code class="option">—include-dir=</code>
          <em class="replaceable"><code>directory</code></em></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-I </code>
          <em class="replaceable"><code>directory</code></em></span></dt><dt><span class="term"><code class="option">-I </code>
          <em class="replaceable"><code>directory</code></em></span></dt><dd><p>如果包含文件没有<a id="OEBPS/apa.html.make3-APP-A-ITERM-1615" class="indexterm"></a>存在于当前目录中，在搜索编译的搜索路径之前在指示的目录中查找包含文件。<code class="option">—include-dir</code>命令行上可以给出任意数量的
            选项。</p></dd><dd><p>If an include file does not <a class="indexterm"></a>exist in the current directory, look in the
            indicated directories for include files before searching the
            compiled-in search path. Any number of
            <code class="option">—include-dir</code> options can be given on the command
            line.</p></dd><dt><span class="term"><code class="option">—keep-going</code></span></dt><dt><span class="term"><code class="option">—keep-going</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-k</code></span></dt><dt><span class="term"><code class="option">-k</code></span></dt><dd><p>不要终止<a id="OEBPS/apa.html.make3-APP-A-ITERM-1616" class="indexterm"></a>如果命令返回错误状态，则<em class="command">make</em>进程。相反，跳过当前目标的其余部分，并继续执行其他目标。</p></dd><dd><p>Do not terminate <a class="indexterm"></a>the <em class="command">make</em> process
            if a command returns an error status. Instead, skip the remainder
            of the current target, and continue on with other targets.</p></dd><dt><span class="term"><code class="option">—just-print</code></span></dt><dt><span class="term"><code class="option">—just-print</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-n</code></span></dt><dt><span class="term"><code class="option">-n</code></span></dt><dd><p>显示命令集<a id="OEBPS/apa.html.make3-APP-A-ITERM-1617" class="indexterm"></a><em class="command">它将由make</em>执行，但不执行命令脚本中的任何命令。当您想在实际执行之前知道<em class="command">make</em>将做什么时，这非常有用。请注意，此选项不会阻止<code class="function">shell</code>函数中的代码执行，只会阻止命令脚本中的命令执行。</p></dd><dd><p>Display the set of commands <a class="indexterm"></a>that would be executed by <em class="command">make</em>, but do not execute any commands
            from command scripts. This is very useful when you want to know
            what <em class="command">make</em> will do before
            actually doing it. Be aware that this option does not prevent code
            in <code class="function">shell</code> functions from
            executing, just commands in command scripts.</p></dd><dt><span class="term"><code class="option">—old-file=</code>
          <em class="replaceable"><code>file</code></em></span></dt><dt><span class="term"><code class="option">—old-file=</code>
          <em class="replaceable"><code>file</code></em></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-o </code> <em class="replaceable"><code>file</code></em></span></dt><dt><span class="term"><code class="option">-o </code> <em class="replaceable"><code>file</code></em></span></dt><dd><p><em class="replaceable"><code>file</code></em>当作是一样对待<a id="OEBPS/apa.html.make3-APP-A-ITERM-1618" class="indexterm"></a>无限旧，并执行适当的操作来更新目标。如果文件被意外触及或确定某个先决条件对依赖关系图的影响，这可能非常有用。这是<code class="option">—new-file</code>( )的补集
            <code class="option">-W</code>。</p></dd><dd><p>Treat <em class="replaceable"><code>file</code></em> as if it
            were<a class="indexterm"></a> infinitely old, and perform the appropriate actions
            to update the goals. This can be very useful if a file has been
            accidentally touched or to determine the effect of one
            prerequisite on the dependency graph. This is the complement of
            <code class="option">—new-file</code> (<code class="option">-W</code>).</p></dd><dt><span class="term"><code class="option">—print-data-base</code></span></dt><dt><span class="term"><code class="option">—print-data-base</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-p</code></span></dt><dt><span class="term"><code class="option">-p</code></span></dt><dd><p>打印<em class="command">make</em>的内部信息
            <a id="OEBPS/apa.html.make3-APP-A-ITERM-1619" class="indexterm"></a>数据库。</p></dd><dd><p>Print <em class="command">make</em>'s internal
            <a class="indexterm"></a>database.</p></dd><dt><span class="term"><code class="option">—touch</code></span></dt><dt><span class="term"><code class="option">—touch</code></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-t</code></span></dt><dt><span class="term"><code class="option">-t</code></span></dt><dd><p>在每个上执行<em class="command">触摸程序</em><a id="OEBPS/apa.html.make3-APP-A-ITERM-1620" class="indexterm"></a>过时的目标更新其时间戳。这对于使依赖关系图中的文件保持最新非常有用。例如，编辑中央头文件中的注释可能会导致
            <em class="command">make</em>不必要地重新编译大量代码。您可以使用该<code class="option">—touch</code>
            选项强制所有文件保持最新，而不是执行编译和浪费机器周期。</p></dd><dd><p>Execute the <em class="command">touch</em> program
            on each <a class="indexterm"></a>out-of-date target to update its timestamp. This can
            be useful in bringing the files in a dependency graph up to date.
            For instance, editing a comment in a central header file may cause
            <em class="command">make</em> to unnecessarily recompile
            an immense amount of code. Instead of performing the compile and
            wasting machine cycles, you can use the <code class="option">—touch</code>
            option to force all files to be up to date.</p></dd><dt><span class="term"><code class="option">—new-file=</code>
          <em class="replaceable"><code>file</code></em></span></dt><dt><span class="term"><code class="option">—new-file=</code>
          <em class="replaceable"><code>file</code></em></span></dt><dd><p></p></dd><dd><p></p></dd><dt><span class="term"><code class="option">-W </code> <em class="replaceable"><code>file</code></em></span></dt><dt><span class="term"><code class="option">-W </code> <em class="replaceable"><code>file</code></em></span></dt><dd><p>假设<em class="replaceable"><code>file</code></em>更新于
            <a id="OEBPS/apa.html.make3-APP-A-ITERM-1621" class="indexterm"></a>任何目标。这对于强制更新目标很有用，而无需编辑或触摸文件。这是 的补集<code class="option">—old-file</code>。</p></dd><dd><p>Assume <em class="replaceable"><code>file</code></em> is newer than
            <a class="indexterm"></a>any target. This can be useful in forcing an update
            on targets without having to edit or touch a file. This is the
            complement of <code class="option">—old-file</code>.</p></dd><dt><span class="term"><code class="option">—warn-undefined-variables</code></span></dt><dt><span class="term"><code class="option">—warn-undefined-variables</code></span></dt><dd><p>打印警告<a id="OEBPS/apa.html.make3-APP-A-ITERM-1622" class="indexterm"></a>如果扩展了未定义的变量，则显示消息。这是一个有用的诊断工具，因为未定义的变量会悄悄消失。然而，出于定制目的，在<em class="filename">makefile</em>中包含空变量也很常见。此选项也将报告任何未设置的自定义变量。</p></dd><dd><p>Print a warning <a class="indexterm"></a>message if an undefined variable is expanded. This
            is a useful diagnostic tool since undefined variables quietly
            collapse into nothing. However, it is also common to include empty
            variables in <em class="filename">makefile</em>s for
            customization purposes. Any unset customization variables will be
            reported by this option as well.</p></dd></dl></div></div></div></div>
<div id="OEBPS/apb.html"><div>
<div class="appendix" title="附录 B. 外部限制"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apb.html.make3-APP-B"></a>附录 B. 外部限制</h1><h1 class="title"><a></a>Appendix&nbsp;B.&nbsp;The Outer Limits</h1></div></div></div><p>正如您所看到的，<acronym class="acronym">GNU </acronym> <em class="command">make</em>可以做一些非常令人难以置信的事情，但我还没有看到太多真正突破<em class="command">make</em> 3.80 及其<code class="function">eval</code>构造限制的东西。在本练习中，我们将看看是否可以比平常进一步扩展它。</p><p>As you've seen, <acronym class="acronym">GNU</acronym> <em class="command">make</em> can do some pretty incredible things, but
      I haven't seen very much that really pushes the limits of <em class="command">make</em> 3.80 with its <code class="function">eval</code> construct. In this exercise, we'll see
      if we can stretch it further than usual.</p><div class="sect1" title="数据结构"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apb.html.make3-APP-B-SECT-1"></a>数据结构</h1><h1 class="title"><a></a>Data Structures</h1></div></div></div><p><em class="command">make</em>的局限性之一<em class="command"></em> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1623" class="indexterm"></a><em class="filename">在编写复杂的makefile</em>时偶尔会出现问题，因为<em class="command">make</em>缺乏数据结构。以非常有限的方式，您可以通过定义来模拟数据结构<a id="OEBPS/apb.html.make3-APP-B-ITERM-1624" class="indexterm"></a> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1625" class="indexterm"></a>带有嵌入句点的变量（或者即使<code class="literal">-&gt;</code>你可以忍受）：</p><p>One of the limitations of <em class="command">make</em> <a class="indexterm"></a>that occasionally chaffs when writing complex <em class="filename">makefile</em>s is <em class="command">make</em>'s lack of data structures. In a very
        limited way, you can simulate a data structure by defining <a class="indexterm"></a> <a class="indexterm"></a>variables with embedded periods (or even <code class="literal">-&gt;</code> if you can stand it):</p><a id="OEBPS/apb.html.I__tt551"></a><pre class="programlisting">文件.path = /foo/bar
文件类型=unix
文件.host = 奥斯卡</pre><pre class="programlisting">file.path = /foo/bar
file.type = unix
file.host = oscar</pre><p>如果按下，您甚至可以<code class="literal">file</code>使用计算变量将此结构“传递”给函数：</p><p>If pressed, you can even "pass" this <code class="literal">file</code> structure to a function by using
        computed variables:</p><a id="OEBPS/apb.html.I__tt552"></a><pre class="programlisting">定义远程文件
  $(if $(过滤unix,$($1.type)), \
    /net/$($1.host)/$($1.path), \
    //$($1.主机)/$($1.路径))
恩德夫</pre><pre class="programlisting">define remote-file
  $(if $(filter unix,$($1.type)), \
    /net/$($1.host)/$($1.path),   \
    //$($1.host)/$($1.path))
endef</pre><p>然而，由于以下几个原因，这似乎是一个令人不满意的解决方案：</p><p>Nevertheless, this seems an unsatisfying solution for several
        reasons:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>您无法轻松分配此“结构”的实例。创建新实例涉及选择新变量名称并分配每个元素。这也意味着这些伪实例不能保证具有相同的字段（称为
            <em class="firstterm">slot</em>）。</p></li><li class="listitem"><p>You cannot easily allocate a instance of this "structure."
            Creating a new instance involves selecting a new variable name and
            assigning each element. This also means these pseudo-instances are
            not guaranteed to have the same fields (called
            <em class="firstterm">slots</em>).</p></li><li class="listitem"><p>该结构仅存在于用户的脑海中，并且作为一组不同的<em class="command">make</em>变量，而不是作为具有自己名称的统一实体。而且由于结构没有名称，因此很难创建对结构的引用（或指针），因此将它们作为参数传递或将其存储在变量中是笨拙的。</p></li><li class="listitem"><p>The structure exists only in the user's mind, and as a set
            of different <em class="command">make</em> variables,
            rather than as a unified entity with its own name. And because the
            structure has no name, it is difficult to create a reference (or
            pointer) to a structure, so passing them as arguments or storing
            one in a variable is clumsy.</p></li><li class="listitem"><p>没有安全的方法来访问该结构的槽。变量名任一部分中的任何印刷错误都会产生错误值（或无值），并且<em class="command">make</em>不会发出警告。</p></li><li class="listitem"><p>There is no safe way to access a slot of the structure. Any
            typographical error in either part of the variable name yields the
            wrong value (or no value) with no warning from <em class="command">make</em>.</p></li></ul></div><p>但<code class="function">remote-file</code>
        功能<a id="OEBPS/apb.html.make3-APP-B-ITERM-1626" class="indexterm"></a> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1627" class="indexterm"></a>暗示了更全面的解决方案。假设我们使用计算变量实现结构实例。早期的 Lisp 对象系统（甚至今天的一些）使用了类似的技术。一个结构，例如<code class="literal">file-info</code>，可以具有由符号名称表示的实例，例如<code class="literal">file_info_1</code>。</p><p>But the <code class="function">remote-file</code>
        function <a class="indexterm"></a> <a class="indexterm"></a>hints at a more comprehensive solution. Suppose we
        implement structure instances using computed variables. Early Lisp
        object systems (and even some today) used similar techniques. A
        structure, say <code class="literal">file-info</code>, can have
        instances represented by a symbolic name, such as <code class="literal">file_info_1</code>.</p><p>另一个实例可能称为<code class="literal">file_info_2</code>.该结构的槽可以用计算变量表示：</p><p>Another instance might be called <code class="literal">file_info_2</code>. The slots of this structure can
        be represented by computed variables:</p><a id="OEBPS/apb.html.I__tt553"></a><pre class="programlisting">文件信息_1_路径
文件信息_1_类型
文件信息_1_主机</pre><pre class="programlisting">file_info_1_path
file_info_1_type
file_info_1_host</pre><p>由于实例具有符号名称，因此可以将其保存在一个或多个变量中（像往常一样，使用递归或简单变量是程序员的选择）：</p><p>Since the instance has a symbolic name, it can be saved in one
        or more variables (as usual, using recursive or simple variables is
        the choice of the programmer):</p><a id="OEBPS/apb.html.I__tt554"></a><pre class="programlisting">before_foo = file_info_1
another_foo = $(before_foo)</pre><pre class="programlisting">before_foo = file_info_1
another_foo = $(before_foo)</pre><p>a 的元素<code class="literal">file-info</code>可以使用类似 Lisp 的 getter 和 setter 来访问：</p><p>Elements of a <code class="literal">file-info</code> can
        be accessed using Lisp-like getters and setters:</p><a id="OEBPS/apb.html.I__tt555"></a><pre class="programlisting">路径 := $(调用 get-value,before_foo,path)
$(调用设置值,before_foo,路径,/usr/tmp/bar)</pre><pre class="programlisting">path := $(call get-value,before_foo,path)
$(call set-value,before_foo,path,/usr/tmp/bar)</pre><p>我们可以更进一步，为
        <code class="literal">file-info</code>结构创建一个模板，以便方便地分配新实例：</p><p>We can go further than this by creating a template for the
        <code class="literal">file-info</code> structure to allow the
        convenient allocation of new instances:</p><a id="OEBPS/apb.html.I__tt556"></a><pre class="programlisting">orig_foo := $(调用新的，文件信息)
$(调用设置值,orig_foo,路径,/foo/bar)

tmp_foo := $(调用新的，文件信息)
$(调用设置值,tmp_foo,路径,/tmp/bar)</pre><pre class="programlisting">orig_foo := $(call new,file-info)
$(call set-value,orig_foo,path,/foo/bar)

tmp_foo := $(call new,file-info)
$(call set-value,tmp_foo,path,/tmp/bar)</pre><p>现在，存在两个不同的实例<code class="literal">file-info</code>。作为最后的便利，我们可以添加槽默认值的概念。为了声明
        <code class="literal">file-info</code>结构，我们可以使用：</p><p>Now, two distinct instances of <code class="literal">file-info</code> exist. As a final convenience, we
        can add the concept of default values for slots. To declare the
        <code class="literal">file-info</code> structure, we might
        use:</p><a id="OEBPS/apb.html.I__tt557"></a><pre class="programlisting">$(调用 defstruct,文件信息,\
  $(调用 defslot,路径,), \
  $(调用 defslot,类型,unix), \
  $(call defslot,host,oscar))</pre><pre class="programlisting">$(call defstruct,file-info,  \
  $(call defslot,path,),     \
  $(call defslot,type,unix), \
  $(call defslot,host,oscar))</pre><p>这里，函数的第一个参数<code class="function">defstruct</code>是结构名称，后面是调用列表<code class="function">defslot</code>
        。每个都<code class="function">defslot</code>包含一个 ( <em class="replaceable"><code>name</code></em>,
         ) 对。<a class="link" href="#OEBPS/apb.html.make3-APP-B-EX-1" title="示例 B-1。 make中的结构体定义">示例 B-1</a>显示了它的实现及其支持代码。<em class="replaceable"><code>default</code></em> <em class="replaceable"><code>value</code></em><a class="link" href="#OEBPS/apb.html.make3-APP-B-EX-1" title="示例 B-1。 make中的结构体定义"></a><code class="function">defstruct</code></p><p>Here, the first argument to the <code class="function">defstruct</code> function is the structure name,
        followed by a list of <code class="function">defslot</code>
        calls. Each <code class="function">defslot</code> contains a
        single (<em class="replaceable"><code>name</code></em>,
        <em class="replaceable"><code>default</code></em> <em class="replaceable"><code>value</code></em>)
        pair. <a class="link" href="#OEBPS/apb.html.make3-APP-B-EX-1" title="Example&nbsp;B-1.&nbsp;Structure definition in make">Example B-1</a> shows the
        implementation of <code class="function">defstruct</code> and
        its supporting code.</p><div class="example"><a id="OEBPS/apb.html.make3-APP-B-EX-1"></a><p class="title">示例 B-1。 make中的结构体定义</p><p class="title">Example&nbsp;B-1.&nbsp;Structure definition in make</p><div class="example-contents"><pre class="programlisting"># $(next-id) - 返回一个唯一的数字
下一个_id_计数器：=
定义下一个 id
$(单词$(next_id_counter))$(eval next_id_counter += 1)
恩德夫

# all_structs - 已定义结构名称的列表
所有结构：=

value_sep := XxSepxX

# $(调用 defstruct, struct_name, $(调用 defslot, slot_name, value), ...)
定义defstruct
  $(eval all_structs += $1) \
  $(eval $1_def_slotnames :=) \
  $(foreach v, $2 $3 $4 $5 $6 $7 $8 $9 $(10) $(11), \
    $(如果$($v_name), \
      $(eval $1_def_slotnames += $($v_name)) \
      $(eval $1_def_$($v_name)_default := $($v_value))))
恩德夫

# $(调用 defslot,slot_name,slot_value)
定义defslot
  $(eval tmp_id := $(next_id))
  $(eval $1_$(tmp_id)_name := $1)
  $(eval $1_$(tmp_id)_value := $2)
  $1_$(tmp_id)
恩德夫

# all_instances - 任何结构的所有实例的列表
所有实例 :=

# $(调用新的, struct_name)
定义新的
$(条\
  $(如果$(过滤器$1,$(all_structs)),, \
    $(未知结构'$(strip $1)'上出现新错误)) \
  $(eval 实例 := $1@$(next-id)) \
  $(eval all_instances += $(实例)) \
  $(foreach v, $($(strip $1)_def_slotnames), \
    $(eval $(instance)_$v := $($(strip $1)_def_$v_default))) \
  $(实例))
恩德夫

# $(调用删除，变量)
定义删除
$(条\
  $(if $(过滤器$($(strip $1)),$(all_instances)),, \
    $(错误无效实例'$($(strip $1))')) \
  $(eval all_instances := $(过滤掉 $($(strip $1)),$(all_instances))) \
  $(foreach v, $($(strip $1)_def_slotnames), \
    $(eval $(实例)_$v := )))
恩德夫

# $(调用结构体名称，instance_id)
定义结构体名称
$(第一个字 $(subst @, ,$($(strip $1))))
恩德夫

# $(调用检查参数、instance_id、slot_name)
定义检查参数
  $(if $(过滤器$($(strip $1)),$(all_instances)),, \
    $(错误无效实例'$(strip $1)')) \
  $(if $(filter $2,$($(call struct-name,$1)_def_slotnames)),, \
    $(错误实例'$($(strip $1))'没有插槽'$(strip $2)'))
恩德夫

# $(调用获取值、instance_id、slot_name)
定义获取值
$(条\
  $(调用检查参数,$1,$2) \
  $($($(条带$1))_$(条带$2)))
恩德夫

# $(调用设置值，instance_id，slot_name，值)
定义设定值
  $(调用检查参数,$1,$2) \
  $(eval $($(条带$1))_$(条带$2) := $3)
恩德夫

# $(调用转储结构，struct_name)
定义转储结构
{ $(条带 $1)_def_slotnames "$($(条带 $1)_def_slotnames)" \
  $(foreach s, \
    $($(条带$1)_def_slotnames),$(条带\
    $(条带$1)_def_$s_default "$($(条带$1)_def_$s_default)")) }
恩德夫

# $(调用打印结构，结构名称)
定义打印结构
{ $(foreach s, \
    $($(条带$1)_def_slotnames),$(条带\
    { "$s" "$($(条带 $1)_def_$s_default)" })) }
恩德夫

# $(调用转储实例，instance_id)
定义转储实例
{ $(eval tmp_name := $(call struct-name,$1)) \
  $(foreach s, \
    $($(tmp_name)_def_slotnames),$(条带\
    { $($(条带 $1))_$s "$($($(条带 $1))_$s)" })) }
恩德夫

# $(调用打印实例，instance_id)
定义打印实例
{ $(foreach s, \
    $($(call struct-name,$1)_def_slotnames),"$(条带\
    $(调用 get-value,$1,$s))") }
恩德夫</pre><pre class="programlisting"># $(next-id) - return a unique number
next_id_counter :=
define next-id
$(words $(next_id_counter))$(eval next_id_counter += 1)
endef

# all_structs - a list of the defined structure names
all_structs :=

value_sep := XxSepxX

# $(call defstruct, struct_name, $(call defslot, slot_name, value), ...)
define defstruct
  $(eval all_structs += $1)                                             \
  $(eval $1_def_slotnames :=)                                           \
  $(foreach v, $2 $3 $4 $5 $6 $7 $8 $9 $(10) $(11),                     \
    $(if $($v_name),                                                    \
      $(eval $1_def_slotnames          += $($v_name))                   \
      $(eval $1_def_$($v_name)_default := $($v_value))))
endef

# $(call defslot,slot_name,slot_value)
define defslot
  $(eval tmp_id := $(next_id))
  $(eval $1_$(tmp_id)_name := $1)
  $(eval $1_$(tmp_id)_value := $2)
  $1_$(tmp_id)
endef

# all_instances - a list of all the instances of any structure
all_instances :=

# $(call new, struct_name)
define new
$(strip                                                         \
  $(if $(filter $1,$(all_structs)),,                            \
    $(error new on unknown struct '$(strip $1)'))               \
  $(eval instance := $1@$(next-id))                             \
  $(eval all_instances += $(instance))                          \
  $(foreach v, $($(strip $1)_def_slotnames),                    \
    $(eval $(instance)_$v := $($(strip $1)_def_$v_default)))    \
  $(instance))
endef

# $(call delete, variable)
define delete
$(strip                                                                  \
  $(if $(filter $($(strip $1)),$(all_instances)),,                       \
    $(error Invalid instance '$($(strip $1))'))                          \
  $(eval all_instances := $(filter-out $($(strip $1)),$(all_instances))) \
  $(foreach v, $($(strip $1)_def_slotnames),                             \
    $(eval $(instance)_$v := )))
endef

# $(call struct-name, instance_id)
define struct-name
$(firstword $(subst @, ,$($(strip $1))))
endef

# $(call check-params, instance_id, slot_name)
define check-params
  $(if $(filter $($(strip $1)),$(all_instances)),,              \
    $(error Invalid instance '$(strip $1)'))                    \
  $(if $(filter $2,$($(call struct-name,$1)_def_slotnames)),,   \
    $(error Instance '$($(strip $1))' does not have slot '$(strip $2)'))
endef

# $(call get-value, instance_id, slot_name)
define get-value
$(strip                         \
  $(call check-params,$1,$2)    \
  $($($(strip $1))_$(strip $2)))
endef

# $(call set-value, instance_id, slot_name, value)
define set-value
  $(call check-params,$1,$2) \
  $(eval $($(strip $1))_$(strip $2) := $3)
endef

# $(call dump-struct, struct_name)
define dump-struct
{ $(strip $1)_def_slotnames "$($(strip $1)_def_slotnames)"      \
  $(foreach s,                                                  \
    $($(strip $1)_def_slotnames),$(strip                        \
    $(strip $1)_def_$s_default "$($(strip $1)_def_$s_default)")) }
endef

# $(call print-struct, struct_name)
define print-struct
{ $(foreach s,                                  \
    $($(strip $1)_def_slotnames),$(strip        \
    { "$s" "$($(strip $1)_def_$s_default)" })) }
endef

# $(call dump-instance, instance_id)
define dump-instance
{ $(eval tmp_name := $(call struct-name,$1))    \
  $(foreach s,                                  \
    $($(tmp_name)_def_slotnames),$(strip        \
    { $($(strip $1))_$s "$($($(strip $1))_$s)" })) }
endef

# $(call print-instance, instance_id)
define print-instance
{ $(foreach s,                                          \
    $($(call struct-name,$1)_def_slotnames),"$(strip    \
    $(call get-value,$1,$s))") }
endef</pre></div></div><p>一次检查一个子句，您会发现它是从定义 function 开始的<code class="function">next-id</code>。这是一个简单的计数器：</p><p>Examining this code one clause at a time, you can see that it
        starts by defining the function <code class="function">next-id</code>. This is a simple counter:</p><a id="OEBPS/apb.html.I__tt558"></a><pre class="programlisting"># $(next-id) - 返回一个唯一的数字
下一个_id_计数器：=
定义下一个 id
$(单词$(next_id_counter))$(eval next_id_counter += 1)
恩德夫</pre><pre class="programlisting"># $(next-id) - return a unique number
next_id_counter :=
define next-id
$(words $(next_id_counter))$(eval next_id_counter += 1)
endef</pre><p>人们常说你不能在<em class="command">make</em>中执行算术，因为语言太有限了。一般来说，这是正确的，但对于像这样的有限情况，您通常可以计算出您需要的内容。该函数用于<code class="function">eval</code>重新定义简单变量的值。该函数包含两个表达式：第一个表达式返回 中的单词数<code class="literal">next_id_counter</code>；第二个表达式将另一个单词附加到变量中。它的效率不是很高，但对于几千个数字来说已经很好了。</p><p>It is often said that you cannot perform arithmetic in <em class="command">make</em>, because the language is too limited.
        In general, this is true, but for limited cases like this you can
        often compute what you need. This function uses <code class="function">eval</code> to redefine the value of a simple
        variable. The function contains two expressions: the first expression
        returns the number of words in <code class="literal">next_id_counter</code>; the second expression
        appends another word to the variable. It isn't very efficient, but for
        numbers in the small thousands it is fine.</p><p>下一节定义<code class="function">defstruct</code>函数本身并创建支持数据结构。</p><p>The next section defines the <code class="function">defstruct</code> function itself and creates the
        supporting data structures.</p><a id="OEBPS/apb.html.I__tt559"></a><pre class="programlisting"># all_structs - 已定义结构名称的列表
所有结构：=

value_sep := XxSepxX

# $(调用 defstruct, struct_name, $(调用 defslot, slot_name, value), ...)
定义defstruct
  $(eval all_structs += $1) \
  $(eval $1_def_slotnames :=) \
  $(foreach v, $2 $3 $4 $5 $6 $7 $8 $9 $(10) $(11), \
    $(如果$($v_name), \
      $(eval $1_def_slotnames += $($v_name)) \
      $(eval $1_def_$($v_name)_default := $($v_value))))
恩德夫

# $(调用 defslot,slot_name,slot_value)
定义defslot
  $(eval tmp_id := $(next_id))
  $(eval $1_$(tmp_id)_name := $1)
  $(eval $1_$(tmp_id)_value := $2)
  $1_$(tmp_id)
恩德夫</pre><pre class="programlisting"># all_structs - a list of the defined structure names
all_structs :=

value_sep := XxSepxX

# $(call defstruct, struct_name, $(call defslot, slot_name, value), ...)
define defstruct
  $(eval all_structs += $1)                              \
  $(eval $1_def_slotnames :=)                            \
  $(foreach v, $2 $3 $4 $5 $6 $7 $8 $9 $(10) $(11),      \
    $(if $($v_name),                                     \
      $(eval $1_def_slotnames          += $($v_name))    \
      $(eval $1_def_$($v_name)_default := $($v_value))))
endef

# $(call defslot,slot_name,slot_value)
define defslot
  $(eval tmp_id := $(next_id))
  $(eval $1_$(tmp_id)_name := $1)
  $(eval $1_$(tmp_id)_value := $2)
  $1_$(tmp_id)
endef</pre><p>该变量<code class="literal">all_structs</code>是用 定义的所有已知结构的列表<code class="function">defstruct</code>。该列表允许<code class="function">new</code>函数对其分配的结构执行类型检查。对于每个结构 ，
        <em class="replaceable"><code>S</code></em>该<code class="function">defstruct</code>函数定义一组变量：</p><p>The variable <code class="literal">all_structs</code> is a
        list of all known structures defined with <code class="function">defstruct</code>. This list allows the <code class="function">new</code> function to perform type checking on
        the structures it allocates. For each structure,
        <em class="replaceable"><code>S</code></em>, the <code class="function">defstruct</code> function defines a set of
        variables:</p><a id="OEBPS/apb.html.I__tt560"></a><pre class="programlisting"><em class="replaceable"><code>S</code></em>_def_slotnames
 <em class="replaceable"><code>S</code></em>_def_ <sub>n</sub> _default<em class="replaceable"><code>slot</code></em>
               <sub></sub></pre><pre class="programlisting"><em class="replaceable"><code>S</code></em>_def_slotnames
<em class="replaceable"><code>S</code></em>_def_<em class="replaceable"><code>slot</code></em>
               <sub>n</sub>_default</pre><p>第一个变量定义结构的槽集。其他变量定义每个插槽的默认值。该函数的前两行分别<code class="function">defstruct</code>附加到<code class="literal">all_structs</code>槽名称列表并初始化槽名称列表。该函数的其余部分迭代槽，构建槽列表并保存默认值。</p><p>The first variable defines the set of slots for a structure. The
        other variables define the default value for each slot. The first two
        lines of the <code class="function">defstruct</code> function
        append to <code class="literal">all_structs</code> and
        initialize the slot names list, respectively. The remainder of the
        function iterates through the slots, building the slot list and saving
        the default value.</p><p>每个槽的定义是<a id="OEBPS/apb.html.make3-APP-B-ITERM-1628" class="indexterm"></a> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1629" class="indexterm"></a>由 处理<code class="function">defslot</code>。该函数分配一个 id，将插槽名称和值保存在两个变量中，并返回前缀。返回前缀允许 的参数列表<code class="function">defstruct</code>成为一个简单的符号列表，每个符号都提供对槽定义的访问。如果稍后将更多属性添加到插槽中，将它们合并到其中<code class="function">defslot</code>就很简单。与更简单的替代实现相比，该技术还允许默认值具有更广泛的值范围（包括空格）。</p><p>Each slot definition is <a class="indexterm"></a> <a class="indexterm"></a>handled by <code class="function">defslot</code>.
        The function allocates an id, saves the slot name and value in two
        variables, and returns the prefix. Returning the prefix allows the
        argument list of <code class="function">defstruct</code> to be
        a simple list of symbols, each of which provides access to a slot
        definition. If more attributes are added to slots later, incorporating
        them into <code class="function">defslot</code> is
        straightforward. This technique also allows default values to have a
        wider range of values (including spaces) than simpler, alternative
        implementations.</p><p>循环<code class="function">foreach</code>中
        <code class="function">defstruct</code> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1630" class="indexterm"></a> <a id="OEBPS/apb.html.make3-APP-B-ITERM-1631" class="indexterm"></a>确定允许的最大插槽数。此版本允许 10 个插槽。主体<code class="function">foreach</code>通过将槽名称附加到变量并将默认值分配给变量来处理每个参数。例如，我们的结构将定义：<em class="replaceable"><code>S</code></em> <code class="literal">_def_slotnames</code><code class="function">file-info</code></p><p>The <code class="function">foreach</code> loop in
        <code class="function">defstruct</code> <a class="indexterm"></a> <a class="indexterm"></a>determines the maximum number of allowable slots. This
        version allows for 10 slots. The body of the <code class="function">foreach</code> processes each argument by
        appending the slot name to <em class="replaceable"><code>S</code></em> <code class="literal">_def_slotnames</code> and assigning the default
        value to a variable. For example, our <code class="function">file-info</code> structure would define:</p><a id="OEBPS/apb.html.I__tt561"></a><pre class="programlisting">file-info_def_slotnames := 路径类型主机
文件信息_def_路径_默认:=
文件信息_def_type_default := unix
file-info_def_host_default := oscar</pre><pre class="programlisting">file-info_def_slotnames := path type host
file-info_def_path_default :=
file-info_def_type_default := unix
file-info_def_host_default := oscar</pre><p>这样就完成了结构体的定义。</p><p>This completes the definition of a structure.</p><p>现在我们可以定义结构了，我们需要能够实例化一个结构。该<code class="function">new</code>函数执行此操作：</p><p>Now that we can define structures, we need to be able to
        instantiate one. The <code class="function">new</code> function
        performs this operation:</p><a id="OEBPS/apb.html.I__tt562"></a><pre class="programlisting"># $(调用新的, struct_name)
定义新的
$(条\
  $(如果$(过滤器$1,$(all_structs)),, \
    $(未知结构'$(strip $1)'上出现新错误)) \
  $(eval 实例 := $1@$(next-id)) \
  $(eval all_instances += $(实例)) \
  $(foreach v, $($(strip $1)_def_slotnames), \
    $(eval $(instance)_$v := $($(strip $1)_def_$v_default))) \
  $(实例))
恩德夫</pre><pre class="programlisting"># $(call new, struct_name)
define new
$(strip                                                         \
  $(if $(filter $1,$(all_structs)),,                            \
    $(error new on unknown struct '$(strip $1)'))               \
  $(eval instance := $1@$(next-id))                             \
  $(eval all_instances += $(instance))                          \
  $(foreach v, $($(strip $1)_def_slotnames),                    \
    $(eval $(instance)_$v := $($(strip $1)_def_$v_default)))    \
  $(instance))
endef</pre><p>函数中的第一个<code class="function">if</code>检查名称是否引用已知结构。如果在 中找不到该结构<code class="literal">all_structs</code>，则会发出错误信号。接下来，我们通过将结构名称与唯一的整数后缀连接起来，为新实例构造一个唯一的 id。我们使用 at 符号将结构名称与后缀分开，以便稍后可以轻松地将两者分开。然后，该<code class="function">new</code>函数记录新的实例名称，以便稍后访问器进行类型检查。然后使用默认值初始化结构体的槽。初始化代码很有趣：</p><p>The first <code class="function">if</code> in the
        function checks that the name refers to a known structure. If the
        structure isn't found in <code class="literal">all_structs</code>, an error is signaled. Next, we
        construct a unique id for the new instance by concatenating the
        structure name with a unique integer suffix. We use an at sign to
        separate the structure name from the suffix so we can easily separate
        the two later. The <code class="function">new</code> function
        then records the new instance name for type checking by accessors
        later. Then the slots of the structure are initialized with their
        default values. The initialization code is interesting:</p><a id="OEBPS/apb.html.I__tt563"></a><pre class="programlisting">$(foreach v, $($(strip $1)_def_slotnames), \
  $(eval $(instance)_$v := $($(strip $1)_def_$v_default)))</pre><pre class="programlisting">$(foreach v, $($(strip $1)_def_slotnames),                \
  $(eval $(instance)_$v := $($(strip $1)_def_$v_default)))</pre><p>该<code class="function">foreach</code>循环迭代结构的槽名称。在结构名称上使用<code class="function">strip</code>around 允许用户在<code class="function">call</code>to中的逗号后面添加空格<code class="function">new</code>。回想一下，每个槽都是通过连接实例名称和槽名称来表示的（例如，
         <code class="literal">file_info@1_path</code>）。右侧是根据结构名称和槽名称计算的默认值。最后，函数返回实例名称。</p><p>The <code class="function">foreach</code> loop iterates
        over the slot names of the structure. Using <code class="function">strip</code> around on the structure name allows
        the user to add spaces after commas in the <code class="function">call</code> to <code class="function">new</code>. Recall that each slot is represented
        by concatenating the instance name and the slot name (for instance,
        <code class="literal">file_info@1_path</code>). The righthand
        side is the default value computed from the structure name and slot
        name. Finally, the instance name is returned by the function.</p><p>请注意，我将这些构造函数称为函数，但它们实际上是宏。也就是说，该符号<code class="function">new</code>被递归扩展以产生一段新的文本，该文本被插入到<em class="filename">makefile</em>中进行重新分析。宏执行我们想要的操作的原因
        <code class="function">defstruct</code>是因为所有工作最终都嵌入到<code class="function">eval</code>调用中，而调用则崩溃为空。同样，<code class="function">new</code>宏在调用中执行其重要工作<code class="function">eval</code>
        。它可以合理地称为函数，因为宏的扩展在概念上产生单个值，即代表新实例的符号。</p><p>Note that I call these constructs functions, but they are
        actually macros. That is, the symbol <code class="function">new</code> is recursively expanded to yield a new
        piece of text that is inserted into the <em class="filename">makefile</em> for reparsing. The reason the
        <code class="function">defstruct</code> macro does what we want
        is because all the work is eventually embedded within <code class="function">eval</code> calls, which collapse to nothing.
        Similarly, the <code class="function">new</code> macro performs
        its significant work within <code class="function">eval</code>
        calls. It can reasonably be termed a function, because the expansion
        of the macro conceptually yields a single value, the symbol
        representing the new instance.</p><p>接下来，我们需要能够在结构中获取和设置值。为此，我们定义了两个新函数：</p><p>Next, we need to be able to get and set values within our
        structures. To do this, we define two new functions:</p><a id="OEBPS/apb.html.I__tt564"></a><pre class="programlisting"># $(调用获取值、instance_id、slot_name)
定义获取值
$(条\
  $(调用检查参数,$1,$2) \
  $($($(条带$1))_$(条带$2)))
恩德夫

# $(调用设置值，instance_id，slot_name，值)
定义设定值
  $(调用检查参数,$1,$2) \
  $(eval $($(条带$1))_$(条带$2) := $3)
恩德夫</pre><pre class="programlisting"># $(call get-value, instance_id, slot_name)
define get-value
$(strip                         \
  $(call check-params,$1,$2)    \
  $($($(strip $1))_$(strip $2)))
endef

# $(call set-value, instance_id, slot_name, value)
define set-value
  $(call check-params,$1,$2) \
  $(eval $($(strip $1))_$(strip $2) := $3)
endef</pre><p>要获取插槽的值，我们只需根据实例 ID 和插槽名称计算插槽变量名称即可。我们可以通过首先使用该函数检查实例和槽名称是否为有效字符串来提高安全性<code class="function">check-params</code>
        。为了允许更美观的格式并确保无关的空间不会破坏槽值，我们将大部分参数包装在<code class="function">strip</code>调用中。</p><p>To get the value of a slot, we simply need to compute the slot
        variable name from the instance id and the slot name. We can improve
        safety by first checking that the instance and slot name are valid
        strings with the <code class="function">check-params</code>
        function. To allow more aesthetic formating and to ensure that
        extraneous spaces do not corrupt the slot value, we wrap most of these
        parameters in <code class="function">strip</code> calls.</p><p>设置函数还在设置值之前检查参数。我们再次删除两个函数参数，以允许用户自由地在参数列表中添加空格。请注意，我们不会删除槽值，因为用户可能实际上需要空格。</p><p>The set function also checks parameters before setting the
        value. Again, we strip the two function arguments to allow users the
        freedom to add spaces in the argument list. Note that we do not strip
        the slot value, because the user might actually need the
        spaces.</p><a id="OEBPS/apb.html.I__tt565"></a><pre class="programlisting"># $(调用检查参数、instance_id、slot_name)
定义检查参数
  $(if $(过滤器$($(strip $1)),$(all_instances)),, \
    $(错误无效实例'$(strip $1)')) \
  $(if $(filter $2,$($(call struct-name,$1)_def_slotnames)),, \
    $(错误实例'$($(strip $1))'没有插槽'$(strip $2)'))
恩德夫

# $(调用结构体名称，instance_id)
定义结构体名称
$(第一个字 $(subst @, ,$($(strip $1))))
恩德夫</pre><pre class="programlisting"># $(call check-params, instance_id, slot_name)
define check-params
  $(if $(filter $($(strip $1)),$(all_instances)),,              \
    $(error Invalid instance '$(strip $1)'))                    \
  $(if $(filter $2,$($(call struct-name,$1)_def_slotnames)),,   \
    $(error Instance '$($(strip $1))' does not have slot '$(strip $2)'))
endef

# $(call struct-name, instance_id)
define struct-name
$(firstword $(subst @, ,$($(strip $1))))
endef</pre><p>该<code class="function">check-params</code>函数只是检查传递给 setter 和 getter 函数的实例 ID 是否包含在已知实例列表中。同样，它检查槽名称是否包含在属于该结构的槽列表中。结构名称是根据实例名称计算的，方法是拆分 上的符号<code class="literal">@</code>并取第一个单词。这意味着结构名称不能包含 at 符号。</p><p>The <code class="function">check-params</code> function
        simply checks that the instance id passed to the setter and getter
        functions is contained within the known instances list. Likewise, it
        checks that the slot name is contained within the list of slots
        belonging to this structure. The structure name is computed from the
        instance name by splitting the symbol on the <code class="literal">@</code> and taking the first word. This means that
        structure names cannot contain an at sign.</p><p>为了完善实现，我们可以添加一些打印和调试功能。以下打印函数显示结构定义和结构实例的简单用户可读表示，而转储函数显示两个构造的实现细节。具体实现请参见<a class="link" href="#OEBPS/apb.html.make3-APP-B-EX-1" title="示例 B-1。 make中的结构体定义">示例 B-1 。</a></p><p>To round out the implementation, we can add a couple of print
        and debugging functions. The following print function displays a
        simple user-readable representation of a structure definition and a
        structure instance, while the dump function displays the
        implementation details of the two constructs. See <a class="link" href="#OEBPS/apb.html.make3-APP-B-EX-1" title="Example&nbsp;B-1.&nbsp;Structure definition in make">Example B-1</a> for the
        implementations.</p><p>这是定义和使用我们的结构的示例<code class="function">file-info</code>：</p><p>Here's an example defining and using our <code class="function">file-info</code> structure:</p><a id="OEBPS/apb.html.I__tt566"></a><pre class="programlisting">包括 defstruct.mk

$(调用 defstruct, 文件信息, \
  $(调用 defslot, 路径,), \
  $(调用 defslot, 类型,unix), \
  $(call defslot, 主持人,oscar))

before := $(调用新的，文件信息)
$(调用设置值、之前、路径、/etc/password)
$（调用设置值，之前，主机，wasatch）

之后：= $(调用新的，文件信息)
$(调用设置值、之后、路径、/etc/shadow)
$(调用设置值，之后，主机，wasatch)

演示：
        # 之前 = $(之前)
        # before.path = $(调用 get-value, before, path)
        # before.type = $(调用 get-value, before, type)
        # before.host = $(调用 get-value, before, host)
        # print before = $(调用 print-instance, before)
        # dump before = $(调用 dump-instance, before)
        #
        # 所有实例 = $(所有实例)
        # all_structs = $(all_structs)
        # 打印文件信息 = $(调用打印结构, 文件信息)
        # 转储文件信息 = $(调用转储结构, 文件信息)</pre><pre class="programlisting">include defstruct.mk

$(call defstruct, file-info,    \
  $(call defslot, path,),       \
  $(call defslot, type,unix),   \
  $(call defslot, host,oscar))

before := $(call new, file-info)
$(call set-value, before, path,/etc/password)
$(call set-value, before, host,wasatch)

after := $(call new,file-info)
$(call set-value, after, path,/etc/shadow)
$(call set-value, after, host,wasatch)

demo:
        # before       = $(before)
        # before.path  = $(call get-value, before, path)
        # before.type  = $(call get-value, before, type)
        # before.host  = $(call get-value, before, host)
        # print before = $(call print-instance, before)
        # dump before  = $(call dump-instance, before)
        #
        # all_instances   = $(all_instances)
        # all_structs     = $(all_structs)
        # print file-info = $(call print-struct, file-info)
        # dump file-info  = $(call dump-struct, file-info)</pre><p>和输出：</p><p>and the output:</p><a id="OEBPS/apb.html.I__tt567"></a><pre class="programlisting">$ 制作
# 之前 = 文件信息@0
# before.path = /etc/password
# before.type = unix
# before.host = wasatch
# print before = { "/etc/password" "unix" "wasatch" }
# dump before = { { file-info@0_path "/etc/password" } { file-info@0_type "unix" }
{ file-info@0_host "wasatch" } }
#
# all_instances = 文件信息@0 文件信息@1
# all_structs = 文件信息
# print file-info = { { "path" "" } { "type" "unix" } { "host" "oscar" } }
# dump file-info = { file-info_def_slotnames " 路径类型主机"
文件信息定义路径默认值
 “” file-info_def_type_default “unix” file-info_def_host_default “oscar” }</pre><pre class="programlisting">$ make
# before       = file-info@0
# before.path  = /etc/password
# before.type  = unix
# before.host  = wasatch
# print before = { "/etc/password" "unix" "wasatch" }
# dump before  = {  { file-info@0_path "/etc/password" } { file-info@0_type "unix" } 
{ file-info@0_host "wasatch" } }
#
# all_instances   =  file-info@0 file-info@1
# all_structs     =  file-info
# print file-info = { { "path" "" } { "type" "unix" } { "host" "oscar" } }
# dump file-info  = { file-info_def_slotnames " path type host" 
file-info_def_path_default
 "" file-info_def_type_default "unix" file-info_def_host_default "oscar" }</pre><p>另请注意非法建筑如何使用<a id="OEBPS/apb.html.make3-APP-B-ITERM-1632" class="indexterm"></a>被困：</p><p>Also note how illegal structure uses <a class="indexterm"></a>are trapped:</p><a id="OEBPS/apb.html.I__tt568"></a><pre class="programlisting">$ 猫 badstruct.mk
包括 defstruct.mk
$(调用新的，没有这样的结构)
$ make -f badstruct.mk
badstruct.mk:2: *** 未知结构“无此类结构”上的新内容。停止。

$ 猫 badslot.mk
包括 defstruct.mk
$(调用 defstruct, foo, defslot(size, 0))
酒吧 := $(调用新的，foo)
$(调用设置值, bar, 大小, 10)
$ make -f badslot.mk
badslot.mk:4: *** 实例“foo@0”没有插槽“siz”。停止。</pre><pre class="programlisting">$ cat badstruct.mk
include defstruct.mk
$(call new, no-such-structure)
$ make -f badstruct.mk
badstruct.mk:2: *** new on unknown struct 'no-such-structure'.  Stop.

$ cat badslot.mk
include defstruct.mk
$(call defstruct, foo, defslot(size, 0))
bar := $(call new, foo)
$(call set-value, bar, siz, 10)
$ make -f badslot.mk
badslot.mk:4: *** Instance 'foo@0' does not have slot 'siz'.  Stop.</pre><p>当然，可以对代码进行很多改进，但基本思想是合理的。以下是可能的增强功能的列表：</p><p>Of course, there are lots of improvements that can be made to
        the code, but the basic ideas are sound. Here is a list of possible
        enhancements:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p>向槽分配添加验证检查。这可以通过一个钩子函数来完成，该函数在执行赋值后必须产生空。钩子可以这样使用：</p><a id="OEBPS/apb.html.I__tt569"></a><pre class="programlisting"># $(调用设置值，instance_id，slot_name，值)
定义设定值
  $(调用检查参数,$1,$2) \
  $(if $(call $(strip $1)_$(strip $2)_hook, value), \
    $(错误设定值挂钩，$(strip $1)_$(strip $2)_hook，失败)) \
  $(eval $($(条带$1))_$(条带$2) := $3)
恩德夫</pre></li><li class="listitem"><p>Add a validation check to the slot assignment. This could be
            done with a hook function that must yield empty after the
            assignment has been performed. The hook could be used like
            this:</p><a></a><pre class="programlisting"># $(call set-value, instance_id, slot_name, value)
define set-value
  $(call check-params,$1,$2)                                       \
  $(if $(call $(strip $1)_$(strip $2)_hook, value),                \
    $(error set-value hook, $(strip $1)_$(strip $2)_hook, failed)) \
  $(eval $($(strip $1))_$(strip $2) := $3)
endef</pre></li><li class="listitem"><p>支持继承。 A<code class="function">defstruct</code>可以接受另一个
            <code class="function">defstruct</code>名称作为超类，从而在子类中复制所有超类的成员。</p></li><li class="listitem"><p>Support for inheritance. A <code class="function">defstruct</code> could accept another
            <code class="function">defstruct</code> name as a
            superclass, duplicating all the superclass's members in the
            subclass.</p></li><li class="listitem"><p>更好地支持结构参考。在当前的实现中，槽可以保存另一个结构的 ID，但访问很困难。可以编写该函数的新版<code class="function">get-value</code>本来检查引用（通过查找
            <em class="replaceable"><code>defstruct</code></em>@ <em class="replaceable"><code>number</code></em>），并执行自动取消引用。</p></li><li class="listitem"><p>Better support for structure references. With the current
            implementation, a slot can hold the ID of another structure, but
            accessing is awkward. A new version of the <code class="function">get-value</code> function could be written to
            check for references (by looking for
            <em class="replaceable"><code>defstruct</code></em>@<em class="replaceable"><code>number</code></em>),
            and perform automatic dereferencing.</p></li></ul></div></div></div></div></div>
<div id="OEBPS/apbs02.html"><div>
<div class="sect1" title="算术"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apbs02.html.make3-APP-B-SECT-2"></a>算术</h1><h1 class="title"><a></a>Arithmetic</h1></div></div></div><p>在之前的<a id="OEBPS/apbs02.html.make3-APP-B-ITERM-1633" class="indexterm"></a> <a id="OEBPS/apbs02.html.make3-APP-B-ITERM-1634" class="indexterm"></a>部分，我注意到不可能仅使用 make 的本机功能在<em class="command">make</em>中执行算术运算。然后，我展示了如何通过将单词附加到列表并返回列表的长度来实现一个简单的计数器。在我发现增量技巧后不久，Michael Mounteney 发布了一个很酷的技巧，用于在<em class="command">make</em>中对整数执行有限形式的加法。</p><p>In the previous <a class="indexterm"></a> <a class="indexterm"></a>section, I noted that it is not possible to perform
        arithmetic in <em class="command">make</em> using only its
        native features. I then showed how you could implement a simple
        counter by appending words to a list and returning the length of the
        list. Soon after I discovered the increment trick, Michael Mounteney
        posted a cool trick for performing a limited form of addition on
        integers in <em class="command">make</em>.</p><p>他的技巧操纵数轴来计算两个大小为 1 或更大的整数的和。要了解其工作原理，请想象数轴：</p><p>His trick manipulates the number line to compute the sum of two
        integers of size one or greater. To see how this works, imagine the
        number line:</p><a id="OEBPS/apbs02.html.I__tt570"></a><pre class="programlisting">2 3 4 5 6 7 8 9 10 11 12 13 14 15</pre><pre class="programlisting">2 3 4 5 6 7 8 9 10 11 12 13 14 15</pre><p>现在，请注意（如果我们能够获得正确的下标），我们可以通过首先获取从第四个元素到末尾的行的子集，然后选择子集的第五个元素来添加，例如 4 加 5。我们可以使用本机<em class="command">make</em>函数来做到这一点：</p><p>Now, notice that (if we could get the subscripts right), we
        could add, say 4 plus 5, by first taking a subset of the line from the
        fourth element to the end then selecting the fifth element of the
        subset. We can do this with native <em class="command">make</em> functions:</p><a id="OEBPS/apbs02.html.I__tt571"></a><pre class="programlisting">行号 = 2 3 4 5 6 7 8 9 10 11 12 13 14 15
加 = $(单词 $2, $(单词列表 $1, 15, $(number_line)))
四+五 = $(调用加, 4, 5)</pre><pre class="programlisting">number_line = 2 3 4 5 6 7 8 9 10 11 12 13 14 15
plus = $(word $2, $(wordlist $1, 15, $(number_line)))
four+five = $(call plus, 4, 5)</pre><p>非常聪明，迈克尔！请注意，数轴以 2 开头，而不是 0 或 1。您可以看到，如果您
        <code class="function">plus</code>使用 1 和 1 运行该函数，这是必需的。两个下标都将产生第一个元素，并且答案必须是 2，因此，第一个元素列表的 必须是 2。这样做的原因是，对于<code class="function">word</code>和
        <code class="function">wordlist</code>函数，列表的第一个元素的下标是 1 而不是（但我没有费心去证明它）。</p><p>Very clever, Michael! Notice that the number line starts with 2
        rather than 0 or 1. You can see that this is necessary if you run the
        <code class="function">plus</code> function with 1 and 1. Both
        subscripts will yield the first element and the answer must be 2,
        therefore, the first element of the list must be 2. The reason for
        this is that, for the <code class="function">word</code> and
        <code class="function">wordlist</code> functions, the first
        element of the list has subscript 1 rather than (but I haven't
        bothered to prove it).</p><p>现在，给定一条数轴，我们可以执行加法，但是如何在<em class="command">make</em>中创建一条数轴
        ，而不需要手动输入或使用 shell 程序呢？我们可以通过将十位中所有可能的值与个位中所有可能的值组合来创建 00 到 99 之间的所有数字。例如：</p><p>Now, given a number line, we can perform addition, but how do we
        create a number line in <em class="command">make</em>
        without typing it in by hand or using a shell program? We can create
        all numbers between 00 and 99 by combining all possible values in the
        tens place with all possible values in the ones place. For
        example:</p><a id="OEBPS/apbs02.html.I__tt572"></a><pre class="programlisting">make -f - &lt;&lt;&lt; '$(警告 $(foreach i, 0 1 2, $(addprefix $i, 0 1 2)))'
/c/TEMP/Gm002568:1: 00 01 02 10 11 12 20 21 22</pre><pre class="programlisting">make -f - &lt;&lt;&lt; '$(warning $(foreach i, 0 1 2, $(addprefix $i, 0 1 2)))'
/c/TEMP/Gm002568:1:  00 01 02  10 11 12  20 21 22</pre><p>通过包含 0 到 9 的所有数字，我们将生成从 00 到 99 的所有数字。通过将 back<code class="literal">foreach</code>与百位列组合，我们将得到从 000 到 999 的数字，等等。剩下的就是去掉前导零，其中必要的。</p><p>By including all digits 0 through 9, we would produce all
        numbers from 00 to 99. By combining the <code class="literal">foreach</code> again with a hundreds column, we
        would get the numbers from 000 to 999, etc. All that is left is to
        strip the leading zeros where necessary.</p><p>以下是 Mounteney 先生的代码的修改形式，用于生成数轴并定义<code class="function">plus</code>
        和<code class="function">gt</code>运算：</p><p>Here is a modified form of Mr. Mounteney's code to generate a
        number line and define the <code class="function">plus</code>
        and <code class="function">gt</code> operations:</p><a id="OEBPS/apbs02.html.I__tt573"></a><pre class="programlisting"># 组合 - 将一个数字序列与另一个数字序列连接起来
组合 = $(foreach i, $1, $(addprefix $i, $2))

# stripzero - 从每个单词中删除一个前导零
stripzero = $(patsubst 0%,%,$1)

#generate - 生成单词列表中三个元素的所有排列
生成 = $(调用 stripzero, \
             $(调用 stripzero, \
               $(调用组合，$1，\
                 $(调用组合, $1, $1))))

# number_line - 创建从 0 到 999 的数轴
number_line := $(调用生成,0 1 2 3 4 5 6 7 8 9)
长度 := $(单词 $(单词 $(number_line)), $(number_line))

# plus - 使用数轴将两个整数相加
加 = $(单词 $2, \
         $(单词列表$1,$(长度),\
           $(单词列表 3, $(长度), $(number_line))))

# gt - 使用数轴确定 $1 是否大于 $2
gt = $(过滤$1, \
       $(单词列表 3, $(长度), \
         $(单词列表$2,$(长度),$(number_line))))


全部：
        @echo $(call plus,4,7)
        @echo $(if $(call gt,4,7),是,不是)
        @echo $(if $(call gt,7,4),是,不是)
        @echo $(if $(call gt,7,7),是,不是)</pre><pre class="programlisting"># combine - concatentate one sequence of numbers with another
combine = $(foreach i, $1, $(addprefix $i, $2))

# stripzero - Remove one leading zero from each word
stripzero = $(patsubst 0%,%,$1)

# generate - Produce all permutations of three elements from the word list
generate = $(call stripzero,                            \
             $(call stripzero,                          \
               $(call combine, $1,                      \
                 $(call combine, $1, $1))))

# number_line - Create a number line from 0 to 999
number_line := $(call generate,0 1 2 3 4 5 6 7 8 9)
length      := $(word $(words $(number_line)), $(number_line))

# plus - Use the number line to add two integers
plus = $(word $2,                                       \
         $(wordlist $1, $(length),                      \
           $(wordlist 3, $(length), $(number_line))))

# gt - Use the number line to determine if $1 is greater than $2
gt = $(filter $1,                                       \
       $(wordlist 3, $(length),                         \
         $(wordlist $2, $(length), $(number_line))))


all:
        @echo $(call plus,4,7)
        @echo $(if $(call gt,4,7),is,is not)
        @echo $(if $(call gt,7,4),is,is not)
        @echo $(if $(call gt,7,7),is,is not)</pre><p>运行时，<em class="filename">makefile</em>
        会产生：</p><p>When run, the <em class="filename">makefile</em>
        yields:</p><a id="OEBPS/apbs02.html.I__tt574"></a><pre class="programlisting">$ 制作
11
不是
是
不是</pre><pre class="programlisting">$ make
11
is not
is
is not</pre><p>我们可以扩展此代码以包括减法，注意下标反向列表就像向后计数一样。例如，要计算 7 减 4，首先创建数轴子集 0 到 6，将其反转，然后选择第四个元素：</p><p>We can extend this code to include subtraction by noting that
        subscripting a reversed list is just like counting backwards. For
        example, to compute 7 minus 4, first create the number line subset 0
        to 6, reverse it, then select the fourth element:</p><a id="OEBPS/apbs02.html.I__tt575"></a><pre class="programlisting">行号 := 0 1 2 3 4 5 6 7 8 9...
1到6 := 0 1 2 3 4 5 6
反向：= 6 5 4 3 2 1 0
第四项 := 3</pre><pre class="programlisting">number_line := 0 1 2 3 4 5 6 7 8 9...
1through6   := 0 1 2 3 4 5 6
reverse_it  := 6 5 4 3 2 1 0
fourth_item := 3</pre><p><em class="command">make</em>语法中的算法如下
        ：</p><p>Here is the algorithm in <em class="command">make</em>
        syntax:</p><a id="OEBPS/apbs02.html.I__tt576"></a><pre class="programlisting"># 向后 - 逆数轴
向后 := $(调用生成, 9 8 7 6 5 4 3 2 1 0)

# 反向 - 反转单词列表
反向= $(条\
               $(foreach f, \
                 $(单词列表 1, $(长度), $(向后)), \
                 $(单词$f, $1)))

# minus - 计算 $1 减去 $2
减 = $(单词 $2, \
               $(调用反向，\
                 $(单词列表 1, $1, $(number_line))))

减：
        # $(调用减号, 7, 4)</pre><pre class="programlisting"># backwards - a reverse number line
backwards := $(call generate, 9 8 7 6 5 4 3 2 1 0)

# reverse - reverse a list of words
reverse    = $(strip                                     \
               $(foreach f,                              \
                 $(wordlist 1, $(length), $(backwards)), \
                 $(word $f, $1)))

# minus - compute $1 minus $2
minus      = $(word $2,                                \
               $(call reverse,                         \
                 $(wordlist 1, $1, $(number_line))))

minus:
        # $(call minus, 7, 4)</pre><p>乘法和除法留给读者作为练习。</p><p>Multiplication and division are left as an exercise for the
        reader.</p></div></div></div>
<div id="OEBPS/apc.html"><div>
<div class="appendix" title="附录 C. GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apc.html.make3-APP-C"></a>附录 C. GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)</h1><h1 class="title"><a></a>Appendix&nbsp;C.&nbsp;GNU Free Documentation License—GNU Project—Free Software
      Foundation (FSF)</h1></div></div></div><p>版本 1.2，2002 年 11 月</p><p>Version 1.2, November 2002</p><table border="0" summary="Simple list" class="simplelist"><tbody><tr><td>版权所有 © 2000,2001,2002 自由软件基金会, Inc.</td></tr><tr><td>59 Temple Place, Suite 330, 波士顿, MA 02111-1307 美国</td></tr></tbody></table><p>任何人都可以复制和分发<a id="OEBPS/apc.html.make3-APP-C-ITERM-1635" class="indexterm"></a>该许可文档的逐字副本，但不允许更改。</p><p>Everyone is permitted to copy and distribute <a class="indexterm"></a>verbatim copies of this license document, but changing it
      is not allowed.</p><div class="sect1" title="0. 前言"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apc.html.make3-APP-C-SECT-1"></a>0. 前言</h1><h1 class="title"><a></a>0. PREAMBLE</h1></div></div></div><p>本许可证的目的是使手册、教科书或其他功能性和有用的文档在自由意义上“免费”：确保每个人都可以有效地自由地复制和重新分发它，无论是否对其进行修改，无论是商业性还是非商业性。其次，该许可证为作者和出版商保留了一种获得其作品荣誉的方式，同时不被认为对他人所做的修改负责。</p><p>The purpose of this License is to make a manual, textbook, or
        other functional and useful document "free" in the sense of freedom:
        to assure everyone the effective freedom to copy and redistribute it,
        with or without modifying it, either commercially or noncommercially.
        Secondarily, this License preserves for the author and publisher a way
        to get credit for their work, while not being considered responsible
        for modifications made by others.</p><p>该许可证是一种“copyleft”，这意味着该文档的衍生作品本身必须在相同意义上是免费的。它补充了 GNU 通用公共许可证，这是专为自由软件设计的 Copyleft 许可证。</p><p>This License is a kind of "copyleft", which means that
        derivative works of the document must themselves be free in the same
        sense. It complements the GNU General Public License, which is a
        copyleft license designed for free software.</p><p>我们设计此许可证是为了将其用作自由软件的手册，因为自由软件需要自由文档：自由程序应该附带提供与软件相同自由的手册。但本许可不限于软件手册；它可用于任何文本作品，无论主题如何或是否以印刷书籍形式出版。我们主要推荐此许可证用于以指导或参考为目的的作品。</p><p>We have designed this License in order to use it for manuals for
        free software, because free software needs free documentation: a free
        program should come with manuals providing the same freedoms that the
        software does. But this License is not limited to software manuals; it
        can be used for any textual work, regardless of subject matter or
        whether it is published as a printed book. We recommend this License
        principally for works whose purpose is instruction or
        reference.</p></div></div></div></div>
<div id="OEBPS/apcs02.html"><div>
<div class="sect1" title="1. 适用范围和定义"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs02.html.make3-APP-C-SECT-2"></a>1. 适用范围和定义</h1><h1 class="title"><a></a>1. APPLICABILITY AND DEFINITIONS</h1></div></div></div><p>本许可证适用于任何媒介中的任何手册或其他作品，其中包含版权所有者发布的声明，表明可以根据本许可证的条款进行分发。此类通知授予在全球范围内、无期限、免版税的许可，以便在此处规定的条件下使用该作品。下面的“文档”指任何此类手册或作品。任何公众成员都是被许可人，并被称为“您”。如果您按照版权法要求许可的方式复制、修改或分发该作品，则表示您接受该许可。</p><p>This License applies to any manual or other work, in any medium,
        that contains a notice placed by the copyright holder saying it can be
        distributed under the terms of this License. Such a notice grants a
        world-wide, royalty-free license, unlimited in duration, to use that
        work under the conditions stated herein. The "Document", below, refers
        to any such manual or work. Any member of the public is a licensee,
        and is addressed as "you". You accept the license if you copy, modify
        or distribute the work in a way requiring permission under copyright
        law.</p><p>本文档的“修改版本”是指包含本文档或其一部分的任何作品，无论是逐字复制还是经过修改和/或翻译成另一种语言。</p><p>A "Modified Version" of the Document means any work containing
        the Document or a portion of it, either copied verbatim, or with
        modifications and/or translated into another language.</p><p>“第二部分”是文档的指定附录或前言部分，专门处理文档的出版商或作者与文档的整体主题（或相关事项）的关系，并且不包含任何可能直接涉及的内容在整个主题内。 （因此，如果该文档的一部分是数学教科书，则第二部分可能不会解释任何数学。）这种关系可能是与主题或相关事项的历史联系，或者是法律、商业、哲学、伦理的历史联系。或关于他们的政治立场。</p><p>A "Secondary Section" is a named appendix or a front-matter
        section of the Document that deals exclusively with the relationship
        of the publishers or authors of the Document to the Document's overall
        subject (or to related matters) and contains nothing that could fall
        directly within that overall subject. (Thus, if the Document is in
        part a textbook of mathematics, a Secondary Section may not explain
        any mathematics.) The relationship could be a matter of historical
        connection with the subject or with related matters, or of legal,
        commercial, philosophical, ethical or political position regarding
        them.</p><p>“不变部分”是某些次要部分，其标题在说明文档根据本许可证发布的通知中指定为不变部分的标题。如果一个部分不符合上述次要的定义，则不允许将其指定为不变的。该文档可以包含零个不变部分。如果文档没有标识任何不变部分，那么就没有不变部分。</p><p>The "Invariant Sections" are certain Secondary Sections whose
        titles are designated, as being those of Invariant Sections, in the
        notice that says that the Document is released under this License. If
        a section does not fit the above definition of Secondary then it is
        not allowed to be designated as Invariant. The Document may contain
        zero Invariant Sections. If the Document does not identify any
        Invariant Sections then there are none.</p><p>“封面文本”是在通知中列出的某些简短文本段落，如封面文本或封底文本，说明文档是根据本许可证发布的。封面文本最多可包含 5 个单词，封底文本最多可包含 25 个单词。</p><p>The "Cover Texts" are certain short passages of text that are
        listed, as Front-Cover Texts or Back-Cover Texts, in the notice that
        says that the Document is released under this License. A Front-Cover
        Text may be at most 5 words, and a Back-Cover Text may be at most 25
        words.</p><p>文件的“透明”副本是指机器可读的副本，以公众可获得的规范格式表示，适合使用通用文本编辑器或（对于由像素组成的图像）​​通用绘画直接修改文档程序或（对于绘图）一些广泛使用的绘图编辑器，并且适合输入到文本格式化程序或自动转换为适合输入到文本格式化程序的各种格式。以其他透明文件格式制作的副本，其标记或无标记已被安排为阻止或阻止读者进行后续修改，该副本不是透明的。如果图像格式用于任何大量文本，则该图像格式不是透明的。非“透明”的副本称为“不透明”。</p><p>A "Transparent" copy of the Document means a machine-readable
        copy, represented in a format whose specification is available to the
        general public, that is suitable for revising the document
        straightforwardly with generic text editors or (for images composed of
        pixels) generic paint programs or (for drawings) some widely available
        drawing editor, and that is suitable for input to text formatters or
        for automatic translation to a variety of formats suitable for input
        to text formatters. A copy made in an otherwise Transparent file
        format whose markup, or absence of markup, has been arranged to thwart
        or discourage subsequent modification by readers is not Transparent.
        An image format is not Transparent if used for any substantial amount
        of text. A copy that is not "Transparent" is called "Opaque".</p><p>透明副本的合适格式的示例包括无标记的纯 ASCII、Texinfo 输入格式、LaTeX 输入格式、使用公开可用的 DTD 的 SGML 或 XML，以及为人工修改而设计的符合标准的简单 HTML、PostScript 或 PDF。透明图像格式的示例包括 PNG、XCF 和 JPG。不透明格式包括只能由专有文字处理器读取和编辑的专有格式、DTD 和/或处理工具通常不可用的 SGML 或 XML，以及由某些文字处理器生成的机器生成的 HTML、PostScript 或 PDF。仅用于输出目的。</p><p>Examples of suitable formats for Transparent copies include
        plain ASCII without markup, Texinfo input format, LaTeX input format,
        SGML or XML using a publicly available DTD, and standard-conforming
        simple HTML, PostScript or PDF designed for human modification.
        Examples of transparent image formats include PNG, XCF and JPG. Opaque
        formats include proprietary formats that can be read and edited only
        by proprietary word processors, SGML or XML for which the DTD and/or
        processing tools are not generally available, and the
        machine-generated HTML, PostScript or PDF produced by some word
        processors for output purposes only.</p><p>对于印刷书籍，“扉页”是指扉页本身，以及清晰地保存本许可证要求在扉页中显示的材料所需的后续页面。对于没有任何标题页的格式的作品，“标题页”是指靠近作品标题最突出的外观、位于文本正文开头之前的文本。</p><p>The "Title Page" means, for a printed book, the title page
        itself, plus such following pages as are needed to hold, legibly, the
        material this License requires to appear in the title page. For works
        in formats which do not have any title page as such, "Title Page"
        means the text near the most prominent appearance of the work's title,
        preceding the beginning of the body of the text.</p><p>“标题为 XYZ”的部分是指文档的命名子单元，其标题要么恰好是 XYZ，要么在将 XYZ 翻译成另一种语言的文本后面的括号中包含 XYZ。 （这里 XYZ 代表下面提到的特定部分名称，例如“致谢”、“奉献”、“认可”或“历史”。）在修改文档时“保留该部分的标题”意味着它根据此定义，保留“标题为 XYZ”的部分。</p><p>A section "Entitled XYZ" means a named subunit of the Document
        whose title either is precisely XYZ or contains XYZ in parentheses
        following text that translates XYZ in another language. (Here XYZ
        stands for a specific section name mentioned below, such as
        "Acknowledgements", "Dedications", "Endorsements", or "History".) To
        "Preserve the Title" of such a section when you modify the Document
        means that it remains a section "Entitled XYZ" according to this
        definition.</p><p>该文档可能在通知旁边包含保证免责声明，声明本许可证适用于该文档。这些保证免责声明被视为通过引用包含在本许可证中，但仅限于免责保证：这些保证免责声明可能具有的任何其他含义都是无效的，并且对本许可证的含义没有影响。</p><p>The Document may include Warranty Disclaimers next to the notice
        which states that this License applies to the Document. These Warranty
        Disclaimers are considered to be included by reference in this
        License, but only as regards disclaiming warranties: any other
        implication that these Warranty Disclaimers may have is void and has
        no effect on the meaning of this License.</p></div></div></div>
<div id="OEBPS/apcs03.html"><div>
<div class="sect1" title="2. 逐字复制"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs03.html.make3-APP-C-SECT-3"></a>2. 逐字复制</h1><h1 class="title"><a></a>2. VERBATIM COPYING</h1></div></div></div><p>您可以在任何商业或非商业媒介上复制和分发本文档，前提是本许可证、版权声明以及说明本许可证适用于本文档的许可证声明均复制到所有副本中，并且您不添加任何其他条件本许可证的内容。您不得使用技术措施阻碍或控制您制作或分发的副本的阅读或进一步复制。但是，您可以接受补偿以换取副本。如果您分发足够多的副本，您还必须遵守第 3 节中的条件。</p><p>You may copy and distribute the Document in any medium, either
        commercially or noncommercially, provided that this License, the
        copyright notices, and the license notice saying this License applies
        to the Document are reproduced in all copies, and that you add no
        other conditions whatsoever to those of this License. You may not use
        technical measures to obstruct or control the reading or further
        copying of the copies you make or distribute. However, you may accept
        compensation in exchange for copies. If you distribute a large enough
        number of copies you must also follow the conditions in section
        3.</p><p>您还可以在上述相同条件下出借副本，并且可以公开展示副本。</p><p>You may also lend copies, under the same conditions stated
        above, and you may publicly display copies.</p></div></div></div>
<div id="OEBPS/apcs04.html"><div>
<div class="sect1" title="3. 复制数量"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs04.html.make3-APP-C-SECT-4"></a>3. 复制数量</h1><h1 class="title"><a></a>3. COPYING IN QUANTITY</h1></div></div></div><p>如果您发布文档的印刷副本（或通常有印刷封面的介质中的副本），数量超过 100，并且文档的许可通知需要封面文本，则您必须将副本附在封面上，其中清晰易读地载有所有这些内容封面文本：封面文本在封面上，封底文本在封底上。两个封面还必须清楚易读地表明您是这些副本的出版商。封面必须呈现完整的标题，标题的所有文字都同样突出和可见。您还可以在封面上添加其他材料。仅限于封面更改的复制，只要保留文档标题并满足这些条件，在其他方面就可以被视为逐字复制。</p><p>If you publish printed copies (or copies in media that commonly
        have printed covers) of the Document, numbering more than 100, and the
        Document's license notice requires Cover Texts, you must enclose the
        copies in covers that carry, clearly and legibly, all these Cover
        Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
        the back cover. Both covers must also clearly and legibly identify you
        as the publisher of these copies. The front cover must present the
        full title with all words of the title equally prominent and visible.
        You may add other material on the covers in addition. Copying with
        changes limited to the covers, as long as they preserve the title of
        the Document and satisfy these conditions, can be treated as verbatim
        copying in other respects.</p><p>如果任一封面所需的文本太大而无法清晰显示，则应将列出的第一个文本（尽可能多地合理放置）放在实际封面上，并将其余内容继续放在相邻的页面上。</p><p>If the required texts for either cover are too voluminous to fit
        legibly, you should put the first ones listed (as many as fit
        reasonably) on the actual cover, and continue the rest onto adjacent
        pages.</p><p>如果您发布或分发的文档的不透明副本数量超过 100，则必须在每个不透明副本中附上机器可读的透明副本，或者在每个不透明副本中注明一个计算机网络位置，一般网络可从该位置使用公众可以使用公共标准网络协议下载该文档的完整透明副本，无需添加材料。如果您使用后一个选项，当您开始大量分发不透明副本时，您必须采取相当谨慎的步骤，以确保此透明副本将在指定位置保持可访问状态，直到您上次分发不透明副本后至少一年。将该版本的不透明副本（直接或通过您的代理商或零售商）向公众公开。</p><p>If you publish or distribute Opaque copies of the Document
        numbering more than 100, you must either include a machine-readable
        Transparent copy along with each Opaque copy, or state in or with each
        Opaque copy a computer-network location from which the general
        network-using public has access to download using public-standard
        network protocols a complete Transparent copy of the Document, free of
        added material. If you use the latter option, you must take reasonably
        prudent steps, when you begin distribution of Opaque copies in
        quantity, to ensure that this Transparent copy will remain thus
        accessible at the stated location until at least one year after the
        last time you distribute an Opaque copy (directly or through your
        agents or retailers) of that edition to the public.</p><p>我们要求（但不是要求）您在重新分发大量副本之前与文档的作者联系，以便他们有机会为您提供文档的更新版本。</p><p>It is requested, but not required, that you contact the authors
        of the Document well before redistributing any large number of copies,
        to give them a chance to provide you with an updated version of the
        Document.</p></div></div></div>
<div id="OEBPS/apcs05.html"><div>
<div class="sect1" title="4. 修改"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs05.html.make3-APP-C-SECT-5"></a>4. 修改</h1><h1 class="title"><a></a>4. MODIFICATIONS</h1></div></div></div><p>您可以根据上述第 2 节和第 3 节的条件复制和分发本文档的修改版本，前提是您完全按照本许可证发布修改版本，并且修改版本填补了文档的角色，从而许可分发和修改修改后的版本交给拥有该副本的任何人。另外，您必须在修改版本中执行以下操作：</p><p>You may copy and distribute a Modified Version of the Document
        under the conditions of sections 2 and 3 above, provided that you
        release the Modified Version under precisely this License, with the
        Modified Version filling the role of the Document, thus licensing
        distribution and modification of the Modified Version to whoever
        possesses a copy of it. In addition, you must do these things in the
        Modified Version:</p><div class="orderedlist"><ol class="orderedlist"><li class="listitem"><p>在扉页（以及封面，如果有）中使用与文档以及以前版本（如果有的话，应该在文档的历史记录部分中列出）不同的标题。如果该版本的原始发行商允许，您可以使用与先前版本相同的标题。</p></li><li class="listitem"><p>Use in the Title Page (and on the covers, if any) a title
            distinct from that of the Document, and from those of previous
            versions (which should, if there were any, be listed in the
            History section of the Document). You may use the same title as a
            previous version if the original publisher of that version gives
            permission.</p></li><li class="listitem"><p>在扉页上列出作为作者、负责修改版本中修改的作者的一个或多个个人或实体，以及文档的至少五位主要作者（如果文档的主要作者少于五），除非他们免除您的此要求。</p></li><li class="listitem"><p>List on the Title Page, as authors, one or more persons or
            entities responsible for authorship of the modifications in the
            Modified Version, together with at least five of the principal
            authors of the Document (all of its principal authors, if it has
            fewer than five), unless they release you from this
            requirement.</p></li><li class="listitem"><p>在扉页上注明修改版本的出版商名称，即出版商。</p></li><li class="listitem"><p>State on the Title page the name of the publisher of the
            Modified Version, as the publisher.</p></li><li class="listitem"><p>保留文档的所有版权声明。</p></li><li class="listitem"><p>Preserve all the copyright notices of the Document.</p></li><li class="listitem"><p>在其他版权声明旁边添加适合您的修改的版权声明。</p></li><li class="listitem"><p>Add an appropriate copyright notice for your modifications
            adjacent to the other copyright notices.</p></li><li class="listitem"><p>在版权声明之后立即包含一份许可声明，允许公众根据本许可证的条款使用修改版本，其形式如下面的附录所示。</p></li><li class="listitem"><p>Include, immediately after the copyright notices, a license
            notice giving the public permission to use the Modified Version
            under the terms of this License, in the form shown in the Addendum
            below.</p></li><li class="listitem"><p>在该许可通知中保留文档许可通知中给出的不变部分和所需封面文本的完整列表。</p></li><li class="listitem"><p>Preserve in that license notice the full lists of Invariant
            Sections and required Cover Texts given in the Document's license
            notice.</p></li><li class="listitem"><p>包含本许可证的未更改副本。</p></li><li class="listitem"><p>Include an unaltered copy of this License.</p></li><li class="listitem"><p>保留标题为“历史”的部分，保留其标题，并向其中添加一个项目，至少说明标题页上给出的修改版本的标题、年份、新作者和出版商。如果文档中没有标题为“历史”的部分，请创建一个说明标题页上给出的文档标题、年份、作者和出版商，然后添加一个描述上一句中所述的修改版本的项目。</p></li><li class="listitem"><p>Preserve the section Entitled "History", Preserve its Title,
            and add to it an item stating at least the title, year, new
            authors, and publisher of the Modified Version as given on the
            Title Page. If there is no section Entitled "History" in the
            Document, create one stating the title, year, authors, and
            publisher of the Document as given on its Title Page, then add an
            item describing the Modified Version as stated in the previous
            sentence.</p></li><li class="listitem"><p>保留文档中给出的网络位置（如果有），以便公众访问文档的透明副本，同样保留文档中给出的其所基于的先前版本的网络位置。这些可以放在“历史”部分。您可以省略至少在文档本身之前四年发布的作品的网络位置，或者如果它所引用的版本的原始出版商给予许可。</p></li><li class="listitem"><p>Preserve the network location, if any, given in the Document
            for public access to a Transparent copy of the Document, and
            likewise the network locations given in the Document for previous
            versions it was based on. These may be placed in the "History"
            section. You may omit a network location for a work that was
            published at least four years before the Document itself, or if
            the original publisher of the version it refers to gives
            permission.</p></li><li class="listitem"><p>对于任何标题为“致谢”或“奉献”的部分，保留该部分的标题，并在该部分中保留其中给出的每个贡献者致谢和/或奉献的所有实质内容和语气。</p></li><li class="listitem"><p>For any section Entitled "Acknowledgements" or
            "Dedications", Preserve the Title of the section, and preserve in
            the section all the substance and tone of each of the contributor
            acknowledgements and/or dedications given therein.</p></li><li class="listitem"><p>保留文档的所有不变部分，其文本和标题不变。章节编号或同等内容不被视为章节标题的一部分。</p></li><li class="listitem"><p>Preserve all the Invariant Sections of the Document,
            unaltered in their text and in their titles. Section numbers or
            the equivalent are not considered part of the section
            titles.</p></li><li class="listitem"><p>删除任何标题为“认可”的部分。修改版本中可能不包含此类部分。</p></li><li class="listitem"><p>Delete any section Entitled "Endorsements". Such a section
            may not be included in the Modified Version.</p></li><li class="listitem"><p>请勿将任何现有部分的标题重新命名为“认可”或与任何不变部分的标题发生冲突。</p></li><li class="listitem"><p>Do not retitle any existing section to be Entitled
            "Endorsements" or to conflict in title with any Invariant
            Section.</p></li><li class="listitem"><p>保留任何保修免责声明。</p></li><li class="listitem"><p>Preserve any Warranty Disclaimers.</p></li></ol></div><p>如果修改版本包含符合次要部分资格的新的前言部分或附录，并且不包含从文档复制的材料，则您可以选择将这些部分中的部分或全部指定为不变。为此，请将其标题添加到修改版本的许可声明中的不变部分列表中。这些标题必须与任何其他部分标题不同。</p><p>If the Modified Version includes new front-matter sections or
        appendices that qualify as Secondary Sections and contain no material
        copied from the Document, you may at your option designate some or all
        of these sections as invariant. To do this, add their titles to the
        list of Invariant Sections in the Modified Version's license notice.
        These titles must be distinct from any other section titles.</p><p>您可以添加标题为“认可”的部分，前提是它只包含各方对您的修改版本的认可，例如同行评审的声明或文本已被组织批准为标准的权威定义。</p><p>You may add a section Entitled "Endorsements", provided it
        contains nothing but endorsements of your Modified Version by various
        parties—for example, statements of peer review or that the text has
        been approved by an organization as the authoritative definition of a
        standard.</p><p>您可以将最多 5 个单词的段落作为封面文本，将最多 25 个单词的段落作为封底文本添加到修改版本中封面文本列表的末尾。任何一个实体（或通过其安排）只能添加一段封面文本和一段封底文本。如果文档已包含同一封面的封面文本（由您之前添加或由您代表的同一实体做出的安排），则您不得添加其他内容；但您可以在获得添加旧版本的前一发布者的明确许可后更换旧版本。</p><p>You may add a passage of up to five words as a Front-Cover Text,
        and a passage of up to 25 words as a Back-Cover Text, to the end of
        the list of Cover Texts in the Modified Version. Only one passage of
        Front-Cover Text and one of Back-Cover Text may be added by (or
        through arrangements made by) any one entity. If the Document already
        includes a cover text for the same cover, previously added by you or
        by arrangement made by the same entity you are acting on behalf of,
        you may not add another; but you may replace the old one, on explicit
        permission from the previous publisher that added the old one.</p><p>文档的作者和出版商未根据本许可证授予使用其姓名进行任何修改版本的宣传或主张或暗示认可的许可。</p><p>The author(s) and publisher(s) of the Document do not by this
        License give permission to use their names for publicity for or to
        assert or imply endorsement of any Modified Version.</p></div></div></div>
<div id="OEBPS/apcs06.html"><div>
<div class="sect1" title="5. 合并文件"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs06.html.make3-APP-C-SECT-6"></a>5. 合并文件</h1><h1 class="title"><a></a>5. COMBINING DOCUMENTS</h1></div></div></div><p>您可以根据上述第 4 节中针对修改版本定义的条款，将本文档与根据本许可证发布的其他文档合并，前提是您在组合中包含所有未经修改的原始文档的所有不变部分，并将它们全部列出作为您的组合作品的许可声明中的不变部分，并且您保留其所有保证免责声明。</p><p>You may combine the Document with other documents released under
        this License, under the terms defined in section 4 above for modified
        versions, provided that you include in the combination all of the
        Invariant Sections of all of the original documents, unmodified, and
        list them all as Invariant Sections of your combined work in its
        license notice, and that you preserve all their Warranty
        Disclaimers.</p><p>组合作品只需包含本许可证的一份副本，多个相同的不变部分可以用一份副本替换。如果存在多个具有相同名称但内容不同的不变部分，请通过在其末尾的括号中添加该部分的原始作者或出版商的名称（如果已知），使每个此类部分的标题唯一，否则为唯一的号码。对组合作品的许可声明中不变章节列表中的章节标题进行相同的调整。</p><p>The combined work need only contain one copy of this License,
        and multiple identical Invariant Sections may be replaced with a
        single copy. If there are multiple Invariant Sections with the same
        name but different contents, make the title of each such section
        unique by adding at the end of it, in parentheses, the name of the
        original author or publisher of that section if known, or else a
        unique number. Make the same adjustment to the section titles in the
        list of Invariant Sections in the license notice of the combined
        work.</p><p>合并时，必须将各原始文件中任意标题为“历史”的章节合并起来，形成一个标题为“历史”的章节；同样，合并任何标题为“致谢”的部分和任何标题为“奉献”的部分。您必须删除所有标题为“认可”的部分。</p><p>In the combination, you must combine any sections Entitled
        "History" in the various original documents, forming one section
        Entitled "History"; likewise combine any sections Entitled
        "Acknowledgements", and any sections Entitled "Dedications". You must
        delete all sections Entitled "Endorsements."</p></div></div></div>
<div id="OEBPS/apcs07.html"><div>
<div class="sect1" title="6. 文件收集"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs07.html.make3-APP-C-SECT-7"></a>6. 文件收集</h1><h1 class="title"><a></a>6. COLLECTIONS OF DOCUMENTS</h1></div></div></div><p>您可以制作一个包含本文档和根据本许可证发布的其他文档的集合，并用集合中包含的单个副本替换各个文档中本许可证的各个副本，前提是您遵循本许可证的规则在所有其他方面逐字复制每份文件。</p><p>You may make a collection consisting of the Document and other
        documents released under this License, and replace the individual
        copies of this License in the various documents with a single copy
        that is included in the collection, provided that you follow the rules
        of this License for verbatim copying of each of the documents in all
        other respects.</p><p>您可以从此类集合中提取单个文档，并根据本许可证将其单独分发，前提是您将本许可证的副本插入到提取的文档中，并在有关逐字复制该文档的所有其他方面遵循本许可证。</p><p>You may extract a single document from such a collection, and
        distribute it individually under this License, provided you insert a
        copy of this License into the extracted document, and follow this
        License in all other respects regarding verbatim copying of that
        document.</p></div></div></div>
<div id="OEBPS/apcs08.html"><div>
<div class="sect1" title="7. 与独立作品的聚合"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs08.html.make3-APP-C-SECT-8"></a>7. 与独立作品的聚合</h1><h1 class="title"><a></a>7. AGGREGATION WITH INDEPENDENT WORKS</h1></div></div></div><p>如果由汇编产生的版权不用于限制合法权利，则在存储或分发介质的卷中或之上对本文档或其衍生品与其他单独且独立的文档或作品的汇编称为“集合体”汇编的用户超出了个别作品允许的范围。当文档包含在一个集合中时，本许可证不适用于集合中的其他作品，这些作品本身不是该文档的衍生作品。</p><p>A compilation of the Document or its derivatives with other
        separate and independent documents or works, in or on a volume of a
        storage or distribution medium, is called an "aggregate" if the
        copyright resulting from the compilation is not used to limit the
        legal rights of the compilation's users beyond what the individual
        works permit. When the Document is included in an aggregate, this
        License does not apply to the other works in the aggregate which are
        not themselves derivative works of the Document.</p><p>如果第 3 节的封面文本要求适用于文档的这些副本，则如果文档少于整个聚合的一半，则文档的封面文本可以放置在将文档括在聚合内的封面上，或者如果文档为电子形式，则封面的电子等效项。否则，它们必须出现在支撑整个聚合体的印刷封面上。</p><p>If the Cover Text requirement of section 3 is applicable to
        these copies of the Document, then if the Document is less than one
        half of the entire aggregate, the Document's Cover Texts may be placed
        on covers that bracket the Document within the aggregate, or the
        electronic equivalent of covers if the Document is in electronic form.
        Otherwise they must appear on printed covers that bracket the whole
        aggregate.</p></div></div></div>
<div id="OEBPS/apcs09.html"><div>
<div class="sect1" title="8. 翻译"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs09.html.make3-APP-C-SECT-9"></a>8. 翻译</h1><h1 class="title"><a></a>8. TRANSLATION</h1></div></div></div><p>翻译被视为一种修改，因此您可以根据第 4 节的条款分发文档的翻译版本。用翻译替换不变部分需要获得其版权所有者的特别许可，但除了以下内容之外，您还可以包括部分或全部不变部分的翻译这些不变部分的原始版本。您可以包含本许可证的翻译以及文档中的所有许可证声明以及任何保证免责声明，前提是您还包含本许可证的原始英文版本以及这些通知和免责声明的原始版本。如果本许可证或通知或免责声明的翻译版本与原始版本之间存在分歧，则以原始版本为准。</p><p>Translation is considered a kind of modification, so you may
        distribute translations of the Document under the terms of section 4.
        Replacing Invariant Sections with translations requires special
        permission from their copyright holders, but you may include
        translations of some or all Invariant Sections in addition to the
        original versions of these Invariant Sections. You may include a
        translation of this License, and all the license notices in the
        Document, and any Warranty Disclaimers, provided that you also include
        the original English version of this License and the original versions
        of those notices and disclaimers. In case of a disagreement between
        the translation and the original version of this License or a notice
        or disclaimer, the original version will prevail.</p><p>如果文档中的某个部分的标题为“致谢”、“奉献”或“历史”，则保留其标题（第 1 节）的要求（第 4 节）通常需要更改实际标题。</p><p>If a section in the Document is Entitled "Acknowledgements",
        "Dedications", or "History", the requirement (section 4) to Preserve
        its Title (section 1) will typically require changing the actual
        title.</p></div></div></div>
<div id="OEBPS/apcs10.html"><div>
<div class="sect1" title="9. 终止"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs10.html.make3-APP-C-SECT-10"></a>9. 终止</h1><h1 class="title"><a></a>9. TERMINATION</h1></div></div></div><p>除非本许可证明确规定，否则您不得复制、修改、再许可或分发本文档。任何其他复制、修改、再许可或分发本文档的尝试均无效，并将自动终止您在本许可证下的权利。但是，根据本许可证从您那里收到副本或权利的各方只要完全遵守规定，其许可证就不会被终止。</p><p>You may not copy, modify, sublicense, or distribute the Document
        except as expressly provided for under this License. Any other attempt
        to copy, modify, sublicense or distribute the Document is void, and
        will automatically terminate your rights under this License. However,
        parties who have received copies, or rights, from you under this
        License will not have their licenses terminated so long as such
        parties remain in full compliance.</p></div></div></div>
<div id="OEBPS/apcs11.html"><div>
<div class="sect1" title="10. 本许可证的未来修订"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/apcs11.html.make3-APP-C-SECT-11"></a>10. 本许可证的未来修订</h1><h1 class="title"><a></a>10. FUTURE REVISIONS OF THIS LICENSE</h1></div></div></div><p>自由软件基金会可能会不时发布 GNU 自由文档许可证的新修订版本。此类新版本在精神上与当前版本相似，但在解决新问题或疑虑方面可能在细节上有所不同。请参阅<a class="ulink" href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>。</p><p>The Free Software Foundation may publish new, revised versions
        of the GNU Free Documentation License from time to time. Such new
        versions will be similar in spirit to the present version, but may
        differ in detail to address new problems or concerns. See <a class="ulink" href="http://www.gnu.org/copyleft/">http://www.gnu.org/copyleft/</a>.</p><p>每个版本的许可证都有一个独特的版本号。如果文档指定本许可证的特定编号版本“或任何更高版本”适用于它，您可以选择遵循该指定版本或任何已发布的更高版本（不作为草案）由自由软件基金会制定。如果文档没有指定本许可证的版本号，您可以选择任何版本
        <a id="OEBPS/apcs11.html.make3-APP-C-ITERM-1636" class="indexterm"></a>曾经由自由软件基金会发布过（不是草稿）。</p><p>Each version of the License is given a distinguishing version
        number. If the Document specifies that a particular numbered version
        of this License "or any later version" applies to it, you have the
        option of following the terms and conditions either of that specified
        version or of any later version that has been published (not as a
        draft) by the Free Software Foundation. If the Document does not
        specify a version number of this License, you may choose any version
        <a class="indexterm"></a>ever published (not as a
        draft) by the Free Software Foundation.</p></div></div></div>
<div id="OEBPS/ix01.html"><div>
<div class="index" title="指数"><div class="titlepage"><div><div><h1 class="title"><a id="OEBPS/ix01.html.id3179703"></a>指数</h1><h1 class="title"><a></a>Index</h1></div></div></div><div class="note" title="关于数字索引的说明"><h3 class="title">关于数字索引的说明</h3><h3 class="title">A note on the digital index</h3><p>索引条目中的链接显示为该条目所在的部分标题。由于某些部分具有多个索引标记，因此一个条目具有多个指向同一部​​分的链接并不罕见。单击任何链接将直接转到文本中出现标记的位置。</p><p>A link in an index entry is displayed as the section title in which that entry appears. Because some sections have multiple index markers, it is not unusual for an entry to have several links to the same section. Clicking on any link will take you directly to the place in the text in which the marker appears.</p></div><div class="index"><div class="indexdiv"><h3>符号</h3><h3>Symbols</h3><dl><dt>$%自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-910">自动变量</a></dt><dt>$% automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-910">Automatic Variables</a></dt><dt>$(OBJECTS) 变量，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-956">静态模式规则</a></dt><dt>$(OBJECTS) variable, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-956">Static Pattern Rules</a></dt><dt>$* 自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-915">自动变量</a></dt><dt>$* automatic variables, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-915">Automatic Variables</a></dt><dt>$+ 自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-914">自动变量</a></dt><dt>$+ automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-914">Automatic Variables</a></dt><dt>$&lt; 自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-911">自动变量</a></dt><dt>$&lt; automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-911">Automatic Variables</a></dt><dt>$？自动变量,<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-912">自动变量</a></dt><dt>$? automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-912">Automatic Variables</a></dt><dt>$@自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-909">自动变量</a></dt><dt>$@ automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-909">Automatic Variables</a></dt><dt>$^自动变量，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-913">自动变量</a></dt><dt>$^ automatic variable, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-913">Automatic Variables</a></dt><dt>%（百分比）字符，模式规则，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-946">模式</a></dt><dt>% (percent) character, pattern rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-946">The Patterns</a></dt><dt>+（加）命令修饰符，<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1321">命令修饰符</a></dt><dt>+ (plus) command modifier, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1321">Command Modifiers</a></dt><dt>+=（附加）运算符，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1057">其他类型的赋值</a></dt><dt>+= (append) operator, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1057">Other Types of Assignment</a></dt><dt>-（破折号）命令前缀、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1318">命令修饰符</a></dt><dt>- (dash) command prefix, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1318">Command Modifiers</a></dt><dt>--always-make 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1610">运行 make</a></dt><dt>--always-make option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1610">Running make</a></dt><dt>--print-data-base 选项，调试和，<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1589">--print-data-base</a></dt><dt>--print-data-base option, debugging and, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1589">—print-data-base</a></dt><dt>？ （问号）通配符，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-849">通配​​符</a></dt><dt>? (question mark) wildcard, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-849">Wildcards</a></dt><dt>?=（条件变量赋值运算符），<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1055">其他类型的赋值</a></dt><dt>?= (conditional variable assignment operator), <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1055">Other Types of Assignment</a></dt><dt>?= 运算符、环境变量、<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1094">变量从何而来</a></dt><dt>?= operator, environment variables, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1094">Where Variables Come From</a></dt><dt>@命令前缀、echo 和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1315">命令修饰符</a></dt><dt>@ command prefix, echo and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1315">Command Modifiers</a></dt><dt>@标志，性能和，<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1542">禁用@</a></dt><dt>@ sign, performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1542">Disabling @</a></dt><dt>^（波形符）通配符、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-853">通配符</a></dt><dt>^ (tilde) wildcard, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-853">Wildcards</a></dt><dt><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1041">变量、变量和宏</a>中的 { }（花括号）<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1041"></a></dt><dt>{ } (curly braces) in variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1041">Variables and Macros</a></dt></dl></div><div class="indexdiv"><h3>A</h3><h3>A</h3><dl><dt>add-manifest 函数、jar、<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1508">管理 Jars</a></dt><dt>add-manifest function, jars, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1508">Managing Jars</a></dt><dt>addprefix 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1234">文件名函数</a></dt><dt>addprefix function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1234">Filename Functions</a></dt><dt>addsuffix 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1230">文件名函数</a></dt><dt>addsuffix function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1230">Filename Functions</a></dt><dt>所有目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-879">虚假目标</a></dt><dt>all target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-879">Phony Targets</a></dt><dt>ALL_TREES变量，<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1452">支持多个二叉树</a></dt><dt>ALL_TREES variable, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1452">Supporting Multiple Binary Trees</a></dt><dt>蚂蚁（Java），<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1475">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1478">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1480">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1486">蚂蚁</a></dt><dt>Ant (Java), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1475">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1478">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1480">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1486">Ant</a></dt><dd><dl><dt>构建文件、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1478">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">Ant</a></dt><dd><dl><dt>mkdir 程序、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">Ant</a></dt></dl></dd><dt>可移植性，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1486">蚂蚁</a></dt><dt>任务，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1480">蚂蚁</a></dt></dl></dd><dd><dl><dt>build files, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1478">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">Ant</a></dt><dd><dl><dt>mkdir program, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1483">Ant</a></dt></dl></dd><dt>portability, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1486">Ant</a></dt><dt>tasks, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1480">Ant</a></dt></dl></dd><dt>任何角色规则，<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-816">最小化重建</a></dt><dt>any character rule, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-816">Minimizing Rebuilds</a></dt><dt>追加运算符 (+=)、<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1058">其他类型的赋值</a></dt><dt>append operator (+=), <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1058">Other Types of Assignment</a></dt><dt>ar 命令、存档库、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1014">管理库</a></dt><dt>ar command, archive libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1014">Managing Libraries</a></dt><dt>档案馆、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1011">图书馆管理</a></dt><dt>archive libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1011">Managing Libraries</a></dt><dt>归档成员、自动变量和<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-905">自动变量</a></dt><dt>archive members, automatic variables and, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-905">Automatic Variables</a></dt><dt>参数、作为内置函数的模式、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1162">内置函数</a></dt><dt>arguments, patterns as built-in functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1162">Built-in Functions</a></dt><dt>算术、增量、<a class="indexterm" href="#OEBPS/apbs02.html.make3-APP-B-ITERM-1633">算术</a></dt><dt>arithmetic, increments, <a class="indexterm" href="#OEBPS/apbs02.html.make3-APP-B-ITERM-1633">Arithmetic</a></dt><dt>数组、文件数组和命令行限制、<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1362">命令行限制</a></dt><dt>arrays, files array and command line limits, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1362">Command-Line Limits</a></dt><dt>断言函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1251">流程控制</a></dt><dt>assert function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1251">Flow Control</a></dt><dt>automake工具，<a class="indexterm" href="#OEBPS/ch07s05.html.make3-CHP-7-ITERM-1441">Automake</a></dt><dt>automake tool, <a class="indexterm" href="#OEBPS/ch07s05.html.make3-CHP-7-ITERM-1441">Automake</a></dt><dt>自动变量、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-893">空目标</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-900">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-903">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-906">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-907">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-931">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-932">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1095">变量来自哪里</a></dt><dt>automatic variables, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-893">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-900">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-903">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-906">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-907">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-931">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-932">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1095">Where Variables Come From</a></dt><dd><dl><dt>档案成员、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-906">自动变量</a></dt><dt>空目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-893">空目标</a></dt><dt>先决条件，<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-907">自动变量</a></dt><dt>目标和<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-903">自动变量</a></dt><dt>VPATH 和，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-931">使用 VPATH 和 vpath 查找文件</a></dt><dt>vpath 和，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-932">使用 VPATH 和 vpath 查找文件</a></dt></dl></dd><dd><dl><dt>archive members, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-906">Automatic Variables</a></dt><dt>empty targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-893">Empty Targets</a></dt><dt>prerequisites, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-907">Automatic Variables</a></dt><dt>targets and, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-903">Automatic Variables</a></dt><dt>VPATH and, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-931">Finding Files with VPATH and vpath</a></dt><dt>vpath and, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-932">Finding Files with VPATH and vpath</a></dt></dl></dd><dt>awk 命令、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-868">虚假目标</a></dt><dt>awk command, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-868">Phony Targets</a></dt></dl></div><div class="indexdiv"><h3>乙</h3><h3>B</h3><dl><dt>基本名称函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1227">文件名函数</a></dt><dt>basename function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1227">Filename Functions</a></dt><dt>bash shell、基准测试和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1524">基准测试</a></dt><dt>bash shell, benchmarking and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1524">Benchmarking</a></dt><dt><a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1523">基准</a>测试、基准<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1525">测试</a>、基准测试、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1526">基准测试</a>、基准测试、基准测试、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1528">基准</a><a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1530">测试</a></dt><dt>benchmarking, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1523">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1525">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1526">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1528">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1530">Benchmarking</a></dt><dd><dl><dt>bash shell，<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1525">基准测试</a></dt><dt>Cygwin 和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1526">基准测试</a></dt><dt>subst 函数调用和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1530">基准测试</a></dt><dt>变量分配速度，<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1528">基准测试</a></dt></dl></dd><dd><dl><dt>bash shell, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1525">Benchmarking</a></dt><dt>Cygwin and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1526">Benchmarking</a></dt><dt>subst function calls and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1530">Benchmarking</a></dt><dt>variable assignment speed, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1528">Benchmarking</a></dt></dl></dd><dt>二叉树、<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1405">要求</a>、<a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1407">文件系统布局</a>、<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1443">分离源代码和二进制文件</a>、<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1444">困难的方法</a>、<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1451">支持多个二叉树</a>、<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1454">支持多个二叉树</a>、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1460">部分源树</a></dt><dt>binary trees, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1405">Requirements</a>, <a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1407">Filesystem Layout</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1443">Separating Source and Binary</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1444">The Hard Way</a>, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1451">Supporting Multiple Binary Trees</a>, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1454">Supporting Multiple Binary Trees</a>, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1460">Partial Source Trees</a></dt><dd><dl><dt>ALL_TREES变量，<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1454">支持多二叉树</a></dt><dt>文件系统布局和<a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1407">文件系统布局</a></dt><dt>multiple，<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1451">支持多个二叉树</a></dt><dt>搜索，<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1460">部分源树</a></dt><dt>分开，<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1405">要求</a></dt><dt>源树分离，<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1443">分离源代码和二进制文件</a>，<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1444">困难的方法</a></dt></dl></dd><dd><dl><dt>ALL_TREES variables, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1454">Supporting Multiple Binary Trees</a></dt><dt>filesystem layout and, <a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1407">Filesystem Layout</a></dt><dt>multiple, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1451">Supporting Multiple Binary Trees</a></dt><dt>searches, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1460">Partial Source Trees</a></dt><dt>separate, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1405">Requirements</a></dt><dt>source tree separation, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1443">Separating Source and Binary</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1444">The Hard Way</a></dt></dl></dd><dt>book makefile、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1551">Book Makefile</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1552">Book Makefile</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1556">XML 预处理</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1559">XML 预处理</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1561">生成输出</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1564">验证源</a></dt><dt>book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1551">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1552">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1556">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1559">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1561">Generating Output</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1564">Validating the Source</a></dt><dd><dl><dt>m4 宏和<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1559">XML 预处理</a></dt><dt>输出生成，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1561">生成输出</a></dt><dt>源验证，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1564">验证源</a></dt><dt>XML 预处理, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1556">XML 预处理</a></dt></dl></dd><dd><dl><dt>m4 macros and, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1559">XML Preprocessing</a></dt><dt>output generation, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1561">Generating Output</a></dt><dt>source validation, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1564">Validating the Source</a></dt><dt>XML preprocessing, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1556">XML Preprocessing</a></dt></dl></dd><dt>瓶颈、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1533">识别和处理瓶颈</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1535">识别和处理瓶颈</a></dt><dt>bottlenecks, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1533">Identifying and Handling Bottlenecks</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1535">Identifying and Handling Bottlenecks</a></dt><dd><dl><dt>依赖关系以及<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1535">识别和处理瓶颈</a></dt></dl></dd><dd><dl><dt>dependencies and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1535">Identifying and Handling Bottlenecks</a></dt></dl></dd><dt>构建文件、XML、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1476">Ant</a></dt><dt>build files, XML, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1476">Ant</a></dt><dt>构建目标、递归 make 以及<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1379">构建其他目标</a></dt><dt>build targets, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1379">Building Other Targets</a></dt><dt>build-classpath 函数，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1503">设置 CLASSPATH</a></dt><dt>build-classpath function, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1503">Setting CLASSPATH</a></dt><dt>构建、<a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1409">自动化构建和测试</a>、<a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1410">自动化构建和测试</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1576">配置与构建</a></dt><dt>builds, <a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1409">Automating Builds and Testing</a>, <a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1410">Automating Builds and Testing</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1576">Configuration Versus Building</a></dt><dd><dl><dt>自动化，<a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1409">自动化构建和测试</a></dt><dt>Linux 内核 makefile，<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1576">配置与构建</a></dt><dt>测试、<a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1410">自动化构建和测试</a></dt></dl></dd><dd><dl><dt>automation, <a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1409">Automating Builds and Testing</a></dt><dt>Linux kernel makefile, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1576">Configuration Versus Building</a></dt><dt>testing, <a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1410">Automating Builds and Testing</a></dt></dl></dd><dt>内置函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1154">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1275">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1157">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1160">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1164">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1211">文件名函数</a></dt><dt>built-in functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1154">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1275">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1157">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1160">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1164">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1211">Filename Functions</a></dt><dd><dl><dt>文件名和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1211">文件名函数</a></dt><dt>模式作为参数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1160">内置函数</a></dt><dt>字符串函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1164">字符串函数</a></dt><dt>语法、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1157">内置函数</a></dt></dl></dd><dd><dl><dt>filenames and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1211">Filename Functions</a></dt><dt>patterns as arguments, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1160">Built-in Functions</a></dt><dt>string functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1164">String Functions</a></dt><dt>syntax, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1157">Built-in Functions</a></dt></dl></dd><dt>内置规则、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-943">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-944">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-968">使用隐式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-979">规则结构</a></dt><dt>built-in rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-943">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-944">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-968">Working with Implicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-979">Rule Structure</a></dt><dd><dl><dt>（另见规则）</dt><dt>隐式规则，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-968">使用隐式规则</a></dt><dt>变量，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-979">规则结构</a></dt></dl></dd><dd><dl><dt>(see also rules)</dt><dt>implicit rules, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-968">Working with Implicit Rules</a></dt><dt>variables, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-979">Rule Structure</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>C</h3><h3>C</h3><dl><dt>-C 目录选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1611">运行 make</a></dt><dt>-C directory
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1611">Running make</a></dt><dt>调用函数、通配符和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-858">通配符</a></dt><dt>calling functions, wildcards and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-858">Wildcards</a></dt><dt>固定序列、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1060">宏</a>（请参阅宏）</dt><dt>canned sequences, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1060">Macros</a> (see macros)</dt><dt><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1035">变量、变量和宏</a>中区分大小写<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1035"></a></dt><dt>case-sensitivity in variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1035">Variables and Macros</a></dt><dt>链接规则、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-940">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-971">使用隐式规则</a></dt><dt>chaining rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-940">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-971">Working with Implicit Rules</a></dt><dd><dl><dt>中间文件和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-971">使用隐式规则</a></dt></dl></dd><dd><dl><dt>intermediate files and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-971">Working with Implicit Rules</a></dt></dl></dd><dt>字符类、通配符和、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-851">通配符</a></dt><dt>character classes, wildcards and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-851">Wildcards</a></dt><dt><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1033">变量、变量和宏</a>中的字符<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1033"></a></dt><dt>characters in variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1033">Variables and Macros</a></dt><dt>检查目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-885">虚假目标</a></dt><dt>check target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-885">Phony Targets</a></dt><dt>循环引用、库、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1026">使用库作为先决条件</a></dt><dt>circular references, libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1026">Using Libraries as Prerequisites</a></dt><dt>循环性、libraires、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1027">使用库作为先决条件</a></dt><dt>circularities, libraires, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1027">Using Libraries as Prerequisites</a></dt><dt>CLASSPATH 变量、Java makefile、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1498">设置 CLASSPATH</a></dt><dt>CLASSPATH variable, Java makefile, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1498">Setting CLASSPATH</a></dt><dt>干净目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-881">虚假目标</a></dt><dt>clean target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-881">Phony Targets</a></dt><dt>代码、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1383">避免重复代码</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">良好编码实践</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">防御性编码</a></dt><dt>code, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1383">Avoiding Duplicate Code</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">Good Coding Practices</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">Defensive Coding</a></dt><dd><dl><dt>调试、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">良好编码实践</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">防御性编码</a></dt><dd><dl><dt>防御性编码,<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">防御性编码</a></dt><dt>为《<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">良好编码实践》写作</a></dt></dl></dd><dt>复制、递归 make 以及<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1383">避免重复代码</a></dt></dl></dd><dd><dl><dt>debugging, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">Good Coding Practices</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">Defensive Coding</a></dt><dd><dl><dt>defensive coding, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1595">Defensive Coding</a></dt><dt>writing for, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1593">Good Coding Practices</a></dt></dl></dd><dt>duplicating, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1383">Avoiding Duplicate Code</a></dt></dl></dd><dt>命令脚本、<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-821">基本 Makefile 语法</a>、<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-822">基本 Makefile 语法</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1302">解析命令</a>、<a class="indexterm" href="#OEBPS/ch05s05.html.make3-CHP-5-ITERM-1357">评估命令</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1604">命令脚本中的错误</a></dt><dt>command scripts, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-821">Basic Makefile Syntax</a>, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-822">Basic Makefile Syntax</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1302">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05s05.html.make3-CHP-5-ITERM-1357">Evaluating Commands</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1604">Errors in Command Scripts</a></dt><dd><dl><dt>（另请参阅脚本）</dt><dt>错误消息、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1604">命令脚本中的错误</a></dt><dt>评估，<a class="indexterm" href="#OEBPS/ch05s05.html.make3-CHP-5-ITERM-1357">评估命令</a></dt><dt>解析和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1302">解析命令</a></dt></dl></dd><dd><dl><dt>(see also scripts)</dt><dt>error messages, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1604">Errors in Command Scripts</a></dt><dt>evaluation, <a class="indexterm" href="#OEBPS/ch05s05.html.make3-CHP-5-ITERM-1357">Evaluating Commands</a></dt><dt>parsing and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1302">Parsing Commands</a></dt></dl></dd><dt>命令行,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-793">如何编写简单的 Makefile</a> ,<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1089">变量来自哪里</a>,<a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1334">使用哪个 Shell</a> ,<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1358">命令行限制</a>,<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">命令行限制</a>,<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1371">命令行选项</a>,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1572">命令行选项</a>,<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1587">命令行选项</a></dt><dt>command-line, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-793">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1089">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1334">Which Shell to Use</a>, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1358">Command-Line Limits</a>, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">Command-Line Limits</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1371">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1572">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1587">Command-Line Options</a></dt><dd><dl><dt>调试选项、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1587">命令行选项</a></dt><dt>限制,<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1358">命令行限制</a>,<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">命令行限制</a></dt><dd><dl><dt>echo 命令行，<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">命令行限制</a></dt></dl></dd><dt>Linux 内核 makefile 选项、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1572">命令行选项</a></dt><dt>递归 make and，<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1371">命令行选项</a></dt><dt>子 shell，<a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1334">使用哪个 Shell</a></dt><dt>目标作为参数，<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-793">如何编写简单的 Makefile</a></dt><dt>变量定义以及<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1089">变量从何而来</a></dt></dl></dd><dd><dl><dt>debugging options, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1587">Command-Line Options</a></dt><dt>limits, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1358">Command-Line Limits</a>, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">Command-Line Limits</a></dt><dd><dl><dt>echo command line, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1359">Command-Line Limits</a></dt></dl></dd><dt>Linux kernel makefile options, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1572">Command-Line Options</a></dt><dt>recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1371">Command-Line Options</a></dt><dt>subshells, <a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1334">Which Shell to Use</a></dt><dt>targets as arguments, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-793">How to Write a Simple Makefile</a></dt><dt>variable definition and, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1089">Where Variables Come From</a></dt></dl></dd><dt>命令,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-803">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-804">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-871">假目标</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-872">假目标</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-988">一个简单的帮助命令</a>,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1015">管理库</a>,<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1077">扩展变量时</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1300">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1309">连续长命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1311">连续长命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1319">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1326">错误</a><a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1324">和中断</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1330">错误和中断</a>,错误和中断,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1331">错误和中断</a>,<a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338">空命令</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339">命令环境</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">命令环境</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">命令环境</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">命令环境</a>,<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608">覆盖目标命令</a><a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1326"></a><a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1330"></a><a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1331"></a><a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349"></a><a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608"></a></dt><dt>commands, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-803">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-804">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-871">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-872">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-988">A Simple Help Command</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1015">Managing Libraries</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1077">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1300">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1309">Continuing Long Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1311">Continuing Long Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1319">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1324">Errors and Interrupts</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1326">Errors and Interrupts</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1330">Errors and Interrupts</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1331">Errors and Interrupts</a>, <a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338">Empty Commands</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608">Overriding Commands for Target</a></dt><dd><dl><dt>ar（档案库），<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1015">管理图书馆</a></dt><dt>awk、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-872">虚假目标</a></dt><dt>df、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-871">虚假目标</a></dt><dt>空，<a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338">空命令</a></dt><dt>环境、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">命令环境</a></dt><dd><dl><dt>文件描述符、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">命令环境</a></dt><dt>MAKEFLAGS 变量，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">命令环境</a></dt><dt>MAKELEVEL 变量，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">命令环境</a></dt></dl></dd><dt>忽略<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1319">命令修饰符中的错误</a></dt><dt>help，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-988">一个简单的帮助命令</a></dt><dt>长、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1311">连续的长命令</a></dt><dt>制作、执行顺序、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-803">目标和先决条件</a></dt><dt>makefile、执行顺序、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-804">目标和先决条件</a></dt><dt>多行、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1331">错误和中断</a></dt><dt>无操作、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1330">错误和中断</a></dt><dt>选项、错误以及<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1326">错误和中断</a></dt><dt>解析,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1300">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">解析命令</a></dt><dd><dl><dt>命令脚本和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">解析命令</a></dt><dt>编辑器和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">解析命令</a></dt></dl></dd><dt>前缀,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">命令修饰符</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">命令修饰符</a></dt><dd><dl><dt>+（加号），<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">命令修饰符</a></dt><dt>-（破折号），<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">命令修饰符</a></dt><dt>@,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">命令修饰符</a></dt></dl></dd><dt>shell、序列、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1309">连续长命令</a></dt><dt>状态码、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1324">错误和中断</a></dt><dt>目标、覆盖、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608">目标的覆盖命令</a></dt><dt>变量扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1077">当变量扩展时</a></dt></dl></dd><dd><dl><dt>ar (archive library), <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1015">Managing Libraries</a></dt><dt>awk, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-872">Phony Targets</a></dt><dt>df, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-871">Phony Targets</a></dt><dt>empty, <a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1338">Empty Commands</a></dt><dt>environments, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1339">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">Command Environment</a></dt><dd><dl><dt>file descriptors, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1349">Command Environment</a></dt><dt>MAKEFLAGS variable, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1341">Command Environment</a></dt><dt>MAKELEVEL variable, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1345">Command Environment</a></dt></dl></dd><dt>errors in, ignoring, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1319">Command Modifiers</a></dt><dt>help, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-988">A Simple Help Command</a></dt><dt>long, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1311">Continuing Long Commands</a></dt><dt>make, execution order, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-803">Targets and Prerequisites</a></dt><dt>makefile, execution order, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-804">Targets and Prerequisites</a></dt><dt>multiline, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1331">Errors and Interrupts</a></dt><dt>no-op, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1330">Errors and Interrupts</a></dt><dt>options, errors and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1326">Errors and Interrupts</a></dt><dt>parsing, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1300">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">Parsing Commands</a></dt><dd><dl><dt>command scripts and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1305">Parsing Commands</a></dt><dt>editors and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1306">Parsing Commands</a></dt></dl></dd><dt>prefixes, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">Command Modifiers</a></dt><dd><dl><dt>+ (plus), <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1322">Command Modifiers</a></dt><dt>- (dash), <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1316">Command Modifiers</a></dt><dt>@, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1313">Command Modifiers</a></dt></dl></dd><dt>shell, sequences, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1309">Continuing Long Commands</a></dt><dt>status code, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1324">Errors and Interrupts</a></dt><dt>targets, overriding, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1608">Overriding Commands for Target</a></dt><dt>variable expansion, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1077">When Variables Are Expanded</a></dt></dl></dd><dt>注释，<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-823">基本 Makefile 语法</a></dt><dt>comments, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-823">Basic Makefile Syntax</a></dt><dt>商业开发模型，<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1402">大型系统的组件</a></dt><dt>commercial development model, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1402">Components of Large Systems</a></dt><dt>编译 bean 函数 (Java)、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1515">Enterprise JavaBeans</a></dt><dt>compile-bean function (Java), <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1515">Enterprise JavaBeans</a></dt><dt>计算变量、断言函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1254">流程控制</a></dt><dt>computed variables, assert function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1254">Flow Control</a></dt><dt>条件指令、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1104">条件并包括处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1109">条件并包括处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1110">条件并包括处理</a></dt><dt>conditional directives, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1104">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1109">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1110">Conditional and include Processing</a></dt><dd><dl><dt>ifeq、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1109">条件和包含处理</a></dt><dt>ifneq 指令、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1110">条件和包含处理</a></dt><dt>语法、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1104">条件和包含处理</a></dt></dl></dd><dd><dl><dt>ifeq, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1109">Conditional and include Processing</a></dt><dt>ifneq directive, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1110">Conditional and include Processing</a></dt><dt>syntax, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1104">Conditional and include Processing</a></dt></dl></dd><dt>条件处理指令，<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1099">Conditional 和 include 处理</a></dt><dt>conditional processing directives, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1099">Conditional and include Processing</a></dt><dt>条件变量赋值运算符 (?=)、<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1053">其他类型的赋值</a></dt><dt>conditional variable assignment operator (?=), <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1053">Other Types of Assignment</a></dt><dt>配置 Linux 内核 makefile，<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1575">配置与构建</a></dt><dt>configuring Linux kernel makefile, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1575">Configuration Versus Building</a></dt><dt>常量、用户自定义变量、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1043">变量和宏</a></dt><dt>constants, user-customized variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1043">Variables and Macros</a></dt><dt>cookie、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-890">空目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-891">空目标</a></dt><dt>cookies, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-890">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-891">Empty Targets</a></dt><dd><dl><dt>（另请参阅空目标）</dt></dl></dd><dd><dl><dt>(see also empty targets)</dt></dl></dd><dt>计数器函数，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-921">使用 VPATH 和 vpath 查找文件</a></dt><dt>counter function, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-921">Finding Files with VPATH and vpath</a></dt><dt>CPPFLAGS 变量、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1082">特定于目标和模式的变量</a></dt><dt>CPPFLAGS variable, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1082">Target- and Pattern-Specific Variables</a></dt><dt>CURDIR 变量、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1123">标准 make 变量</a>、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1125">标准 make 变量</a></dt><dt>CURDIR variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1123">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1125">Standard make Variables</a></dt><dt><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1040">变量、变量和宏</a>中的花括号 ({ })<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1040"></a></dt><dt>curly braces ({ }) in variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1040">Variables and Macros</a></dt><dt>CVS（并发版本系统）、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-986">源代码控制</a>、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1465">参考版本、库和安装程序的隐式规则</a></dt><dt>CVS (Concurrent Version Systems), <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-986">Implicit Rules for Source Control</a>, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1465">Reference Builds, Libraries, and Installers</a></dt><dd><dl><dt>二进制文件、大型、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1465">参考版本、库和安装程序</a></dt><dt>隐式规则和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-986">源代码控制的隐式规则</a></dt></dl></dd><dd><dl><dt>binary files, large, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1465">Reference Builds, Libraries, and Installers</a></dt><dt>implicit rules and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-986">Implicit Rules for Source Control</a></dt></dl></dd><dt>cwd（当前工作目录）、CURDIR 变量和<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1127">标准 make 变量</a></dt><dt>cwd (current working directory), CURDIR variable
                  and, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1127">Standard make Variables</a></dt><dt>Cygwin、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1144">用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1424">Cygwin</a>、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1425">行终止</a>、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1427">文件系统</a>、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1429">程序冲突</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1501">设置 CLASSPATH</a>、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1527">基准测试</a></dt><dt>Cygwin, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1144">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1424">Cygwin</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1425">Line Termination</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1427">Filesystem</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1429">Program Conflicts</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1501">Setting CLASSPATH</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1527">Benchmarking</a></dt><dd><dl><dt>基准测试和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1527">基准测试</a></dt><dt>冲突、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1429">程序冲突</a></dt><dt>线路终端,<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1425">线路终端</a></dt><dt>可移植性和<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1424">Cygwin</a></dt><dt>regtool，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1501">设置 CLASSPATH</a></dt><dt>Windows 文件系统和<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1427">文件系统</a></dt></dl></dd><dd><dl><dt>benchmarking and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1527">Benchmarking</a></dt><dt>conflicts, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1429">Program Conflicts</a></dt><dt>line termination, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1425">Line Termination</a></dt><dt>portability and, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1424">Cygwin</a></dt><dt>regtool, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1501">Setting CLASSPATH</a></dt><dt>Windows filesystem and, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1427">Filesystem</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>D</h3><h3>D</h3><dl><dt>数据结构,<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1623">数据结构</a>,<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1632">数据结构</a></dt><dt>data structures, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1623">Data Structures</a>, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1632">Data Structures</a></dt><dd><dl><dt>非法，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1632">数据结构</a></dt></dl></dd><dd><dl><dt>illegal, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1632">Data Structures</a></dt></dl></dd><dt>--debug 选项，<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1591">--debug 选项</a></dt><dt>--debug option, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1591">The —debug Option</a></dt><dt>调试输入变量，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1279">高级用户定义函数</a></dt><dt>debug-enter variable, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1279">Advanced User-Defined Functions</a></dt><dt>调试离开变量，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1280">高级用户定义函数</a></dt><dt>debug-leave variable, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1280">Advanced User-Defined Functions</a></dt><dt>调试、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-875">假目标</a>、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1283">高级用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1583">make 调试功能</a>、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1585">make 调试功能</a>、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1586">命令行选项</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1592">良好编码实践</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1594">防御性编码</a>、<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1596">调试技术</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1597">常见错误消息</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1599">语法错误</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1606">命令脚本中的错误</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1609">覆盖命令对于目标</a></dt><dt>debugging, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-875">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1283">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1583">Debugging Features of make</a>, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1585">Debugging Features of make</a>, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1586">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1592">Good Coding Practices</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1594">Defensive Coding</a>, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1596">Debugging Techniques</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1597">Common Error Messages</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1599">Syntax Errors</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1606">Errors in Command Scripts</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1609">Overriding Commands for Target</a></dt><dd><dl><dt>代码编写和<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1592">良好编码实践</a></dt><dt>命令脚本错误消息、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1606">命令脚本中的错误</a></dt><dt>命令行选项,<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1586">命令行选项</a></dt><dt>防御性编码和<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1594">防御性编码</a></dt><dt>错误消息、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1597">常见错误消息</a></dt><dt>简介、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1583">make 的调试功能</a></dt><dt>宏和<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1283">高级用户定义函数</a></dt><dt>制作输出、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-875">虚假目标</a></dt><dt>覆盖命令、目标、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1609">目标的覆盖命令</a></dt><dt>语法错误,<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1599">语法错误</a></dt><dt>技术，<a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1596">调试技术</a></dt><dt><a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1585">make 的</a>警告功能和调试功能<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1585"></a></dt></dl></dd><dd><dl><dt>code writing and, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1592">Good Coding Practices</a></dt><dt>command script error messages, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1606">Errors in Command Scripts</a></dt><dt>command-line options, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1586">Command-Line Options</a></dt><dt>defensive coding and, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1594">Defensive Coding</a></dt><dt>error messages, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1597">Common Error Messages</a></dt><dt>introduction, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1583">Debugging Features of make</a></dt><dt>macros and, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1283">Advanced User-Defined Functions</a></dt><dt>make output, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-875">Phony Targets</a></dt><dt>overriding commands, targets, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1609">Overriding Commands for Target</a></dt><dt>syntax errors, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1599">Syntax Errors</a></dt><dt>techniuqes for, <a class="indexterm" href="#OEBPS/ch12s02.html.make3-CHP-12-ITERM-1596">Debugging Techniques</a></dt><dt>warning function and, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1585">Debugging Features of make</a></dt></dl></dd><dt>声明、可重用、库函数、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-925">使用 VPATH 和 vpath 查找文件</a></dt><dt>declarations, reusable, library functions, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-925">Finding Files with VPATH and vpath</a></dt><dt>延迟扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1071">当变量扩展时</a></dt><dt>deferred expansion, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1071">When Variables Are Expanded</a></dt><dt>定义指令、宏、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1062">宏</a></dt><dt>define directive, macros, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1062">Macros</a></dt><dt>defslot 函数，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1628">数据结构</a></dt><dt>defslot function, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1628">Data Structures</a></dt><dt>.DELETE_ON_ERROR 目标修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1008">特殊目标</a></dt><dt>.DELETE_ON_ERROR
                  target modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1008">Special Targets</a></dt><dt>依赖项、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-800">目标和先决条件</a>、<a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">自动依赖项生成</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1116">包含和依赖项</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1369">递归 make</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1381">跨 Makefile 依赖项</a>、<a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1448">依赖项生成</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1497">使用依赖项进行编译</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1534">识别和处理瓶颈</a></dt><dt>dependencies, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-800">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">Automatic Dependency Generation</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1116">include and Dependencies</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1369">Recursive make</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1381">Cross-Makefile Dependencies</a>, <a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1448">Dependency Generation</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1497">Compiling with Dependencies</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1534">Identifying and Handling Bottlenecks</a></dt><dd><dl><dt>瓶颈以及<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1534">识别和处理瓶颈</a></dt><dt>生成、<a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">自动依赖生成</a>、<a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1448">依赖生成</a></dt><dd><dl><dt>自动，<a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">自动依赖生成</a></dt></dl></dd><dt>include 指令和、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1116">include 和依赖项</a></dt><dt>Java makefile，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1497">使用依赖项进行编译</a></dt><dt>递归和，<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1369">递归make</a></dt><dt>规则、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-800">目标和先决条件</a></dt></dl></dd><dd><dl><dt>bottlenecks and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1534">Identifying and Handling Bottlenecks</a></dt><dt>generating, <a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">Automatic Dependency Generation</a>, <a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1448">Dependency Generation</a></dt><dd><dl><dt>automatically, <a class="indexterm" href="#OEBPS/ch02s07.html.make3-CHP-2-ITERM-1009">Automatic Dependency Generation</a></dt></dl></dd><dt>include directive and, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1116">include and Dependencies</a></dt><dt>Java makefile, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1497">Compiling with Dependencies</a></dt><dt>recursion and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1369">Recursive make</a></dt><dt>rules, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-800">Targets and Prerequisites</a></dt></dl></dd><dt>依赖性检查,<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-807">依赖性检查</a></dt><dt>dependency checking, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-807">Dependency Checking</a></dt><dt>开发环境，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1097">变量从何而来</a></dt><dt>development environments, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1097">Where Variables Come From</a></dt><dd><dl><dt>变量，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1097">变量从何而来</a></dt></dl></dd><dd><dl><dt>variables, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1097">Where Variables Come From</a></dt></dl></dd><dt>开发需求、<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1404">要求</a></dt><dt>development requirements, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1404">Requirements</a></dt><dt>开发风格，<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1403">大型系统的组件</a></dt><dt>development styles, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1403">Components of Large Systems</a></dt><dt>df 命令、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-867">虚假目标</a></dt><dt>df command, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-867">Phony Targets</a></dt><dt>dir 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1217">文件名函数</a></dt><dt>dir function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1217">Filename Functions</a></dt><dt>指令、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-935">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1064">宏</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1100">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1103">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1106">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1115">包含指令</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">包含和依赖项</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">非递归 make</a></dt><dt>directives, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-935">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1064">Macros</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1100">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1103">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1106">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1115">The include Directive</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">include and Dependencies</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">Nonrecursive make</a></dt><dd><dl><dt>条件处理,<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1100">有条件并包括处理</a></dt><dt>条件、语法、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1106">条件和包含处理</a></dt><dt>定义、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1064">宏</a></dt><dt>包含、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1103">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1115">包含指令</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">包含和依赖项</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">非递归 make</a></dt><dd><dl><dt>依赖关系，<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">包括和依赖关系</a></dt><dt>优化，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">非递归make</a></dt></dl></dd><dt>vpath，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-935">使用 VPATH 和 vpath 查找文件</a></dt></dl></dd><dd><dl><dt>conditional processing, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1100">Conditional and include Processing</a></dt><dt>conditional, syntax, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1106">Conditional and include Processing</a></dt><dt>define, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1064">Macros</a></dt><dt>include, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1103">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1115">The include Directive</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">include and Dependencies</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">Nonrecursive make</a></dt><dd><dl><dt>dependencies and, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1118">include and Dependencies</a></dt><dt>optimization, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1398">Nonrecursive make</a></dt></dl></dd><dt>vpath, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-935">Finding Files with VPATH and vpath</a></dt></dl></dd><dt>目录、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-855">通配符</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1386">非递归 make</a></dt><dt>directories, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-855">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1386">Nonrecursive make</a></dt><dd><dl><dt>多目录项目、非递归 make 和<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1386">非递归 make</a></dt><dt>^（波形符）和，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-855">通配符</a></dt></dl></dd><dd><dl><dt>multidirectory projects, nonrecursive make
            and, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1386">Nonrecursive make</a></dt><dt>^ (tilde) and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-855">Wildcards</a></dt></dl></dd><dt>distclean 目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-882">虚假目标</a></dt><dt>distclean target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-882">Phony Targets</a></dt><dt>分布、性能和、<a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1549">分布式制作</a></dt><dt>distribution, performance and, <a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1549">Distributed make</a></dt><dt>双冒号规则,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1029">双冒号规则</a></dt><dt>double-colon rules, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1029">Double-Colon Rules</a></dt></dl></div><div class="indexdiv"><h3>乙</h3><h3>E</h3><dl><dt>echo 命令行、限制、<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1360">命令行限制</a></dt><dt>echo command line, limits, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1360">Command-Line Limits</a></dt><dt>Eclipse、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1491">IDE</a></dt><dt>Eclipse, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1491">IDEs</a></dt><dt>EJB（企业 Java Bean）、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1514">企业 JavaBean</a></dt><dt>EJB (Enterprise Java Beans), <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1514">Enterprise JavaBeans</a></dt><dt>ejb-rule 函数，<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1519">Enterprise JavaBeans</a></dt><dt>ejb-rule function, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1519">Enterprise JavaBeans</a></dt><dt>EJBS 变量、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1517">Enterprise JavaBeans</a></dt><dt>EJBS variable, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1517">Enterprise JavaBeans</a></dt><dt>Emacs JDEE、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1492">IDE</a></dt><dt>Emacs JDEE, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1492">IDEs</a></dt><dt>嵌入周期、变量定义和<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1625">数据结构</a></dt><dt>embedded periods, variable definition and, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1625">Data Structures</a></dt><dt>空命令，<a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1337">空命令</a></dt><dt>empty commands, <a class="indexterm" href="#OEBPS/ch05s03.html.make3-CHP-5-ITERM-1337">Empty Commands</a></dt><dt>空目标,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-887">空目标</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-895">空目标</a></dt><dt>empty targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-887">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-895">Empty Targets</a></dt><dd><dl><dt>自动变量和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-895">空目标</a></dt></dl></dd><dd><dl><dt>automatic variables and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-895">Empty Targets</a></dt></dl></dd><dt>封装、Java 包、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1473">Java</a></dt><dt>encapsulation, Java packages, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1473">Java</a></dt><dt>endef 关键字、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1065">宏</a></dt><dt>endef keyword, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1065">Macros</a></dt><dt>环境变量，?= 运算符，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1093">变量从何而来</a></dt><dt>environment variables, ?= operator, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1093">Where Variables Come From</a></dt><dt>--environment-overrides 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1612">运行 make</a></dt><dt>--environment-overrides
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1612">Running make</a></dt><dt>环境、<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1090">变量从何而来</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1340">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">命令环境</a></dt><dt>environments, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1090">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1340">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">Command Environment</a></dt><dd><dl><dt>命令、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1340">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">命令环境</a>、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">命令环境</a></dt><dd><dl><dt>文件描述符、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">命令环境</a></dt><dt>MAKEFLAGS 变量，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">命令环境</a></dt><dt>MAKELEVEL 变量，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">命令环境</a></dt></dl></dd><dt>变量定义以及<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1090">变量从何而来</a></dt></dl></dd><dd><dl><dt>commands, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1340">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">Command Environment</a></dt><dd><dl><dt>file descriptors, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1350">Command Environment</a></dt><dt>MAKEFLAGS variable, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1342">Command Environment</a></dt><dt>MAKELEVEL variable, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1346">Command Environment</a></dt></dl></dd><dt>variable definition and, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1090">Where Variables Come From</a></dt></dl></dd><dt>误差函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1246">流量控制</a></dt><dt>error function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1246">Flow Control</a></dt><dt>错误处理、递归 make 和、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1377">错误处理</a></dt><dt>error handling, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1377">Error Handling</a></dt><dt>错误消息、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1248">流程控制</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1598">常见错误消息</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1605">命令脚本中的错误</a></dt><dt>error messages, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1248">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1598">Common Error Messages</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1605">Errors in Command Scripts</a></dt><dd><dl><dt>命令脚本、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1605">命令脚本中的错误</a></dt><dt>调试和<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1598">常见错误消息</a></dt><dt>致命、打印、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1248">流量控制</a></dt></dl></dd><dd><dl><dt>command scripts, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1605">Errors in Command Scripts</a></dt><dt>debugging and, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1598">Common Error Messages</a></dt><dt>fatal, printing, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1248">Flow Control</a></dt></dl></dd><dt>错误、命令、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1320">命令修饰符</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1328">错误和中断</a></dt><dt>errors, commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1320">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1328">Errors and Interrupts</a></dt><dd><dl><dt>忽略，<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1320">命令修饰符</a></dt><dt>选项、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1328">错误和中断</a></dt></dl></dd><dd><dl><dt>ignoring, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1320">Command Modifiers</a></dt><dt>options, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1328">Errors and Interrupts</a></dt></dl></dd><dt>eval 函数、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1285">eval 和 value</a>、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1289">eval 和 value</a></dt><dt>eval function, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1285">eval and value</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1289">eval and value</a></dt><dd><dl><dt>解析 and、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1289">eval 和 value</a></dt></dl></dd><dd><dl><dt>parsing and, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1289">eval and value</a></dt></dl></dd><dt>扩展宏，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1069">当变量扩展时</a></dt><dt>exanding macros, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1069">When Variables Are Expanded</a></dt><dt>扩展宏、<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1074">扩展变量时</a>、<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1075">扩展变量时</a>、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1149">用户定义函数</a></dt><dt>expanding macros, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1074">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1075">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1149">User-Defined Functions</a></dt><dd><dl><dt>延迟扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1075">当变量扩展时</a></dt><dt>立即扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1074">当变量扩展时</a></dt><dt>从另一个<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1149">用户定义函数调用的宏</a></dt></dl></dd><dd><dl><dt>deferred expansion, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1075">When Variables Are Expanded</a></dt><dt>immediate expansion, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1074">When Variables Are Expanded</a></dt><dt>macros invoked from another, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1149">User-Defined Functions</a></dt></dl></dd><dt>扩展文本、foreach 函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1260">流程控制</a></dt><dt>expanding text, foreach function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1260">Flow Control</a></dt><dt>扩展变量、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1039">变量和宏</a>、<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1067">何时扩展变量</a>、<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072">何时扩展变量</a>、<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1073">何时扩展变量</a></dt><dt>expanding variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1039">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1067">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1073">When Variables Are Expanded</a></dt><dd><dl><dt>大括号和<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1039">变量和宏</a></dt><dt><a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072">当变量扩展时</a>延迟<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072"></a></dt><dt>立即生效，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1073">当变量扩展时</a></dt></dl></dd><dd><dl><dt>curly braces and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1039">Variables and Macros</a></dt><dt>deferred, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1072">When Variables Are Expanded</a></dt><dt>immediate, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1073">When Variables Are Expanded</a></dt></dl></dd><dt>显式规则,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-827">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-839">显式规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-896">空目标</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-847">通配符</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-863">虚假目标</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-888">空目标</a></dt><dt>explicit rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-827">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-839">Explicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-896">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-847">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-863">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-888">Empty Targets</a></dt><dd><dl><dt>空目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-888">空目标</a></dt><dt>虚假目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-863">虚假目标</a></dt><dt>通配符,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-847">通配符</a></dt></dl></dd><dd><dl><dt>empty targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-888">Empty Targets</a></dt><dt>phony targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-863">Phony Targets</a></dt><dt>wildcards, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-847">Wildcards</a></dt></dl></dd><dt>导出变量，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1091">变量从何而来</a></dt><dt>exporting variables, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1091">Where Variables Come From</a></dt></dl></div><div class="indexdiv"><h3>F</h3><h3>F</h3><dl><dt>致命错误消息、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1249">流量控制</a></dt><dt>fatal error messages, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1249">Flow Control</a></dt><dt>文件描述符、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1351">命令环境</a></dt><dt>file descriptors, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1351">Command Environment</a></dt><dt>文件管理、<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1431">管理程序和文件</a>、<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1436">源树布局</a></dt><dt>file management, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1431">Managing Programs and Files</a>, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1436">Source Tree Layout</a></dt><dd><dl><dt>源树布局，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1436">源树布局</a></dt></dl></dd><dd><dl><dt>source tree layout, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1436">Source Tree Layout</a></dt></dl></dd><dt>--file 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1613">运行 make</a></dt><dt>--file option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1613">Running make</a></dt><dt>文件名,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-938">模式规则</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1208">重要杂项函数</a>,文件<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">名</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1212">函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">文件名函数</a>,文件名<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222">函数 , 文件名函数</a>,文件<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">文件名函数</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236"></a></dt><dt>filenames, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-938">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1208">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1212">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">Filename Functions</a></dt><dd><dl><dt>内置函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1212">文件名函数</a></dt><dt>函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">文件名函数</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">,</a>文件名函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">文件名函数</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236"></a></dt><dd><dl><dt>addprefix，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">文件名函数</a></dt><dt>addsuffix，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">文件名函数</a></dt><dt>基本名称、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">文件名函数</a></dt><dt>目录、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">文件名函数</a></dt><dt>join，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">文件名函数</a></dt><dt>notdir，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">文件名函数</a></dt><dt>后缀、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">文件名功能</a></dt><dt>通配符函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">文件名函数</a></dt></dl></dd><dt>模式，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-938">模式规则</a>（参见模式规则）</dt><dt>后缀、函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222">文件名函数</a></dt><dt>时间戳和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1208">重要的杂项功能</a></dt></dl></dd><dd><dl><dt>built-in functions and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1212">Filename Functions</a></dt><dt>functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">Filename Functions</a></dt><dd><dl><dt>addprefix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1233">Filename Functions</a></dt><dt>addsuffix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1231">Filename Functions</a></dt><dt>basename, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1228">Filename Functions</a></dt><dt>dir, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1216">Filename Functions</a></dt><dt>join, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1236">Filename Functions</a></dt><dt>notdir, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1219">Filename Functions</a></dt><dt>suffix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1226">Filename Functions</a></dt><dt>wildcard function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1215">Filename Functions</a></dt></dl></dd><dt>patterns, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-938">Pattern Rules</a> (see pattern rules)</dt><dt>suffixes, functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1222">Filename Functions</a></dt><dt>timestamps and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1208">Important Miscellaneous Functions</a></dt></dl></dd><dt>文件、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-843">通配符</a>、<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1088">变量从何而来</a></dt><dt>files, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-843">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1088">Where Variables Come From</a></dt><dd><dl><dt>变量定义以及<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1088">变量从何而来</a></dt><dt>通配符,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-843">通配符</a></dt></dl></dd><dd><dl><dt>variable definition and, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1088">Where Variables Come From</a></dt><dt>wildcards, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-843">Wildcards</a></dt></dl></dd><dt>文件数组、命令行限制和<a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1361">命令行限制</a></dt><dt>files array, command line limits and, <a class="indexterm" href="#OEBPS/ch05s06.html.make3-CHP-5-ITERM-1361">Command-Line Limits</a></dt><dt>文件系统布局、二叉树和<a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1406">文件系统布局</a></dt><dt>filesystems layout, binary trees and, <a class="indexterm" href="#OEBPS/ch06s04.html.make3-CHP-6-ITERM-1406">Filesystem Layout</a></dt><dt>过滤函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1169">字符串函数</a></dt><dt>filter function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1169">String Functions</a></dt><dt>过滤函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1172">字符串函数</a></dt><dt>filter-out function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1172">String Functions</a></dt><dt>find 命令、模块定义、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1400">非递归 make</a></dt><dt>find command, module definition, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1400">Nonrecursive make</a></dt><dt>findstring 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1175">字符串函数</a></dt><dt>findstring function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1175">String Functions</a></dt><dt>第一个字函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1194">字符串函数</a></dt><dt>firstword function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1194">String Functions</a></dt><dt>流量控制功能,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1240">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1242">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1245">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1250">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1253">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1256">流量控制</a></dt><dt>flow control functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1240">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1242">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1245">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1250">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1253">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1256">Flow Control</a></dt><dd><dl><dt>断言、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1250">流控制</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1253">流控制</a></dt><dt>错误，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1245">流量控制</a></dt><dt>foreach，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1256">流量控制</a></dt><dt>如果，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1242">流量控制</a></dt></dl></dd><dd><dl><dt>assert, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1250">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1253">Flow Control</a></dt><dt>error, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1245">Flow Control</a></dt><dt>foreach, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1256">Flow Control</a></dt><dt>if, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1242">Flow Control</a></dt></dl></dd><dt>foreach函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1257">流量控制</a></dt><dt>foreach function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1257">Flow Control</a></dt><dt>foreach 循环，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1630">数据结构</a></dt><dt>foreach loop, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1630">Data Structures</a></dt><dt>免费软件模型开发，<a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1401">大型系统的组件</a></dt><dt>free software model development, <a class="indexterm" href="#OEBPS/ch06s03.html.make3-CHP-6-ITERM-1401">Components of Large Systems</a></dt><dt>函数、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-857">通配符</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-922">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-924">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">变量和宏</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1113">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1140">用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1153">用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1155">内置函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1276">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">内置</a>函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">字符串</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1167">函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1170">字符串</a>函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1173">字符串函数 , 字符串</a>函数<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1176">, 字符串</a>函数<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1180">, 字符串</a>函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1183">字符串函数</a>,字符串<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1185">函数,</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1190">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1192">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1195">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1198">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1201">重要杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1203">重要杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1214">文件名函数</a>,文件<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1218">名</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1221">函数</a>,文件<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1224">名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1229">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1232">文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1235">文件名函数</a>,文件<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1238">名函数 , 文件名函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1239">流控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1241">流控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1244">流</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1247">控制</a>,流控制,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1252">流控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1258">流控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1264">不太重要杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1265">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1269">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1272">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1274">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">高级用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">传递参数</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1286">eval 和 value</a> ,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1293">挂钩函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1297">传递参数</a>,<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1390">非递归 make</a> ,<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1394">非递归 make</a> ,<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1396">非递归 make</a> ,<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1433">管理程序和文件</a>,<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1435">管理程序和文件</a>,<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1504">设置 CLASSPATH</a> ,<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1509">管理 Jars</a> , <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1516">Enterprise JavaBeans</a> , <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1520">Enterprise JavaBeans</a> ,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">用户定义的函数</a>,<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1627">数据结构</a>,<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1629">数据结构</a></dt><dt>functions, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-857">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-922">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-924">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1113">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1140">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1153">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1155">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1276">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1167">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1170">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1173">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1176">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1180">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1183">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1185">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1190">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1192">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1195">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1198">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1201">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1203">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1214">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1218">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1221">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1224">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1229">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1232">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1235">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1238">Filename Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1239">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1241">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1244">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1247">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1252">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1258">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1264">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1265">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1269">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1272">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1274">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">Passing Parameters</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1286">eval and value</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1293">Hooking Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1297">Passing Parameters</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1390">Nonrecursive make</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1394">Nonrecursive make</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1396">Nonrecursive make</a>, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1433">Managing Programs and Files</a>, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1435">Managing Programs and Files</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1504">Setting CLASSPATH</a>, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1509">Managing Jars</a>, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1516">Enterprise JavaBeans</a>, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1520">Enterprise JavaBeans</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1627">Data Structures</a>, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1629">Data Structures</a></dt><dd><dl><dt>add-manifest，<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1509">管理罐子</a></dt><dt>addprefix，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1235">文件名函数</a></dt><dt>addsuffix，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1232">文件名函数</a></dt><dt>断言、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1252">流程控制</a></dt><dt>基本名称、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1229">文件名函数</a></dt><dt>构建类路径，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1504">设置 CLASSPATH</a></dt><dt>内置,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1155">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1276">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">内置函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">字符串函数</a></dt><dd><dl><dt>模式作为参数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">内置函数</a></dt><dt>字符串函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">字符串函数</a></dt><dt>语法、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">内置函数</a></dt></dl></dd><dt>呼叫、通配符和、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-857">通配符</a></dt><dt>编译 bean，<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1516">企业 JavaBean</a></dt><dt>计数器，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-922">使用 VPATH 和 vpath 查找文件</a></dt><dt>defslot，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1629">数据结构</a></dt><dt>目录、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1218">文件名函数</a></dt><dt>ejb 规则，<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1520">企业 JavaBean</a></dt><dt>错误，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1247">流量控制</a></dt><dt>评估、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1286">评估和价值</a></dt><dt>过滤器、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1170">字符串函数</a></dt><dt>过滤器，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1173">字符串函数</a></dt><dt>查找字符串、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1176">字符串函数</a></dt><dt>第一个字，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1195">字符串函数</a></dt><dt>流量控制,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1239">流量控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1241">流量控制</a></dt><dt>foreach，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1258">流量控制</a></dt><dt>生成源，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1396">非递归 make</a></dt><dt>钩子、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1293">钩子函数</a></dt><dt>如果，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1244">流量控制</a></dt><dt>join，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1238">文件名函数</a></dt><dt>库、声明、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-924">使用 VPATH 和 vpath 查找文件</a></dt><dt>make-library，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1390">非递归make</a></dt><dt>杂项、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1265">不太重要的杂项功能</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1274">不太重要的杂项功能</a></dt><dt>notdir，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1221">文件名函数</a></dt><dt>起源，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1269">不太重要的杂项功能</a></dt><dt>参数，传递给，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1297">传递参数</a></dt><dt>patsubst，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1185">字符串函数</a></dt><dt>远程文件，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1627">数据结构</a></dt><dt>搜索和替换、字符串、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1180">字符串函数</a></dt><dt>shell，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1203">重要的杂项函数</a></dt><dt>排序，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1201">重要的杂项函数</a></dt><dt>源到对象，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1394">非递归 make</a></dt><dt>空间问题，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1435">管理程序和文件</a></dt><dt>字符串函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1167">字符串函数</a></dt><dt>条带，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1264">不太重要的杂项功能</a></dt><dt>剥离、空白删除、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1113">条件和包含处理</a></dt><dt>subst，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1183">字符串函数</a></dt><dt>后缀、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1224">文件名功能</a></dt><dt>用户定义,<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">变量和宏</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1140">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1153">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">高级用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">传递参数</a>,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">用户定义函数</a></dt><dd><dl><dt>高级、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">高级用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">传递参数</a></dt><dt>Linux 内核 makefile、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">用户定义函数</a></dt><dt>参数和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">用户定义的函数</a></dt><dt>变量、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">变量和宏</a></dt></dl></dd><dt>警告，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1272">不太重要的杂项功能</a></dt><dt>空格操作、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1190">字符串函数</a></dt><dt>通配符、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1214">文件名函数</a></dt><dt>通配符空格，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1433">管理程序和文件</a></dt><dt>词表、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1198">字符串函数</a></dt><dt>单词、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1192">字符串函数</a></dt></dl></dd><dd><dl><dt>add-manifest, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1509">Managing Jars</a></dt><dt>addprefix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1235">Filename Functions</a></dt><dt>addsuffix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1232">Filename Functions</a></dt><dt>assert, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1252">Flow Control</a></dt><dt>basename, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1229">Filename Functions</a></dt><dt>build-classpath, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1504">Setting CLASSPATH</a></dt><dt>built-in, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1155">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1276">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">String Functions</a></dt><dd><dl><dt>patterns as arguments, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1161">Built-in Functions</a></dt><dt>string functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1165">String Functions</a></dt><dt>syntax, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1158">Built-in Functions</a></dt></dl></dd><dt>calling, wildcards and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-857">Wildcards</a></dt><dt>compile-bean, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1516">Enterprise JavaBeans</a></dt><dt>counter, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-922">Finding Files with VPATH and vpath</a></dt><dt>defslot, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1629">Data Structures</a></dt><dt>dir, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1218">Filename Functions</a></dt><dt>ejb-rule, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1520">Enterprise JavaBeans</a></dt><dt>error, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1247">Flow Control</a></dt><dt>eval, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1286">eval and value</a></dt><dt>filter, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1170">String Functions</a></dt><dt>filter-out, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1173">String Functions</a></dt><dt>findstring, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1176">String Functions</a></dt><dt>firstword, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1195">String Functions</a></dt><dt>flow control, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1239">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1241">Flow Control</a></dt><dt>foreach, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1258">Flow Control</a></dt><dt>generated-source, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1396">Nonrecursive make</a></dt><dt>hooks, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1293">Hooking Functions</a></dt><dt>if, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1244">Flow Control</a></dt><dt>join, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1238">Filename Functions</a></dt><dt>library, declarations, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-924">Finding Files with VPATH and vpath</a></dt><dt>make-library, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1390">Nonrecursive make</a></dt><dt>miscellaneous, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1265">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1274">Less Important Miscellaneous Functions</a></dt><dt>notdir, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1221">Filename Functions</a></dt><dt>origin, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1269">Less Important Miscellaneous Functions</a></dt><dt>parameters, passing to, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1297">Passing Parameters</a></dt><dt>patsubst, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1185">String Functions</a></dt><dt>remote-file, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1627">Data Structures</a></dt><dt>search and replace, strings, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1180">String Functions</a></dt><dt>shell, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1203">Important Miscellaneous Functions</a></dt><dt>sort, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1201">Important Miscellaneous Functions</a></dt><dt>source-to-object, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1394">Nonrecursive make</a></dt><dt>space-to-question, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1435">Managing Programs and Files</a></dt><dt>string functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1167">String Functions</a></dt><dt>strip, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1264">Less Important Miscellaneous Functions</a></dt><dt>strip, whitespace removal, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1113">Conditional and include Processing</a></dt><dt>subst, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1183">String Functions</a></dt><dt>suffix, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1224">Filename Functions</a></dt><dt>user-defined, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1140">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1153">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">Passing Parameters</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">User-Defined Functions</a></dt><dd><dl><dt>advanced, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1278">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1299">Passing Parameters</a></dt><dt>Linux kernel makefile, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1582">User-Defined Functions</a></dt><dt>parameters and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1146">User-Defined Functions</a></dt><dt>variables, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1045">Variables and Macros</a></dt></dl></dd><dt>warning, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1272">Less Important Miscellaneous Functions</a></dt><dt>whitespace manipulation, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1190">String Functions</a></dt><dt>wildcard, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1214">Filename Functions</a></dt><dt>wildcard-spaces, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1433">Managing Programs and Files</a></dt><dt>wordlist, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1198">String Functions</a></dt><dt>words, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1192">String Functions</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>G</h3><h3>G</h3><dl><dt>生成源函数，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1395">非递归 make</a></dt><dt>generated-source function, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1395">Nonrecursive make</a></dt><dt>生成依赖关系，<a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1449">依赖生成</a></dt><dt>generating dependencies, <a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1449">Dependency Generation</a></dt><dt>通配符、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-845">通配符</a></dt><dt>globbing, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-845">Wildcards</a></dt><dt>GNU 自由文档许可证、<a class="indexterm" href="#OEBPS/apc.html.make3-APP-C-ITERM-1635">GNU 自由文档许可证 — GNU 项目 — 自由软件基金会 (FSF)</a>，<a class="indexterm" href="#OEBPS/apcs11.html.make3-APP-C-ITERM-1636">10. 本许可证的未来修订版</a></dt><dt>GNU Free Documentation License, <a class="indexterm" href="#OEBPS/apc.html.make3-APP-C-ITERM-1635">GNU Free Documentation License—GNU Project—Free Software
      Foundation (FSF)</a>, <a class="indexterm" href="#OEBPS/apcs11.html.make3-APP-C-ITERM-1636">10. FUTURE REVISIONS OF THIS LICENSE</a></dt><dt>grep 命令、变量和<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1355">命令环境</a></dt><dt>grep command, variables and, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1355">Command Environment</a></dt></dl></div><div class="indexdiv"><h3>H</h3><h3>H</h3><dl><dt>头文件、包含目录、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-927">使用 VPATH 和 vpath 查找文件</a></dt><dt>header files, include directory, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-927">Finding Files with VPATH and vpath</a></dt><dt>Hello World makefile 文件，<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-790">如何编写简单的 Makefile</a></dt><dt>Hello World makefile file, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-790">How to Write a Simple Makefile</a></dt><dt>help 命令，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-987">一个简单的帮助命令</a></dt><dt>help commands, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-987">A Simple Help Command</a></dt><dt>--help 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1614">运行 make</a></dt><dt>--help option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1614">Running make</a></dt><dt>主目录、^（波形符）和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-854">通配符</a></dt><dt>home directory, ^ (tilde) and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-854">Wildcards</a></dt><dt>钩子、函数、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1294">挂钩函数</a></dt><dt>hooks, functions, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1294">Hooking Functions</a></dt></dl></div><div class="indexdiv"><h3>我</h3><h3>I</h3><dl><dt>IDE（集成开发环境）、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1466">Java</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1489">IDE</a></dt><dt>IDEs (Integrated Development Environments), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1466">Java</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1489">IDEs</a></dt><dt>if 函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1243">流量控制</a></dt><dt>if function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1243">Flow Control</a></dt><dt>ifeq 条件指令、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1107">Conditional 和 include 处理</a></dt><dt>ifeq conditional directive, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1107">Conditional and include Processing</a></dt><dt>ifneq 条件指令、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1108">Conditional 和 include 处理</a></dt><dt>ifneq conditional directive, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1108">Conditional and include Processing</a></dt><dt>立即扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1070">当变量扩展时</a></dt><dt>immediate expansion, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1070">When Variables Are Expanded</a></dt><dt>隐式规则,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-835">规则</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-965">隐式规则数据库</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-967">使用隐式规则</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-981">源代码管理的隐式规则</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">源代码管理的隐式规则</a></dt><dt>implicit rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-835">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-965">The Implicit Rules Database</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-967">Working with Implicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-981">Implicit Rules for Source Control</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">Implicit Rules for Source Control</a></dt><dd><dl><dt>内置，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-967">使用隐式规则</a></dt><dt>源代码控制和，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-981">源代码控制的隐式规则</a>，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">源代码控制的隐式规则</a></dt><dd><dl><dt>CVS，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">源代码控制的隐式规则</a></dt></dl></dd></dl></dd><dd><dl><dt>built-in, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-967">Working with Implicit Rules</a></dt><dt>source control and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-981">Implicit Rules for Source Control</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">Implicit Rules for Source Control</a></dt><dd><dl><dt>CVS, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-985">Implicit Rules for Source Control</a></dt></dl></dd></dl></dd><dt>include 指令、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-929">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1102">条件和 include 处理</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1114">include 指令</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1117">include 和依赖项</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1397">非递归 make</a></dt><dt>include directive, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-929">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1102">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1114">The include Directive</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1117">include and Dependencies</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1397">Nonrecursive make</a></dt><dd><dl><dt>依赖关系，<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1117">包括和依赖关系</a></dt><dt>头文件，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-929">使用 VPATH 和 vpath 查找文件</a></dt><dt>优化，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1397">非递归make</a></dt></dl></dd><dd><dl><dt>dependencies and, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1117">include and Dependencies</a></dt><dt>header files, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-929">Finding Files with VPATH and vpath</a></dt><dt>optimization, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1397">Nonrecursive make</a></dt></dl></dd><dt>包括处理、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1101">条件和包括处理</a></dt><dt>include processing, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1101">Conditional and include Processing</a></dt><dt>--include-dir 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1615">运行 make</a></dt><dt>--include-dir
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1615">Running make</a></dt><dt>递增、<a class="indexterm" href="#OEBPS/apbs02.html.make3-APP-B-ITERM-1634">算术</a></dt><dt>incrementing, <a class="indexterm" href="#OEBPS/apbs02.html.make3-APP-B-ITERM-1634">Arithmetic</a></dt><dt>信息目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-884">虚假目标</a></dt><dt>info target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-884">Phony Targets</a></dt><dt>初始化、性能和<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1545">延迟初始化</a></dt><dt>initialization, performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1545">Lazy Initialization</a></dt><dt>输入文件、文本打印、<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-812">最小化重建</a></dt><dt>input files, text printing, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-812">Minimizing Rebuilds</a></dt><dt>安装目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-880">假目标</a></dt><dt>install target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-880">Phony Targets</a></dt><dt>安装程序、参考版本和<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1464">参考版本、库和安装程序</a></dt><dt>installers, reference builds and, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1464">Reference Builds, Libraries, and Installers</a></dt><dt>接口、虚假目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-877">虚假目标</a></dt><dt>interfaces, phony targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-877">Phony Targets</a></dt><dt>中间文件、链接规则以及<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-972">使用隐式规则</a></dt><dt>intermediate files, chaining rules and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-972">Working with Implicit Rules</a></dt><dt>.INTERMEDIATE 目标修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-996">特殊目标</a></dt><dt>.INTERMEDIATE
                  target modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-996">Special Targets</a></dt><dt>调用 make,<a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-818">调用 make</a></dt><dt>invoking make, <a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-818">Invoking make</a></dt></dl></div><div class="indexdiv"><h3>J</h3><h3>J</h3><dl><dt>jar 程序、<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1507">管理 Jars</a>、<a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1510">参考树和第三方 Jars</a>、<a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1512">参考树和第三方 Jars</a></dt><dt>jar program, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1507">Managing Jars</a>, <a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1510">Reference Trees and Third-Party Jars</a>, <a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1512">Reference Trees and Third-Party Jars</a></dt><dd><dl><dt>参考树、<a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1510">参考树和第三方 Jar</a></dt><dt>第三方、<a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1512">参考树和第三方 Jar</a></dt></dl></dd><dd><dl><dt>reference trees, <a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1510">Reference Trees and Third-Party Jars</a></dt><dt>third-party, <a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1512">Reference Trees and Third-Party Jars</a></dt></dl></dd><dt>jars (Java)，<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1506">管理 Jars</a></dt><dt>jars (Java), <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1506">Managing Jars</a></dt><dt>Java、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1467">Java</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1468">Java</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1471">Java</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1474">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">Ant</a>、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1490">IDE</a>、<a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1494">通用 Java Makefile</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">使用依赖项进行编译</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">设置 CLASSPATH</a>、<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1505">管理 Jars</a>、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1513">Enterprise JavaBean</a></dt><dt>Java, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1467">Java</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1468">Java</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1471">Java</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1474">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1490">IDEs</a>, <a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1494">A Generic Java Makefile</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">Compiling with Dependencies</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">Setting CLASSPATH</a>, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1505">Managing Jars</a>, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1513">Enterprise JavaBeans</a></dt><dd><dl><dt>蚂蚁，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1474">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">蚂蚁</a>，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">蚂蚁</a></dt><dd><dl><dt>构建文件，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">蚂蚁</a></dt><dt>mkdir 程序、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">Ant</a></dt><dt>可移植性，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">蚂蚁</a></dt><dt>任务，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">蚂蚁</a></dt></dl></dd><dt>日食，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1467">Java</a></dt><dt>EJB（企业 JavaBean）、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1513">企业 JavaBean</a></dt><dt>IDE、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1490">IDE</a></dt><dt>罐子和<a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1505">管理罐子</a></dt><dt>使和，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1468">Java</a></dt><dt>makefile（通用）、<a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1494">通用 Java Makefile</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">使用依赖项进行编译</a>、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">设置 CLASSPATH</a></dt><dd><dl><dt>CLASSPATH变量，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">设置CLASSPATH</a></dt><dt>依赖关系以及<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">使用依赖关系进行编译</a></dt></dl></dd><dt>包、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1471">Java</a></dt></dl></dd><dd><dl><dt>Ant, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1474">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">Ant</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">Ant</a></dt><dd><dl><dt>build file, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1479">Ant</a></dt><dt>mkdir program, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1484">Ant</a></dt><dt>portability, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1488">Ant</a></dt><dt>tasks, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1481">Ant</a></dt></dl></dd><dt>Eclipse, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1467">Java</a></dt><dt>EJB (Enterprise JavaBeans), <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1513">Enterprise JavaBeans</a></dt><dt>IDEs, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1490">IDEs</a></dt><dt>jars and, <a class="indexterm" href="#OEBPS/ch09s04.html.make3-CHP-9-ITERM-1505">Managing Jars</a></dt><dt>make and, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1468">Java</a></dt><dt>makefile (generic), <a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1494">A Generic Java Makefile</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">Compiling with Dependencies</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">Setting CLASSPATH</a></dt><dd><dl><dt>CLASSPATH variable, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1500">Setting CLASSPATH</a></dt><dt>dependecies and, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1496">Compiling with Dependencies</a></dt></dl></dd><dt>packages, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1471">Java</a></dt></dl></dd><dt>JBuilder、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1493">IDE</a></dt><dt>JBuilder, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1493">IDEs</a></dt><dt>JIT（即时）优化，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1469">Java</a></dt><dt>JIT (just-in-time) optimization, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1469">Java</a></dt><dt>连接函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1237">文件名函数</a></dt><dt>join function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1237">Filename Functions</a></dt><dt>--just-print 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1617">运行 make</a></dt><dt>--just-print
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1617">Running make</a></dt><dt>--just-print 选项，调试，<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1588">--just-print</a></dt><dt>--just-print
                option, debugging, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1588">—just-print</a></dt><dt>JVM（Java虚拟机），<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1470">Java</a></dt><dt>JVM (Java virtual machine), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1470">Java</a></dt></dl></div><div class="indexdiv"><h3>K</h3><h3>K</h3><dl><dt>--keep-going 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1616">运行 make</a></dt><dt>--keep-going
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1616">Running make</a></dt><dt>终止进程、用户定义的函数和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1142">用户定义的函数</a></dt><dt>killing processes, user-defined functions and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1142">User-Defined Functions</a></dt></dl></div><div class="indexdiv"><h3>L</h3><h3>L</h3><dl><dt>大型项目、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1363">管理大型项目</a>、<a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1411">自动化构建和测试</a></dt><dt>large projects, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1363">Managing Large Projects</a>, <a class="indexterm" href="#OEBPS/ch06s05.html.make3-CHP-6-ITERM-1411">Automating Builds and Testing</a></dt><dt>库、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1002">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1012">管理库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1018">创建和更新库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1019">创建和更新库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1022">使用库作为先决条件</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1025">使用库作为先决条件</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1366">递归 make</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1392">非递归 make</a>、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1463">参考构建、库和安装程序</a></dt><dt>libraries, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1002">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1012">Managing Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1018">Creating and Updating Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1019">Creating and Updating Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1022">Using Libraries as Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1025">Using Libraries as Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1366">Recursive make</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1392">Nonrecursive make</a>, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1463">Reference Builds, Libraries, and Installers</a></dt><dd><dl><dt>档案馆、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1012">图书馆管理</a></dt><dt>循环引用，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1025">使用库作为先决条件</a></dt><dt>创建、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1018">创建和更新库</a></dt><dt>make-library 函数，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1392">非递归 make</a></dt><dt>作为先决条件，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1022">使用库作为先决条件</a></dt><dt>递归和，<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1366">递归make</a></dt><dt>参考构建、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1463">参考构建、库和安装程序</a></dt><dt>.SECONDARY 目标修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1002">特殊目标</a></dt><dt>更新、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1019">创建和更新库</a></dt></dl></dd><dd><dl><dt>archive libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1012">Managing Libraries</a></dt><dt>circular references, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1025">Using Libraries as Prerequisites</a></dt><dt>creating, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1018">Creating and Updating Libraries</a></dt><dt>make-library function, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1392">Nonrecursive make</a></dt><dt>as prerequisites, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1022">Using Libraries as Prerequisites</a></dt><dt>recursion and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1366">Recursive make</a></dt><dt>reference builds and, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1463">Reference Builds, Libraries, and Installers</a></dt><dt>.SECONDARY
                  target modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1002">Special Targets</a></dt><dt>updating, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1019">Creating and Updating Libraries</a></dt></dl></dd><dt>库函数，可重用，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-923">使用 VPATH 和 vpath 查找文件</a></dt><dt>library functions, reusable, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-923">Finding Files with VPATH and vpath</a></dt><dt>库管理、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1010">管理库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1016">创建和更新库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1017">创建和更新库</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1030">双冒号规则</a></dt><dt>library management, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1010">Managing Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1016">Creating and Updating Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1017">Creating and Updating Libraries</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1030">Double-Colon Rules</a></dt><dd><dl><dt>档案图书馆和<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1010">管理图书馆</a></dt><dt>创建库、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1017">创建和更新库</a></dt><dt>双冒号规则,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1030">双冒号规则</a></dt><dt>更新库，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1016">创建和更新库</a></dt></dl></dd><dd><dl><dt>archive libraries and, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1010">Managing Libraries</a></dt><dt>creating libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1017">Creating and Updating Libraries</a></dt><dt>double-colon rules, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1030">Double-Colon Rules</a></dt><dt>updating libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1016">Creating and Updating Libraries</a></dt></dl></dd><dt>线路终端、Cygwin、<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1426">线路终端</a></dt><dt>line termination, Cygwin, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1426">Line Termination</a></dt><dt>Linux 内核 makefile、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1569">Linux 内核 Makefile</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1570">命令行选项</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1573">配置与构建</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1577">管理命令回显</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1579">用户定义函数</a></dt><dt>Linux kernel makefile, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1569">The Linux Kernel Makefile</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1570">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1573">Configuration Versus Building</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1577">Managing Command Echo</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1579">User-Defined Functions</a></dt><dd><dl><dt>命令回显，<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1577">管理命令回显</a></dt><dt>命令行选项,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1570">命令行选项</a></dt><dt>配置与构建，<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1573">配置与构建</a></dt><dt>用户定义函数,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1579">用户定义函数</a></dt></dl></dd><dd><dl><dt>command echo, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1577">Managing Command Echo</a></dt><dt>command-line options, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1570">Command-Line Options</a></dt><dt>configuration versus building, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1573">Configuration Versus Building</a></dt><dt>user-defined functions, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1579">User-Defined Functions</a></dt></dl></dd><dt>长命令、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1312">连续长命令</a></dt><dt>long commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1312">Continuing Long Commands</a></dt><dt>循环、foreach、<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1631">数据结构</a></dt><dt>loops, foreach, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1631">Data Structures</a></dt></dl></div><div class="indexdiv"><h3>中号</h3><h3>M</h3><dl><dt>m4 宏、书籍 makefile 和<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1558">XML 预处理</a></dt><dt>m4 macros, book makefile and, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1558">XML Preprocessing</a></dt><dt>宏,<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1059">宏</a>,<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1063">宏</a>,<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1068">当变量展开时</a>,<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1076">当变量展开时</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1148">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1151">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1284">高级用户定义函数</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1288">eval 和 value</a> , <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1292">eval 和 value</a></dt><dt>macros, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1059">Macros</a>, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1063">Macros</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1068">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1076">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1148">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1151">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1284">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1288">eval and value</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1292">eval and value</a></dt><dd><dl><dt>调试和<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1284">高级用户定义函数</a></dt><dt>定义指令、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1063">宏</a></dt><dt>定义，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1076">当变量扩展时</a></dt><dt>扩展，<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1068">当变量扩展时</a></dt><dt>实现、范围界定和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1151">用户定义的函数</a></dt><dt>简介、<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1059">宏</a></dt><dt>从另一个宏、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1148">用户定义函数调用</a></dt><dt>程序变量、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1288">eval 和 value</a></dt><dt>规则、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1292">评估和价值</a></dt></dl></dd><dd><dl><dt>debugging and, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1284">Advanced User-Defined Functions</a></dt><dt>define directive, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1063">Macros</a></dt><dt>defining, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1076">When Variables Are Expanded</a></dt><dt>expanding, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1068">When Variables Are Expanded</a></dt><dt>implementing, scoping and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1151">User-Defined Functions</a></dt><dt>introduction, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1059">Macros</a></dt><dt>invoking from another macro, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1148">User-Defined Functions</a></dt><dt>program-variables, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1288">eval and value</a></dt><dt>rules in, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1292">eval and value</a></dt></dl></dd><dt>make、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-786">如何编写简单的 Makefile</a>、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-787">如何编写简单的 Makefile</a>、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-801">目标和先决条件</a>、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-808">依赖项检查</a>、<a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-817">调用 make</a>、<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-824">基本 Makefile 语法</a>、<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-825">基本 Makefile 语法</a></dt><dt>make, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-786">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-787">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-801">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-808">Dependency Checking</a>, <a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-817">Invoking make</a>, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-824">Basic Makefile Syntax</a>, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-825">Basic Makefile Syntax</a></dt><dd><dl><dt>自动化以及<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-786">如何编写简单的 Makefile</a></dt><dt>命令执行、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-801">目标和先决条件</a></dt><dt>注释，<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-824">基本 Makefile 语法</a></dt><dt>依赖性检查,<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-808">依赖性检查</a></dt><dt>转义字符，<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-825">基本 Makefile 语法</a></dt><dt>调用，<a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-817">调用 make</a></dt><dt>脚本以及<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-787">如何编写简单的 Makefile</a></dt></dl></dd><dd><dl><dt>automation and, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-786">How to Write a Simple Makefile</a></dt><dt>command execution, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-801">Targets and Prerequisites</a></dt><dt>comments, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-824">Basic Makefile Syntax</a></dt><dt>dependency checking, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-808">Dependency Checking</a></dt><dt>escape character, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-825">Basic Makefile Syntax</a></dt><dt>invoking, <a class="indexterm" href="#OEBPS/ch01s04.html.make3-CHP-1-ITERM-817">Invoking make</a></dt><dt>scripts and, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-787">How to Write a Simple Makefile</a></dt></dl></dd><dt>make shell 命令、基准测试和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1531">基准测试</a></dt><dt>make shell command, benchmarking and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1531">Benchmarking</a></dt><dt>make-library 函数，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1391">非递归 make</a></dt><dt>make-library function, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1391">Nonrecursive make</a></dt><dt>MAKECMDGOALS 变量、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1132">标准 make 变量</a>、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1135">标准 make 变量</a></dt><dt>MAKECMDGOALS variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1132">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1135">Standard make Variables</a></dt><dt>makedepend, <a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1450">makedepend 程序</a></dt><dt>makedepend, <a class="indexterm" href="#OEBPS/ch08s03.html.make3-CHP-8-ITERM-1450">makedepend Programs</a></dt><dt>makefiles,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-789">如何编写简单的 Makefile</a> ,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-791">如何编写简单的 Makefile</a> ,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-802">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-806">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-819">基本 Makefile 语法</a>,<a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1495">通用 Java Makefile</a> ,<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1550">书籍 Makefile</a> ,<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1553">书籍 Makefile</a> , <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML 预处理</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML 预处理</a>,<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">生成输出</a>,<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">验证源代码</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1568">Linux 内核 Makefile</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">命令行选项</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">配置与构建</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">管理命令回显</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">用户定义函数</a></dt><dt>makefiles, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-789">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-791">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-802">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-806">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-819">Basic Makefile Syntax</a>, <a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1495">A Generic Java Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1550">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1553">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">Generating Output</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">Validating the Source</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1568">The Linux Kernel Makefile</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">Configuration Versus Building</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">Managing Command Echo</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">User-Defined Functions</a></dt><dd><dl><dt>book makefile、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1550">Book Makefile</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1553">Book Makefile</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML 预处理</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML 预处理</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">生成输出</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">验证源</a></dt><dd><dl><dt>m4 宏、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML 预处理</a></dt><dt>输出生成，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">生成输出</a></dt><dt>源验证，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">验证源</a></dt><dt>XML 预处理, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML 预处理</a></dt></dl></dd><dt>命令执行、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-802">目标和先决条件</a></dt><dt>你好世界，<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-789">如何编写一个简单的 Makefile</a></dt><dt>Java，通用，<a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1495">通用 Java Makefile</a></dt><dt>Linux 内核、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1568">Linux 内核 Makefile</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">命令行选项</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">配置与构建</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">管理命令回显</a>、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">用户定义函数</a></dt><dd><dl><dt>命令回显和<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">管理命令回显</a></dt><dt>命令行选项,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">命令行选项</a></dt><dt>配置与构建，<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">配置与构建</a></dt><dt>用户定义函数,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">用户定义函数</a></dt></dl></dd><dt>语法，<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-819">基本 Makefile 语法</a></dt><dt>目标作为命令行参数，<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-791">如何编写简单的 Makefile</a></dt><dt>自上而下的风格、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-806">目标和先决条件</a></dt></dl></dd><dd><dl><dt>book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1550">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1553">The Book Makefile</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML Preprocessing</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">Generating Output</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">Validating the Source</a></dt><dd><dl><dt>m4 macros, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1560">XML Preprocessing</a></dt><dt>output generation, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1562">Generating Output</a></dt><dt>source validation, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1565">Validating the Source</a></dt><dt>XML preprocessing, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1555">XML Preprocessing</a></dt></dl></dd><dt>command execution, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-802">Targets and Prerequisites</a></dt><dt>Hello World, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-789">How to Write a Simple Makefile</a></dt><dt>Java, generic for, <a class="indexterm" href="#OEBPS/ch09s02.html.make3-CHP-9-ITERM-1495">A Generic Java Makefile</a></dt><dt>Linux kernel, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1568">The Linux Kernel Makefile</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">Configuration Versus Building</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">Managing Command Echo</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">User-Defined Functions</a></dt><dd><dl><dt>command echo and, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1578">Managing Command Echo</a></dt><dt>command-line options, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1571">Command-Line Options</a></dt><dt>configuration versus building, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1574">Configuration Versus Building</a></dt><dt>user-defined functions, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1580">User-Defined Functions</a></dt></dl></dd><dt>syntax, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-819">Basic Makefile Syntax</a></dt><dt>targets as command-line arguments, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-791">How to Write a Simple Makefile</a></dt><dt>top-down style, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-806">Targets and Prerequisites</a></dt></dl></dd><dt>MAKEFILE_LIST 变量、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1128">标准 make 变量</a>、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1130">标准 make 变量</a></dt><dt>MAKEFILE_LIST variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1128">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1130">Standard make Variables</a></dt><dt>MAKEFLAGS 变量、命令环境和<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1343">命令环境</a></dt><dt>MAKEFLAGS variable, command environment and, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1343">Command Environment</a></dt><dt>MAKELEVEL 变量、命令环境、<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1347">命令环境</a></dt><dt>MAKELEVEL variable, command environments, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1347">Command Environment</a></dt><dt>MAKE_VERSION 变量、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1119">标准 make 变量</a>、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1122">标准 make 变量</a></dt><dt>MAKE_VERSION variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1119">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1122">Standard make Variables</a></dt><dt>匹配规则、自动变量、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-902">自动变量</a></dt><dt>matched rules, automatic variables, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-902">Automatic Variables</a></dt><dt>档案图书馆成员、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1013">图书馆管理</a></dt><dt>members of archive libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1013">Managing Libraries</a></dt><dt>杂项功能、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1266">不太重要的杂项功能</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1273">不太重要的杂项功能</a></dt><dt>miscellaneous functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1266">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1273">Less Important Miscellaneous Functions</a></dt><dd><dl><dt>警告，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1273">不太重要的杂项功能</a></dt></dl></dd><dd><dl><dt>warning, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1273">Less Important Miscellaneous Functions</a></dt></dl></dd><dt>mkdir、Ant (Java)、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1485">Ant</a></dt><dt>mkdir, Ant (Java), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1485">Ant</a></dt><dt>模块定义、查找命令、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1399">非递归 make</a></dt><dt>module definition, find command, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1399">Nonrecursive make</a></dt><dt>module.mk 包含文件，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1389">非递归 make</a></dt><dt>module.mk include files, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1389">Nonrecursive make</a></dt><dt>多行命令、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1332">错误和中断</a></dt><dt>multiline commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1332">Errors and Interrupts</a></dt></dl></div><div class="indexdiv"><h3>氮</h3><h3>N</h3><dl><dt>--new-file 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1621">运行 make</a></dt><dt>--new-file option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1621">Running make</a></dt><dt>换行规则，<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-815">最小化重建</a></dt><dt>newline rule, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-815">Minimizing Rebuilds</a></dt><dt>无操作命令、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1329">错误和中断</a></dt><dt>no-op commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1329">Errors and Interrupts</a></dt><dt>非递归make、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1385">非递归make</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1388">非递归make</a></dt><dt>nonrecursive make, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1385">Nonrecursive make</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1388">Nonrecursive make</a></dt><dd><dl><dt>虚假目标和<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1388">非递归 make</a></dt></dl></dd><dd><dl><dt>phony targets and, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1388">Nonrecursive make</a></dt></dl></dd><dt>notdir 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1220">文件名函数</a></dt><dt>notdir function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1220">Filename Functions</a></dt></dl></div><div class="indexdiv"><h3>氧</h3><h3>O</h3><dl><dt>目标文件、更新、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-975">规则结构</a></dt><dt>object files, updates, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-975">Rule Structure</a></dt><dt>--old-file 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1618">运行 make</a></dt><dt>--old-file option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1618">Running make</a></dt><dt>选项、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1327">错误和中断</a>、<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1417">可移植性问题</a></dt><dt>options, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1327">Errors and Interrupts</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1417">Portability Issues</a></dt><dd><dl><dt>命令、错误以及<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1327">错误和中断</a></dt><dt>可移植性和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1417">可移植性问题</a></dt></dl></dd><dd><dl><dt>commands, errors and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1327">Errors and Interrupts</a></dt><dt>portability and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1417">Portability Issues</a></dt></dl></dd><dt>原点函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1268">不太重要的杂项函数</a></dt><dt>origin function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1268">Less Important Miscellaneous Functions</a></dt><dt>输出，书籍 makefile 示例，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1563">生成输出</a></dt><dt>output, book makefile example, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1563">Generating Output</a></dt></dl></div><div class="indexdiv"><h3>磷</h3><h3>P</h3><dl><dt>包、Java、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1472">Java</a></dt><dt>packages, Java, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1472">Java</a></dt><dt>并行性、性能和<a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1547">并行性</a></dt><dt>parallelism, performance and, <a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1547">Parallel make</a></dt><dt>参数、<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1147">用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1295">传递参数</a></dt><dt>parameters, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1147">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1295">Passing Parameters</a></dt><dd><dl><dt>传递给函数，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1295">传递参数</a></dt><dt>用户定义函数,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1147">用户定义函数</a></dt></dl></dd><dd><dl><dt>passing to functions, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1295">Passing Parameters</a></dt><dt>user-defined functions, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1147">User-Defined Functions</a></dt></dl></dd><dt>括号、变量和、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1037">变量和宏</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1262">有关变量和括号的样式注释</a></dt><dt>parentheses, variables and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1037">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1262">Style note concerning variables and parentheses</a></dt><dt>解析、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1290">eval 和 value</a> ,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1301">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">解析命令</a></dt><dt>parsing, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1290">eval and value</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1301">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">Parsing Commands</a></dt><dd><dl><dt>命令,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1301">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">解析命令</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">解析命令</a></dt><dd><dl><dt>命令脚本和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">解析命令</a></dt><dt>编辑器和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">解析命令</a></dt></dl></dd><dt>eval 函数 and, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1290">eval 和 value</a></dt></dl></dd><dd><dl><dt>commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1301">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">Parsing Commands</a></dt><dd><dl><dt>command scripts and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1304">Parsing Commands</a></dt><dt>editors and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1307">Parsing Commands</a></dt></dl></dd><dt>eval function and, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1290">eval and value</a></dt></dl></dd><dt>部分源树,<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1456">部分源树</a></dt><dt>partial source trees, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1456">Partial Source Trees</a></dt><dt>将参数传递给函数，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1296">传递参数</a></dt><dt>passing parameters to functions, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1296">Passing Parameters</a></dt><dt>传递变量、递归 make 和、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1375">传递变量</a></dt><dt>passing variables, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1375">Passing Variables</a></dt><dt>路径、可移植性和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1415">可移植性问题</a></dt><dt>paths, portability and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1415">Portability Issues</a></dt><dt>patsubst 函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1184">字符串函数</a></dt><dt>patsubst function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1184">String Functions</a></dt><dt>模式规则、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-830">规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-833">规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-937">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-945">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-947">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-952">静态模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-958">后缀规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-964">后缀规则</a></dt><dt>pattern rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-830">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-833">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-937">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-945">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-947">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-952">Static Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-958">Suffix Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-964">Suffix Rules</a></dt><dd><dl><dt>%（百分比）字符，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-947">模式</a></dt><dt>隐含规则和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-830">规则</a></dt><dt>图案、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-945">图案</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">图案</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">图案</a></dt><dd><dl><dt>后缀、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">模式</a></dt></dl></dd><dt>静态模式规则,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-952">静态模式规则</a></dt><dt>后缀规则,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-958">后缀规则</a></dt><dt>后缀、删除、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-964">后缀规则</a></dt></dl></dd><dd><dl><dt>% (percent) character, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-947">The Patterns</a></dt><dt>implicit rules and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-830">Rules</a></dt><dt>patterns, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-945">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">The Patterns</a></dt><dd><dl><dt>suffixes, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-948">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-949">The Patterns</a></dt></dl></dd><dt>static pattern rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-952">Static Pattern Rules</a></dt><dt>suffix rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-958">Suffix Rules</a></dt><dt>suffixes, deleting, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-964">Suffix Rules</a></dt></dl></dd><dt>特定于模式的变量、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1079">特定于目标和模式的变量</a></dt><dt>pattern-specific variables, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1079">Target- and Pattern-Specific Variables</a></dt><dt>模式、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1163">内置函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1171">字符串函数</a></dt><dt>patterns, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1163">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1171">String Functions</a></dt><dd><dl><dt>作为内置函数中的参数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1163">内置函数</a></dt><dt>过滤函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1171">字符串函数</a></dt></dl></dd><dd><dl><dt>as arguments
            in built-in functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1163">Built-in Functions</a></dt><dt>filter function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1171">String Functions</a></dt></dl></dd><dt>性能、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1521">提高 make 的性能</a>、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1522">基准测试</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1532">识别和处理瓶颈</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1536">简单变量与递归</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1537">简单变量与递归</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1543">禁用 @</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1544">延迟初始化</a>、<a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1546">并行 make</a>、<a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1548">分布式 make</a></dt><dt>performance, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1521">Improving the Performance of make</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1522">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1532">Identifying and Handling Bottlenecks</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1536">Simple Variables Versus Recursive</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1537">Simple Variables Versus Recursive</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1543">Disabling @</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1544">Lazy Initialization</a>, <a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1546">Parallel make</a>, <a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1548">Distributed make</a></dt><dd><dl><dt>@ 符号并且<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1543">禁用 @</a></dt><dt>基准测试和<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1522">基准测试</a></dt><dt>瓶颈、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1532">识别和处理瓶颈</a></dt><dt>分布式和<a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1548">分布式制造</a></dt><dt>初始化和<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1544">延迟初始化</a></dt><dt>简介，<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1521">提高 make 的性能</a></dt><dt>并行性和<a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1546">并行性</a></dt><dt>递归变量，<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1536">简单变量与递归</a></dt><dt>简单变量，<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1537">简单变量与递归</a></dt></dl></dd><dd><dl><dt>@ sign and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1543">Disabling @</a></dt><dt>benchmarking and, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1522">Benchmarking</a></dt><dt>bottlenecks, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1532">Identifying and Handling Bottlenecks</a></dt><dt>distribution and, <a class="indexterm" href="#OEBPS/ch10s04.html.make3-CHP-10-ITERM-1548">Distributed make</a></dt><dt>initialization and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1544">Lazy Initialization</a></dt><dt>introduction, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1521">Improving the Performance of make</a></dt><dt>parallelism and, <a class="indexterm" href="#OEBPS/ch10s03.html.make3-CHP-10-ITERM-1546">Parallel make</a></dt><dt>recursive variables, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1536">Simple Variables Versus Recursive</a></dt><dt>simple variables, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1537">Simple Variables Versus Recursive</a></dt></dl></dd><dt>虚假目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-861">虚假</a><a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-866">目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-869">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-870">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">虚假目标</a>、虚假目标、虚假<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-876">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-878">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-991">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1387">非递归 make</a></dt><dt>phony targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-861">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-866">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-869">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-870">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-876">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-878">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-991">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1387">Nonrecursive make</a></dt><dd><dl><dt>awk 命令，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-870">虚假目标</a></dt><dt>df 命令，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-869">虚假目标</a></dt><dt>接口和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-876">虚假目标</a></dt><dt>非递归 make 和<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1387">非递归 make</a></dt><dt>输出，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">虚假目标</a>，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">虚假目标</a></dt><dd><dl><dt>调试，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">虚假目标</a></dt><dt>阅读，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">虚假目标</a></dt></dl></dd><dt>先决条件、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-866">虚假目标</a></dt><dt>特殊目标，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-991">特殊目标</a></dt><dt>标准、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-878">虚假目标</a></dt></dl></dd><dd><dl><dt>awk command, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-870">Phony Targets</a></dt><dt>df command, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-869">Phony Targets</a></dt><dt>interfaces and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-876">Phony Targets</a></dt><dt>nonrecursive make and, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1387">Nonrecursive make</a></dt><dt>output, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">Phony Targets</a></dt><dd><dl><dt>debugging, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-874">Phony Targets</a></dt><dt>reading, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-873">Phony Targets</a></dt></dl></dd><dt>prerequisites, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-866">Phony Targets</a></dt><dt>special targets, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-991">Special Targets</a></dt><dt>standard, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-878">Phony Targets</a></dt></dl></dd><dt>可移植性,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1412">可移植性 Makefile</a> ,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1413">可移植性问题</a>,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1416">可移植性问题</a>,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1418">可移植性</a>问题,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1420">可移植性问题</a>,<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1422">可移植性问题</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1423">Cygwin</a> ,<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1438">使用不可移植工具</a>,<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1440">标准 Shell</a> , <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1487">Ant</a></dt><dt>portability, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1412">Portable Makefiles</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1413">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1416">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1418">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1420">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1422">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1423">Cygwin</a>, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1438">Working with Nonportable Tools</a>, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1440">A Standard Shell</a>, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1487">Ant</a></dt><dd><dl><dt>蚂蚁（Java），<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1487">蚂蚁</a></dt><dt>西格温,<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1423">西格温</a></dt><dt>非便携式工具，<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1438">使用非便携式工具</a></dt><dt>选项和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1418">可移植性问题</a></dt><dt>路径和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1416">可移植性问题</a></dt><dt>程序行为和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1422">可移植性问题</a></dt><dt>程序名称和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1413">可移植性问题</a></dt><dt>shell 和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1420">可移植性问题</a>，<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1440">标准 Shell</a></dt></dl></dd><dd><dl><dt>Ant (Java), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1487">Ant</a></dt><dt>Cygwin, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1423">Cygwin</a></dt><dt>nonportable tools, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1438">Working with Nonportable Tools</a></dt><dt>options and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1418">Portability Issues</a></dt><dt>paths and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1416">Portability Issues</a></dt><dt>program behavior and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1422">Portability Issues</a></dt><dt>program names and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1413">Portability Issues</a></dt><dt>shell and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1420">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1440">A Standard Shell</a></dt></dl></dd><dt>.PRECIOUS 目标修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1004">特殊目标</a></dt><dt>.PRECIOUS target
                  modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1004">Special Targets</a></dt><dt>命令前缀、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1314">命令修饰符</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1317">命令修饰符</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1323">命令修饰符</a></dt><dt>prefixes on commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1314">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1317">Command Modifiers</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1323">Command Modifiers</a></dt><dd><dl><dt>+（加号），<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1323">命令修饰符</a></dt><dt>-（破折号），<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1317">命令修饰符</a></dt><dt>@,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1314">命令修饰符</a></dt></dl></dd><dd><dl><dt>+ (plus), <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1323">Command Modifiers</a></dt><dt>- (dash), <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1317">Command Modifiers</a></dt><dt>@, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1314">Command Modifiers</a></dt></dl></dd><dt>前缀、模式规则、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-950">模式</a></dt><dt>prefixes, pattern rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-950">The Patterns</a></dt><dt>先决条件,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-797">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">依赖项检查</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-865">虚假目标</a>,<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-908">自动变量</a>,<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1021">使用库作为先决条件</a>,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1024">使用库作为先决条件</a>,<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1367">递归 make</a></dt><dt>prerequisites, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-797">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">Dependency Checking</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-865">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-908">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1021">Using Libraries as Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1024">Using Libraries as Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1367">Recursive make</a></dt><dd><dl><dt>自动变量和<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-908">自动变量</a></dt><dt>库作为，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1021">使用库作为先决条件</a></dt><dt>虚假目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-865">虚假目标</a></dt><dt>规则、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-797">目标和先决条件</a></dt><dt>保存，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1024">使用库作为先决条件</a></dt><dt>目标、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">依赖性检查</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">特殊目标</a></dt><dd><dl><dt>链接、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">依赖性检查</a></dt><dt>.INTERMEDIATE 修饰符和<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">特殊目标</a></dt><dt>.SECONDARY 修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">特殊目标</a></dt></dl></dd><dt>更新、排序和<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1367">递归 make</a></dt></dl></dd><dd><dl><dt>automatic variables and, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-908">Automatic Variables</a></dt><dt>libraries as, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1021">Using Libraries as Prerequisites</a></dt><dt>phony targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-865">Phony Targets</a></dt><dt>rules and, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-797">Targets and Prerequisites</a></dt><dt>saving, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1024">Using Libraries as Prerequisites</a></dt><dt>targets, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">Dependency Checking</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">Special Targets</a></dt><dd><dl><dt>chaining, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-810">Dependency Checking</a></dt><dt>.INTERMEDIATE
                  modifier and, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-997">Special Targets</a></dt><dt>.SECONDARY
                  modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1001">Special Targets</a></dt></dl></dd><dt>updates, ordering and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1367">Recursive make</a></dt></dl></dd><dt>--print-data-base 选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1619">运行 make</a></dt><dt>--print-data-base
                option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1619">Running make</a></dt><dt>程序行为、可移植性和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1421">可移植性问题</a></dt><dt>program behavior, portability and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1421">Portability Issues</a></dt><dt>程序管理，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1430">管理程序和文件</a></dt><dt>program management, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1430">Managing Programs and Files</a></dt><dt>程序名称、可移植性和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1414">可移植性问题</a></dt><dt>program names, portability and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1414">Portability Issues</a></dt><dt>程序变量宏、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1287">eval 和 value</a></dt><dt>program-variables macro, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1287">eval and value</a></dt></dl></div><div class="indexdiv"><h3>右</h3><h3>R</h3><dl><dt>RCS 源代码控制、隐式规则和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-983">源代码控制的隐式规则</a></dt><dt>RCS source control, implicit rules and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-983">Implicit Rules for Source Control</a></dt><dt>只读源,<a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1447">只读源</a></dt><dt>read-only source, <a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1447">Read-Only Source</a></dt><dt>重建、最小化、<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-811">最小化重建</a></dt><dt>rebuilds, minimizing, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-811">Minimizing Rebuilds</a></dt><dt>递归，<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1364">管理大型项目</a></dt><dt>recursion, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1364">Managing Large Projects</a></dt><dt>递归 make、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1365">递归 make</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1370">递归 make</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1372">命令行选项</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1373">传递变量</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1376">错误处理</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1380">构建其他目标</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1382">避免重复代码</a>、<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1384">非递归 make</a></dt><dt>recursive make, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1365">Recursive make</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1370">Recursive make</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1372">Command-Line Options</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1373">Passing Variables</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1376">Error Handling</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1380">Building Other Targets</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1382">Avoiding Duplicate Code</a>, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1384">Nonrecursive make</a></dt><dd><dl><dt>（另请参阅非递归 make）</dt><dt>建立目标并<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1380">建立其他目标</a></dt><dt>代码重复，<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1382">避免重复代码</a></dt><dt>命令行和<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1372">命令行选项</a></dt><dt>依赖关系和<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1370">递归 make</a></dt><dt>错误处理,<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1376">错误处理</a></dt><dt>变量、传递、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1373">传递变量</a></dt></dl></dd><dd><dl><dt>(see also nonrecursive make)</dt><dt>build targets and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1380">Building Other Targets</a></dt><dt>code duplication, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1382">Avoiding Duplicate Code</a></dt><dt>command-line and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1372">Command-Line Options</a></dt><dt>dependencies and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1370">Recursive make</a></dt><dt>error handling, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1376">Error Handling</a></dt><dt>variables, passing, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1373">Passing Variables</a></dt></dl></dd><dt>递归变量、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1207">重要的杂项函数</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1538">简单变量与递归</a></dt><dt>recursive variables, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1207">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1538">Simple Variables Versus Recursive</a></dt><dd><dl><dt>性能以及<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1538">简单变量与递归</a></dt><dt>shell 函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1207">重要的杂项函数</a></dt></dl></dd><dd><dl><dt>performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1538">Simple Variables Versus Recursive</a></dt><dt>shell function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1207">Important Miscellaneous Functions</a></dt></dl></dd><dt>递归扩展变量，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1052">变量类型</a></dt><dt>recursively expanded variables, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1052">Variable Types</a></dt><dt>参考构建、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1461">参考构建、库和安装程序</a>、<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1462">参考构建、库和安装程序</a></dt><dt>reference builds, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1461">Reference Builds, Libraries, and Installers</a>, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1462">Reference Builds, Libraries, and Installers</a></dt><dd><dl><dt>安装程序和<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1462">参考版本、库和安装程序</a></dt><dt>库以及<a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1461">参考版本、库和安装程序</a></dt></dl></dd><dd><dl><dt>installers and, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1462">Reference Builds, Libraries, and Installers</a></dt><dt>libraries and, <a class="indexterm" href="#OEBPS/ch08s06.html.make3-CHP-8-ITERM-1461">Reference Builds, Libraries, and Installers</a></dt></dl></dd><dt>参考树、jar 程序、<a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1511">参考树和第三方 Jars</a></dt><dt>reference trees, jar program, <a class="indexterm" href="#OEBPS/ch09s05.html.make3-CHP-9-ITERM-1511">Reference Trees and Third-Party Jars</a></dt><dt>regtool，<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1502">设置 CLASSPATH</a></dt><dt>regtool, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1502">Setting CLASSPATH</a></dt><dt>相对路径、转换为 Java 类名、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1210">重要杂项函数</a></dt><dt>relative paths, converting to Java class name, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1210">Important Miscellaneous Functions</a></dt><dt>远程文件函数，<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1626">数据结构</a></dt><dt>remote-file function, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1626">Data Structures</a></dt><dt>可重用的库函数、声明、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-926">使用 VPATH 和 vpath 查找文件</a></dt><dt>reusable library functions, declarations, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-926">Finding Files with VPATH and vpath</a></dt><dt>规则链、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-939">模式规则</a></dt><dt>rule chaining, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-939">Pattern Rules</a></dt><dt>规则,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-794">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-795">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-798">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-799">目标和先决条件</a>,<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-813">最小化重建</a>,<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-814">最小化重建</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-826">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-832">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-834">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-836">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-838">规则</a>,显式<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-840">规则</a>,空<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-897">目标</a>,显式<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">规则</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">假目标</a>,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">空目标</a>,<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-901">自动变量</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-936">模式规则</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-954">静态模式规则</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">后缀规则</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-966">隐式规则数据库</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">使用隐式</a>规则,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-970">使用隐式规则</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-973">规则结构</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-977">规则结构</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-978">规则结构</a>,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">源代码管理隐式规则</a>,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1028">双冒号规则</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1291">eval 和 value</a></dt><dt>rules, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-794">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-795">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-798">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-799">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-813">Minimizing Rebuilds</a>, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-814">Minimizing Rebuilds</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-826">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-832">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-834">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-836">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-838">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-840">Explicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-897">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">Explicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-901">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-936">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-954">Static Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">Suffix Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-966">The Implicit Rules Database</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">Working with Implicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-970">Working with Implicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-973">Rule Structure</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-977">Rule Structure</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-978">Rule Structure</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">Implicit Rules for Source Control</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1028">Double-Colon Rules</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1291">eval and value</a></dt><dd><dl><dt>任何角色，<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-813">最小化重建</a></dt><dt>链接、中间文件、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-970">使用隐式规则</a></dt><dt>定制、变量和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-977">规则结构</a></dt><dt>默认规则、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-798">目标和先决条件</a></dt><dt>家属、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-799">目标和先决条件</a></dt><dt>双冒号,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1028">双冒号规则</a></dt><dt>显式、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-826">规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-840">显式规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-897">空目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">空目标</a></dt><dd><dl><dt>空目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">空目标</a></dt><dt>虚假目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">虚假目标</a></dt></dl></dd><dt>隐式、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-834">规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-966">隐式规则数据库</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">使用隐式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">源代码控制的隐式规则</a></dt><dd><dl><dt>内置，<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">使用隐式规则</a></dt><dt>源代码控制和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">源代码控制的隐式规则</a></dt></dl></dd><dt>宏、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1291">eval 和 value</a></dt><dt>匹配、自动变量和、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-901">自动变量</a></dt><dt>换行，<a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-814">最小化重建</a></dt><dt>模式、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-832">规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-936">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">后缀规则</a></dt><dd><dl><dt>后缀规则,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">后缀规则</a></dt></dl></dd><dt>先决条件和<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-795">目标和先决条件</a></dt><dt>静态模式,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-836">规则</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-954">静态模式规则</a></dt><dt>结构、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-973">规则结构</a></dt><dt>后缀、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-838">规则</a></dt><dt>目标、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-794">目标和先决条件</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">明确规则</a></dt><dd><dl><dt>多重、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">明确的规则</a></dt></dl></dd><dt>变量、定制和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-978">规则结构</a></dt></dl></dd><dd><dl><dt>any character, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-813">Minimizing Rebuilds</a></dt><dt>chaining, intermediate files, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-970">Working with Implicit Rules</a></dt><dt>customization, variables and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-977">Rule Structure</a></dt><dt>default rule, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-798">Targets and Prerequisites</a></dt><dt>dependents, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-799">Targets and Prerequisites</a></dt><dt>double-colon, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1028">Double-Colon Rules</a></dt><dt>explicit, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-826">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-840">Explicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-897">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">Empty Targets</a></dt><dd><dl><dt>empty targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-889">Empty Targets</a></dt><dt>phony targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-864">Phony Targets</a></dt></dl></dd><dt>implicit, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-834">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-966">The Implicit Rules Database</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">Working with Implicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">Implicit Rules for Source Control</a></dt><dd><dl><dt>built-in, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-969">Working with Implicit Rules</a></dt><dt>source control and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-982">Implicit Rules for Source Control</a></dt></dl></dd><dt>macros, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1291">eval and value</a></dt><dt>matching, automatic variables and, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-901">Automatic Variables</a></dt><dt>newline, <a class="indexterm" href="#OEBPS/ch01s03.html.make3-CHP-1-ITERM-814">Minimizing Rebuilds</a></dt><dt>pattern, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-832">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-936">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">Suffix Rules</a></dt><dd><dl><dt>suffix rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-959">Suffix Rules</a></dt></dl></dd><dt>prerequisites and, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-795">Targets and Prerequisites</a></dt><dt>static pattern, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-836">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-954">Static Pattern Rules</a></dt><dt>structure, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-973">Rule Structure</a></dt><dt>suffix, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-838">Rules</a></dt><dt>targets, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-794">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">Explicit Rules</a></dt><dd><dl><dt>multiple, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-841">Explicit Rules</a></dt></dl></dd><dt>variables, customization and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-978">Rule Structure</a></dt></dl></dd><dt>run-make shell 脚本、运行书籍 makefile、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1554">管理示例</a></dt><dt>run-make shell script, running book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1554">Managing Examples</a></dt></dl></div><div class="indexdiv"><h3>S</h3><h3>S</h3><dl><dt>SCCS 源代码控制、隐式规则和<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-984">源代码控制的隐式规则</a></dt><dt>SCCS source control, implicit rules and, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-984">Implicit Rules for Source Control</a></dt><dt>范围界定、宏实现和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1150">用户定义函数</a></dt><dt>scoping, macro implementation and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1150">User-Defined Functions</a></dt><dt>脚本、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-788">如何编写简单的 Makefile</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1303">解析命令</a></dt><dt>scripts, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-788">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1303">Parsing Commands</a></dt><dd><dl><dt>命令脚本、解析和<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1303">解析命令</a></dt><dt>make 以及<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-788">如何编写简单的 Makefile</a></dt></dl></dd><dd><dl><dt>command scripts, parsing and, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1303">Parsing Commands</a></dt><dt>make and, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-788">How to Write a Simple Makefile</a></dt></dl></dd><dt>搜索和替换函数、字符串、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1179">字符串函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1187">字符串函数</a></dt><dt>search and replace functions, strings, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1179">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1187">String Functions</a></dt><dd><dl><dt>替换引用、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1187">字符串函数</a></dt></dl></dd><dd><dl><dt>substitution references, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1187">String Functions</a></dt></dl></dd><dt>搜索、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-919">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-920">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1457">部分源树</a>、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1458">部分源树</a></dt><dt>searches, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-919">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-920">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1457">Partial Source Trees</a>, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1458">Partial Source Trees</a></dt><dd><dl><dt>二叉树、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1458">部分源树</a></dt><dt>源树，<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1457">部分源树</a></dt><dt>VPATH 和，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-919">使用 VPATH 和 vpath 查找文件</a></dt><dt>vpath 和，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-920">使用 VPATH 和 vpath 查找文件</a></dt></dl></dd><dd><dl><dt>binary trees, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1458">Partial Source Trees</a></dt><dt>source treese, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1457">Partial Source Trees</a></dt><dt>VPATH and, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-919">Finding Files with VPATH and vpath</a></dt><dt>vpath and, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-920">Finding Files with VPATH and vpath</a></dt></dl></dd><dt>.SECONDARY 目标修饰符，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1000">特殊目标</a></dt><dt>.SECONDARY
                  target modifier, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1000">Special Targets</a></dt><dt>分隔符、缺失（错误消息）、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1601">缺失分隔符</a></dt><dt>separators, missing (error messages), <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1601">missing separator</a></dt><dt>shell、<a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1336">使用哪个 Shell</a>、<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1419">可移植性问题</a>、<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1439">标准 Shell</a></dt><dt>shell, <a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1336">Which Shell to Use</a>, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1419">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1439">A Standard Shell</a></dt><dd><dl><dt>命令行、子 shell、<a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1336">使用哪个 Shell</a></dt><dt>可移植性和<a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1419">可移植性问题</a>，<a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1439">标准 Shell</a></dt></dl></dd><dd><dl><dt>command lines, subshells, <a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1336">Which Shell to Use</a></dt><dt>portability and, <a class="indexterm" href="#OEBPS/ch07.html.make3-CHP-7-ITERM-1419">Portability Issues</a>, <a class="indexterm" href="#OEBPS/ch07s04.html.make3-CHP-7-ITERM-1439">A Standard Shell</a></dt></dl></dd><dt>shell 命令、序列、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1310">连续长命令</a></dt><dt>shell commands, sequences, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1310">Continuing Long Commands</a></dt><dt>shell 函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1202">重要杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1204">重要杂项函数</a></dt><dt>shell function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1202">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1204">Important Miscellaneous Functions</a></dt><dd><dl><dt>变量，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1204">重要的杂项函数</a></dt></dl></dd><dd><dl><dt>variables, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1204">Important Miscellaneous Functions</a></dt></dl></dd><dt>简单变量、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1206">重要杂项函数</a>、<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1539">简单变量与递归</a></dt><dt>simple variables, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1206">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1539">Simple Variables Versus Recursive</a></dt><dd><dl><dt>性能以及<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1539">简单变量与递归</a></dt><dt>shell 函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1206">重要的杂项函数</a></dt></dl></dd><dd><dl><dt>performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1539">Simple Variables Versus Recursive</a></dt><dt>shell function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1206">Important Miscellaneous Functions</a></dt></dl></dd><dt>简单扩展变量，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1050">变量类型</a></dt><dt>simply expanded variables, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1050">Variable Types</a></dt><dt>排序函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1200">重要的杂项函数</a></dt><dt>sort function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1200">Important Miscellaneous Functions</a></dt><dt>源、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-928">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1442">分离源代码和二进制文件</a>、<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1445">困难的方法</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1566">验证源代码</a></dt><dt>source, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-928">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1442">Separating Source and Binary</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1445">The Hard Way</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1566">Validating the Source</a></dt><dd><dl><dt>二叉树分离，<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1442">分离源代码和二进制</a>，<a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1445">困难的方法</a></dt><dt>src目录，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-928">使用VPATH和vpath查找文件</a></dt><dt>验证、书籍 makefile、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1566">验证源代码</a></dt></dl></dd><dd><dl><dt>binary tree separation, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1442">Separating Source and Binary</a>, <a class="indexterm" href="#OEBPS/ch08.html.make3-CHP-8-ITERM-1445">The Hard Way</a></dt><dt>src directory, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-928">Finding Files with VPATH and vpath</a></dt><dt>validation, book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1566">Validating the Source</a></dt></dl></dd><dt>源树、<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1437">源树布局</a>、<a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1446">只读源</a>、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1455">部分源树</a>、<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1459">部分源树</a></dt><dt>source trees, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1437">Source Tree Layout</a>, <a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1446">Read-Only Source</a>, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1455">Partial Source Trees</a>, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1459">Partial Source Trees</a></dt><dd><dl><dt>布局、文件管理和<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1437">源树布局</a></dt><dt>部分，<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1455">部分源树</a></dt><dt>只读，<a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1446">只读源</a></dt><dt>搜索，<a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1459">部分源树</a></dt></dl></dd><dd><dl><dt>layout, file management and, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1437">Source Tree Layout</a></dt><dt>partial, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1455">Partial Source Trees</a></dt><dt>read-only, <a class="indexterm" href="#OEBPS/ch08s02.html.make3-CHP-8-ITERM-1446">Read-Only Source</a></dt><dt>searches, <a class="indexterm" href="#OEBPS/ch08s05.html.make3-CHP-8-ITERM-1459">Partial Source Trees</a></dt></dl></dd><dt>源到对象函数，<a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1393">非递归 make</a></dt><dt>source-to-object function, <a class="indexterm" href="#OEBPS/ch06s02.html.make3-CHP-6-ITERM-1393">Nonrecursive make</a></dt><dt>变量的来源，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1087">变量从哪里来</a></dt><dt>sources of variables, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1087">Where Variables Come From</a></dt><dt>空格转题功能，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1434">管理程序和文件</a></dt><dt>space-to-question function, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1434">Managing Programs and Files</a></dt><dt>特殊目标，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-990">特殊目标</a></dt><dt>special targets, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-990">Special Targets</a></dt><dt>src 目录、源文件、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-930">使用 VPATH 和 vpath 查找文件</a></dt><dt>src directory, source files, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-930">Finding Files with VPATH and vpath</a></dt><dt>静态模式规则,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-837">规则</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-953">静态模式规则</a></dt><dt>static pattern rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-837">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-953">Static Pattern Rules</a></dt><dt>状态码、命令、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1325">错误和中断</a></dt><dt>status code, commands, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1325">Errors and Interrupts</a></dt><dt>stderr 文件描述符，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1354">命令环境</a></dt><dt>stderr file descriptor, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1354">Command Environment</a></dt><dt>stdin 文件描述符，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1352">命令环境</a></dt><dt>stdin file descriptor, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1352">Command Environment</a></dt><dt>stdout 文件描述符，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1353">命令环境</a></dt><dt>stdout file descriptor, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1353">Command Environment</a></dt><dt>字符串函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1166">字符串函数</a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1168">,</a>字符串<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1174">函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1177">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1178">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1182">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1186">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1193">字符串函数</a>,字符串函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1196">字符串函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1199">字符串函数</a></dt><dt>string functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1166">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1168">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1174">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1177">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1178">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1182">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1186">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1193">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1196">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1199">String Functions</a></dt><dd><dl><dt>过滤器、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1168">字符串函数</a></dt><dt>过滤器，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1174">字符串函数</a></dt><dt>查找字符串、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1177">字符串函数</a></dt><dt>第一个字，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1196">字符串函数</a></dt><dt>patsubst，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1186">字符串函数</a></dt><dt>搜索和替换函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1178">字符串函数</a></dt><dt>subst，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1182">字符串函数</a></dt><dt>词表、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1199">字符串函数</a></dt><dt>单词、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1193">字符串函数</a></dt></dl></dd><dd><dl><dt>filter, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1168">String Functions</a></dt><dt>filter-out, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1174">String Functions</a></dt><dt>findstring, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1177">String Functions</a></dt><dt>firstword, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1196">String Functions</a></dt><dt>patsubst, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1186">String Functions</a></dt><dt>search and replace functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1178">String Functions</a></dt><dt>subst, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1182">String Functions</a></dt><dt>wordlist, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1199">String Functions</a></dt><dt>words, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1193">String Functions</a></dt></dl></dd><dt>剥离功能，<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1112">条件和包括处理</a>，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1263">不太重要的杂项功能</a></dt><dt>strip function, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1112">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1263">Less Important Miscellaneous Functions</a></dt><dd><dl><dt>空白删除、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1112">条件和包含处理</a></dt></dl></dd><dd><dl><dt>whitespace removal, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1112">Conditional and include Processing</a></dt></dl></dd><dt>规则结构,<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-974">规则结构</a></dt><dt>structure of rules, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-974">Rule Structure</a></dt><dt>子 shell、命令行以及<a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1335">使用哪个 Shell</a></dt><dt>subshells, command lines and, <a class="indexterm" href="#OEBPS/ch05s02.html.make3-CHP-5-ITERM-1335">Which Shell to Use</a></dt><dt>subst 函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1181">字符串函数</a></dt><dt>subst function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1181">String Functions</a></dt><dt>替换引用、字符串函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1188">字符串函数</a></dt><dt>substitution references, string
                    functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1188">String Functions</a></dt><dt>后缀函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1225">文件名函数</a></dt><dt>suffix function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1225">Filename Functions</a></dt><dt>后缀规则,<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-831">规则</a>,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-960">后缀规则</a></dt><dt>suffix rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-831">Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-960">Suffix Rules</a></dt><dd><dl><dt>隐含规则和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-831">规则</a></dt></dl></dd><dd><dl><dt>implicit rules and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-831">Rules</a></dt></dl></dd><dt>后缀、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-951">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-962">后缀规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">后缀规则</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1223">文件名函数</a></dt><dt>suffixes, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-951">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-962">Suffix Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">Suffix Rules</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1223">Filename Functions</a></dt><dd><dl><dt>文件名、函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1223">文件名函数</a></dt><dt>模式规则、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-951">模式</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">后缀规则</a></dt><dd><dl><dt>删除、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">后缀规则</a></dt></dl></dd><dt>目标，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-962">后缀规则</a></dt></dl></dd><dd><dl><dt>filenames, functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1223">Filename Functions</a></dt><dt>pattern rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-951">The Patterns</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">Suffix Rules</a></dt><dd><dl><dt>deleting, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-963">Suffix Rules</a></dt></dl></dd><dt>targets, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-962">Suffix Rules</a></dt></dl></dd><dt>语法、<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-820">基本 Makefile 语法</a>、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1084">特定于目标和模式的变量</a>、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1105">条件和包含处理</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1156">内置函数</a>、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1308">解析命令</a>、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1600">语法错误</a></dt><dt>syntax, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-820">Basic Makefile Syntax</a>, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1084">Target- and Pattern-Specific Variables</a>, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1105">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1156">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1308">Parsing Commands</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1600">Syntax Errors</a></dt><dd><dl><dt>内置函数,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1156">内置函数</a></dt><dt>条件指令、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1105">Conditional 和 include 处理</a></dt><dt>编辑器，<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1308">解析命令</a></dt><dt>错误、调试和<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1600">语法错误</a></dt><dt>makefile，<a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-820">基本 Makefile 语法</a></dt><dt>特定于目标的变量、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1084">特定于目标和模式的变量</a></dt></dl></dd><dd><dl><dt>built-in functions, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1156">Built-in Functions</a></dt><dt>conditional directives, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1105">Conditional and include Processing</a></dt><dt>editors, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1308">Parsing Commands</a></dt><dt>errors, debugging and, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1600">Syntax Errors</a></dt><dt>makefile, <a class="indexterm" href="#OEBPS/ch01s05.html.make3-CHP-1-ITERM-820">Basic Makefile Syntax</a></dt><dt>target-specific variables, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1084">Target- and Pattern-Specific Variables</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>时间</h3><h3>T</h3><dl><dt>制表符、错误消息、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1602">命令在第一个目标之前开始</a></dt><dt>tab character, error message, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1602">commands commence before first target</a></dt><dt>标签 目标，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-883">虚假目标</a></dt><dt>TAGS target, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-883">Phony Targets</a></dt><dt>特定于目标的变量、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1078">特定于目标和模式的变量</a>、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1085">特定于目标和模式的变量</a></dt><dt>target-specific variables, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1078">Target- and Pattern-Specific Variables</a>, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1085">Target- and Pattern-Specific Variables</a></dt><dd><dl><dt>语法、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1085">特定于目标和模式的变量</a></dt></dl></dd><dd><dl><dt>syntax, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1085">Target- and Pattern-Specific Variables</a></dt></dl></dd><dt>目标、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-792">如何编写简单的 Makefile</a>、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-796">目标和先决条件</a>、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">依赖性检查</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">显式规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-886">虚假目标</a>、空<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-862">目标</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-904">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-941">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-955">静态模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-961">后缀规则</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-989">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-993">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">特殊目标</a>,<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">使用库作为先决条件</a>,<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1333">删除和保留目标文件</a>,<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1378">构建其他目标</a>,<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607">覆盖目标命令</a><a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-886"></a><a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-904"></a><a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-941"></a><a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-955"></a><a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-961"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-989"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-993"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005"></a><a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007"></a><a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023"></a><a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1333"></a><a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1378"></a><a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607"></a></dt><dt>targets, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-792">How to Write a Simple Makefile</a>, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-796">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">Dependency Checking</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">Explicit Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-862">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-886">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-904">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-941">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-955">Static Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-961">Suffix Rules</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-989">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-993">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">Using Libraries as Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1333">Deleting and preserving target files</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1378">Building Other Targets</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607">Overriding Commands for Target</a></dt><dd><dl><dt>自动变量和<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-904">自动变量</a></dt><dt>构建目标、递归 make 以及<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1378">构建其他目标</a></dt><dt>作为命令行参数，<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-792">如何编写简单的 Makefile</a></dt><dt>命令、覆盖、<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607">覆盖目标命令</a></dt><dt>删除、<a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1333">删除和保留目标文件</a></dt><dt>空，<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-886">空目标</a></dt><dt>修饰符、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-993">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">特殊目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">特殊目标</a></dt><dd><dl><dt>.DELETE_ON_ERROR，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">特殊目标</a></dt><dt>.中级，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">特殊目标</a></dt><dt>.珍贵<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">的特殊目标</a></dt><dt>.SECONDARY，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">特殊目标</a></dt></dl></dd><dt>虚假目标、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-862">虚假目标</a>、<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">特殊目标</a></dt><dd><dl><dt>特殊目标，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">特殊目标</a></dt></dl></dd><dt>先决条件、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">依赖项检查</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">使用库作为先决条件</a></dt><dd><dl><dt>链接、<a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">依赖性检查</a></dt><dt>保存，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">使用库作为先决条件</a></dt></dl></dd><dt>规则、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-796">目标和先决条件</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">明确规则</a></dt><dd><dl><dt>明确的规则、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">规则</a></dt><dt>多重、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">明确的规则</a></dt></dl></dd><dt>特殊目标，<a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-989">特殊目标</a></dt><dt>静态模式规则,<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-955">静态模式规则</a></dt><dt>后缀、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-961">后缀规则</a></dt><dt>更新、规则链接和<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-941">模式规则</a></dt></dl></dd><dd><dl><dt>automatic variables and, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-904">Automatic Variables</a></dt><dt>build targets, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1378">Building Other Targets</a></dt><dt>as command-line
          arguments, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-792">How to Write a Simple Makefile</a></dt><dt>commands, overriding, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1607">Overriding Commands for Target</a></dt><dt>deleting, <a class="indexterm" href="#OEBPS/ch05.html.make3-CHP-5-ITERM-1333">Deleting and preserving target files</a></dt><dt>empty, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-886">Empty Targets</a></dt><dt>modifiers, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-993">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">Special Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">Special Targets</a></dt><dd><dl><dt>.DELETE_ON_ERROR, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1007">Special Targets</a></dt><dt>.INTERMEDIATE, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-995">Special Targets</a></dt><dt>.PRECIOUS, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-1005">Special Targets</a></dt><dt>.SECONDARY, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-999">Special Targets</a></dt></dl></dd><dt>phony targets, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-862">Phony Targets</a>, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">Special Targets</a></dt><dd><dl><dt>special targets, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-992">Special Targets</a></dt></dl></dd><dt>prerequisites, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">Dependency Checking</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">Using Libraries as Prerequisites</a></dt><dd><dl><dt>chaining, <a class="indexterm" href="#OEBPS/ch01s02.html.make3-CHP-1-ITERM-809">Dependency Checking</a></dt><dt>saving, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1023">Using Libraries as Prerequisites</a></dt></dl></dd><dt>rules, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-796">Targets and Prerequisites</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">Explicit Rules</a></dt><dd><dl><dt>explicit rules, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-828">Rules</a></dt><dt>multiple, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-842">Explicit Rules</a></dt></dl></dd><dt>special targets, <a class="indexterm" href="#OEBPS/ch02s06.html.make3-CHP-2-ITERM-989">Special Targets</a></dt><dt>static pattern rules, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-955">Static Pattern Rules</a></dt><dt>suffixes, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-961">Suffix Rules</a></dt><dt>updating, rule chaining and, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-941">Pattern Rules</a></dt></dl></dd><dt>任务（蚂蚁），<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1482">蚂蚁</a></dt><dt>tasks (Ant), <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1482">Ant</a></dt><dt>文本扩展、foreach 函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1259">流程控制</a></dt><dt>text expansion, foreach function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1259">Flow Control</a></dt><dt>时间戳、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-892">空目标</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1209">重要杂项函数</a></dt><dt>timestamps, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-892">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1209">Important Miscellaneous Functions</a></dt><dd><dl><dt>空文件和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-892">空目标</a></dt><dt>文件名和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1209">重要的杂项功能</a></dt></dl></dd><dd><dl><dt>empty files and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-892">Empty Targets</a></dt><dt>filenames and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1209">Important Miscellaneous Functions</a></dt></dl></dd><dt>自上而下的风格、makefile、<a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-805">目标和先决条件</a></dt><dt>top-down style, makefiles, <a class="indexterm" href="#OEBPS/ch01.html.make3-CHP-1-ITERM-805">Targets and Prerequisites</a></dt><dt>--touch选项，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1620">运行make</a></dt><dt>--touch option, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1620">Running make</a></dt></dl></div><div class="indexdiv"><h3>U</h3><h3>U</h3><dl><dt>更新、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-942">模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-976">规则结构</a>、<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1020">创建和更新库</a>、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1368">递归 make</a></dt><dt>updates, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-942">Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-976">Rule Structure</a>, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1020">Creating and Updating Libraries</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1368">Recursive make</a></dt><dd><dl><dt>库，<a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1020">创建和更新库</a></dt><dt>目标文件、规则、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-976">规则结构</a></dt><dt>先决条件、排序和<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1368">递归 make</a></dt><dt>目标、规则链、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-942">模式规则</a></dt></dl></dd><dd><dl><dt>libraries, <a class="indexterm" href="#OEBPS/ch02s08.html.make3-CHP-2-ITERM-1020">Creating and Updating Libraries</a></dt><dt>object files, rules, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-976">Rule Structure</a></dt><dt>prerequisites, ordering and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1368">Recursive make</a></dt><dt>targets, rule chaining, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-942">Pattern Rules</a></dt></dl></dd><dt>用户定义函数,<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1046">变量和宏</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1141">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1143">用户定义</a><a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1152">函数</a>,用户定义函数,<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1145">用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277">高级用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298">传递参数</a>,<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581">用户定义函数</a><a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1143"></a><a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1145"></a><a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277"></a><a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298"></a><a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581"></a></dt><dt>user-defined functions, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1046">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1141">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1152">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1143">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1145">User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298">Passing Parameters</a>, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581">User-Defined Functions</a></dt><dd><dl><dt>高级、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277">高级用户定义函数</a>、<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298">传递参数</a></dt><dt>终止进程和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1143">用户定义的函数</a></dt><dt>Linux 内核 makefile、<a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581">用户定义函数</a></dt><dt>参数和<a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1145">用户定义的函数</a></dt><dt>变量和，<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1046">变量和宏</a></dt></dl></dd><dd><dl><dt>advanced, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1277">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1298">Passing Parameters</a></dt><dt>killing processes and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1143">User-Defined Functions</a></dt><dt>Linux kernel makefile, <a class="indexterm" href="#OEBPS/ch11s02.html.make3-CHP-11-ITERM-1581">User-Defined Functions</a></dt><dt>parameters and, <a class="indexterm" href="#OEBPS/ch04.html.make3-CHP-4-ITERM-1145">User-Defined Functions</a></dt><dt>variables and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1046">Variables and Macros</a></dt></dl></dd></dl></div><div class="indexdiv"><h3>V</h3><h3>V</h3><dl><dt>验证源代码，书籍 makefile，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1567">验证源代码</a></dt><dt>validating source, book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1567">Validating the Source</a></dt><dt>.VARIABLES 变量，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1136">标准 make 变量</a></dt><dt>.VARIABLES
                variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1136">Standard make Variables</a></dt><dt>变量、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">空目标</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-898">变量</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-899">自动变量</a>、<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-933">使用 VPATH 和 vpath 查找文件</a>、<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-957">静态模式规则</a>、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-980">规则结构</a>、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1032">变量</a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1031">和宏</a>、变量和宏、变量<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1034">和宏</a>、变量<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1036">和宏</a>、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">变量和宏</a>、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1042">变量和宏</a>、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1044">变量和宏</a>,<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1047">变量和宏</a>,<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1048">变量的用途</a>,<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049">变量类型</a>,<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051">变量类型</a>,<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">其他类型的</a>赋值,<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056">其他类型的赋值</a>,<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061">宏</a>,<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066">何时扩展变量</a>,<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080">特定于目标和模式的变量</a>,<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081">特定于目标和模式的变量</a>,特定于<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083">目标和模式的变量</a>,<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086">变量来自哪里</a>,<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096">变量来自哪里</a><a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092">,</a>变量来自哪里,<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098">变量来自哪里</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120">标准制作变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121">标准制作变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124">标准制作变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126">标准制作变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129">标准制作变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131">标准make 变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133">标准 make 变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134">标准 make 变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137">标准 make 变量</a>,<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139">标准 make 变量</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205">重要杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255">流程控制</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261">有关变量和括号的样式注释</a>,<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270">不太重要的杂项函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281">高级用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282">高级用户定义函数</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344">命令环境</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348">命令环境</a>,<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356">命令环境</a>,<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1374">传递变量</a>,<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453">支持多个二叉树</a>,<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499">设置 CLASSPATH</a> , <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518">Enterprise JavaBeans</a> ,<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1529">基准测试</a>,<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540">简单变量与递归</a>,<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541">简单变量与递归</a>,<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603">未终止变量引用</a>,<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1624">数据结构</a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1032"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1034"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1036"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1042"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1044"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1047"></a><a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1048"></a><a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049"></a><a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051"></a><a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054"></a><a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056"></a><a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061"></a><a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066"></a><a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080"></a><a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081"></a><a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083"></a><a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086"></a><a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092"></a><a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096"></a><a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137"></a><a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261"></a><a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270"></a><a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281"></a><a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348"></a><a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356"></a><a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1374"></a><a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453"></a><a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499"></a><a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518"></a><a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1529"></a><a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540"></a><a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541"></a><a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603"></a><a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1624"></a></dt><dt>variables, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-898">Variables</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-899">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-933">Finding Files with VPATH and vpath</a>, <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-957">Static Pattern Rules</a>, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-980">Rule Structure</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1031">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1032">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1034">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1036">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1042">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1044">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1047">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1048">What Variables Are Used For</a>, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049">Variable Types</a>, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051">Variable Types</a>, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">Other Types of Assignment</a>, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056">Other Types of Assignment</a>, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061">Macros</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066">When Variables Are Expanded</a>, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080">Target- and Pattern-Specific Variables</a>, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081">Target- and Pattern-Specific Variables</a>, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083">Target- and Pattern-Specific Variables</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098">Where Variables Come From</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205">Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255">Flow Control</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261">Style note concerning variables and parentheses</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282">Advanced User-Defined Functions</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356">Command Environment</a>, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1374">Passing Variables</a>, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453">Supporting Multiple Binary Trees</a>, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499">Setting CLASSPATH</a>, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518">Enterprise JavaBeans</a>, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1529">Benchmarking</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540">Simple Variables Versus Recursive</a>, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541">Simple Variables Versus Recursive</a>, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603">unterminated variable reference</a>, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1624">Data Structures</a></dt><dd><dl><dt>$(OBJECTS)，<a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-957">静态模式规则</a></dt><dt>+=（附加）运算符，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056">其他类型的赋值</a></dt><dt>ALL_TREES，<a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453">支持多二叉树</a></dt><dt>分配、速度、<a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1529">基准测试</a></dt><dt>自动、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">空目标</a>、<a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-899">自动变量</a>、<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096">变量来自哪里</a></dt><dd><dl><dt>空目标和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">空目标</a></dt></dl></dd><dt>内置规则、<a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-980">规则结构</a></dt><dt>区分大小写、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1034">变量和宏</a></dt><dt>允许的字符、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1032">变量和宏</a></dt><dt>CLASSPATH、Java makefile、<a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499">设置 CLASSPATH</a></dt><dt>计算、断言函数和<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255">流程控制</a></dt><dt>常量、用户自定义、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1042">变量和宏</a></dt><dt>CPPFLAGS、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083">特定于目标和模式的变量</a></dt><dt>CURDIR、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124">标准 make 变量</a>、<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126">标准 make 变量</a></dt><dt>debug-enter，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281">高级用户定义函数</a></dt><dt>调试离开，<a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282">高级用户定义函数</a></dt><dt>开发环境，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098">变量从何而来</a></dt><dt>EJBS、<a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518">企业 JavaBean</a></dt><dt>错误消息，<a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603">未终止的变量引用</a></dt><dt>扩展,<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">变量和宏</a>,<a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066">当变量扩展时</a></dt><dd><dl><dt>大括号和<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">变量和宏</a></dt></dl></dd><dt>导出，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092">变量从何而来</a></dt><dt>函数、用户定义、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1044">变量和宏</a></dt><dt>grep 命令，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356">命令环境</a></dt><dt>简介、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1031">变量和宏</a></dt><dt>宏和<a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061">宏</a></dt><dt>MAKECMDGOALS，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133">标准 make 变量</a>，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134">标准 make 变量</a></dt><dt>MAKEFILE_LIST，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129">标准 make 变量</a>，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131">标准 make 变量</a></dt><dt>MAKEFLAGS、命令环境和<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344">命令环境</a></dt><dt>MAKELEVEL，<a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348">命令环境</a></dt><dt>MAKE_VERSION，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120">标准 make 变量</a>，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121">标准 make 变量</a></dt><dt>运算符、<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">其他类型的赋值</a></dt><dd><dl><dt>?=（条件变量赋值运算符），<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">其他类型的赋值</a></dt></dl></dd><dt>起源、起源函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270">不太重要的杂项函数</a></dt><dt>括号和，<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1036">变量和宏</a>，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261">有关变量和括号的样式注释</a></dt><dt>传递、递归 make 和、<a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1374">传递变量</a></dt><dt>模式特定、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081">目标特定和模式特定变量</a></dt><dt>周期、嵌入式、<a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1624">数据结构</a></dt><dt>递归、性能和<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540">简单变量与递归</a></dt><dt>递归扩展，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051">变量类型</a></dt><dt>shell函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205">重要的杂项函数</a></dt><dt>简单、性能和<a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541">简单变量与递归</a></dt><dt>简单扩展，<a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049">变量类型</a></dt><dt>来源，<a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086">变量从何而来</a></dt><dt>特定于目标、<a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080">特定于目标和模式的变量</a></dt><dt>尾随空格、<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1047">变量和宏</a></dt><dt>用途，<a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1048">变量的用途</a></dt><dt>.VARIABLE，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137">标准 make 变量</a></dt><dt>变量，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139">标准 make 变量</a></dt><dt>VPATH，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-933">使用 VPATH 和 vpath 查找文件</a>（请参阅 VPATH）</dt></dl></dd><dd><dl><dt>$(OBJECTS), <a class="indexterm" href="#OEBPS/ch02s04.html.make3-CHP-2-ITERM-957">Static Pattern Rules</a></dt><dt>+= (append) operator, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1056">Other Types of Assignment</a></dt><dt>ALL_TREES, <a class="indexterm" href="#OEBPS/ch08s04.html.make3-CHP-8-ITERM-1453">Supporting Multiple Binary Trees</a></dt><dt>assigning, speed, <a class="indexterm" href="#OEBPS/ch10.html.make3-CHP-10-ITERM-1529">Benchmarking</a></dt><dt>automatic, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">Empty Targets</a>, <a class="indexterm" href="#OEBPS/ch02s02.html.make3-CHP-2-ITERM-899">Automatic Variables</a>, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1096">Where Variables Come From</a></dt><dd><dl><dt>empty targets and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-894">Empty Targets</a></dt></dl></dd><dt>built-in rules, <a class="indexterm" href="#OEBPS/ch02s05.html.make3-CHP-2-ITERM-980">Rule Structure</a></dt><dt>case-sensitivity, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1034">Variables and Macros</a></dt><dt>characters allowed, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1032">Variables and Macros</a></dt><dt>CLASSPATH, Java makefile, <a class="indexterm" href="#OEBPS/ch09s03.html.make3-CHP-9-ITERM-1499">Setting CLASSPATH</a></dt><dt>computed, assert function and, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1255">Flow Control</a></dt><dt>constants, user-customized, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1042">Variables and Macros</a></dt><dt>CPPFLAGS, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1083">Target- and Pattern-Specific Variables</a></dt><dt>CURDIR, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1124">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1126">Standard make Variables</a></dt><dt>debug-enter, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1281">Advanced User-Defined Functions</a></dt><dt>debug-leave, <a class="indexterm" href="#OEBPS/ch04s03.html.make3-CHP-4-ITERM-1282">Advanced User-Defined Functions</a></dt><dt>development environment, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1098">Where Variables Come From</a></dt><dt>EJBS, <a class="indexterm" href="#OEBPS/ch09s06.html.make3-CHP-9-ITERM-1518">Enterprise JavaBeans</a></dt><dt>error messagess, <a class="indexterm" href="#OEBPS/ch12s03.html.make3-CHP-12-ITERM-1603">unterminated variable reference</a></dt><dt>expanding, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch03s04.html.make3-CHP-3-ITERM-1066">When Variables Are Expanded</a></dt><dd><dl><dt>curly braces and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1038">Variables and Macros</a></dt></dl></dd><dt>exporting, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1092">Where Variables Come From</a></dt><dt>functions, user-defined, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1044">Variables and Macros</a></dt><dt>grep command, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1356">Command Environment</a></dt><dt>introduction, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1031">Variables and Macros</a></dt><dt>macros and, <a class="indexterm" href="#OEBPS/ch03s03.html.make3-CHP-3-ITERM-1061">Macros</a></dt><dt>MAKECMDGOALS, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1133">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1134">Standard make Variables</a></dt><dt>MAKEFILE_LIST, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1129">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1131">Standard make Variables</a></dt><dt>MAKEFLAGS, command environment and, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1344">Command Environment</a></dt><dt>MAKELEVEL, <a class="indexterm" href="#OEBPS/ch05s04.html.make3-CHP-5-ITERM-1348">Command Environment</a></dt><dt>MAKE_VERSION, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1120">Standard make Variables</a>, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1121">Standard make Variables</a></dt><dt>operators, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">Other Types of Assignment</a></dt><dd><dl><dt>?= (conditional variable assignment
              operator), <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1054">Other Types of Assignment</a></dt></dl></dd><dt>origins, origin function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1270">Less Important Miscellaneous Functions</a></dt><dt>parentheses and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1036">Variables and Macros</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1261">Style note concerning variables and parentheses</a></dt><dt>passing, recursive make and, <a class="indexterm" href="#OEBPS/ch06.html.make3-CHP-6-ITERM-1374">Passing Variables</a></dt><dt>pattern-specific, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1081">Target- and Pattern-Specific Variables</a></dt><dt>periods, embedded, <a class="indexterm" href="#OEBPS/apb.html.make3-APP-B-ITERM-1624">Data Structures</a></dt><dt>recursive, performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1540">Simple Variables Versus Recursive</a></dt><dt>recursively expanded, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1051">Variable Types</a></dt><dt>shell function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1205">Important Miscellaneous Functions</a></dt><dt>simple, performance and, <a class="indexterm" href="#OEBPS/ch10s02.html.make3-CHP-10-ITERM-1541">Simple Variables Versus Recursive</a></dt><dt>simply expanded, <a class="indexterm" href="#OEBPS/ch03s02.html.make3-CHP-3-ITERM-1049">Variable Types</a></dt><dt>sources, <a class="indexterm" href="#OEBPS/ch03s06.html.make3-CHP-3-ITERM-1086">Where Variables Come From</a></dt><dt>target-specific, <a class="indexterm" href="#OEBPS/ch03s05.html.make3-CHP-3-ITERM-1080">Target- and Pattern-Specific Variables</a></dt><dt>trailing spaces and, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1047">Variables and Macros</a></dt><dt>uses, <a class="indexterm" href="#OEBPS/ch03.html.make3-CHP-3-ITERM-1048">What Variables Are Used For</a></dt><dt>.VARIABLE, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1137">Standard make Variables</a></dt><dt>VARIABLES, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1139">Standard make Variables</a></dt><dt>VPATH, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-933">Finding Files with VPATH and vpath</a> (see VPATH)</dt></dl></dd><dt>VARIABLES 变量，<a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1138">标准 make 变量</a></dt><dt>VARIABLES variable, <a class="indexterm" href="#OEBPS/ch03s08.html.make3-CHP-3-ITERM-1138">Standard make Variables</a></dt><dt>VPATH，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-917">使用 VPATH 和 vpath 查找文件</a></dt><dt>VPATH, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-917">Finding Files with VPATH and vpath</a></dt><dt>vpath，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-918">使用 VPATH 和 vpath 查找文件</a></dt><dt>vpath, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-918">Finding Files with VPATH and vpath</a></dt><dt>vpath 指令，<a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-934">使用 VPATH 和 vpath 查找文件</a></dt><dt>vpath directive, <a class="indexterm" href="#OEBPS/ch02s03.html.make3-CHP-2-ITERM-934">Finding Files with VPATH and vpath</a></dt></dl></div><div class="indexdiv"><h3>瓦</h3><h3>W</h3><dl><dt>--warn-undefined-variables 选项，<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1590">--warn-undefined-variables</a>，<a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1622">运行 make</a></dt><dt>--warn-undefined-variables
                option, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1590">—warn-undefined-variables</a>, <a class="indexterm" href="#OEBPS/apa.html.make3-APP-A-ITERM-1622">Running make</a></dt><dd><dl><dt>调试和<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1590">——警告未定义变量</a></dt></dl></dd><dd><dl><dt>debugging and, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1590">—warn-undefined-variables</a></dt></dl></dd><dt>警告函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1271">不太重要的杂项函数</a>、<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1584">make 的调试功能</a></dt><dt>warning function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1271">Less Important Miscellaneous Functions</a>, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1584">Debugging Features of make</a></dt><dd><dl><dt>调试和<a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1584">make 的调试功能</a></dt></dl></dd><dd><dl><dt>debugging and, <a class="indexterm" href="#OEBPS/ch12.html.make3-CHP-12-ITERM-1584">Debugging Features of make</a></dt></dl></dd><dt>空白、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1111">条件并包括处理</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1159">内置函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1189">字符串函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">不太重要的杂项函数</a></dt><dt>whitespace, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1111">Conditional and include Processing</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1159">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1189">String Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">Less Important Miscellaneous Functions</a></dt><dd><dl><dt>用于操作的函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1189">字符串函数</a></dt><dt>删除、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1159">内置函数</a>、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">不太重要的杂项函数</a></dt><dd><dl><dt>剥离函数，<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">不太重要的杂项函数</a></dt></dl></dd><dt>剥离功能和、<a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1111">条件和包括处理</a></dt></dl></dd><dd><dl><dt>functions for manipulating, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1189">String Functions</a></dt><dt>removing, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1159">Built-in Functions</a>, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">Less Important Miscellaneous Functions</a></dt><dd><dl><dt>strip function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1267">Less Important Miscellaneous Functions</a></dt></dl></dd><dt>strip function and, <a class="indexterm" href="#OEBPS/ch03s07.html.make3-CHP-3-ITERM-1111">Conditional and include Processing</a></dt></dl></dd><dt>通配符函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1213">文件名函数</a></dt><dt>wildcard function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1213">Filename Functions</a></dt><dt>通配符空格函数，<a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1432">管理程序和文件</a></dt><dt>wildcard-spaces function, <a class="indexterm" href="#OEBPS/ch07s03.html.make3-CHP-7-ITERM-1432">Managing Programs and Files</a></dt><dt>通配符、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-829">规则</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-844">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-846">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-860">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-848">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-850">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-852">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-856">通配符</a>、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-859">通配符</a><a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-860"></a></dt><dt>wildcards, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-829">Rules</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-844">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-846">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-848">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-850">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-852">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-856">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-859">Wildcards</a>, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-860">Wildcards</a></dt><dd><dl><dt>（另请参见通配符）</dt><dt>？ （问号）、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-848">通配符</a></dt><dt>调用函数和、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-859">通配符</a></dt><dt>字符类、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-850">通配符</a></dt><dt>扩展、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-856">通配符</a></dt><dt>滥用、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-860">通配符</a></dt><dt>模式规则和<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-829">规则</a></dt><dt>^（波形符）、<a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-852">通配符</a></dt></dl></dd><dd><dl><dt>(see also globbing)</dt><dt>? (question mark), <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-848">Wildcards</a></dt><dt>calling functions and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-859">Wildcards</a></dt><dt>character classes, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-850">Wildcards</a></dt><dt>expanding, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-856">Wildcards</a></dt><dt>misuse, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-860">Wildcards</a></dt><dt>pattern rules and, <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-829">Rules</a></dt><dt>^ (tilde), <a class="indexterm" href="#OEBPS/ch02.html.make3-CHP-2-ITERM-852">Wildcards</a></dt></dl></dd><dt>Windows 文件系统、Cygwin 和<a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1428">文件系统</a></dt><dt>Windows filesystem, Cygwin and, <a class="indexterm" href="#OEBPS/ch07s02.html.make3-CHP-7-ITERM-1428">Filesystem</a></dt><dt>词表函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1197">字符串函数</a></dt><dt>wordlist function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1197">String Functions</a></dt><dt>单词函数、<a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1191">字符串函数</a></dt><dt>words function, <a class="indexterm" href="#OEBPS/ch04s02.html.make3-CHP-4-ITERM-1191">String Functions</a></dt></dl></div><div class="indexdiv"><h3>X</h3><h3>X</h3><dl><dt>XML、<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1477">Ant</a>、<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1557">XML 预处理</a></dt><dt>XML, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1477">Ant</a>, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1557">XML Preprocessing</a></dt><dd><dl><dt>构建文件，<a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1477">Ant</a></dt><dt>预处理书籍 makefile，<a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1557">XML 预处理</a></dt></dl></dd><dd><dl><dt>build files, <a class="indexterm" href="#OEBPS/ch09.html.make3-CHP-9-ITERM-1477">Ant</a></dt><dt>preprocessing book makefile, <a class="indexterm" href="#OEBPS/ch11.html.make3-CHP-11-ITERM-1557">XML Preprocessing</a></dt></dl></dd></dl></div></div></div></div></div>
<div id="OEBPS/author_bios.html"><div>
<div class="colophon" title="关于作者"><h1 class="title"><a id="OEBPS/author_bios.html.id3179715"></a>关于作者</h1><h1 class="title"><a></a>About the Author</h1><p>Robert Mecklenburg 于 1977 年作为一名学生开始使用 Unix，并已从事专业编程 23 年。他的 make 经验始于 1982 年在 NASA 的 Unix 版本 7。 1991 年获得犹他大学计算机科学博士学位。此后，他涉足从机械 CAD 到生物信息学等多个领域，并利用自己在 C++、Java 和 Lisp 方面的丰富经验来解决 make 的项目管理问题。</p><p>Robert Mecklenburg began using Unix as a student in 1977 and has been programming professionally for 23 years. His make experience started in 1982 at NASA with Unix version 7. Robert received his Ph.D. in Computer Science from the University of Utah in 1991. Since then, he has worked in many fields ranging from mechanical CAD to bioinformatics, and he brings his extensive experience in C++, Java, and Lisp to bear on the problems of project management with make</p></div></div></div>
<div id="OEBPS/co02.html"><div>
<div class="colophon" title="版画"><h1 class="title"><a id="OEBPS/co02.html.make3-COLOPHON"></a>版画</h1><h1 class="title"><a></a>Colophon</h1><p>我们的外观是读者评论、我们自己的实验以及发行渠道反馈的结果。独特的封面补充了我们处理技术主题的独特方法，为潜在的枯燥主题注入个性和生命力。</p><p>Our look is the result of reader comments, our own experimentation,
    and feedback from distribution channels. Distinctive covers complement our
    distinctive approach to technical topics, breathing personality and life
    into potentially dry subjects.</p><p>《使用 GNU Make 管理项目，第三版》封面上的动物是懒猴家族的一员——potto。袋鼠是一种原产于西非热带森林的小型灵长类动物，长 17 英寸，覆盖着浓密的红棕色毛皮。它的对生拇指使其能够很好地抓握，使其很好地适应在树上的生活。马铃薯白天睡在树缝或树洞里，晚上出来寻找食物（昆虫、蜗牛和蝙蝠）。与许多灵长类动物不同，马铃薯通常独居。</p><p>The animal on the cover of Managing Projects with GNU Make, Third
    Edition is a potto, a member of the loris family. A small primate native
    to the tropical forests of West Africa, the potto is 17 inches long and
    covered with dense, wooly, reddish-brown fur. Its opposable thumbs give it
    an excellent grasp, leaving it well adapted to its life in the trees. The
    potto spends its days sleeping in crevices or holes in trees, emerging at
    night to hunt for food (insects, snails, and bats). Unlike many primates,
    the potto generally lives alone.</p><p>Matt Hutchinson 是《使用 GNU Make 管理项目，第三版》的制作编辑。 Octal Publishing, Inc. 提供制作服务。约翰娜·丁斯 (Johnna Dinse) 撰写了该索引。 Adam Witwer、Jamie Peppard 和 Darren Kelly 负责质量控制。</p><p>Matt Hutchinson was the production editor for Managing Projects with
    GNU Make, Third Edition . Octal Publishing, Inc. provided production
    services. Johnna Dinse wrote the index. Adam Witwer, Jamie Peppard, and
    Darren Kelly provided quality control.</p><p>埃迪·弗里德曼设计了这本书的封面。封面图片是来自多佛图画档案馆的 19 世纪版画。 Clay Fernald 使用 QuarkXPress 4.1 使用 Adob​​e 的 ITC Garamond 字体制作了封面布局。</p><p>Edie Freedman designed the cover of this book. The cover image is a
    19th-century engraving from the Dover Pictorial Archive. Clay Fernald
    produced the cover layout with QuarkXPress 4.1 using Adobe's ITC Garamond
    font.</p><p>大卫·富塔托 (David Futato) 设计了室内布局。 Joe Wizda 使用 Erik Ray、Jason McIntosh、Neil Walls 和 Mike Sierra 创建的使用 Perl 和 XML 技术的格式转换工具将本书转换为 FrameMaker 5.5.6。文字字体为Linotype Birka；标题字体为 Adob​​e Myriad Condensed；代码字体是 LucasFont 的 TheSans Mono Condensed。书中出现的插图由 Robert Romano 和 Jessamyn Read 使用 Macromedia FreeHand MX 和 Adob​​e Photoshop CS 制作。</p><p>David Futato designed the interior layout. This book was converted
    by Joe Wizda to FrameMaker 5.5.6 with a format conversion tool created by
    Erik Ray, Jason McIntosh, Neil Walls, and Mike Sierra that uses Perl and
    XML technologies. The text font is Linotype Birka; the heading font is
    Adobe Myriad Condensed; and the code font is LucasFont's TheSans Mono
    Condensed. The illustrations that appear in the book were produced by
    Robert Romano and Jessamyn Read using Macromedia FreeHand MX and Adobe
    Photoshop CS.</p><p>本书的在线版本是由 Safari 制作组（John Chodacki、Ken Douglass 和 Ellie Cutler）创建的，使用了一组由 Erik Ray、Benn Salter、John Chodacki 编写和维护的 Frame-to-XML 转换和清理工具，艾莉·卡特勒和杰夫·利格特。</p><p>The online edition of this book was created by the Safari production
    group (John Chodacki, Ken Douglass, and Ellie Cutler) using a set of
    Frame-to-XML conversion and cleanup tools written and maintained by Erik
    Ray, Benn Salter, John Chodacki, Ellie Cutler, and Jeff Liggett.</p></div></div></div>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>
