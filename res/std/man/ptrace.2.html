<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 1993 Michael Haardt <michael@moria.de>
   Fri Apr  2 11:32:09 MET DST 1993
  
   and changes Copyright (C) 1999 Mike Coleman (mkc@acm.org)
   -- major revision to fully document ptrace semantics per recent Linux
      kernel (2.2.10) and glibc (2.1.2)
   Sun Nov  7 03:18:35 CST 1999
  
   and Copyright (c) 2011, Denys Vlasenko <vda.linux@googlemail.com>
   and Copyright (c) 2015, 2016, Michael Kerrisk <mtk.manpages@gmail.com>
  
   SPDX-License-Identifier: GPL-2.0-or-later
  
   Modified Fri Jul 23 23:47:18 1993 by Rik Faith <faith@cs.unc.edu>
   Modified Fri Jan 31 16:46:30 1997 by Eric S. Raymond <esr@thyrsus.com>
   Modified Thu Oct  7 17:28:49 1999 by Andries Brouwer <aeb@cwi.nl>
   Modified, 27 May 2004, Michael Kerrisk <mtk.manpages@gmail.com>
       Added notes on capability requirements
  
   2006-03-24, Chuck Ebbert <76306.1226@compuserve.com>
      Added    PTRACE_SETOPTIONS, PTRACE_GETEVENTMSG, PTRACE_GETSIGINFO,
          PTRACE_SETSIGINFO, PTRACE_SYSEMU, PTRACE_SYSEMU_SINGLESTEP
      (Thanks to Blaisorblade, Daniel Jacobowitz and others who helped.)
   2011-09, major update by Denys Vlasenko <vda.linux@googlemail.com>
   2015-01, Kees Cook <keescook@chromium.org>
      Added PTRACE_O_TRACESECCOMP, PTRACE_EVENT_SECCOMP
  
   FIXME The following are undocumented:
  
   PTRACE_GETWMMXREGS
   PTRACE_SETWMMXREGS
  	ARM
   	Linux 2.6.12
  
   PTRACE_SET_SYSCALL
  	ARM and ARM64
  	Linux 2.6.16
  	commit 3f471126ee53feb5e9b210ea2f525ed3bb9b7a7f
  	Author: Nicolas Pitre <nico@cam.org>
  	Date:   Sat Jan 14 19:30:04 2006 +0000
  
   PTRACE_GETCRUNCHREGS
   PTRACE_SETCRUNCHREGS
  	ARM
  	Linux 2.6.18
  	commit 3bec6ded282b331552587267d67a06ed7fd95ddd
  	Author: Lennert Buytenhek <buytenh@wantstofly.org>
  	Date:   Tue Jun 27 22:56:18 2006 +0100
  
   PTRACE_GETVFPREGS
   PTRACE_SETVFPREGS
  	ARM and ARM64
  	Linux 2.6.30
  	commit 3d1228ead618b88e8606015cbabc49019981805d
  	Author: Catalin Marinas <catalin.marinas@arm.com>
  	Date:   Wed Feb 11 13:12:56 2009 +0100
  
   PTRACE_GETHBPREGS
   PTRACE_SETHBPREGS
  	ARM and ARM64
  	Linux 2.6.37
  	commit 864232fa1a2f8dfe003438ef0851a56722740f3e
  	Author: Will Deacon <will.deacon@arm.com>
  	Date:   Fri Sep 3 10:42:55 2010 +0100
  
   PTRACE_SINGLEBLOCK
  	Since at least Linux 2.4.0 on various architectures
  	Since Linux 2.6.25 on x86 (and others?)
  	commit 5b88abbf770a0e1975c668743100f42934f385e8
  	Author: Roland McGrath <roland@redhat.com>
  	Date:   Wed Jan 30 13:30:53 2008 +0100
  	    ptrace: generic PTRACE_SINGLEBLOCK
  
   PTRACE_GETFPXREGS
   PTRACE_SETFPXREGS
  	Since at least Linux 2.4.0 on various architectures
  
   PTRACE_GETFDPIC
   PTRACE_GETFDPIC_EXEC
   PTRACE_GETFDPIC_INTERP
  	blackfin, c6x, frv, sh
  	First appearance in Linux 2.6.11 on frv
  
   and others that can be found in the arch/*/include/uapi/asm/ptrace files
   --><head>
<meta name="dc.identifier" content="res/60e4db2f4f581ad9c4ca869844536c4d1cbbc0f0">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>ptrace(2)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">ptrace(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">ptrace(2)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">ptrace - process trace</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Standard C library (<i>libc</i>, <i>-lc</i>)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;sys/ptrace.h&gt;</b></pre>
<pre><b>long ptrace(enum __ptrace_request </b><i>request</i><b>, pid_t </b><i>pid</i><b>,</b>
<b>            void *</b><i>addr</i><b>, void *</b><i>data</i><b>);</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>ptrace</b>() system call provides a means by which one
    process (the "tracer") may observe and control the execution of
    another process (the "tracee"), and examine and change the
    tracee's memory and registers. It is primarily used to implement breakpoint
    debugging and system call tracing.</p>
<p class="Pp">A tracee first needs to be attached to the tracer. Attachment and
    subsequent commands are per thread: in a multithreaded process, every thread
    can be individually attached to a (potentially different) tracer, or left
    not attached and thus not debugged. Therefore, "tracee" always
    means "(one) thread", never "a (possibly multithreaded)
    process". Ptrace commands are always sent to a specific tracee using a
    call of the form</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_foo, pid, ...)
</pre>
<br>
<p class="Pp">where <i>pid</i> is the thread ID of the corresponding Linux
    thread.</p>
<p class="Pp">(Note that in this page, a "multithreaded process" means
    a thread group consisting of threads created using the <b>clone</b>(2)
    <b>CLONE_THREAD</b> flag.)</p>
<p class="Pp">A process can initiate a trace by calling <b>fork</b>(2) and
    having the resulting child do a <b>PTRACE_TRACEME</b>, followed (typically)
    by an <b>execve</b>(2). Alternatively, one process may commence tracing
    another process using <b>PTRACE_ATTACH</b> or <b>PTRACE_SEIZE</b>.</p>
<p class="Pp">While being traced, the tracee will stop each time a signal is
    delivered, even if the signal is being ignored. (An exception is
    <b>SIGKILL</b>, which has its usual effect.) The tracer will be notified at
    its next call to <b>waitpid</b>(2) (or one of the related "wait"
    system calls); that call will return a <i>status</i> value containing
    information that indicates the cause of the stop in the tracee. While the
    tracee is stopped, the tracer can use various ptrace requests to inspect and
    modify the tracee. The tracer then causes the tracee to continue, optionally
    ignoring the delivered signal (or even delivering a different signal
    instead).</p>
<p class="Pp">If the <b>PTRACE_O_TRACEEXEC</b> option is not in effect, all
    successful calls to <b>execve</b>(2) by the traced process will cause it to
    be sent a <b>SIGTRAP</b> signal, giving the parent a chance to gain control
    before the new program begins execution.</p>
<p class="Pp">When the tracer is finished tracing, it can cause the tracee to
    continue executing in a normal, untraced mode via <b>PTRACE_DETACH</b>.</p>
<p class="Pp">The value of <i>request</i> determines the action to be
  performed:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_TRACEME"><a class="permalink" href="#PTRACE_TRACEME"><b>PTRACE_TRACEME</b></a></dt>
  <dd>Indicate that this process is to be traced by its parent. A process
      probably shouldn't make this request if its parent isn't expecting to
      trace it. (<i>pid</i>, <i>addr</i>, and <i>data</i> are ignored.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <b>PTRACE_TRACEME</b> request is used only by the tracee; the
      remaining requests are used only by the tracer. In the following requests,
      <i>pid</i> specifies the thread ID of the tracee to be acted on. For
      requests other than <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b>,
      <b>PTRACE_INTERRUPT</b>, and <b>PTRACE_KILL</b>, the tracee must be
      stopped.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_PEEKTEXT"><a class="permalink" href="#PTRACE_PEEKTEXT"><b>PTRACE_PEEKTEXT</b>,
    <b>PTRACE_PEEKDATA</b></a></dt>
  <dd>Read a word at the address <i>addr</i> in the tracee's memory, returning
      the word as the result of the <b>ptrace</b>() call. Linux does not have
      separate text and data address spaces, so these two requests are currently
      equivalent. (<i>data</i> is ignored; but see NOTES.)</dd>
  <dt id="PTRACE_PEEKUSER"><a class="permalink" href="#PTRACE_PEEKUSER"><b>PTRACE_PEEKUSER</b></a></dt>
  <dd>Read a word at offset <i>addr</i> in the tracee's USER area, which holds
      the registers and other information about the process (see
      <i>&lt;sys/user.h&gt;</i>). The word is returned as the result of the
      <b>ptrace</b>() call. Typically, the offset must be word-aligned, though
      this might vary by architecture. See NOTES. (<i>data</i> is ignored; but
      see NOTES.)</dd>
  <dt id="PTRACE_POKETEXT"><a class="permalink" href="#PTRACE_POKETEXT"><b>PTRACE_POKETEXT</b>,
    <b>PTRACE_POKEDATA</b></a></dt>
  <dd>Copy the word <i>data</i> to the address <i>addr</i> in the tracee's
      memory. As for <b>PTRACE_PEEKTEXT</b> and <b>PTRACE_PEEKDATA</b>, these
      two requests are currently equivalent.</dd>
  <dt id="PTRACE_POKEUSER"><a class="permalink" href="#PTRACE_POKEUSER"><b>PTRACE_POKEUSER</b></a></dt>
  <dd>Copy the word <i>data</i> to offset <i>addr</i> in the tracee's USER area.
      As for <b>PTRACE_PEEKUSER</b>, the offset must typically be word-aligned.
      In order to maintain the integrity of the kernel, some modifications to
      the USER area are disallowed.</dd>
  <dt id="PTRACE_GETREGS"><a class="permalink" href="#PTRACE_GETREGS"><b>PTRACE_GETREGS</b>,
    <b>PTRACE_GETFPREGS</b></a></dt>
  <dd>Copy the tracee's general-purpose or floating-point registers,
      respectively, to the address <i>data</i> in the tracer. See
      <i>&lt;sys/user.h&gt;</i> for information on the format of this data.
      (<i>addr</i> is ignored.) Note that SPARC systems have the meaning of
      <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is ignored and
      the registers are copied to the address <i>addr</i>. <b>PTRACE_GETREGS</b>
      and <b>PTRACE_GETFPREGS</b> are not present on all architectures.</dd>
  <dt id="PTRACE_GETREGSET"><a class="permalink" href="#PTRACE_GETREGSET"><b>PTRACE_GETREGSET</b>
    (since Linux 2.6.34)</a></dt>
  <dd>Read the tracee's registers. <i>addr</i> specifies, in an
      architecture-dependent way, the type of registers to be read.
      <b>NT_PRSTATUS</b> (with numerical value 1) usually results in reading of
      general-purpose registers. If the CPU has, for example, floating-point
      and/or vector registers, they can be retrieved by setting <i>addr</i> to
      the corresponding <b>NT_foo</b> constant. <i>data</i> points to a
      <b>struct iovec</b>, which describes the destination buffer's location and
      length. On return, the kernel modifies <b>iov.len</b> to indicate the
      actual number of bytes returned.</dd>
  <dt id="PTRACE_SETREGS"><a class="permalink" href="#PTRACE_SETREGS"><b>PTRACE_SETREGS</b>,
    <b>PTRACE_SETFPREGS</b></a></dt>
  <dd>Modify the tracee's general-purpose or floating-point registers,
      respectively, from the address <i>data</i> in the tracer. As for
      <b>PTRACE_POKEUSER</b>, some general-purpose register modifications may be
      disallowed. (<i>addr</i> is ignored.) Note that SPARC systems have the
      meaning of <i>data</i> and <i>addr</i> reversed; that is, <i>data</i> is
      ignored and the registers are copied from the address <i>addr</i>.
      <b>PTRACE_SETREGS</b> and <b>PTRACE_SETFPREGS</b> are not present on all
      architectures.</dd>
  <dt id="PTRACE_SETREGSET"><a class="permalink" href="#PTRACE_SETREGSET"><b>PTRACE_SETREGSET</b>
    (since Linux 2.6.34)</a></dt>
  <dd>Modify the tracee's registers. The meaning of <i>addr</i> and <i>data</i>
      is analogous to <b>PTRACE_GETREGSET</b>.</dd>
  <dt id="PTRACE_GETSIGINFO"><a class="permalink" href="#PTRACE_GETSIGINFO"><b>PTRACE_GETSIGINFO</b>
    (since Linux 2.3.99-pre6)</a></dt>
  <dd>Retrieve information about the signal that caused the stop. Copy a
      <i>siginfo_t</i> structure (see <b>sigaction</b>(2)) from the tracee to
      the address <i>data</i> in the tracer. (<i>addr</i> is ignored.)</dd>
  <dt id="PTRACE_SETSIGINFO"><a class="permalink" href="#PTRACE_SETSIGINFO"><b>PTRACE_SETSIGINFO</b>
    (since Linux 2.3.99-pre6)</a></dt>
  <dd>Set signal information: copy a <i>siginfo_t</i> structure from the address
      <i>data</i> in the tracer to the tracee. This will affect only signals
      that would normally be delivered to the tracee and were caught by the
      tracer. It may be difficult to tell these normal signals from synthetic
      signals generated by <b>ptrace</b>() itself. (<i>addr</i> is
    ignored.)</dd>
  <dt id="PTRACE_PEEKSIGINFO"><a class="permalink" href="#PTRACE_PEEKSIGINFO"><b>PTRACE_PEEKSIGINFO</b>
    (since Linux 3.10)</a></dt>
  <dd>Retrieve <i>siginfo_t</i> structures without removing signals from a
      queue. <i>addr</i> points to a <i>ptrace_peeksiginfo_args</i> structure
      that specifies the ordinal position from which copying of signals should
      start, and the number of signals to copy. <i>siginfo_t</i> structures are
      copied into the buffer pointed to by <i>data</i>. The return value
      contains the number of copied signals (zero indicates that there is no
      signal corresponding to the specified ordinal position). Within the
      returned <i>siginfo</i> structures, the <i>si_code</i> field includes
      information (<b>__SI_CHLD</b>, <b>__SI_FAULT</b>, etc.) that are not
      otherwise exposed to user space.</dd>
</dl>
<p class="Pp">
  <br>
</p>
<pre>struct ptrace_peeksiginfo_args {
<br>
    u64 off;    /* Ordinal position in queue at which
<br>
                   to start copying signals */
<br>
    u32 flags;  /* PTRACE_PEEKSIGINFO_SHARED or 0 */
<br>
    s32 nr;     /* Number of signals to copy */
};
</pre>
<br>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Currently, there is only one flag, <b>PTRACE_PEEKSIGINFO_SHARED</b>, for
      dumping signals from the process-wide signal queue. If this flag is not
      set, signals are read from the per-thread queue of the specified thread.
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_GETSIGMASK"><a class="permalink" href="#PTRACE_GETSIGMASK"><b>PTRACE_GETSIGMASK</b>
    (since Linux 3.11)</a></dt>
  <dd>Place a copy of the mask of blocked signals (see <b>sigprocmask</b>(2)) in
      the buffer pointed to by <i>data</i>, which should be a pointer to a
      buffer of type <i>sigset_t</i>. The <i>addr</i> argument contains the size
      of the buffer pointed to by <i>data</i> (i.e.,
    <i>sizeof(sigset_t)</i>).</dd>
  <dt id="PTRACE_SETSIGMASK"><a class="permalink" href="#PTRACE_SETSIGMASK"><b>PTRACE_SETSIGMASK</b>
    (since Linux 3.11)</a></dt>
  <dd>Change the mask of blocked signals (see <b>sigprocmask</b>(2)) to the
      value specified in the buffer pointed to by <i>data</i>, which should be a
      pointer to a buffer of type <i>sigset_t</i>. The <i>addr</i> argument
      contains the size of the buffer pointed to by <i>data</i> (i.e.,
      <i>sizeof(sigset_t)</i>).</dd>
  <dt id="PTRACE_SETOPTIONS"><a class="permalink" href="#PTRACE_SETOPTIONS"><b>PTRACE_SETOPTIONS</b>
    (since Linux 2.4.6; see BUGS for caveats)</a></dt>
  <dd>Set ptrace options from <i>data</i>. (<i>addr</i> is ignored.) <i>data</i>
      is interpreted as a bit mask of options, which are specified by the
      following flags:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PTRACE_O_EXITKILL"><a class="permalink" href="#PTRACE_O_EXITKILL"><b>PTRACE_O_EXITKILL</b>
    (since Linux 3.8)</a></dt>
  <dd>Send a <b>SIGKILL</b> signal to the tracee if the tracer exits. This
      option is useful for ptrace jailers that want to ensure that tracees can
      never escape the tracer's control.</dd>
  <dt id="PTRACE_O_TRACECLONE"><a class="permalink" href="#PTRACE_O_TRACECLONE"><b>PTRACE_O_TRACECLONE</b>
    (since Linux 2.5.46)</a></dt>
  <dd>Stop the tracee at the next <b>clone</b>(2) and automatically start
      tracing the newly cloned process, which will start with a <b>SIGSTOP</b>,
      or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
      <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such
      that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_CLONE&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>The PID of the new process can be retrieved with
      <b>PTRACE_GETEVENTMSG</b>.</dd>
  <dt></dt>
  <dd>This option may not catch <b>clone</b>(2) calls in all cases. If the
      tracee calls <b>clone</b>(2) with the <b>CLONE_VFORK</b> flag,
      <b>PTRACE_EVENT_VFORK</b> will be delivered instead if
      <b>PTRACE_O_TRACEVFORK</b> is set; otherwise if the tracee calls
      <b>clone</b>(2) with the exit signal set to <b>SIGCHLD</b>,
      <b>PTRACE_EVENT_FORK</b> will be delivered if <b>PTRACE_O_TRACEFORK</b> is
      set.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACEEXEC"><a class="permalink" href="#PTRACE_O_TRACEEXEC"><b>PTRACE_O_TRACEEXEC</b>
    (since Linux 2.5.46)</a></dt>
  <dd>Stop the tracee at the next <b>execve</b>(2). A <b>waitpid</b>(2) by the
      tracer will return a <i>status</i> value such that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXEC&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>If the execing thread is not a thread group leader, the thread ID is reset
      to thread group leader's ID before this stop. Since Linux 3.0, the former
      thread ID can be retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACEEXIT"><a class="permalink" href="#PTRACE_O_TRACEEXIT"><b>PTRACE_O_TRACEEXIT</b>
    (since Linux 2.5.60)</a></dt>
  <dd>Stop the tracee at exit. A <b>waitpid</b>(2) by the tracer will return a
      <i>status</i> value such that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_EXIT&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>The tracee's exit status can be retrieved with
    <b>PTRACE_GETEVENTMSG</b>.</dd>
  <dt></dt>
  <dd>The tracee is stopped early during process exit, when registers are still
      available, allowing the tracer to see where the exit occurred, whereas the
      normal exit notification is done after the process is finished exiting.
      Even though context is available, the tracer cannot prevent the exit from
      happening at this point.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACEFORK"><a class="permalink" href="#PTRACE_O_TRACEFORK"><b>PTRACE_O_TRACEFORK</b>
    (since Linux 2.5.46)</a></dt>
  <dd>Stop the tracee at the next <b>fork</b>(2) and automatically start tracing
      the newly forked process, which will start with a <b>SIGSTOP</b>, or
      <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
      <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such
      that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_FORK&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>The PID of the new process can be retrieved with
      <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACESYSGOOD"><a class="permalink" href="#PTRACE_O_TRACESYSGOOD"><b>PTRACE_O_TRACESYSGOOD</b>
    (since Linux 2.4.6)</a></dt>
  <dd>When delivering system call traps, set bit 7 in the signal number (i.e.,
      deliver <i>SIGTRAP|0x80</i>). This makes it easy for the tracer to
      distinguish normal traps from those caused by a system call.</dd>
  <dt id="PTRACE_O_TRACEVFORK"><a class="permalink" href="#PTRACE_O_TRACEVFORK"><b>PTRACE_O_TRACEVFORK</b>
    (since Linux 2.5.46)</a></dt>
  <dd>Stop the tracee at the next <b>vfork</b>(2) and automatically start
      tracing the newly vforked process, which will start with a <b>SIGSTOP</b>,
      or <b>PTRACE_EVENT_STOP</b> if <b>PTRACE_SEIZE</b> was used. A
      <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such
      that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>The PID of the new process can be retrieved with
      <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACEVFORKDONE"><a class="permalink" href="#PTRACE_O_TRACEVFORKDONE"><b>PTRACE_O_TRACEVFORKDONE</b>
    (since Linux 2.5.60)</a></dt>
  <dd>Stop the tracee at the completion of the next <b>vfork</b>(2). A
      <b>waitpid</b>(2) by the tracer will return a <i>status</i> value such
      that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_VFORK_DONE&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>The PID of the new process can (since Linux 2.6.18) be retrieved with
      <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_TRACESECCOMP"><a class="permalink" href="#PTRACE_O_TRACESECCOMP"><b>PTRACE_O_TRACESECCOMP</b>
    (since Linux 3.5)</a></dt>
  <dd>Stop the tracee when a <b>seccomp</b>(2) <b>SECCOMP_RET_TRACE</b> rule is
      triggered. A <b>waitpid</b>(2) by the tracer will return a <i>status</i>
      value such that</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <pre><br>
  status&gt;&gt;8 == (SIGTRAP | (PTRACE_EVENT_SECCOMP&lt;&lt;8))</pre>
  </dd>
  <dt></dt>
  <dd>While this triggers a <b>PTRACE_EVENT</b> stop, it is similar to a
      syscall-enter-stop. For details, see the note on
      <b>PTRACE_EVENT_SECCOMP</b> below. The seccomp event message data (from
      the <b>SECCOMP_RET_DATA</b> portion of the seccomp filter rule) can be
      retrieved with <b>PTRACE_GETEVENTMSG</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_O_SUSPEND_SECCOMP"><a class="permalink" href="#PTRACE_O_SUSPEND_SECCOMP"><b>PTRACE_O_SUSPEND_SECCOMP</b>
    (since Linux 4.3)</a></dt>
  <dd>Suspend the tracee's seccomp protections. This applies regardless of mode,
      and can be used when the tracee has not yet installed seccomp filters.
      That is, a valid use case is to suspend a tracee's seccomp protections
      before they are installed by the tracee, let the tracee install the
      filters, and then clear this flag when the filters should be resumed.
      Setting this option requires that the tracer have the <b>CAP_SYS_ADMIN</b>
      capability, not have any seccomp protections installed, and not have
      <b>PTRACE_O_SUSPEND_SECCOMP</b> set on itself.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PTRACE_GETEVENTMSG"><a class="permalink" href="#PTRACE_GETEVENTMSG"><b>PTRACE_GETEVENTMSG</b>
    (since Linux 2.5.46)</a></dt>
  <dd>Retrieve a message (as an <i>unsigned long</i>) about the ptrace event
      that just happened, placing it at the address <i>data</i> in the tracer.
      For <b>PTRACE_EVENT_EXIT</b>, this is the tracee's exit status. For
      <b>PTRACE_EVENT_FORK</b>, <b>PTRACE_EVENT_VFORK</b>,
      <b>PTRACE_EVENT_VFORK_DONE</b>, and <b>PTRACE_EVENT_CLONE</b>, this is the
      PID of the new process. For <b>PTRACE_EVENT_SECCOMP</b>, this is the
      <b>seccomp</b>(2) filter's <b>SECCOMP_RET_DATA</b> associated with the
      triggered rule. (<i>addr</i> is ignored.)</dd>
  <dt id="PTRACE_CONT"><a class="permalink" href="#PTRACE_CONT"><b>PTRACE_CONT</b></a></dt>
  <dd>Restart the stopped tracee process. If <i>data</i> is nonzero, it is
      interpreted as the number of a signal to be delivered to the tracee;
      otherwise, no signal is delivered. Thus, for example, the tracer can
      control whether a signal sent to the tracee is delivered or not.
      (<i>addr</i> is ignored.)</dd>
  <dt id="PTRACE_SYSCALL"><a class="permalink" href="#PTRACE_SYSCALL"><b>PTRACE_SYSCALL</b>,
    <b>PTRACE_SINGLESTEP</b></a></dt>
  <dd>Restart the stopped tracee as for <b>PTRACE_CONT</b>, but arrange for the
      tracee to be stopped at the next entry to or exit from a system call, or
      after execution of a single instruction, respectively. (The tracee will
      also, as usual, be stopped upon receipt of a signal.) From the tracer's
      perspective, the tracee will appear to have been stopped by receipt of a
      <b>SIGTRAP</b>. So, for <b>PTRACE_SYSCALL</b>, for example, the idea is to
      inspect the arguments to the system call at the first stop, then do
      another <b>PTRACE_SYSCALL</b> and inspect the return value of the system
      call at the second stop. The <i>data</i> argument is treated as for
      <b>PTRACE_CONT</b>. (<i>addr</i> is ignored.)</dd>
  <dt id="PTRACE_SET_SYSCALL"><a class="permalink" href="#PTRACE_SET_SYSCALL"><b>PTRACE_SET_SYSCALL</b>
    (since Linux 2.6.16)</a></dt>
  <dd>When in syscall-enter-stop, change the number of the system call that is
      about to be executed to the number specified in the <i>data</i> argument.
      The <i>addr</i> argument is ignored. This request is currently supported
      only on arm (and arm64, though only for backwards compatibility), but most
      other architectures have other means of accomplishing this (usually by
      changing the register that the userland code passed the system call number
      in).</dd>
  <dt id="PTRACE_SYSEMU"><a class="permalink" href="#PTRACE_SYSEMU"><b>PTRACE_SYSEMU</b>,
    <b>PTRACE_SYSEMU_SINGLESTEP</b> (since Linux 2.6.14)</a></dt>
  <dd>For <b>PTRACE_SYSEMU</b>, continue and stop on entry to the next system
      call, which will not be executed. See the documentation on syscall-stops
      below. For <b>PTRACE_SYSEMU_SINGLESTEP</b>, do the same but also
      singlestep if not a system call. This call is used by programs like User
      Mode Linux that want to emulate all the tracee's system calls. The
      <i>data</i> argument is treated as for <b>PTRACE_CONT</b>. The <i>addr</i>
      argument is ignored. These requests are currently supported only on
    x86.</dd>
  <dt id="PTRACE_LISTEN"><a class="permalink" href="#PTRACE_LISTEN"><b>PTRACE_LISTEN</b>
    (since Linux 3.4)</a></dt>
  <dd>Restart the stopped tracee, but prevent it from executing. The resulting
      state of the tracee is similar to a process which has been stopped by a
      <b>SIGSTOP</b> (or other stopping signal). See the "group-stop"
      subsection for additional information. <b>PTRACE_LISTEN</b> works only on
      tracees attached by <b>PTRACE_SEIZE</b>.</dd>
  <dt id="PTRACE_KILL"><a class="permalink" href="#PTRACE_KILL"><b>PTRACE_KILL</b></a></dt>
  <dd>Send the tracee a <b>SIGKILL</b> to terminate it. (<i>addr</i> and
      <i>data</i> are ignored.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><i>This operation is deprecated; do not use it!</i> Instead, send a
      <b>SIGKILL</b> directly using <b>kill</b>(2) or <b>tgkill</b>(2). The
      problem with <b>PTRACE_KILL</b> is that it requires the tracee to be in
      signal-delivery-stop, otherwise it may not work (i.e., may complete
      successfully but won't kill the tracee). By contrast, sending a
      <b>SIGKILL</b> directly has no such limitation.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_INTERRUPT"><a class="permalink" href="#PTRACE_INTERRUPT"><b>PTRACE_INTERRUPT</b>
    (since Linux 3.4)</a></dt>
  <dd>Stop a tracee. If the tracee is running or sleeping in kernel space and
      <b>PTRACE_SYSCALL</b> is in effect, the system call is interrupted and
      syscall-exit-stop is reported. (The interrupted system call is restarted
      when the tracee is restarted.) If the tracee was already stopped by a
      signal and <b>PTRACE_LISTEN</b> was sent to it, the tracee stops with
      <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i> returns the stop
      signal. If any other ptrace-stop is generated at the same time (for
      example, if a signal is sent to the tracee), this ptrace-stop happens. If
      none of the above applies (for example, if the tracee is running in user
      space), it stops with <b>PTRACE_EVENT_STOP</b> with
      <i>WSTOPSIG(status)</i> == <b>SIGTRAP</b>. <b>PTRACE_INTERRUPT</b> only
      works on tracees attached by <b>PTRACE_SEIZE</b>.</dd>
  <dt id="PTRACE_ATTACH"><a class="permalink" href="#PTRACE_ATTACH"><b>PTRACE_ATTACH</b></a></dt>
  <dd>Attach to the process specified in <i>pid</i>, making it a tracee of the
      calling process. The tracee is sent a <b>SIGSTOP</b>, but will not
      necessarily have stopped by the completion of this call; use
      <b>waitpid</b>(2) to wait for the tracee to stop. See the "Attaching
      and detaching" subsection for additional information. (<i>addr</i>
      and <i>data</i> are ignored.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Permission to perform a <b>PTRACE_ATTACH</b> is governed by a ptrace
      access mode <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see below.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_SEIZE"><a class="permalink" href="#PTRACE_SEIZE"><b>PTRACE_SEIZE</b>
    (since Linux 3.4)</a></dt>
  <dd>Attach to the process specified in <i>pid</i>, making it a tracee of the
      calling process. Unlike <b>PTRACE_ATTACH</b>, <b>PTRACE_SEIZE</b> does not
      stop the process. Group-stops are reported as <b>PTRACE_EVENT_STOP</b> and
      <i>WSTOPSIG(status)</i> returns the stop signal. Automatically attached
      children stop with <b>PTRACE_EVENT_STOP</b> and <i>WSTOPSIG(status)</i>
      returns <b>SIGTRAP</b> instead of having <b>SIGSTOP</b> signal delivered
      to them. <b>execve</b>(2) does not deliver an extra <b>SIGTRAP</b>. Only a
      <b>PTRACE_SEIZE</b>d process can accept <b>PTRACE_INTERRUPT</b> and
      <b>PTRACE_LISTEN</b> commands. The "seized" behavior just
      described is inherited by children that are automatically attached using
      <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, and
      <b>PTRACE_O_TRACECLONE</b>. <i>addr</i> must be zero. <i>data</i> contains
      a bit mask of ptrace options to activate immediately.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Permission to perform a <b>PTRACE_SEIZE</b> is governed by a ptrace access
      mode <b>PTRACE_MODE_ATTACH_REALCREDS</b> check; see below.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_SECCOMP_GET_FILTER"><a class="permalink" href="#PTRACE_SECCOMP_GET_FILTER"><b>PTRACE_SECCOMP_GET_FILTER</b>
    (since Linux 4.4)</a></dt>
  <dd>This operation allows the tracer to dump the tracee's classic BPF
    filters.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><i>addr</i> is an integer specifying the index of the filter to be dumped.
      The most recently installed filter has the index 0. If <i>addr</i> is
      greater than the number of installed filters, the operation fails with the
      error <b>ENOENT</b>.</dd>
  <dt></dt>
  <dd><i>data</i> is either a pointer to a <i>struct sock_filter</i> array that
      is large enough to store the BPF program, or NULL if the program is not to
      be stored.</dd>
  <dt></dt>
  <dd>Upon success, the return value is the number of instructions in the BPF
      program. If <i>data</i> was NULL, then this return value can be used to
      correctly size the <i>struct sock_filter</i> array passed in a subsequent
      call.</dd>
  <dt></dt>
  <dd>This operation fails with the error <b>EACCES</b> if the caller does not
      have the <b>CAP_SYS_ADMIN</b> capability or if the caller is in strict or
      filter seccomp mode. If the filter referred to by <i>addr</i> is not a
      classic BPF filter, the operation fails with the error
    <b>EMEDIUMTYPE</b>.</dd>
  <dt></dt>
  <dd>This operation is available if the kernel was configured with both the
      <b>CONFIG_SECCOMP_FILTER</b> and the <b>CONFIG_CHECKPOINT_RESTORE</b>
      options.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PTRACE_DETACH"><a class="permalink" href="#PTRACE_DETACH"><b>PTRACE_DETACH</b></a></dt>
  <dd>Restart the stopped tracee as for <b>PTRACE_CONT</b>, but first detach
      from it. Under Linux, a tracee can be detached in this way regardless of
      which method was used to initiate tracing. (<i>addr</i> is ignored.)</dd>
  <dt id="PTRACE_GET_THREAD_AREA"><a class="permalink" href="#PTRACE_GET_THREAD_AREA"><b>PTRACE_GET_THREAD_AREA</b>
    (since Linux 2.6.0)</a></dt>
  <dd>This operation performs a similar task to <b>get_thread_area</b>(2). It
      reads the TLS entry in the GDT whose index is given in <i>addr</i>,
      placing a copy of the entry into the <i>struct user_desc</i> pointed to by
      <i>data</i>. (By contrast with <b>get_thread_area</b>(2), the
      <i>entry_number</i> of the <i>struct user_desc</i> is ignored.)</dd>
  <dt id="PTRACE_SET_THREAD_AREA"><a class="permalink" href="#PTRACE_SET_THREAD_AREA"><b>PTRACE_SET_THREAD_AREA</b>
    (since Linux 2.6.0)</a></dt>
  <dd>This operation performs a similar task to <b>set_thread_area</b>(2). It
      sets the TLS entry in the GDT whose index is given in <i>addr</i>,
      assigning it the data supplied in the <i>struct user_desc</i> pointed to
      by <i>data</i>. (By contrast with <b>set_thread_area</b>(2), the
      <i>entry_number</i> of the <i>struct user_desc</i> is ignored; in other
      words, this ptrace operation can't be used to allocate a free TLS
    entry.)</dd>
  <dt id="PTRACE_GET_SYSCALL_INFO"><a class="permalink" href="#PTRACE_GET_SYSCALL_INFO"><b>PTRACE_GET_SYSCALL_INFO</b>
    (since Linux 5.3)</a></dt>
  <dd>Retrieve information about the system call that caused the stop. The
      information is placed into the buffer pointed by the <i>data</i> argument,
      which should be a pointer to a buffer of type <i>struct
      ptrace_syscall_info</i>. The <i>addr</i> argument contains the size of the
      buffer pointed to by the <i>data</i> argument (i.e., <i>sizeof(struct
      ptrace_syscall_info)</i>). The return value contains the number of bytes
      available to be written by the kernel. If the size of the data to be
      written by the kernel exceeds the size specified by the <i>addr</i>
      argument, the output data is truncated.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>ptrace_syscall_info</i> structure contains the following
    fields:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>struct ptrace_syscall_info {
<br>
    __u8 op;        /* Type of system call stop */
<br>
    __u32 arch;     /* AUDIT_ARCH_* value; see seccomp(2) */
<br>
    __u64 instruction_pointer; /* CPU instruction pointer */
<br>
    __u64 stack_pointer;    /* CPU stack pointer */
<br>
    union {
<br>
        struct {    /* op == PTRACE_SYSCALL_INFO_ENTRY */
<br>
            __u64 nr;       /* System call number */
<br>
            __u64 args[6];  /* System call arguments */
<br>
        } entry;
<br>
        struct {    /* op == PTRACE_SYSCALL_INFO_EXIT */
<br>
            __s64 rval;     /* System call return value */
<br>
            __u8 is_error;  /* System call error flag;
<br>
                               Boolean: does rval contain
<br>
                               an error value (-ERRCODE) or
<br>
                               a nonerror return value? */
<br>
        } exit;
<br>
        struct {    /* op == PTRACE_SYSCALL_INFO_SECCOMP */
<br>
            __u64 nr;       /* System call number */
<br>
            __u64 args[6];  /* System call arguments */
<br>
            __u32 ret_data; /* SECCOMP_RET_DATA portion
<br>
                               of SECCOMP_RET_TRACE
<br>
                               return value */
<br>
        } seccomp;
<br>
    };
};
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The <i>op</i>, <i>arch</i>, <i>instruction_pointer</i>, and
      <i>stack_pointer</i> fields are defined for all kinds of ptrace system
      call stops. The rest of the structure is a union; one should read only
      those fields that are meaningful for the kind of system call stop
      specified by the <i>op</i> field.</dd>
  <dt></dt>
  <dd>The <i>op</i> field has one of the following values (defined in
      <i>&lt;linux/ptrace.h&gt;</i>) indicating what type of stop occurred and
      which part of the union is filled:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PTRACE_SYSCALL_INFO_ENTRY"><a class="permalink" href="#PTRACE_SYSCALL_INFO_ENTRY"><b>PTRACE_SYSCALL_INFO_ENTRY</b></a></dt>
  <dd>The <i>entry</i> component of the union contains information relating to a
      system call entry stop.</dd>
  <dt id="PTRACE_SYSCALL_INFO_EXIT"><a class="permalink" href="#PTRACE_SYSCALL_INFO_EXIT"><b>PTRACE_SYSCALL_INFO_EXIT</b></a></dt>
  <dd>The <i>exit</i> component of the union contains information relating to a
      system call exit stop.</dd>
  <dt id="PTRACE_SYSCALL_INFO_SECCOMP"><a class="permalink" href="#PTRACE_SYSCALL_INFO_SECCOMP"><b>PTRACE_SYSCALL_INFO_SECCOMP</b></a></dt>
  <dd>The <i>seccomp</i> component of the union contains information relating to
      a <b>PTRACE_EVENT_SECCOMP</b> stop.</dd>
  <dt id="PTRACE_SYSCALL_INFO_NONE"><a class="permalink" href="#PTRACE_SYSCALL_INFO_NONE"><b>PTRACE_SYSCALL_INFO_NONE</b></a></dt>
  <dd>No component of the union contains relevant information.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>In case of system call entry or exit stops, the data returned by
      <b>PTRACE_GET_SYSCALL_INFO</b> is limited to type
      <b>PTRACE_SYSCALL_INFO_NONE</b> unless <b>PTRACE_O_TRACESYSGOOD</b> option
      is set before the corresponding system call stop has occurred.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Death_under_ptrace"><a class="permalink" href="#Death_under_ptrace">Death
  under ptrace</a></h2>
<p class="Pp">When a (possibly multithreaded) process receives a killing signal
    (one whose disposition is set to <b>SIG_DFL</b> and whose default action is
    to kill the process), all threads exit. Tracees report their death to their
    tracer(s). Notification of this event is delivered via
  <b>waitpid</b>(2).</p>
<p class="Pp">Note that the killing signal will first cause signal-delivery-stop
    (on one tracee only), and only after it is injected by the tracer (or after
    it was dispatched to a thread which isn't traced), will death from the
    signal happen on <i>all</i> tracees within a multithreaded process. (The
    term "signal-delivery-stop" is explained below.)</p>
<p class="Pp"><b>SIGKILL</b> does not generate signal-delivery-stop and
    therefore the tracer can't suppress it. <b>SIGKILL</b> kills even within
    system calls (syscall-exit-stop is not generated prior to death by
    <b>SIGKILL</b>). The net effect is that <b>SIGKILL</b> always kills the
    process (all its threads), even if some threads of the process are
  ptraced.</p>
<p class="Pp">When the tracee calls <b>_exit</b>(2), it reports its death to its
    tracer. Other threads are not affected.</p>
<p class="Pp">When any thread executes <b>exit_group</b>(2), every tracee in its
    thread group reports its death to its tracer.</p>
<p class="Pp">If the <b>PTRACE_O_TRACEEXIT</b> option is on,
    <b>PTRACE_EVENT_EXIT</b> will happen before actual death. This applies to
    exits via <b>exit</b>(2), <b>exit_group</b>(2), and signal deaths (except
    <b>SIGKILL</b>, depending on the kernel version; see BUGS below), and when
    threads are torn down on <b>execve</b>(2) in a multithreaded process.</p>
<p class="Pp">The tracer cannot assume that the ptrace-stopped tracee exists.
    There are many scenarios when the tracee may die while stopped (such as
    <b>SIGKILL</b>). Therefore, the tracer must be prepared to handle an
    <b>ESRCH</b> error on any ptrace operation. Unfortunately, the same error is
    returned if the tracee exists but is not ptrace-stopped (for commands which
    require a stopped tracee), or if it is not traced by the process which
    issued the ptrace call. The tracer needs to keep track of the
    stopped/running state of the tracee, and interpret <b>ESRCH</b> as
    "tracee died unexpectedly" only if it knows that the tracee has
    been observed to enter ptrace-stop. Note that there is no guarantee that
    <i>waitpid(WNOHANG)</i> will reliably report the tracee's death status if a
    ptrace operation returned <b>ESRCH</b>. <i>waitpid(WNOHANG)</i> may return 0
    instead. In other words, the tracee may be "not yet fully dead",
    but already refusing ptrace requests.</p>
<p class="Pp">The tracer can't assume that the tracee <i>always</i> ends its
    life by reporting <i>WIFEXITED(status)</i> or <i>WIFSIGNALED(status)</i>;
    there are cases where this does not occur. For example, if a thread other
    than thread group leader does an <b>execve</b>(2), it disappears; its PID
    will never be seen again, and any subsequent ptrace stops will be reported
    under the thread group leader's PID.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Stopped_states"><a class="permalink" href="#Stopped_states">Stopped
  states</a></h2>
<p class="Pp">A tracee can be in two states: running or stopped. For the
    purposes of ptrace, a tracee which is blocked in a system call (such as
    <b>read</b>(2), <b>pause</b>(2), etc.) is nevertheless considered to be
    running, even if the tracee is blocked for a long time. The state of the
    tracee after <b>PTRACE_LISTEN</b> is somewhat of a gray area: it is not in
    any ptrace-stop (ptrace commands won't work on it, and it will deliver
    <b>waitpid</b>(2) notifications), but it also may be considered
    "stopped" because it is not executing instructions (is not
    scheduled), and if it was in group-stop before <b>PTRACE_LISTEN</b>, it will
    not respond to signals until <b>SIGCONT</b> is received.</p>
<p class="Pp">There are many kinds of states when the tracee is stopped, and in
    ptrace discussions they are often conflated. Therefore, it is important to
    use precise terms.</p>
<p class="Pp">In this manual page, any stopped state in which the tracee is
    ready to accept ptrace commands from the tracer is called
    <i>ptrace-stop</i>. Ptrace-stops can be further subdivided into
    <i>signal-delivery-stop</i>, <i>group-stop</i>, <i>syscall-stop</i>,
    <i>PTRACE_EVENT stops</i>, and so on. These stopped states are described in
    detail below.</p>
<p class="Pp">When the running tracee enters ptrace-stop, it notifies its tracer
    using <b>waitpid</b>(2) (or one of the other "wait" system calls).
    Most of this manual page assumes that the tracer waits with:</p>
<p class="Pp">
  <br>
</p>
<pre>pid = waitpid(pid_or_minus_1, &amp;status, __WALL);
</pre>
<br>
<p class="Pp">Ptrace-stopped tracees are reported as returns with <i>pid</i>
    greater than 0 and <i>WIFSTOPPED(status)</i> true.</p>
<p class="Pp">The <b>__WALL</b> flag does not include the <b>WSTOPPED</b> and
    <b>WEXITED</b> flags, but implies their functionality.</p>
<p class="Pp">Setting the <b>WCONTINUED</b> flag when calling <b>waitpid</b>(2)
    is not recommended: the "continued" state is per-process and
    consuming it can confuse the real parent of the tracee.</p>
<p class="Pp">Use of the <b>WNOHANG</b> flag may cause <b>waitpid</b>(2) to
    return 0 ("no wait results available yet") even if the tracer
    knows there should be a notification. Example:</p>
<p class="Pp">
  <br>
</p>
<pre>errno = 0;
ptrace(PTRACE_CONT, pid, 0L, 0L);
if (errno == ESRCH) {
<br>
    /* tracee is dead */
<br>
    r = waitpid(tracee, &amp;status, __WALL | WNOHANG);
<br>
    /* r can still be 0 here! */
}
</pre>
<br>
<p class="Pp">The following kinds of ptrace-stops exist: signal-delivery-stops,
    group-stops, <b>PTRACE_EVENT</b> stops, syscall-stops. They all are reported
    by <b>waitpid</b>(2) with <i>WIFSTOPPED(status)</i> true. They may be
    differentiated by examining the value <i>status&gt;&gt;8</i>, and if there
    is ambiguity in that value, by querying <b>PTRACE_GETSIGINFO</b>. (Note: the
    <i>WSTOPSIG(status)</i> macro can't be used to perform this examination,
    because it returns the value
    <i>(status&gt;&gt;8)&nbsp;&amp;&nbsp;0xff</i>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Signal-delivery-stop"><a class="permalink" href="#Signal-delivery-stop">Signal-delivery-stop</a></h2>
<p class="Pp">When a (possibly multithreaded) process receives any signal except
    <b>SIGKILL</b>, the kernel selects an arbitrary thread which handles the
    signal. (If the signal is generated with <b>tgkill</b>(2), the target thread
    can be explicitly selected by the caller.) If the selected thread is traced,
    it enters signal-delivery-stop. At this point, the signal is not yet
    delivered to the process, and can be suppressed by the tracer. If the tracer
    doesn't suppress the signal, it passes the signal to the tracee in the next
    ptrace restart request. This second step of signal delivery is called
    <i>signal injection</i> in this manual page. Note that if the signal is
    blocked, signal-delivery-stop doesn't happen until the signal is unblocked,
    with the usual exception that <b>SIGSTOP</b> can't be blocked.</p>
<p class="Pp">Signal-delivery-stop is observed by the tracer as
    <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i> true, with the
    signal returned by <i>WSTOPSIG(status)</i>. If the signal is <b>SIGTRAP</b>,
    this may be a different kind of ptrace-stop; see the
    "Syscall-stops" and "execve" sections below for details.
    If <i>WSTOPSIG(status)</i> returns a stopping signal, this may be a
    group-stop; see below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Signal_injection_and_suppression"><a class="permalink" href="#Signal_injection_and_suppression">Signal
  injection and suppression</a></h2>
<p class="Pp">After signal-delivery-stop is observed by the tracer, the tracer
    should restart the tracee with the call</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_restart, pid, 0, sig)
</pre>
<br>
<p class="Pp">where <b>PTRACE_restart</b> is one of the restarting ptrace
    requests. If <i>sig</i> is 0, then a signal is not delivered. Otherwise, the
    signal <i>sig</i> is delivered. This operation is called <i>signal
    injection</i> in this manual page, to distinguish it from
    signal-delivery-stop.</p>
<p class="Pp">The <i>sig</i> value may be different from the
    <i>WSTOPSIG(status)</i> value: the tracer can cause a different signal to be
    injected.</p>
<p class="Pp">Note that a suppressed signal still causes system calls to return
    prematurely. In this case, system calls will be restarted: the tracer will
    observe the tracee to reexecute the interrupted system call (or
    <b>restart_syscall</b>(2) system call for a few system calls which use a
    different mechanism for restarting) if the tracer uses
    <b>PTRACE_SYSCALL</b>. Even system calls (such as <b>poll</b>(2)) which are
    not restartable after signal are restarted after signal is suppressed;
    however, kernel bugs exist which cause some system calls to fail with
    <b>EINTR</b> even though no observable signal is injected to the tracee.</p>
<p class="Pp">Restarting ptrace commands issued in ptrace-stops other than
    signal-delivery-stop are not guaranteed to inject a signal, even if
    <i>sig</i> is nonzero. No error is reported; a nonzero <i>sig</i> may simply
    be ignored. Ptrace users should not try to "create a new signal"
    this way: use <b>tgkill</b>(2) instead.</p>
<p class="Pp">The fact that signal injection requests may be ignored when
    restarting the tracee after ptrace stops that are not signal-delivery-stops
    is a cause of confusion among ptrace users. One typical scenario is that the
    tracer observes group-stop, mistakes it for signal-delivery-stop, restarts
    the tracee with</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_restart, pid, 0, stopsig)
</pre>
<br>
<p class="Pp">with the intention of injecting <i>stopsig</i>, but <i>stopsig</i>
    gets ignored and the tracee continues to run.</p>
<p class="Pp">The <b>SIGCONT</b> signal has a side effect of waking up (all
    threads of) a group-stopped process. This side effect happens before
    signal-delivery-stop. The tracer can't suppress this side effect (it can
    only suppress signal injection, which only causes the <b>SIGCONT</b> handler
    to not be executed in the tracee, if such a handler is installed). In fact,
    waking up from group-stop may be followed by signal-delivery-stop for
    signal(s) <i>other than</i> <b>SIGCONT</b>, if they were pending when
    <b>SIGCONT</b> was delivered. In other words, <b>SIGCONT</b> may be not the
    first signal observed by the tracee after it was sent.</p>
<p class="Pp">Stopping signals cause (all threads of) a process to enter
    group-stop. This side effect happens after signal injection, and therefore
    can be suppressed by the tracer.</p>
<p class="Pp">In Linux 2.4 and earlier, the <b>SIGSTOP</b> signal can't be
    injected.</p>
<p class="Pp"><b>PTRACE_GETSIGINFO</b> can be used to retrieve a
    <i>siginfo_t</i> structure which corresponds to the delivered signal.
    <b>PTRACE_SETSIGINFO</b> may be used to modify it. If
    <b>PTRACE_SETSIGINFO</b> has been used to alter <i>siginfo_t</i>, the
    <i>si_signo</i> field and the <i>sig</i> parameter in the restarting command
    must match, otherwise the result is undefined.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Group-stop"><a class="permalink" href="#Group-stop">Group-stop</a></h2>
<p class="Pp">When a (possibly multithreaded) process receives a stopping
    signal, all threads stop. If some threads are traced, they enter a
    group-stop. Note that the stopping signal will first cause
    signal-delivery-stop (on one tracee only), and only after it is injected by
    the tracer (or after it was dispatched to a thread which isn't traced), will
    group-stop be initiated on <i>all</i> tracees within the multithreaded
    process. As usual, every tracee reports its group-stop separately to the
    corresponding tracer.</p>
<p class="Pp">Group-stop is observed by the tracer as <b>waitpid</b>(2)
    returning with <i>WIFSTOPPED(status)</i> true, with the stopping signal
    available via <i>WSTOPSIG(status)</i>. The same result is returned by some
    other classes of ptrace-stops, therefore the recommended practice is to
    perform the call</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo)
</pre>
<br>
<p class="Pp">The call can be avoided if the signal is not <b>SIGSTOP</b>,
    <b>SIGTSTP</b>, <b>SIGTTIN</b>, or <b>SIGTTOU</b>; only these four signals
    are stopping signals. If the tracer sees something else, it can't be a
    group-stop. Otherwise, the tracer needs to call <b>PTRACE_GETSIGINFO</b>. If
    <b>PTRACE_GETSIGINFO</b> fails with <b>EINVAL</b>, then it is definitely a
    group-stop. (Other failure codes are possible, such as <b>ESRCH</b>
    ("no such process") if a <b>SIGKILL</b> killed the tracee.)</p>
<p class="Pp">If tracee was attached using <b>PTRACE_SEIZE</b>, group-stop is
    indicated by <b>PTRACE_EVENT_STOP</b>: <i>status&gt;&gt;16 ==
    PTRACE_EVENT_STOP</i>. This allows detection of group-stops without
    requiring an extra <b>PTRACE_GETSIGINFO</b> call.</p>
<p class="Pp">As of Linux 2.6.38, after the tracer sees the tracee ptrace-stop
    and until it restarts or kills it, the tracee will not run, and will not
    send notifications (except <b>SIGKILL</b> death) to the tracer, even if the
    tracer enters into another <b>waitpid</b>(2) call.</p>
<p class="Pp">The kernel behavior described in the previous paragraph causes a
    problem with transparent handling of stopping signals. If the tracer
    restarts the tracee after group-stop, the stopping signal is effectively
    ignoredthe tracee doesn't remain stopped, it runs. If the tracer
    doesn't restart the tracee before entering into the next <b>waitpid</b>(2),
    future <b>SIGCONT</b> signals will not be reported to the tracer; this would
    cause the <b>SIGCONT</b> signals to have no effect on the tracee.</p>
<p class="Pp">Since Linux 3.4, there is a method to overcome this problem:
    instead of <b>PTRACE_CONT</b>, a <b>PTRACE_LISTEN</b> command can be used to
    restart a tracee in a way where it does not execute, but waits for a new
    event which it can report via <b>waitpid</b>(2) (such as when it is
    restarted by a <b>SIGCONT</b>).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PTRACE_EVENT_stops"><a class="permalink" href="#PTRACE_EVENT_stops">PTRACE_EVENT
  stops</a></h2>
<p class="Pp">If the tracer sets <b>PTRACE_O_TRACE_*</b> options, the tracee
    will enter ptrace-stops called <b>PTRACE_EVENT</b> stops.</p>
<p class="Pp"><b>PTRACE_EVENT</b> stops are observed by the tracer as
    <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i>, and
    <i>WSTOPSIG(status)</i> returns <b>SIGTRAP</b> (or for
    <b>PTRACE_EVENT_STOP</b>, returns the stopping signal if tracee is in a
    group-stop). An additional bit is set in the higher byte of the status word:
    the value <i>status&gt;&gt;8</i> will be</p>
<p class="Pp">
  <br>
</p>
<pre>((PTRACE_EVENT_foo&lt;&lt;8) | SIGTRAP).
</pre>
<br>
<p class="Pp">The following events exist:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_EVENT_VFORK"><a class="permalink" href="#PTRACE_EVENT_VFORK"><b>PTRACE_EVENT_VFORK</b></a></dt>
  <dd>Stop before return from <b>vfork</b>(2) or <b>clone</b>(2) with the
      <b>CLONE_VFORK</b> flag. When the tracee is continued after this stop, it
      will wait for child to exit/exec before continuing its execution (in other
      words, the usual behavior on <b>vfork</b>(2)).</dd>
  <dt id="PTRACE_EVENT_FORK"><a class="permalink" href="#PTRACE_EVENT_FORK"><b>PTRACE_EVENT_FORK</b></a></dt>
  <dd>Stop before return from <b>fork</b>(2) or <b>clone</b>(2) with the exit
      signal set to <b>SIGCHLD</b>.</dd>
  <dt id="PTRACE_EVENT_CLONE"><a class="permalink" href="#PTRACE_EVENT_CLONE"><b>PTRACE_EVENT_CLONE</b></a></dt>
  <dd>Stop before return from <b>clone</b>(2).</dd>
  <dt id="PTRACE_EVENT_VFORK_DONE"><a class="permalink" href="#PTRACE_EVENT_VFORK_DONE"><b>PTRACE_EVENT_VFORK_DONE</b></a></dt>
  <dd>Stop before return from <b>vfork</b>(2) or <b>clone</b>(2) with the
      <b>CLONE_VFORK</b> flag, but after the child unblocked this tracee by
      exiting or execing.</dd>
</dl>
<p class="Pp">For all four stops described above, the stop occurs in the parent
    (i.e., the tracee), not in the newly created thread.
    <b>PTRACE_GETEVENTMSG</b> can be used to retrieve the new thread's ID.</p>
<dl class="Bl-tag">
  <dt id="PTRACE_EVENT_EXEC"><a class="permalink" href="#PTRACE_EVENT_EXEC"><b>PTRACE_EVENT_EXEC</b></a></dt>
  <dd>Stop before return from <b>execve</b>(2). Since Linux 3.0,
      <b>PTRACE_GETEVENTMSG</b> returns the former thread ID.</dd>
  <dt id="PTRACE_EVENT_EXIT"><a class="permalink" href="#PTRACE_EVENT_EXIT"><b>PTRACE_EVENT_EXIT</b></a></dt>
  <dd>Stop before exit (including death from <b>exit_group</b>(2)), signal
      death, or exit caused by <b>execve</b>(2) in a multithreaded process.
      <b>PTRACE_GETEVENTMSG</b> returns the exit status. Registers can be
      examined (unlike when "real" exit happens). The tracee is still
      alive; it needs to be <b>PTRACE_CONT</b>ed or <b>PTRACE_DETACH</b>ed to
      finish exiting.</dd>
  <dt id="PTRACE_EVENT_STOP"><a class="permalink" href="#PTRACE_EVENT_STOP"><b>PTRACE_EVENT_STOP</b></a></dt>
  <dd>Stop induced by <b>PTRACE_INTERRUPT</b> command, or group-stop, or initial
      ptrace-stop when a new child is attached (only if attached using
      <b>PTRACE_SEIZE</b>).</dd>
  <dt id="PTRACE_EVENT_SECCOMP"><a class="permalink" href="#PTRACE_EVENT_SECCOMP"><b>PTRACE_EVENT_SECCOMP</b></a></dt>
  <dd>Stop triggered by a <b>seccomp</b>(2) rule on tracee syscall entry when
      <b>PTRACE_O_TRACESECCOMP</b> has been set by the tracer. The seccomp event
      message data (from the <b>SECCOMP_RET_DATA</b> portion of the seccomp
      filter rule) can be retrieved with <b>PTRACE_GETEVENTMSG</b>. The
      semantics of this stop are described in detail in a separate section
      below.</dd>
</dl>
<p class="Pp"><b>PTRACE_GETSIGINFO</b> on <b>PTRACE_EVENT</b> stops returns
    <b>SIGTRAP</b> in <i>si_signo</i>, with <i>si_code</i> set to
    <i>(event&lt;&lt;8)&nbsp;|&nbsp;SIGTRAP</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Syscall-stops"><a class="permalink" href="#Syscall-stops">Syscall-stops</a></h2>
<p class="Pp">If the tracee was restarted by <b>PTRACE_SYSCALL</b> or
    <b>PTRACE_SYSEMU</b>, the tracee enters syscall-enter-stop just prior to
    entering any system call (which will not be executed if the restart was
    using <b>PTRACE_SYSEMU</b>, regardless of any change made to registers at
    this point or how the tracee is restarted after this stop). No matter which
    method caused the syscall-entry-stop, if the tracer restarts the tracee with
    <b>PTRACE_SYSCALL</b>, the tracee enters syscall-exit-stop when the system
    call is finished, or if it is interrupted by a signal. (That is,
    signal-delivery-stop never happens between syscall-enter-stop and
    syscall-exit-stop; it happens <i>after</i> syscall-exit-stop.). If the
    tracee is continued using any other method (including <b>PTRACE_SYSEMU</b>),
    no syscall-exit-stop occurs. Note that all mentions <b>PTRACE_SYSEMU</b>
    apply equally to <b>PTRACE_SYSEMU_SINGLESTEP</b>.</p>
<p class="Pp">However, even if the tracee was continued using
    <b>PTRACE_SYSCALL</b>, it is not guaranteed that the next stop will be a
    syscall-exit-stop. Other possibilities are that the tracee may stop in a
    <b>PTRACE_EVENT</b> stop (including seccomp stops), exit (if it entered
    <b>_exit</b>(2) or <b>exit_group</b>(2)), be killed by <b>SIGKILL</b>, or
    die silently (if it is a thread group leader, the <b>execve</b>(2) happened
    in another thread, and that thread is not traced by the same tracer; this
    situation is discussed later).</p>
<p class="Pp">Syscall-enter-stop and syscall-exit-stop are observed by the
    tracer as <b>waitpid</b>(2) returning with <i>WIFSTOPPED(status)</i> true,
    and <i>WSTOPSIG(status)</i> giving <b>SIGTRAP</b>. If the
    <b>PTRACE_O_TRACESYSGOOD</b> option was set by the tracer, then
    <i>WSTOPSIG(status)</i> will give the value
    <i>(SIGTRAP&nbsp;|&nbsp;0x80)</i>.</p>
<p class="Pp">Syscall-stops can be distinguished from signal-delivery-stop with
    <b>SIGTRAP</b> by querying <b>PTRACE_GETSIGINFO</b> for the following
  cases:</p>
<dl class="Bl-tag">
  <dt id="si_code"><a class="permalink" href="#si_code"><i>si_code</i> &lt;=
    0</a></dt>
  <dd><b>SIGTRAP</b> was delivered as a result of a user-space action, for
      example, a system call (<b>tgkill</b>(2), <b>kill</b>(2),
      <b>sigqueue</b>(3), etc.), expiration of a POSIX timer, change of state on
      a POSIX message queue, or completion of an asynchronous I/O request.</dd>
  <dt id="si_code~2"><a class="permalink" href="#si_code~2"><i>si_code</i> ==
    SI_KERNEL (0x80)</a></dt>
  <dd><b>SIGTRAP</b> was sent by the kernel.</dd>
  <dt id="si_code~3"><a class="permalink" href="#si_code~3"><i>si_code</i> ==
    SIGTRAP or <i>si_code</i> == (SIGTRAP|0x80)</a></dt>
  <dd>This is a syscall-stop.</dd>
</dl>
<p class="Pp">However, syscall-stops happen very often (twice per system call),
    and performing <b>PTRACE_GETSIGINFO</b> for every syscall-stop may be
    somewhat expensive.</p>
<p class="Pp">Some architectures allow the cases to be distinguished by
    examining registers. For example, on x86, <i>rax</i> == -<b>ENOSYS</b> in
    syscall-enter-stop. Since <b>SIGTRAP</b> (like any other signal) always
    happens <i>after</i> syscall-exit-stop, and at this point <i>rax</i> almost
    never contains -<b>ENOSYS</b>, the <b>SIGTRAP</b> looks like
    "syscall-stop which is not syscall-enter-stop"; in other words, it
    looks like a "stray syscall-exit-stop" and can be detected this
    way. But such detection is fragile and is best avoided.</p>
<p class="Pp">Using the <b>PTRACE_O_TRACESYSGOOD</b> option is the recommended
    method to distinguish syscall-stops from other kinds of ptrace-stops, since
    it is reliable and does not incur a performance penalty.</p>
<p class="Pp">Syscall-enter-stop and syscall-exit-stop are indistinguishable
    from each other by the tracer. The tracer needs to keep track of the
    sequence of ptrace-stops in order to not misinterpret syscall-enter-stop as
    syscall-exit-stop or vice versa. In general, a syscall-enter-stop is always
    followed by syscall-exit-stop, <b>PTRACE_EVENT</b> stop, or the tracee's
    death; no other kinds of ptrace-stop can occur in between. However, note
    that seccomp stops (see below) can cause syscall-exit-stops, without
    preceding syscall-entry-stops. If seccomp is in use, care needs to be taken
    not to misinterpret such stops as syscall-entry-stops.</p>
<p class="Pp">If after syscall-enter-stop, the tracer uses a restarting command
    other than <b>PTRACE_SYSCALL</b>, syscall-exit-stop is not generated.</p>
<p class="Pp"><b>PTRACE_GETSIGINFO</b> on syscall-stops returns <b>SIGTRAP</b>
    in <i>si_signo</i>, with <i>si_code</i> set to <b>SIGTRAP</b> or
    <i>(SIGTRAP|0x80)</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PTRACE_EVENT_SECCOMP_stops_(Linux_3.5_to_Linux_4.7)"><a class="permalink" href="#PTRACE_EVENT_SECCOMP_stops_(Linux_3.5_to_Linux_4.7)">PTRACE_EVENT_SECCOMP
  stops (Linux 3.5 to Linux 4.7)</a></h2>
<p class="Pp">The behavior of <b>PTRACE_EVENT_SECCOMP</b> stops and their
    interaction with other kinds of ptrace stops has changed between kernel
    versions. This documents the behavior from their introduction until Linux
    4.7 (inclusive). The behavior in later kernel versions is documented in the
    next section.</p>
<p class="Pp">A <b>PTRACE_EVENT_SECCOMP</b> stop occurs whenever a
    <b>SECCOMP_RET_TRACE</b> rule is triggered. This is independent of which
    methods was used to restart the system call. Notably, seccomp still runs
    even if the tracee was restarted using <b>PTRACE_SYSEMU</b> and this system
    call is unconditionally skipped.</p>
<p class="Pp">Restarts from this stop will behave as if the stop had occurred
    right before the system call in question. In particular, both
    <b>PTRACE_SYSCALL</b> and <b>PTRACE_SYSEMU</b> will normally cause a
    subsequent syscall-entry-stop. However, if after the
    <b>PTRACE_EVENT_SECCOMP</b> the system call number is negative, both the
    syscall-entry-stop and the system call itself will be skipped. This means
    that if the system call number is negative after a
    <b>PTRACE_EVENT_SECCOMP</b> and the tracee is restarted using
    <b>PTRACE_SYSCALL</b>, the next observed stop will be a syscall-exit-stop,
    rather than the syscall-entry-stop that might have been expected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PTRACE_EVENT_SECCOMP_stops_(since_Linux_4.8)"><a class="permalink" href="#PTRACE_EVENT_SECCOMP_stops_(since_Linux_4.8)">PTRACE_EVENT_SECCOMP
  stops (since Linux 4.8)</a></h2>
<p class="Pp">Starting with Linux 4.8, the <b>PTRACE_EVENT_SECCOMP</b> stop was
    reordered to occur between syscall-entry-stop and syscall-exit-stop. Note
    that seccomp no longer runs (and no <b>PTRACE_EVENT_SECCOMP</b> will be
    reported) if the system call is skipped due to <b>PTRACE_SYSEMU</b>.</p>
<p class="Pp">Functionally, a <b>PTRACE_EVENT_SECCOMP</b> stop functions
    comparably to a syscall-entry-stop (i.e., continuations using
    <b>PTRACE_SYSCALL</b> will cause syscall-exit-stops, the system call number
    may be changed and any other modified registers are visible to the
    to-be-executed system call as well). Note that there may be, but need not
    have been a preceding syscall-entry-stop.</p>
<p class="Pp">After a <b>PTRACE_EVENT_SECCOMP</b> stop, seccomp will be rerun,
    with a <b>SECCOMP_RET_TRACE</b> rule now functioning the same as a
    <b>SECCOMP_RET_ALLOW</b>. Specifically, this means that if registers are not
    modified during the <b>PTRACE_EVENT_SECCOMP</b> stop, the system call will
    then be allowed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="PTRACE_SINGLESTEP_stops"><a class="permalink" href="#PTRACE_SINGLESTEP_stops">PTRACE_SINGLESTEP
  stops</a></h2>
<p class="Pp">[Details of these kinds of stops are yet to be documented.]</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Informational_and_restarting_ptrace_commands"><a class="permalink" href="#Informational_and_restarting_ptrace_commands">Informational
  and restarting ptrace commands</a></h2>
<p class="Pp">Most ptrace commands (all except <b>PTRACE_ATTACH</b>,
    <b>PTRACE_SEIZE</b>, <b>PTRACE_TRACEME</b>, <b>PTRACE_INTERRUPT</b>, and
    <b>PTRACE_KILL</b>) require the tracee to be in a ptrace-stop, otherwise
    they fail with <b>ESRCH</b>.</p>
<p class="Pp">When the tracee is in ptrace-stop, the tracer can read and write
    data to the tracee using informational commands. These commands leave the
    tracee in ptrace-stopped state:</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_PEEKTEXT/PEEKDATA/PEEKUSER, pid, addr, 0);
ptrace(PTRACE_POKETEXT/POKEDATA/POKEUSER, pid, addr, long_val);
ptrace(PTRACE_GETREGS/GETFPREGS, pid, 0, &amp;struct);
ptrace(PTRACE_SETREGS/SETFPREGS, pid, 0, &amp;struct);
ptrace(PTRACE_GETREGSET, pid, NT_foo, &amp;iov);
ptrace(PTRACE_SETREGSET, pid, NT_foo, &amp;iov);
ptrace(PTRACE_GETSIGINFO, pid, 0, &amp;siginfo);
ptrace(PTRACE_SETSIGINFO, pid, 0, &amp;siginfo);
ptrace(PTRACE_GETEVENTMSG, pid, 0, &amp;long_var);
ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);
</pre>
<br>
<p class="Pp">Note that some errors are not reported. For example, setting
    signal information (<i>siginfo</i>) may have no effect in some ptrace-stops,
    yet the call may succeed (return 0 and not set <i>errno</i>); querying
    <b>PTRACE_GETEVENTMSG</b> may succeed and return some random value if
    current ptrace-stop is not documented as returning a meaningful event
    message.</p>
<p class="Pp">The call</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_SETOPTIONS, pid, 0, PTRACE_O_flags);
</pre>
<br>
<p class="Pp">affects one tracee. The tracee's current flags are replaced. Flags
    are inherited by new tracees created and "auto-attached" via
    active <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
    <b>PTRACE_O_TRACECLONE</b> options.</p>
<p class="Pp">Another group of commands makes the ptrace-stopped tracee run.
    They have the form:</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(cmd, pid, 0, sig);
</pre>
<br>
<p class="Pp">where <i>cmd</i> is <b>PTRACE_CONT</b>, <b>PTRACE_LISTEN</b>,
    <b>PTRACE_DETACH</b>, <b>PTRACE_SYSCALL</b>, <b>PTRACE_SINGLESTEP</b>,
    <b>PTRACE_SYSEMU</b>, or <b>PTRACE_SYSEMU_SINGLESTEP</b>. If the tracee is
    in signal-delivery-stop, <i>sig</i> is the signal to be injected (if it is
    nonzero). Otherwise, <i>sig</i> may be ignored. (When restarting a tracee
    from a ptrace-stop other than signal-delivery-stop, recommended practice is
    to always pass 0 in <i>sig</i>.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Attaching_and_detaching"><a class="permalink" href="#Attaching_and_detaching">Attaching
  and detaching</a></h2>
<p class="Pp">A thread can be attached to the tracer using the call</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_ATTACH, pid, 0, 0);
</pre>
<br>
<p class="Pp">or</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_SEIZE, pid, 0, PTRACE_O_flags);
</pre>
<br>
<p class="Pp"><b>PTRACE_ATTACH</b> sends <b>SIGSTOP</b> to this thread. If the
    tracer wants this <b>SIGSTOP</b> to have no effect, it needs to suppress it.
    Note that if other signals are concurrently sent to this thread during
    attach, the tracer may see the tracee enter signal-delivery-stop with other
    signal(s) first! The usual practice is to reinject these signals until
    <b>SIGSTOP</b> is seen, then suppress <b>SIGSTOP</b> injection. The design
    bug here is that a ptrace attach and a concurrently delivered <b>SIGSTOP</b>
    may race and the concurrent <b>SIGSTOP</b> may be lost.</p>
<p class="Pp">Since attaching sends <b>SIGSTOP</b> and the tracer usually
    suppresses it, this may cause a stray <b>EINTR</b> return from the currently
    executing system call in the tracee, as described in the "Signal
    injection and suppression" section.</p>
<p class="Pp">Since Linux 3.4, <b>PTRACE_SEIZE</b> can be used instead of
    <b>PTRACE_ATTACH</b>. <b>PTRACE_SEIZE</b> does not stop the attached
    process. If you need to stop it after attach (or at any other time) without
    sending it any signals, use <b>PTRACE_INTERRUPT</b> command.</p>
<p class="Pp">The request</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_TRACEME, 0, 0, 0);
</pre>
<br>
<p class="Pp">turns the calling thread into a tracee. The thread continues to
    run (doesn't enter ptrace-stop). A common practice is to follow the
    <b>PTRACE_TRACEME</b> with</p>
<p class="Pp">
  <br>
</p>
<pre>raise(SIGSTOP);
</pre>
<br>
<p class="Pp">and allow the parent (which is our tracer now) to observe our
    signal-delivery-stop.</p>
<p class="Pp">If the <b>PTRACE_O_TRACEFORK</b>, <b>PTRACE_O_TRACEVFORK</b>, or
    <b>PTRACE_O_TRACECLONE</b> options are in effect, then children created by,
    respectively, <b>vfork</b>(2) or <b>clone</b>(2) with the <b>CLONE_VFORK</b>
    flag, <b>fork</b>(2) or <b>clone</b>(2) with the exit signal set to
    <b>SIGCHLD</b>, and other kinds of <b>clone</b>(2), are automatically
    attached to the same tracer which traced their parent. <b>SIGSTOP</b> is
    delivered to the children, causing them to enter signal-delivery-stop after
    they exit the system call which created them.</p>
<p class="Pp">Detaching of the tracee is performed by:</p>
<p class="Pp">
  <br>
</p>
<pre>ptrace(PTRACE_DETACH, pid, 0, sig);
</pre>
<br>
<p class="Pp"><b>PTRACE_DETACH</b> is a restarting operation; therefore it
    requires the tracee to be in ptrace-stop. If the tracee is in
    signal-delivery-stop, a signal can be injected. Otherwise, the <i>sig</i>
    parameter may be silently ignored.</p>
<p class="Pp">If the tracee is running when the tracer wants to detach it, the
    usual solution is to send <b>SIGSTOP</b> (using <b>tgkill</b>(2), to make
    sure it goes to the correct thread), wait for the tracee to stop in
    signal-delivery-stop for <b>SIGSTOP</b> and then detach it (suppressing
    <b>SIGSTOP</b> injection). A design bug is that this can race with
    concurrent <b>SIGSTOP</b>s. Another complication is that the tracee may
    enter other ptrace-stops and needs to be restarted and waited for again,
    until <b>SIGSTOP</b> is seen. Yet another complication is to be sure that
    the tracee is not already ptrace-stopped, because no signal delivery happens
    while it isnot even <b>SIGSTOP</b>.</p>
<p class="Pp">If the tracer dies, all tracees are automatically detached and
    restarted, unless they were in group-stop. Handling of restart from
    group-stop is currently buggy, but the "as planned" behavior is to
    leave tracee stopped and waiting for <b>SIGCONT</b>. If the tracee is
    restarted from signal-delivery-stop, the pending signal is injected.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="execve(2)_under_ptrace"><a class="permalink" href="#execve(2)_under_ptrace">execve(2)
  under ptrace</a></h2>
<p class="Pp">When one thread in a multithreaded process calls <b>execve</b>(2),
    the kernel destroys all other threads in the process, and resets the thread
    ID of the execing thread to the thread group ID (process ID). (Or, to put
    things another way, when a multithreaded process does an <b>execve</b>(2),
    at completion of the call, it appears as though the <b>execve</b>(2)
    occurred in the thread group leader, regardless of which thread did the
    <b>execve</b>(2).) This resetting of the thread ID looks very confusing to
    tracers:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>All other threads stop in <b>PTRACE_EVENT_EXIT</b> stop, if the
      <b>PTRACE_O_TRACEEXIT</b> option was turned on. Then all other threads
      except the thread group leader report death as if they exited via
      <b>_exit</b>(2) with exit code 0.</dd>
  <dt></dt>
  <dd>The execing tracee changes its thread ID while it is in the
      <b>execve</b>(2). (Remember, under ptrace, the "pid" returned
      from <b>waitpid</b>(2), or fed into ptrace calls, is the tracee's thread
      ID.) That is, the tracee's thread ID is reset to be the same as its
      process ID, which is the same as the thread group leader's thread ID.</dd>
  <dt></dt>
  <dd>Then a <b>PTRACE_EVENT_EXEC</b> stop happens, if the
      <b>PTRACE_O_TRACEEXEC</b> option was turned on.</dd>
  <dt></dt>
  <dd>If the thread group leader has reported its <b>PTRACE_EVENT_EXIT</b> stop
      by this time, it appears to the tracer that the dead thread leader
      "reappears from nowhere". (Note: the thread group leader does
      not report death via <i>WIFEXITED(status)</i> until there is at least one
      other live thread. This eliminates the possibility that the tracer will
      see it dying and then reappearing.) If the thread group leader was still
      alive, for the tracer this may look as if thread group leader returns from
      a different system call than it entered, or even "returned from a
      system call even though it was not in any system call". If the thread
      group leader was not traced (or was traced by a different tracer), then
      during <b>execve</b>(2) it will appear as if it has become a tracee of the
      tracer of the execing tracee.</dd>
</dl>
<p class="Pp">All of the above effects are the artifacts of the thread ID change
    in the tracee.</p>
<p class="Pp">The <b>PTRACE_O_TRACEEXEC</b> option is the recommended tool for
    dealing with this situation. First, it enables <b>PTRACE_EVENT_EXEC</b>
    stop, which occurs before <b>execve</b>(2) returns. In this stop, the tracer
    can use <b>PTRACE_GETEVENTMSG</b> to retrieve the tracee's former thread ID.
    (This feature was introduced in Linux 3.0.) Second, the
    <b>PTRACE_O_TRACEEXEC</b> option disables legacy <b>SIGTRAP</b> generation
    on <b>execve</b>(2).</p>
<p class="Pp">When the tracer receives <b>PTRACE_EVENT_EXEC</b> stop
    notification, it is guaranteed that except this tracee and the thread group
    leader, no other threads from the process are alive.</p>
<p class="Pp">On receiving the <b>PTRACE_EVENT_EXEC</b> stop notification, the
    tracer should clean up all its internal data structures describing the
    threads of this process, and retain only one data structureone which
    describes the single still running tracee, with</p>
<p class="Pp">
  <br>
</p>
<pre>thread ID == thread group ID == process ID.
</pre>
<br>
<p class="Pp">Example: two threads call <b>execve</b>(2) at the same time:</p>
<p class="Pp"></p>
<pre>*** we get syscall-enter-stop in thread 1: **
PID1 execve("/bin/foo", "foo" &lt;unfinished ...&gt;
*** we issue PTRACE_SYSCALL for thread 1 **
*** we get syscall-enter-stop in thread 2: **
PID2 execve("/bin/bar", "bar" &lt;unfinished ...&gt;
*** we issue PTRACE_SYSCALL for thread 2 **
*** we get PTRACE_EVENT_EXEC for PID0, we issue PTRACE_SYSCALL **
*** we get syscall-exit-stop for PID0: **
PID0 &lt;... execve resumed&gt; )             = 0</pre>
<p class="Pp">If the <b>PTRACE_O_TRACEEXEC</b> option is <i>not</i> in effect
    for the execing tracee, and if the tracee was <b>PTRACE_ATTACH</b>ed rather
    that <b>PTRACE_SEIZE</b>d, the kernel delivers an extra <b>SIGTRAP</b> to
    the tracee after <b>execve</b>(2) returns. This is an ordinary signal
    (similar to one which can be generated by <i>kill -TRAP</i>), not a special
    kind of ptrace-stop. Employing <b>PTRACE_GETSIGINFO</b> for this signal
    returns <i>si_code</i> set to 0 (<i>SI_USER</i>). This signal may be blocked
    by signal mask, and thus may be delivered (much) later.</p>
<p class="Pp">Usually, the tracer (for example, <b>strace</b>(1)) would not want
    to show this extra post-execve <b>SIGTRAP</b> signal to the user, and would
    suppress its delivery to the tracee (if <b>SIGTRAP</b> is set to
    <b>SIG_DFL</b>, it is a killing signal). However, determining <i>which</i>
    <b>SIGTRAP</b> to suppress is not easy. Setting the
    <b>PTRACE_O_TRACEEXEC</b> option or using <b>PTRACE_SEIZE</b> and thus
    suppressing this extra <b>SIGTRAP</b> is the recommended approach.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Real_parent"><a class="permalink" href="#Real_parent">Real
  parent</a></h2>
<p class="Pp">The ptrace API (ab)uses the standard UNIX parent/child signaling
    over <b>waitpid</b>(2). This used to cause the real parent of the process to
    stop receiving several kinds of <b>waitpid</b>(2) notifications when the
    child process is traced by some other process.</p>
<p class="Pp">Many of these bugs have been fixed, but as of Linux 2.6.38 several
    still exist; see BUGS below.</p>
<p class="Pp">As of Linux 2.6.38, the following is believed to work
  correctly:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>exit/death by signal is reported first to the tracer, then, when the
      tracer consumes the <b>waitpid</b>(2) result, to the real parent (to the
      real parent only when the whole multithreaded process exits). If the
      tracer and the real parent are the same process, the report is sent only
      once.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">On success, the <b>PTRACE_PEEK*</b> requests return the requested
    data (but see NOTES), the <b>PTRACE_SECCOMP_GET_FILTER</b> request returns
    the number of instructions in the BPF program, the
    <b>PTRACE_GET_SYSCALL_INFO</b> request returns the number of bytes available
    to be written by the kernel, and other requests return zero.</p>
<p class="Pp">On error, all requests return -1, and <i>errno</i> is set to
    indicate the error. Since the value returned by a successful
    <b>PTRACE_PEEK*</b> request may be -1, the caller must clear <i>errno</i>
    before the call, and then check it afterward to determine whether or not an
    error occurred.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<dl class="Bl-tag">
  <dt id="EBUSY"><a class="permalink" href="#EBUSY"><b>EBUSY</b></a></dt>
  <dd>(i386 only) There was an error with allocating or freeing a debug
      register.</dd>
  <dt id="EFAULT"><a class="permalink" href="#EFAULT"><b>EFAULT</b></a></dt>
  <dd>There was an attempt to read from or write to an invalid area in the
      tracer's or the tracee's memory, probably because the area wasn't mapped
      or accessible. Unfortunately, under Linux, different variations of this
      fault will return <b>EIO</b> or <b>EFAULT</b> more or less
    arbitrarily.</dd>
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>An attempt was made to set an invalid option.</dd>
  <dt id="EIO"><a class="permalink" href="#EIO"><b>EIO</b></a></dt>
  <dd><i>request</i> is invalid, or an attempt was made to read from or write to
      an invalid area in the tracer's or the tracee's memory, or there was a
      word-alignment violation, or an invalid signal was specified during a
      restart request.</dd>
  <dt id="EPERM"><a class="permalink" href="#EPERM"><b>EPERM</b></a></dt>
  <dd>The specified process cannot be traced. This could be because the tracer
      has insufficient privileges (the required capability is
      <b>CAP_SYS_PTRACE</b>); unprivileged processes cannot trace processes that
      they cannot send signals to or those running set-user-ID/set-group-ID
      programs, for obvious reasons. Alternatively, the process may already be
      being traced, or (before Linux 2.6.26) be <b>init</b>(1) (PID 1).</dd>
  <dt id="ESRCH"><a class="permalink" href="#ESRCH"><b>ESRCH</b></a></dt>
  <dd>The specified process does not exist, or is not currently being traced by
      the caller, or is not stopped (for requests that require a stopped
      tracee).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">SVr4, 4.3BSD.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Although arguments to <b>ptrace</b>() are interpreted according to
    the prototype given, glibc currently declares <b>ptrace</b>() as a variadic
    function with only the <i>request</i> argument fixed. It is recommended to
    always supply four arguments, even if the requested operation does not use
    them, setting unused/ignored arguments to <i>0L</i> or
    <i>(void&nbsp;*)&nbsp;0</i>.</p>
<p class="Pp">Before Linux 2.6.26, <b>init</b>(1), the process with PID 1, may
    not be traced.</p>
<p class="Pp">A tracees parent continues to be the tracer even if that tracer
    calls <b>execve</b>(2).</p>
<p class="Pp">The layout of the contents of memory and the USER area are quite
    operating-system- and architecture-specific. The offset supplied, and the
    data returned, might not entirely match with the definition of <i>struct
    user</i>.</p>
<p class="Pp">The size of a "word" is determined by the
    operating-system variant (e.g., for 32-bit Linux it is 32 bits).</p>
<p class="Pp">This page documents the way the <b>ptrace</b>() call works
    currently in Linux. Its behavior differs significantly on other flavors of
    UNIX. In any case, use of <b>ptrace</b>() is highly specific to the
    operating system and architecture.</p>
<section class="Ss">
<h2 class="Ss" id="Ptrace_access_mode_checking"><a class="permalink" href="#Ptrace_access_mode_checking">Ptrace
  access mode checking</a></h2>
<p class="Pp">Various parts of the kernel-user-space API (not just
    <b>ptrace</b>() operations), require so-called "ptrace access
    mode" checks, whose outcome determines whether an operation is
    permitted (or, in a few cases, causes a "read" operation to return
    sanitized data). These checks are performed in cases where one process can
    inspect sensitive information about, or in some cases modify the state of,
    another process. The checks are based on factors such as the credentials and
    capabilities of the two processes, whether or not the "target"
    process is dumpable, and the results of checks performed by any enabled
    Linux Security Module (LSM)for example, SELinux, Yama, or
    Smackand by the commoncap LSM (which is always invoked).</p>
<p class="Pp">Prior to Linux 2.6.27, all access checks were of a single type.
    Since Linux 2.6.27, two access mode levels are distinguished:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_MODE_READ"><a class="permalink" href="#PTRACE_MODE_READ"><b>PTRACE_MODE_READ</b></a></dt>
  <dd>For "read" operations or other operations that are less
      dangerous, such as: <b>get_robust_list</b>(2); <b>kcmp</b>(2); reading
      <i>/proc/</i>pid<i>/auxv</i>, <i>/proc/</i>pid<i>/environ</i>, or
      <i>/proc/</i>pid<i>/stat</i>; or <b>readlink</b>(2) of a
      <i>/proc/</i>pid<i>/ns/*</i> file.</dd>
  <dt id="PTRACE_MODE_ATTACH"><a class="permalink" href="#PTRACE_MODE_ATTACH"><b>PTRACE_MODE_ATTACH</b></a></dt>
  <dd>For "write" operations, or other operations that are more
      dangerous, such as: ptrace attaching (<b>PTRACE_ATTACH</b>) to another
      process or calling <b>process_vm_writev</b>(2). (<b>PTRACE_MODE_ATTACH</b>
      was effectively the default before Linux 2.6.27.)</dd>
</dl>
<p class="Pp">Since Linux 4.5, the above access mode checks are combined (ORed)
    with one of the following modifiers:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_MODE_FSCREDS"><a class="permalink" href="#PTRACE_MODE_FSCREDS"><b>PTRACE_MODE_FSCREDS</b></a></dt>
  <dd>Use the caller's filesystem UID and GID (see <b>credentials</b>(7)) or
      effective capabilities for LSM checks.</dd>
  <dt id="PTRACE_MODE_REALCREDS"><a class="permalink" href="#PTRACE_MODE_REALCREDS"><b>PTRACE_MODE_REALCREDS</b></a></dt>
  <dd>Use the caller's real UID and GID or permitted capabilities for LSM
      checks. This was effectively the default before Linux 4.5.</dd>
</dl>
<p class="Pp">Because combining one of the credential modifiers with one of the
    aforementioned access modes is typical, some macros are defined in the
    kernel sources for the combinations:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_MODE_READ_FSCREDS"><a class="permalink" href="#PTRACE_MODE_READ_FSCREDS"><b>PTRACE_MODE_READ_FSCREDS</b></a></dt>
  <dd>Defined as <b>PTRACE_MODE_READ | PTRACE_MODE_FSCREDS</b>.</dd>
  <dt id="PTRACE_MODE_READ_REALCREDS"><a class="permalink" href="#PTRACE_MODE_READ_REALCREDS"><b>PTRACE_MODE_READ_REALCREDS</b></a></dt>
  <dd>Defined as <b>PTRACE_MODE_READ | PTRACE_MODE_REALCREDS</b>.</dd>
  <dt id="PTRACE_MODE_ATTACH_FSCREDS"><a class="permalink" href="#PTRACE_MODE_ATTACH_FSCREDS"><b>PTRACE_MODE_ATTACH_FSCREDS</b></a></dt>
  <dd>Defined as <b>PTRACE_MODE_ATTACH | PTRACE_MODE_FSCREDS</b>.</dd>
  <dt id="PTRACE_MODE_ATTACH_REALCREDS"><a class="permalink" href="#PTRACE_MODE_ATTACH_REALCREDS"><b>PTRACE_MODE_ATTACH_REALCREDS</b></a></dt>
  <dd>Defined as <b>PTRACE_MODE_ATTACH | PTRACE_MODE_REALCREDS</b>.</dd>
</dl>
<p class="Pp">One further modifier can be ORed with the access mode:</p>
<dl class="Bl-tag">
  <dt id="PTRACE_MODE_NOAUDIT"><a class="permalink" href="#PTRACE_MODE_NOAUDIT"><b>PTRACE_MODE_NOAUDIT</b>
    (since Linux 3.3)</a></dt>
  <dd>Don't audit this access mode check. This modifier is employed for ptrace
      access mode checks (such as checks when reading
      <i>/proc/</i>pid<i>/stat</i>) that merely cause the output to be filtered
      or sanitized, rather than causing an error to be returned to the caller.
      In these cases, accessing the file is not a security violation and there
      is no reason to generate a security audit record. This modifier suppresses
      the generation of such an audit record for the particular access
    check.</dd>
</dl>
<p class="Pp">Note that all of the <b>PTRACE_MODE_*</b> constants described in
    this subsection are kernel-internal, and not visible to user space. The
    constant names are mentioned here in order to label the various kinds of
    ptrace access mode checks that are performed for various system calls and
    accesses to various pseudofiles (e.g., under <i>/proc</i>). These names are
    used in other manual pages to provide a simple shorthand for labeling the
    different kernel checks.</p>
<p class="Pp">The algorithm employed for ptrace access mode checking determines
    whether the calling process is allowed to perform the corresponding action
    on the target process. (In the case of opening <i>/proc/</i>pid files, the
    "calling process" is the one opening the file, and the process
    with the corresponding PID is the "target process".) The algorithm
    is as follows:</p>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>If the calling thread and the target thread are in the same thread group,
      access is always allowed.</dd>
  <dt>(2)</dt>
  <dd>If the access mode specifies <b>PTRACE_MODE_FSCREDS</b>, then, for the
      check in the next step, employ the caller's filesystem UID and GID. (As
      noted in <b>credentials</b>(7), the filesystem UID and GID almost always
      have the same values as the corresponding effective IDs.)</dd>
  <dt></dt>
  <dd>Otherwise, the access mode specifies <b>PTRACE_MODE_REALCREDS</b>, so use
      the caller's real UID and GID for the checks in the next step. (Most APIs
      that check the caller's UID and GID use the effective IDs. For historical
      reasons, the <b>PTRACE_MODE_REALCREDS</b> check uses the real IDs
      instead.)</dd>
  <dt>(3)</dt>
  <dd>Deny access if <i>neither</i> of the following is true:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt></dt>
  <dd>The real, effective, and saved-set user IDs of the target match the
      caller's user ID, <i>and</i> the real, effective, and saved-set group IDs
      of the target match the caller's group ID.</dd>
  <dt></dt>
  <dd>The caller has the <b>CAP_SYS_PTRACE</b> capability in the user namespace
      of the target.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(4)</dt>
  <dd>Deny access if the target process "dumpable" attribute has a
      value other than 1 (<b>SUID_DUMP_USER</b>; see the discussion of
      <b>PR_SET_DUMPABLE</b> in <b>prctl</b>(2)), and the caller does not have
      the <b>CAP_SYS_PTRACE</b> capability in the user namespace of the target
      process.</dd>
  <dt>(5)</dt>
  <dd>The kernel LSM <i>security_ptrace_access_check</i>() interface is invoked
      to see if ptrace access is permitted. The results depend on the LSM(s).
      The implementation of this interface in the commoncap LSM performs the
      following steps:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(5.1)</dt>
  <dd>If the access mode includes <b>PTRACE_MODE_FSCREDS</b>, then use the
      caller's <i>effective</i> capability set in the following check; otherwise
      (the access mode specifies <b>PTRACE_MODE_REALCREDS</b>, so) use the
      caller's <i>permitted</i> capability set.</dd>
  <dt>(5.2)</dt>
  <dd>Deny access if <i>neither</i> of the following is true:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt></dt>
  <dd>The caller and the target process are in the same user namespace, and the
      caller's capabilities are a superset of the target process's
      <i>permitted</i> capabilities.</dd>
  <dt></dt>
  <dd>The caller has the <b>CAP_SYS_PTRACE</b> capability in the target
      process's user namespace.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that the commoncap LSM does not distinguish between
      <b>PTRACE_MODE_READ</b> and <b>PTRACE_MODE_ATTACH</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(6)</dt>
  <dd>If access has not been denied by any of the preceding steps, then access
      is allowed.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="/proc/sys/kernel/yama/ptrace_scope"><a class="permalink" href="#/proc/sys/kernel/yama/ptrace_scope">/proc/sys/kernel/yama/ptrace_scope</a></h2>
<p class="Pp">On systems with the Yama Linux Security Module (LSM) installed
    (i.e., the kernel was configured with <b>CONFIG_SECURITY_YAMA</b>), the
    <i>/proc/sys/kernel/yama/ptrace_scope</i> file (available since Linux 3.4)
    can be used to restrict the ability to trace a process with <b>ptrace</b>()
    (and thus also the ability to use tools such as <b>strace</b>(1) and
    <b>gdb</b>(1)). The goal of such restrictions is to prevent attack
    escalation whereby a compromised process can ptrace-attach to other
    sensitive processes (e.g., a GPG agent or an SSH session) owned by the user
    in order to gain additional credentials that may exist in memory and thus
    expand the scope of the attack.</p>
<p class="Pp">More precisely, the Yama LSM limits two types of operations:</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Any operation that performs a ptrace access mode <b>PTRACE_MODE_ATTACH</b>
      checkfor example, <b>ptrace</b>() <b>PTRACE_ATTACH</b>. (See the
      "Ptrace access mode checking" discussion above.)</dd>
  <dt></dt>
  <dd><b>ptrace</b>() <b>PTRACE_TRACEME</b>.</dd>
</dl>
<p class="Pp">A process that has the <b>CAP_SYS_PTRACE</b> capability can update
    the <i>/proc/sys/kernel/yama/ptrace_scope</i> file with one of the following
    values:</p>
<dl class="Bl-tag">
  <dt>0 ("classic ptrace permissions")</dt>
  <dd>No additional restrictions on operations that perform
      <b>PTRACE_MODE_ATTACH</b> checks (beyond those imposed by the commoncap
      and other LSMs).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The use of <b>PTRACE_TRACEME</b> is unchanged.</dd>
</dl>
<dl class="Bl-tag">
  <dt>1 ("restricted ptrace") [default value]</dt>
  <dd>When performing an operation that requires a <b>PTRACE_MODE_ATTACH</b>
      check, the calling process must either have the <b>CAP_SYS_PTRACE</b>
      capability in the user namespace of the target process or it must have a
      predefined relationship with the target process. By default, the
      predefined relationship is that the target process must be a descendant of
      the caller.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>A target process can employ the <b>prctl</b>(2) <b>PR_SET_PTRACER</b>
      operation to declare an additional PID that is allowed to perform
      <b>PTRACE_MODE_ATTACH</b> operations on the target. See the kernel source
      file <i>Documentation/admin-guide/LSM/Yama.rst</i> (or
      <i>Documentation/security/Yama.txt</i> before Linux 4.13) for further
      details.</dd>
  <dt></dt>
  <dd>The use of <b>PTRACE_TRACEME</b> is unchanged.</dd>
</dl>
<dl class="Bl-tag">
  <dt>2 ("admin-only attach")</dt>
  <dd>Only processes with the <b>CAP_SYS_PTRACE</b> capability in the user
      namespace of the target process may perform <b>PTRACE_MODE_ATTACH</b>
      operations or trace children that employ <b>PTRACE_TRACEME</b>.</dd>
  <dt>3 ("no attach")</dt>
  <dd>No process may perform <b>PTRACE_MODE_ATTACH</b> operations or trace
      children that employ <b>PTRACE_TRACEME</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Once this value has been written to the file, it cannot be changed.</dd>
</dl>
<p class="Pp">With respect to values 1 and 2, note that creating a new user
    namespace effectively removes the protection offered by Yama. This is
    because a process in the parent user namespace whose effective UID matches
    the UID of the creator of a child namespace has all capabilities (including
    <b>CAP_SYS_PTRACE</b>) when performing operations within the child user
    namespace (and further-removed descendants of that namespace). Consequently,
    when a process tries to use user namespaces to sandbox itself, it
    inadvertently weakens the protections offered by the Yama LSM.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="C_library/kernel_differences"><a class="permalink" href="#C_library/kernel_differences">C
  library/kernel differences</a></h2>
<p class="Pp">At the system call level, the <b>PTRACE_PEEKTEXT</b>,
    <b>PTRACE_PEEKDATA</b>, and <b>PTRACE_PEEKUSER</b> requests have a different
    API: they store the result at the address specified by the <i>data</i>
    parameter, and the return value is the error flag. The glibc wrapper
    function provides the API given in DESCRIPTION above, with the result being
    returned via the function return value.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">On hosts with Linux 2.6 kernel headers, <b>PTRACE_SETOPTIONS</b>
    is declared with a different value than the one for Linux 2.4. This leads to
    applications compiled with Linux 2.6 kernel headers failing when run on
    Linux 2.4. This can be worked around by redefining <b>PTRACE_SETOPTIONS</b>
    to <b>PTRACE_OLDSETOPTIONS</b>, if that is defined.</p>
<p class="Pp">Group-stop notifications are sent to the tracer, but not to real
    parent. Last confirmed on 2.6.38.6.</p>
<p class="Pp">If a thread group leader is traced and exits by calling
    <b>_exit</b>(2), a <b>PTRACE_EVENT_EXIT</b> stop will happen for it (if
    requested), but the subsequent <b>WIFEXITED</b> notification will not be
    delivered until all other threads exit. As explained above, if one of other
    threads calls <b>execve</b>(2), the death of the thread group leader will
    <i>never</i> be reported. If the execed thread is not traced by this tracer,
    the tracer will never know that <b>execve</b>(2) happened. One possible
    workaround is to <b>PTRACE_DETACH</b> the thread group leader instead of
    restarting it in this case. Last confirmed on 2.6.38.6.</p>
<p class="Pp">A <b>SIGKILL</b> signal may still cause a <b>PTRACE_EVENT_EXIT</b>
    stop before actual signal death. This may be changed in the future;
    <b>SIGKILL</b> is meant to always immediately kill tasks even under ptrace.
    Last confirmed on Linux 3.13.</p>
<p class="Pp">Some system calls return with <b>EINTR</b> if a signal was sent to
    a tracee, but delivery was suppressed by the tracer. (This is very typical
    operation: it is usually done by debuggers on every attach, in order to not
    introduce a bogus <b>SIGSTOP</b>). As of Linux 3.2.9, the following system
    calls are affected (this list is likely incomplete): <b>epoll_wait</b>(2),
    and <b>read</b>(2) from an <b>inotify</b>(7) file descriptor. The usual
    symptom of this bug is that when you attach to a quiescent process with the
    command</p>
<p class="Pp">
  <br>
</p>
<pre>strace -p &lt;process-ID&gt;
</pre>
<br>
<p class="Pp">then, instead of the usual and expected one-line output such
  as</p>
<p class="Pp">
  <br>
</p>
<pre>restart_syscall(&lt;... resuming interrupted call ...&gt;_
</pre>
<br>
<p class="Pp">or</p>
<p class="Pp">
  <br>
</p>
<pre>select(6, [5], NULL, [5], NULL_
</pre>
<br>
<p class="Pp">('_' denotes the cursor position), you observe more than one line.
    For example:</p>
<p class="Pp">
  <br>
</p>
<pre><br>
    clock_gettime(CLOCK_MONOTONIC, {15370, 690928118}) = 0
<br>
    epoll_wait(4,_
</pre>
<br>
<p class="Pp">What is not visible here is that the process was blocked in
    <b>epoll_wait</b>(2) before <b>strace</b>(1) has attached to it. Attaching
    caused <b>epoll_wait</b>(2) to return to user space with the error
    <b>EINTR</b>. In this particular case, the program reacted to <b>EINTR</b>
    by checking the current time, and then executing <b>epoll_wait</b>(2) again.
    (Programs which do not expect such "stray" <b>EINTR</b> errors may
    behave in an unintended way upon an <b>strace</b>(1) attach.)</p>
<p class="Pp">Contrary to the normal rules, the glibc wrapper for
    <b>ptrace</b>() can set <i>errno</i> to zero.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>gdb</b>(1), <b>ltrace</b>(1), <b>strace</b>(1),
    <b>clone</b>(2), <b>execve</b>(2), <b>fork</b>(2), <b>gettid</b>(2),
    <b>prctl</b>(2), <b>seccomp</b>(2), <b>sigaction</b>(2), <b>tgkill</b>(2),
    <b>vfork</b>(2), <b>waitpid</b>(2), <b>exec</b>(3), <b>capabilities</b>(7),
    <b>signal</b>(7)</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>