<!DOCTYPE html><html><head>
<meta name="dc.identifier" content="res/93b0765389edb51a70b7556cdfbdcb164955ebc4">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>fcntl(2)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">fcntl(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">fcntl(2)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">fcntl - manipulate file descriptor</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Standard C library (<i>libc</i>, <i>-lc</i>)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;fcntl.h&gt;</b></pre>
<pre><b>int fcntl(int </b><i>fd</i><b>, int </b><i>cmd</i><b>, ... /* </b><i>arg</i><b> */ );</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp"><b>fcntl</b>() performs one of the operations described below on
    the open file descriptor <i>fd</i>. The operation is determined by
    <i>cmd</i>.</p>
<p class="Pp"><b>fcntl</b>() can take an optional third argument. Whether or not
    this argument is required is determined by <i>cmd</i>. The required argument
    type is indicated in parentheses after each <i>cmd</i> name (in most cases,
    the required type is <i>int</i>, and we identify the argument using the name
    <i>arg</i>), or <i>void</i> is specified if the argument is not
  required.</p>
<p class="Pp">Certain of the operations below are supported only since a
    particular Linux kernel version. The preferred method of checking whether
    the host kernel supports a particular operation is to invoke <b>fcntl</b>()
    with the desired <i>cmd</i> value and then test whether the call failed with
    <b>EINVAL</b>, indicating that the kernel does not recognize this value.</p>
<section class="Ss">
<h2 class="Ss" id="Duplicating_a_file_descriptor"><a class="permalink" href="#Duplicating_a_file_descriptor">Duplicating
  a file descriptor</a></h2>
<dl class="Bl-tag">
  <dt id="F_DUPFD"><a class="permalink" href="#F_DUPFD"><b>F_DUPFD</b>
    (<i>int</i>)</a></dt>
  <dd>Duplicate the file descriptor <i>fd</i> using the lowest-numbered
      available file descriptor greater than or equal to <i>arg</i>. This is
      different from <b>dup2</b>(2), which uses exactly the file descriptor
      specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>On success, the new file descriptor is returned.</dd>
  <dt></dt>
  <dd>See <b>dup</b>(2) for further details.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F_DUPFD_CLOEXEC"><a class="permalink" href="#F_DUPFD_CLOEXEC"><b>F_DUPFD_CLOEXEC</b>
    (<i>int</i>; since Linux 2.6.24)</a></dt>
  <dd>As for <b>F_DUPFD</b>, but additionally set the close-on-exec flag for the
      duplicate file descriptor. Specifying this flag permits a program to avoid
      an additional <b>fcntl</b>() <b>F_SETFD</b> operation to set the
      <b>FD_CLOEXEC</b> flag. For an explanation of why this flag is useful, see
      the description of <b>O_CLOEXEC</b> in <b>open</b>(2).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="File_descriptor_flags"><a class="permalink" href="#File_descriptor_flags">File
  descriptor flags</a></h2>
<p class="Pp">The following commands manipulate the flags associated with a file
    descriptor. Currently, only one such flag is defined: <b>FD_CLOEXEC</b>, the
    close-on-exec flag. If the <b>FD_CLOEXEC</b> bit is set, the file descriptor
    will automatically be closed during a successful <b>execve</b>(2). (If the
    <b>execve</b>(2) fails, the file descriptor is left open.) If the
    <b>FD_CLOEXEC</b> bit is not set, the file descriptor will remain open
    across an <b>execve</b>(2).</p>
<dl class="Bl-tag">
  <dt id="F_GETFD"><a class="permalink" href="#F_GETFD"><b>F_GETFD</b>
    (<i>void</i>)</a></dt>
  <dd>Return (as the function result) the file descriptor flags; <i>arg</i> is
      ignored.</dd>
  <dt id="F_SETFD"><a class="permalink" href="#F_SETFD"><b>F_SETFD</b>
    (<i>int</i>)</a></dt>
  <dd>Set the file descriptor flags to the value specified by <i>arg</i>.</dd>
</dl>
<p class="Pp">In multithreaded programs, using <b>fcntl</b>() <b>F_SETFD</b> to
    set the close-on-exec flag at the same time as another thread performs a
    <b>fork</b>(2) plus <b>execve</b>(2) is vulnerable to a race condition that
    may unintentionally leak the file descriptor to the program executed in the
    child process. See the discussion of the <b>O_CLOEXEC</b> flag in
    <b>open</b>(2) for details and a remedy to the problem.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="File_status_flags"><a class="permalink" href="#File_status_flags">File
  status flags</a></h2>
<p class="Pp">Each open file description has certain associated status flags,
    initialized by <b>open</b>(2) and possibly modified by <b>fcntl</b>().
    Duplicated file descriptors (made with <b>dup</b>(2), <b>fcntl</b>(F_DUPFD),
    <b>fork</b>(2), etc.) refer to the same open file description, and thus
    share the same file status flags.</p>
<p class="Pp">The file status flags and their semantics are described in
    <b>open</b>(2).</p>
<dl class="Bl-tag">
  <dt id="F_GETFL"><a class="permalink" href="#F_GETFL"><b>F_GETFL</b>
    (<i>void</i>)</a></dt>
  <dd>Return (as the function result) the file access mode and the file status
      flags; <i>arg</i> is ignored.</dd>
  <dt id="F_SETFL"><a class="permalink" href="#F_SETFL"><b>F_SETFL</b>
    (<i>int</i>)</a></dt>
  <dd>Set the file status flags to the value specified by <i>arg</i>. File
      access mode (<b>O_RDONLY</b>, <b>O_WRONLY</b>, <b>O_RDWR</b>) and file
      creation flags (i.e., <b>O_CREAT</b>, <b>O_EXCL</b>, <b>O_NOCTTY</b>,
      <b>O_TRUNC</b>) in <i>arg</i> are ignored. On Linux, this command can
      change only the <b>O_APPEND</b>, <b>O_ASYNC</b>, <b>O_DIRECT</b>,
      <b>O_NOATIME</b>, and <b>O_NONBLOCK</b> flags. It is not possible to
      change the <b>O_DSYNC</b> and <b>O_SYNC</b> flags; see BUGS, below.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Advisory_record_locking"><a class="permalink" href="#Advisory_record_locking">Advisory
  record locking</a></h2>
<p class="Pp">Linux implements traditional ("process-associated") UNIX
    record locks, as standardized by POSIX. For a Linux-specific alternative
    with better semantics, see the discussion of open file description locks
    below.</p>
<p class="Pp"><b>F_SETLK</b>, <b>F_SETLKW</b>, and <b>F_GETLK</b> are used to
    acquire, release, and test for the existence of record locks (also known as
    byte-range, file-segment, or file-region locks). The third argument,
    <i>lock</i>, is a pointer to a structure that has at least the following
    fields (in unspecified order).</p>
<p class="Pp">
  <br>
</p>
<pre>struct flock {
<br>
    ...
<br>
    short l_type;    /* Type of lock: F_RDLCK,
<br>
                        F_WRLCK, F_UNLCK */
<br>
    short l_whence;  /* How to interpret l_start:
<br>
                        SEEK_SET, SEEK_CUR, SEEK_END */
<br>
    off_t l_start;   /* Starting offset for lock */
<br>
    off_t l_len;     /* Number of bytes to lock */
<br>
    pid_t l_pid;     /* PID of process blocking our lock
<br>
                        (set by F_GETLK and F_OFD_GETLK) */
<br>
    ...
};
</pre>
<br>
<p class="Pp">The <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of
    this structure specify the range of bytes we wish to lock. Bytes past the
    end of the file may be locked, but not bytes before the start of the
  file.</p>
<p class="Pp"><i>l_start</i> is the starting offset for the lock, and is
    interpreted relative to either: the start of the file (if <i>l_whence</i> is
    <b>SEEK_SET</b>); the current file offset (if <i>l_whence</i> is
    <b>SEEK_CUR</b>); or the end of the file (if <i>l_whence</i> is
    <b>SEEK_END</b>). In the final two cases, <i>l_start</i> can be a negative
    number provided the offset does not lie before the start of the file.</p>
<p class="Pp"><i>l_len</i> specifies the number of bytes to be locked. If
    <i>l_len</i> is positive, then the range to be locked covers bytes
    <i>l_start</i> up to and including <i>l_start</i>+<i>l_len</i>-1. Specifying
    0 for <i>l_len</i> has the special meaning: lock all bytes starting at the
    location specified by <i>l_whence</i> and <i>l_start</i> through to the end
    of file, no matter how large the file grows.</p>
<p class="Pp">POSIX.1-2001 allows (but does not require) an implementation to
    support a negative <i>l_len</i> value; if <i>l_len</i> is negative, the
    interval described by <i>lock</i> covers bytes <i>l_start</i>+<i>l_len</i>
    up to and including <i>l_start</i>-1. This is supported since Linux 2.4.21
    and Linux 2.5.49.</p>
<p class="Pp">The <i>l_type</i> field can be used to place a read
    (<b>F_RDLCK</b>) or a write (<b>F_WRLCK</b>) lock on a file. Any number of
    processes may hold a read lock (shared lock) on a file region, but only one
    process may hold a write lock (exclusive lock). An exclusive lock excludes
    all other locks, both shared and exclusive. A single process can hold only
    one type of lock on a file region; if a new lock is applied to an
    already-locked region, then the existing lock is converted to the new lock
    type. (Such conversions may involve splitting, shrinking, or coalescing with
    an existing lock if the byte range specified by the new lock does not
    precisely coincide with the range of the existing lock.)</p>
<dl class="Bl-tag">
  <dt id="F_SETLK"><a class="permalink" href="#F_SETLK"><b>F_SETLK</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>Acquire a lock (when <i>l_type</i> is <b>F_RDLCK</b> or <b>F_WRLCK</b>) or
      release a lock (when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes
      specified by the <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields
      of <i>lock</i>. If a conflicting lock is held by another process, this
      call returns -1 and sets <i>errno</i> to <b>EACCES</b> or <b>EAGAIN</b>.
      (The error returned in this case differs across implementations, so POSIX
      requires a portable application to check for both errors.)</dd>
  <dt id="F_SETLKW"><a class="permalink" href="#F_SETLKW"><b>F_SETLKW</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>As for <b>F_SETLK</b>, but if a conflicting lock is held on the file, then
      wait for that lock to be released. If a signal is caught while waiting,
      then the call is interrupted and (after the signal handler has returned)
      returns immediately (with return value -1 and <i>errno</i> set to
      <b>EINTR</b>; see <b>signal</b>(7)).</dd>
  <dt id="F_GETLK"><a class="permalink" href="#F_GETLK"><b>F_GETLK</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>On input to this call, <i>lock</i> describes a lock we would like to place
      on the file. If the lock could be placed, <b>fcntl</b>() does not actually
      place it, but returns <b>F_UNLCK</b> in the <i>l_type</i> field of
      <i>lock</i> and leaves the other fields of the structure unchanged.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If one or more incompatible locks would prevent this lock being placed,
      then <b>fcntl</b>() returns details about one of those locks in the
      <i>l_type</i>, <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of
      <i>lock</i>. If the conflicting lock is a traditional (process-associated)
      record lock, then the <i>l_pid</i> field is set to the PID of the process
      holding that lock. If the conflicting lock is an open file description
      lock, then <i>l_pid</i> is set to -1. Note that the returned information
      may already be out of date by the time the caller inspects it.</dd>
</dl>
<p class="Pp">In order to place a read lock, <i>fd</i> must be open for reading.
    In order to place a write lock, <i>fd</i> must be open for writing. To place
    both types of lock, open a file read-write.</p>
<p class="Pp">When placing locks with <b>F_SETLKW</b>, the kernel detects
    <i>deadlocks</i>, whereby two or more processes have their lock requests
    mutually blocked by locks held by the other processes. For example, suppose
    process A holds a write lock on byte 100 of a file, and process B holds a
    write lock on byte 200. If each process then attempts to lock the byte
    already locked by the other process using <b>F_SETLKW</b>, then, without
    deadlock detection, both processes would remain blocked indefinitely. When
    the kernel detects such deadlocks, it causes one of the blocking lock
    requests to immediately fail with the error <b>EDEADLK</b>; an application
    that encounters such an error should release some of its locks to allow
    other applications to proceed before attempting regain the locks that it
    requires. Circular deadlocks involving more than two processes are also
    detected. Note, however, that there are limitations to the kernel's
    deadlock-detection algorithm; see BUGS.</p>
<p class="Pp">As well as being removed by an explicit <b>F_UNLCK</b>, record
    locks are automatically released when the process terminates.</p>
<p class="Pp">Record locks are not inherited by a child created via
    <b>fork</b>(2), but are preserved across an <b>execve</b>(2).</p>
<p class="Pp">Because of the buffering performed by the <b>stdio</b>(3) library,
    the use of record locking with routines in that package should be avoided;
    use <b>read</b>(2) and <b>write</b>(2) instead.</p>
<p class="Pp">The record locks described above are associated with the process
    (unlike the open file description locks described below). This has some
    unfortunate consequences:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If a process closes <i>any</i> file descriptor referring to a file, then
      all of the process's locks on that file are released, regardless of the
      file descriptor(s) on which the locks were obtained. This is bad: it means
      that a process can lose its locks on a file such as <i>/etc/passwd</i> or
      <i>/etc/mtab</i> when for some reason a library function decides to open,
      read, and close the same file.</dd>
  <dt>•</dt>
  <dd>The threads in a process share locks. In other words, a multithreaded
      program can't use record locking to ensure that threads don't
      simultaneously access the same region of a file.</dd>
</dl>
<p class="Pp">Open file description locks solve both of these problems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Open_file_description_locks_(non-POSIX)"><a class="permalink" href="#Open_file_description_locks_(non-POSIX)">Open
  file description locks (non-POSIX)</a></h2>
<p class="Pp">Open file description locks are advisory byte-range locks whose
    operation is in most respects identical to the traditional record locks
    described above. This lock type is Linux-specific, and available since Linux
    3.15. (There is a proposal with the Austin Group to include this lock type
    in the next revision of POSIX.1.) For an explanation of open file
    descriptions, see <b>open</b>(2).</p>
<p class="Pp">The principal difference between the two lock types is that
    whereas traditional record locks are associated with a process, open file
    description locks are associated with the open file description on which
    they are acquired, much like locks acquired with <b>flock</b>(2).
    Consequently (and unlike traditional advisory record locks), open file
    description locks are inherited across <b>fork</b>(2) (and <b>clone</b>(2)
    with <b>CLONE_FILES</b>), and are only automatically released on the last
    close of the open file description, instead of being released on any close
    of the file.</p>
<p class="Pp">Conflicting lock combinations (i.e., a read lock and a write lock
    or two write locks) where one lock is an open file description lock and the
    other is a traditional record lock conflict even when they are acquired by
    the same process on the same file descriptor.</p>
<p class="Pp">Open file description locks placed via the same open file
    description (i.e., via the same file descriptor, or via a duplicate of the
    file descriptor created by <b>fork</b>(2), <b>dup</b>(2), <b>fcntl</b>()
    <b>F_DUPFD</b>, and so on) are always compatible: if a new lock is placed on
    an already locked region, then the existing lock is converted to the new
    lock type. (Such conversions may result in splitting, shrinking, or
    coalescing with an existing lock as discussed above.)</p>
<p class="Pp">On the other hand, open file description locks may conflict with
    each other when they are acquired via different open file descriptions.
    Thus, the threads in a multithreaded program can use open file description
    locks to synchronize access to a file region by having each thread perform
    its own <b>open</b>(2) on the file and applying locks via the resulting file
    descriptor.</p>
<p class="Pp">As with traditional advisory locks, the third argument to
    <b>fcntl</b>(), <i>lock</i>, is a pointer to an <i>flock</i> structure. By
    contrast with traditional record locks, the <i>l_pid</i> field of that
    structure must be set to zero when using the commands described below.</p>
<p class="Pp">The commands for working with open file description locks are
    analogous to those used with traditional locks:</p>
<dl class="Bl-tag">
  <dt id="F_OFD_SETLK"><a class="permalink" href="#F_OFD_SETLK"><b>F_OFD_SETLK</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>Acquire an open file description lock (when <i>l_type</i> is
      <b>F_RDLCK</b> or <b>F_WRLCK</b>) or release an open file description lock
      (when <i>l_type</i> is <b>F_UNLCK</b>) on the bytes specified by the
      <i>l_whence</i>, <i>l_start</i>, and <i>l_len</i> fields of <i>lock</i>.
      If a conflicting lock is held by another process, this call returns -1 and
      sets <i>errno</i> to <b>EAGAIN</b>.</dd>
  <dt id="F_OFD_SETLKW"><a class="permalink" href="#F_OFD_SETLKW"><b>F_OFD_SETLKW</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>As for <b>F_OFD_SETLK</b>, but if a conflicting lock is held on the file,
      then wait for that lock to be released. If a signal is caught while
      waiting, then the call is interrupted and (after the signal handler has
      returned) returns immediately (with return value -1 and <i>errno</i> set
      to <b>EINTR</b>; see <b>signal</b>(7)).</dd>
  <dt id="F_OFD_GETLK"><a class="permalink" href="#F_OFD_GETLK"><b>F_OFD_GETLK</b>
    (<i>struct flock *</i>)</a></dt>
  <dd>On input to this call, <i>lock</i> describes an open file description lock
      we would like to place on the file. If the lock could be placed,
      <b>fcntl</b>() does not actually place it, but returns <b>F_UNLCK</b> in
      the <i>l_type</i> field of <i>lock</i> and leaves the other fields of the
      structure unchanged. If one or more incompatible locks would prevent this
      lock being placed, then details about one of these locks are returned via
      <i>lock</i>, as described above for <b>F_GETLK</b>.</dd>
</dl>
<p class="Pp">In the current implementation, no deadlock detection is performed
    for open file description locks. (This contrasts with process-associated
    record locks, for which the kernel does perform deadlock detection.)</p>
</section>
<section class="Ss">
<h2 class="Ss">Mandatory locking</h2>
<p class="Pp"><i>Warning</i>: the Linux implementation of mandatory locking is
    unreliable. See BUGS below. Because of these bugs, and the fact that the
    feature is believed to be little used, since Linux 4.5, mandatory locking
    has been made an optional feature, governed by a configuration option
    (<b>CONFIG_MANDATORY_FILE_LOCKING</b>). This feature is no longer supported
    at all in Linux 5.15 and above.</p>
<p class="Pp">By default, both traditional (process-associated) and open file
    description record locks are advisory. Advisory locks are not enforced and
    are useful only between cooperating processes.</p>
<p class="Pp">Both lock types can also be mandatory. Mandatory locks are
    enforced for all processes. If a process tries to perform an incompatible
    access (e.g., <b>read</b>(2) or <b>write</b>(2)) on a file region that has
    an incompatible mandatory lock, then the result depends upon whether the
    <b>O_NONBLOCK</b> flag is enabled for its open file description. If the
    <b>O_NONBLOCK</b> flag is not enabled, then the system call is blocked until
    the lock is removed or converted to a mode that is compatible with the
    access. If the <b>O_NONBLOCK</b> flag is enabled, then the system call fails
    with the error <b>EAGAIN</b>.</p>
<p class="Pp">To make use of mandatory locks, mandatory locking must be enabled
    both on the filesystem that contains the file to be locked, and on the file
    itself. Mandatory locking is enabled on a filesystem using the "-o
    mand" option to <b>mount</b>(8), or the <b>MS_MANDLOCK</b> flag for
    <b>mount</b>(2). Mandatory locking is enabled on a file by disabling group
    execute permission on the file and enabling the set-group-ID permission bit
    (see <b>chmod</b>(1) and <b>chmod</b>(2)).</p>
<p class="Pp">Mandatory locking is not specified by POSIX. Some other systems
    also support mandatory locking, although the details of how to enable it
    vary across systems.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Lost_locks"><a class="permalink" href="#Lost_locks">Lost
  locks</a></h2>
<p class="Pp">When an advisory lock is obtained on a networked filesystem such
    as NFS it is possible that the lock might get lost. This may happen due to
    administrative action on the server, or due to a network partition (i.e.,
    loss of network connectivity with the server) which lasts long enough for
    the server to assume that the client is no longer functioning.</p>
<p class="Pp">When the filesystem determines that a lock has been lost, future
    <b>read</b>(2) or <b>write</b>(2) requests may fail with the error
    <b>EIO</b>. This error will persist until the lock is removed or the file
    descriptor is closed. Since Linux 3.12, this happens at least for NFSv4
    (including all minor versions).</p>
<p class="Pp">Some versions of UNIX send a signal (<b>SIGLOST</b>) in this
    circumstance. Linux does not define this signal, and does not provide any
    asynchronous notification of lost locks.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Managing_signals"><a class="permalink" href="#Managing_signals">Managing
  signals</a></h2>
<p class="Pp"><b>F_GETOWN</b>, <b>F_SETOWN</b>, <b>F_GETOWN_EX</b>,
    <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and <b>F_SETSIG</b> are used to manage
    I/O availability signals:</p>
<dl class="Bl-tag">
  <dt id="F_GETOWN"><a class="permalink" href="#F_GETOWN"><b>F_GETOWN</b>
    (<i>void</i>)</a></dt>
  <dd>Return (as the function result) the process ID or process group ID
      currently receiving <b>SIGIO</b> and <b>SIGURG</b> signals for events on
      file descriptor <i>fd</i>. Process IDs are returned as positive values;
      process group IDs are returned as negative values (but see BUGS below).
      <i>arg</i> is ignored.</dd>
  <dt id="F_SETOWN"><a class="permalink" href="#F_SETOWN"><b>F_SETOWN</b>
    (<i>int</i>)</a></dt>
  <dd>Set the process ID or process group ID that will receive <b>SIGIO</b> and
      <b>SIGURG</b> signals for events on the file descriptor <i>fd</i>. The
      target process or process group ID is specified in <i>arg</i>. A process
      ID is specified as a positive value; a process group ID is specified as a
      negative value. Most commonly, the calling process specifies itself as the
      owner (that is, <i>arg</i> is specified as <b>getpid</b>(2)).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>As well as setting the file descriptor owner, one must also enable
      generation of signals on the file descriptor. This is done by using the
      <b>fcntl</b>() <b>F_SETFL</b> command to set the <b>O_ASYNC</b> file
      status flag on the file descriptor. Subsequently, a <b>SIGIO</b> signal is
      sent whenever input or output becomes possible on the file descriptor. The
      <b>fcntl</b>() <b>F_SETSIG</b> command can be used to obtain delivery of a
      signal other than <b>SIGIO</b>.</dd>
  <dt></dt>
  <dd>Sending a signal to the owner process (group) specified by <b>F_SETOWN</b>
      is subject to the same permissions checks as are described for
      <b>kill</b>(2), where the sending process is the one that employs
      <b>F_SETOWN</b> (but see BUGS below). If this permission check fails, then
      the signal is silently discarded. <i>Note</i>: The <b>F_SETOWN</b>
      operation records the caller's credentials at the time of the
      <b>fcntl</b>() call, and it is these saved credentials that are used for
      the permission checks.</dd>
  <dt></dt>
  <dd>If the file descriptor <i>fd</i> refers to a socket, <b>F_SETOWN</b> also
      selects the recipient of <b>SIGURG</b> signals that are delivered when
      out-of-band data arrives on that socket. (<b>SIGURG</b> is sent in any
      situation where <b>select</b>(2) would report the socket as having an
      "exceptional condition".)</dd>
  <dt></dt>
  <dd>The following was true in Linux 2.6.x up to and including Linux
    2.6.11:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt></dt>
  <dd>If a nonzero value is given to <b>F_SETSIG</b> in a multithreaded process
      running with a threading library that supports thread groups (e.g., NPTL),
      then a positive value given to <b>F_SETOWN</b> has a different meaning:
      instead of being a process ID identifying a whole process, it is a thread
      ID identifying a specific thread within a process. Consequently, it may be
      necessary to pass <b>F_SETOWN</b> the result of <b>gettid</b>(2) instead
      of <b>getpid</b>(2) to get sensible results when <b>F_SETSIG</b> is used.
      (In current Linux threading implementations, a main thread's thread ID is
      the same as its process ID. This means that a single-threaded program can
      equally use <b>gettid</b>(2) or <b>getpid</b>(2) in this scenario.) Note,
      however, that the statements in this paragraph do not apply to the
      <b>SIGURG</b> signal generated for out-of-band data on a socket: this
      signal is always sent to either a process or a process group, depending on
      the value given to <b>F_SETOWN</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The above behavior was accidentally dropped in Linux 2.6.12, and won't be
      restored. From Linux 2.6.32 onward, use <b>F_SETOWN_EX</b> to target
      <b>SIGIO</b> and <b>SIGURG</b> signals at a particular thread.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F_GETOWN_EX"><a class="permalink" href="#F_GETOWN_EX"><b>F_GETOWN_EX</b>
    (<i>struct f_owner_ex *</i>) (since Linux 2.6.32)</a></dt>
  <dd>Return the current file descriptor owner settings as defined by a previous
      <b>F_SETOWN_EX</b> operation. The information is returned in the structure
      pointed to by <i>arg</i>, which has the following form:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct f_owner_ex {
<br>
    int   type;
<br>
    pid_t pid;
};
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The <i>type</i> field will have one of the values <b>F_OWNER_TID</b>,
      <b>F_OWNER_PID</b>, or <b>F_OWNER_PGRP</b>. The <i>pid</i> field is a
      positive integer representing a thread ID, process ID, or process group
      ID. See <b>F_SETOWN_EX</b> for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F_SETOWN_EX"><a class="permalink" href="#F_SETOWN_EX"><b>F_SETOWN_EX</b>
    (<i>struct f_owner_ex *</i>) (since Linux 2.6.32)</a></dt>
  <dd>This operation performs a similar task to <b>F_SETOWN</b>. It allows the
      caller to direct I/O availability signals to a specific thread, process,
      or process group. The caller specifies the target of signals via
      <i>arg</i>, which is a pointer to a <i>f_owner_ex</i> structure. The
      <i>type</i> field has one of the following values, which define how
      <i>pid</i> is interpreted:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="F_OWNER_TID"><a class="permalink" href="#F_OWNER_TID"><b>F_OWNER_TID</b></a></dt>
  <dd>Send the signal to the thread whose thread ID (the value returned by a
      call to <b>clone</b>(2) or <b>gettid</b>(2)) is specified in
    <i>pid</i>.</dd>
  <dt id="F_OWNER_PID"><a class="permalink" href="#F_OWNER_PID"><b>F_OWNER_PID</b></a></dt>
  <dd>Send the signal to the process whose ID is specified in <i>pid</i>.</dd>
  <dt id="F_OWNER_PGRP"><a class="permalink" href="#F_OWNER_PGRP"><b>F_OWNER_PGRP</b></a></dt>
  <dd>Send the signal to the process group whose ID is specified in <i>pid</i>.
      (Note that, unlike with <b>F_SETOWN</b>, a process group ID is specified
      as a positive value here.)</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="F_GETSIG"><a class="permalink" href="#F_GETSIG"><b>F_GETSIG</b>
    (<i>void</i>)</a></dt>
  <dd>Return (as the function result) the signal sent when input or output
      becomes possible. A value of zero means <b>SIGIO</b> is sent. Any other
      value (including <b>SIGIO</b>) is the signal sent instead, and in this
      case additional info is available to the signal handler if installed with
      <b>SA_SIGINFO</b>. <i>arg</i> is ignored.</dd>
  <dt id="F_SETSIG"><a class="permalink" href="#F_SETSIG"><b>F_SETSIG</b>
    (<i>int</i>)</a></dt>
  <dd>Set the signal sent when input or output becomes possible to the value
      given in <i>arg</i>. A value of zero means to send the default
      <b>SIGIO</b> signal. Any other value (including <b>SIGIO</b>) is the
      signal to send instead, and in this case additional info is available to
      the signal handler if installed with <b>SA_SIGINFO</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>By using <b>F_SETSIG</b> with a nonzero value, and setting
      <b>SA_SIGINFO</b> for the signal handler (see <b>sigaction</b>(2)), extra
      information about I/O events is passed to the handler in a
      <i>siginfo_t</i> structure. If the <i>si_code</i> field indicates the
      source is <b>SI_SIGIO</b>, the <i>si_fd</i> field gives the file
      descriptor associated with the event. Otherwise, there is no indication
      which file descriptors are pending, and you should use the usual
      mechanisms (<b>select</b>(2), <b>poll</b>(2), <b>read</b>(2) with
      <b>O_NONBLOCK</b> set etc.) to determine which file descriptors are
      available for I/O.</dd>
  <dt></dt>
  <dd>Note that the file descriptor provided in <i>si_fd</i> is the one that was
      specified during the <b>F_SETSIG</b> operation. This can lead to an
      unusual corner case. If the file descriptor is duplicated (<b>dup</b>(2)
      or similar), and the original file descriptor is closed, then I/O events
      will continue to be generated, but the <i>si_fd</i> field will contain the
      number of the now closed file descriptor.</dd>
  <dt></dt>
  <dd>By selecting a real time signal (value &gt;= <b>SIGRTMIN</b>), multiple
      I/O events may be queued using the same signal numbers. (Queuing is
      dependent on available memory.) Extra information is available if
      <b>SA_SIGINFO</b> is set for the signal handler, as above.</dd>
  <dt></dt>
  <dd>Note that Linux imposes a limit on the number of real-time signals that
      may be queued to a process (see <b>getrlimit</b>(2) and <b>signal</b>(7))
      and if this limit is reached, then the kernel reverts to delivering
      <b>SIGIO</b>, and this signal is delivered to the entire process rather
      than to a specific thread.</dd>
</dl>
<p class="Pp">Using these mechanisms, a program can implement fully asynchronous
    I/O without using <b>select</b>(2) or <b>poll</b>(2) most of the time.</p>
<p class="Pp">The use of <b>O_ASYNC</b> is specific to BSD and Linux. The only
    use of <b>F_GETOWN</b> and <b>F_SETOWN</b> specified in POSIX.1 is in
    conjunction with the use of the <b>SIGURG</b> signal on sockets. (POSIX does
    not specify the <b>SIGIO</b> signal.) <b>F_GETOWN_EX</b>,
    <b>F_SETOWN_EX</b>, <b>F_GETSIG</b>, and <b>F_SETSIG</b> are Linux-specific.
    POSIX has asynchronous I/O and the <i>aio_sigevent</i> structure to achieve
    similar things; these are also available in Linux as part of the GNU C
    Library (glibc).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Leases"><a class="permalink" href="#Leases">Leases</a></h2>
<p class="Pp"><b>F_SETLEASE</b> and <b>F_GETLEASE</b> (Linux 2.4 onward) are
    used to establish a new lease, and retrieve the current lease, on the open
    file description referred to by the file descriptor <i>fd</i>. A file lease
    provides a mechanism whereby the process holding the lease (the "lease
    holder") is notified (via delivery of a signal) when a process (the
    "lease breaker") tries to <b>open</b>(2) or <b>truncate</b>(2) the
    file referred to by that file descriptor.</p>
<dl class="Bl-tag">
  <dt id="F_SETLEASE"><a class="permalink" href="#F_SETLEASE"><b>F_SETLEASE</b>
    (<i>int</i>)</a></dt>
  <dd>Set or remove a file lease according to which of the following values is
      specified in the integer <i>arg</i>:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="F_RDLCK"><a class="permalink" href="#F_RDLCK"><b>F_RDLCK</b></a></dt>
  <dd>Take out a read lease. This will cause the calling process to be notified
      when the file is opened for writing or is truncated. A read lease can be
      placed only on a file descriptor that is opened read-only.</dd>
  <dt id="F_WRLCK"><a class="permalink" href="#F_WRLCK"><b>F_WRLCK</b></a></dt>
  <dd>Take out a write lease. This will cause the caller to be notified when the
      file is opened for reading or writing or is truncated. A write lease may
      be placed on a file only if there are no other open file descriptors for
      the file.</dd>
  <dt id="F_UNLCK"><a class="permalink" href="#F_UNLCK"><b>F_UNLCK</b></a></dt>
  <dd>Remove our lease from the file.</dd>
</dl>
</div>
<p class="Pp">Leases are associated with an open file description (see
    <b>open</b>(2)). This means that duplicate file descriptors (created by, for
    example, <b>fork</b>(2) or <b>dup</b>(2)) refer to the same lease, and this
    lease may be modified or released using any of these descriptors.
    Furthermore, the lease is released by either an explicit <b>F_UNLCK</b>
    operation on any of these duplicate file descriptors, or when all such file
    descriptors have been closed.</p>
<p class="Pp">Leases may be taken out only on regular files. An unprivileged
    process may take out a lease only on a file whose UID (owner) matches the
    filesystem UID of the process. A process with the <b>CAP_LEASE</b>
    capability may take out leases on arbitrary files.</p>
<dl class="Bl-tag">
  <dt id="F_GETLEASE"><a class="permalink" href="#F_GETLEASE"><b>F_GETLEASE</b>
    (<i>void</i>)</a></dt>
  <dd>Indicates what type of lease is associated with the file descriptor
      <i>fd</i> by returning either <b>F_RDLCK</b>, <b>F_WRLCK</b>, or
      <b>F_UNLCK</b>, indicating, respectively, a read lease , a write lease, or
      no lease. <i>arg</i> is ignored.</dd>
</dl>
<p class="Pp">When a process (the "lease breaker") performs an
    <b>open</b>(2) or <b>truncate</b>(2) that conflicts with a lease established
    via <b>F_SETLEASE</b>, the system call is blocked by the kernel and the
    kernel notifies the lease holder by sending it a signal (<b>SIGIO</b> by
    default). The lease holder should respond to receipt of this signal by doing
    whatever cleanup is required in preparation for the file to be accessed by
    another process (e.g., flushing cached buffers) and then either remove or
    downgrade its lease. A lease is removed by performing an <b>F_SETLEASE</b>
    command specifying <i>arg</i> as <b>F_UNLCK</b>. If the lease holder
    currently holds a write lease on the file, and the lease breaker is opening
    the file for reading, then it is sufficient for the lease holder to
    downgrade the lease to a read lease. This is done by performing an
    <b>F_SETLEASE</b> command specifying <i>arg</i> as <b>F_RDLCK</b>.</p>
<p class="Pp">If the lease holder fails to downgrade or remove the lease within
    the number of seconds specified in <i>/proc/sys/fs/lease-break-time</i>,
    then the kernel forcibly removes or downgrades the lease holder's lease.</p>
<p class="Pp">Once a lease break has been initiated, <b>F_GETLEASE</b> returns
    the target lease type (either <b>F_RDLCK</b> or <b>F_UNLCK</b>, depending on
    what would be compatible with the lease breaker) until the lease holder
    voluntarily downgrades or removes the lease or the kernel forcibly does so
    after the lease break timer expires.</p>
<p class="Pp">Once the lease has been voluntarily or forcibly removed or
    downgraded, and assuming the lease breaker has not unblocked its system
    call, the kernel permits the lease breaker's system call to proceed.</p>
<p class="Pp">If the lease breaker's blocked <b>open</b>(2) or
    <b>truncate</b>(2) is interrupted by a signal handler, then the system call
    fails with the error <b>EINTR</b>, but the other steps still occur as
    described above. If the lease breaker is killed by a signal while blocked in
    <b>open</b>(2) or <b>truncate</b>(2), then the other steps still occur as
    described above. If the lease breaker specifies the <b>O_NONBLOCK</b> flag
    when calling <b>open</b>(2), then the call immediately fails with the error
    <b>EWOULDBLOCK</b>, but the other steps still occur as described above.</p>
<p class="Pp">The default signal used to notify the lease holder is
    <b>SIGIO</b>, but this can be changed using the <b>F_SETSIG</b> command to
    <b>fcntl</b>(). If a <b>F_SETSIG</b> command is performed (even one
    specifying <b>SIGIO</b>), and the signal handler is established using
    <b>SA_SIGINFO</b>, then the handler will receive a <i>siginfo_t</i>
    structure as its second argument, and the <i>si_fd</i> field of this
    argument will hold the file descriptor of the leased file that has been
    accessed by another process. (This is useful if the caller holds leases
    against multiple files.)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="File_and_directory_change_notification_(dnotify)"><a class="permalink" href="#File_and_directory_change_notification_(dnotify)">File
  and directory change notification (dnotify)</a></h2>
<dl class="Bl-tag">
  <dt id="F_NOTIFY"><a class="permalink" href="#F_NOTIFY"><b>F_NOTIFY</b>
    (<i>int</i>)</a></dt>
  <dd>(Linux 2.4 onward) Provide notification when the directory referred to by
      <i>fd</i> or any of the files that it contains is changed. The events to
      be notified are specified in <i>arg</i>, which is a bit mask specified by
      ORing together zero or more of the following bits:</dd>
</dl>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="DN_ACCESS"><a class="permalink" href="#DN_ACCESS"><b>DN_ACCESS</b></a></dt>
  <dd>A file was accessed (<b>read</b>(2), <b>pread</b>(2), <b>readv</b>(2), and
      similar)</dd>
  <dt id="DN_MODIFY"><a class="permalink" href="#DN_MODIFY"><b>DN_MODIFY</b></a></dt>
  <dd>A file was modified (<b>write</b>(2), <b>pwrite</b>(2), <b>writev</b>(2),
      <b>truncate</b>(2), <b>ftruncate</b>(2), and similar).</dd>
  <dt id="DN_CREATE"><a class="permalink" href="#DN_CREATE"><b>DN_CREATE</b></a></dt>
  <dd>A file was created (<b>open</b>(2), <b>creat</b>(2), <b>mknod</b>(2),
      <b>mkdir</b>(2), <b>link</b>(2), <b>symlink</b>(2), <b>rename</b>(2) into
      this directory).</dd>
  <dt id="DN_DELETE"><a class="permalink" href="#DN_DELETE"><b>DN_DELETE</b></a></dt>
  <dd>A file was unlinked (<b>unlink</b>(2), <b>rename</b>(2) to another
      directory, <b>rmdir</b>(2)).</dd>
  <dt id="DN_RENAME"><a class="permalink" href="#DN_RENAME"><b>DN_RENAME</b></a></dt>
  <dd>A file was renamed within this directory (<b>rename</b>(2)).</dd>
  <dt id="DN_ATTRIB"><a class="permalink" href="#DN_ATTRIB"><b>DN_ATTRIB</b></a></dt>
  <dd>The attributes of a file were changed (<b>chown</b>(2), <b>chmod</b>(2),
      <b>utime</b>(2), <b>utimensat</b>(2), and similar).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>(In order to obtain these definitions, the <b>_GNU_SOURCE</b> feature test
      macro must be defined before including <i>any</i> header files.)</dd>
  <dt></dt>
  <dd>Directory notifications are normally "one-shot", and the
      application must reregister to receive further notifications.
      Alternatively, if <b>DN_MULTISHOT</b> is included in <i>arg</i>, then
      notification will remain in effect until explicitly removed.</dd>
  <dt></dt>
  <dd>A series of <b>F_NOTIFY</b> requests is cumulative, with the events in
      <i>arg</i> being added to the set already monitored. To disable
      notification of all events, make an <b>F_NOTIFY</b> call specifying
      <i>arg</i> as 0.</dd>
  <dt></dt>
  <dd>Notification occurs via delivery of a signal. The default signal is
      <b>SIGIO</b>, but this can be changed using the <b>F_SETSIG</b> command to
      <b>fcntl</b>(). (Note that <b>SIGIO</b> is one of the nonqueuing standard
      signals; switching to the use of a real-time signal means that multiple
      notifications can be queued to the process.) In the latter case, the
      signal handler receives a <i>siginfo_t</i> structure as its second
      argument (if the handler was established using <b>SA_SIGINFO</b>) and the
      <i>si_fd</i> field of this structure contains the file descriptor which
      generated the notification (useful when establishing notification on
      multiple directories).</dd>
  <dt></dt>
  <dd>Especially when using <b>DN_MULTISHOT</b>, a real time signal should be
      used for notification, so that multiple notifications can be queued.</dd>
  <dt></dt>
  <dd><b>NOTE:</b> New applications should use the <i>inotify</i> interface
      (available since Linux 2.6.13), which provides a much superior interface
      for obtaining notifications of filesystem events. See
    <b>inotify</b>(7).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Changing_the_capacity_of_a_pipe"><a class="permalink" href="#Changing_the_capacity_of_a_pipe">Changing
  the capacity of a pipe</a></h2>
<dl class="Bl-tag">
  <dt id="F_SETPIPE_SZ"><a class="permalink" href="#F_SETPIPE_SZ"><b>F_SETPIPE_SZ</b>
    (<i>int</i>; since Linux 2.6.35)</a></dt>
  <dd>Change the capacity of the pipe referred to by <i>fd</i> to be at least
      <i>arg</i> bytes. An unprivileged process can adjust the pipe capacity to
      any value between the system page size and the limit defined in
      <i>/proc/sys/fs/pipe-max-size</i> (see <b>proc</b>(5)). Attempts to set
      the pipe capacity below the page size are silently rounded up to the page
      size. Attempts by an unprivileged process to set the pipe capacity above
      the limit in <i>/proc/sys/fs/pipe-max-size</i> yield the error
      <b>EPERM</b>; a privileged process (<b>CAP_SYS_RESOURCE</b>) can override
      the limit.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When allocating the buffer for the pipe, the kernel may use a capacity
      larger than <i>arg</i>, if that is convenient for the implementation. (In
      the current implementation, the allocation is the next higher power-of-two
      page-size multiple of the requested size.) The actual capacity (in bytes)
      that is set is returned as the function result.</dd>
  <dt></dt>
  <dd>Attempting to set the pipe capacity smaller than the amount of buffer
      space currently used to store data produces the error <b>EBUSY</b>.</dd>
  <dt></dt>
  <dd>Note that because of the way the pages of the pipe buffer are employed
      when data is written to the pipe, the number of bytes that can be written
      may be less than the nominal size, depending on the size of the
    writes.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F_GETPIPE_SZ"><a class="permalink" href="#F_GETPIPE_SZ"><b>F_GETPIPE_SZ</b>
    (<i>void</i>; since Linux 2.6.35)</a></dt>
  <dd>Return (as the function result) the capacity of the pipe referred to by
      <i>fd</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="File_Sealing"><a class="permalink" href="#File_Sealing">File
  Sealing</a></h2>
<p class="Pp">File seals limit the set of allowed operations on a given file.
    For each seal that is set on a file, a specific set of operations will fail
    with <b>EPERM</b> on this file from now on. The file is said to be sealed.
    The default set of seals depends on the type of the underlying file and
    filesystem. For an overview of file sealing, a discussion of its purpose,
    and some code examples, see <b>memfd_create</b>(2).</p>
<p class="Pp">Currently, file seals can be applied only to a file descriptor
    returned by <b>memfd_create</b>(2) (if the <b>MFD_ALLOW_SEALING</b> was
    employed). On other filesystems, all <b>fcntl</b>() operations that operate
    on seals will return <b>EINVAL</b>.</p>
<p class="Pp">Seals are a property of an inode. Thus, all open file descriptors
    referring to the same inode share the same set of seals. Furthermore, seals
    can never be removed, only added.</p>
<dl class="Bl-tag">
  <dt id="F_ADD_SEALS"><a class="permalink" href="#F_ADD_SEALS"><b>F_ADD_SEALS</b>
    (<i>int</i>; since Linux 3.17)</a></dt>
  <dd>Add the seals given in the bit-mask argument <i>arg</i> to the set of
      seals of the inode referred to by the file descriptor <i>fd</i>. Seals
      cannot be removed again. Once this call succeeds, the seals are enforced
      by the kernel immediately. If the current set of seals includes
      <b>F_SEAL_SEAL</b> (see below), then this call will be rejected with
      <b>EPERM</b>. Adding a seal that is already set is a no-op, in case
      <b>F_SEAL_SEAL</b> is not set already. In order to place a seal, the file
      descriptor <i>fd</i> must be writable.</dd>
  <dt id="F_GET_SEALS"><a class="permalink" href="#F_GET_SEALS"><b>F_GET_SEALS</b>
    (<i>void</i>; since Linux 3.17)</a></dt>
  <dd>Return (as the function result) the current set of seals of the inode
      referred to by <i>fd</i>. If no seals are set, 0 is returned. If the file
      does not support sealing, -1 is returned and <i>errno</i> is set to
      <b>EINVAL</b>.</dd>
</dl>
<p class="Pp">The following seals are available:</p>
<dl class="Bl-tag">
  <dt id="F_SEAL_SEAL"><a class="permalink" href="#F_SEAL_SEAL"><b>F_SEAL_SEAL</b></a></dt>
  <dd>If this seal is set, any further call to <b>fcntl</b>() with
      <b>F_ADD_SEALS</b> fails with the error <b>EPERM</b>. Therefore, this seal
      prevents any modifications to the set of seals itself. If the initial set
      of seals of a file includes <b>F_SEAL_SEAL</b>, then this effectively
      causes the set of seals to be constant and locked.</dd>
  <dt id="F_SEAL_SHRINK"><a class="permalink" href="#F_SEAL_SHRINK"><b>F_SEAL_SHRINK</b></a></dt>
  <dd>If this seal is set, the file in question cannot be reduced in size. This
      affects <b>open</b>(2) with the <b>O_TRUNC</b> flag as well as
      <b>truncate</b>(2) and <b>ftruncate</b>(2). Those calls fail with
      <b>EPERM</b> if you try to shrink the file in question. Increasing the
      file size is still possible.</dd>
  <dt id="F_SEAL_GROW"><a class="permalink" href="#F_SEAL_GROW"><b>F_SEAL_GROW</b></a></dt>
  <dd>If this seal is set, the size of the file in question cannot be increased.
      This affects <b>write</b>(2) beyond the end of the file,
      <b>truncate</b>(2), <b>ftruncate</b>(2), and <b>fallocate</b>(2). These
      calls fail with <b>EPERM</b> if you use them to increase the file size. If
      you keep the size or shrink it, those calls still work as expected.</dd>
  <dt id="F_SEAL_WRITE"><a class="permalink" href="#F_SEAL_WRITE"><b>F_SEAL_WRITE</b></a></dt>
  <dd>If this seal is set, you cannot modify the contents of the file. Note that
      shrinking or growing the size of the file is still possible and allowed.
      Thus, this seal is normally used in combination with one of the other
      seals. This seal affects <b>write</b>(2) and <b>fallocate</b>(2) (only in
      combination with the <b>FALLOC_FL_PUNCH_HOLE</b> flag). Those calls fail
      with <b>EPERM</b> if this seal is set. Furthermore, trying to create new
      shared, writable memory-mappings via <b>mmap</b>(2) will also fail with
      <b>EPERM</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Using the <b>F_ADD_SEALS</b> operation to set the <b>F_SEAL_WRITE</b> seal
      fails with <b>EBUSY</b> if any writable, shared mapping exists. Such
      mappings must be unmapped before you can add this seal. Furthermore, if
      there are any asynchronous I/O operations (<b>io_submit</b>(2)) pending on
      the file, all outstanding writes will be discarded.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="F_SEAL_FUTURE_WRITE"><a class="permalink" href="#F_SEAL_FUTURE_WRITE"><b>F_SEAL_FUTURE_WRITE</b>
    (since Linux 5.1)</a></dt>
  <dd>The effect of this seal is similar to <b>F_SEAL_WRITE</b>, but the
      contents of the file can still be modified via shared writable mappings
      that were created prior to the seal being set. Any attempt to create a new
      writable mapping on the file via <b>mmap</b>(2) will fail with
      <b>EPERM</b>. Likewise, an attempt to write to the file via
      <b>write</b>(2) will fail with <b>EPERM</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Using this seal, one process can create a memory buffer that it can
      continue to modify while sharing that buffer on a "read-only"
      basis with other processes.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="File_read/write_hints"><a class="permalink" href="#File_read/write_hints">File
  read/write hints</a></h2>
<p class="Pp">Write lifetime hints can be used to inform the kernel about the
    relative expected lifetime of writes on a given inode or via a particular
    open file description. (See <b>open</b>(2) for an explanation of open file
    descriptions.) In this context, the term "write lifetime" means
    the expected time the data will live on media, before being overwritten or
    erased.</p>
<p class="Pp">An application may use the different hint values specified below
    to separate writes into different write classes, so that multiple users or
    applications running on a single storage back-end can aggregate their I/O
    patterns in a consistent manner. However, there are no functional semantics
    implied by these flags, and different I/O classes can use the write lifetime
    hints in arbitrary ways, so long as the hints are used consistently.</p>
<p class="Pp">The following operations can be applied to the file descriptor,
    <i>fd</i>:</p>
<dl class="Bl-tag">
  <dt id="F_GET_RW_HINT"><a class="permalink" href="#F_GET_RW_HINT"><b>F_GET_RW_HINT</b>
    (<i>uint64_t *</i>; since Linux 4.13)</a></dt>
  <dd>Returns the value of the read/write hint associated with the underlying
      inode referred to by <i>fd</i>.</dd>
  <dt id="F_SET_RW_HINT"><a class="permalink" href="#F_SET_RW_HINT"><b>F_SET_RW_HINT</b>
    (<i>uint64_t *</i>; since Linux 4.13)</a></dt>
  <dd>Sets the read/write hint value associated with the underlying inode
      referred to by <i>fd</i>. This hint persists until either it is explicitly
      modified or the underlying filesystem is unmounted.</dd>
  <dt id="F_GET_FILE_RW_HINT"><a class="permalink" href="#F_GET_FILE_RW_HINT"><b>F_GET_FILE_RW_HINT</b>
    (<i>uint64_t *</i>; since Linux 4.13)</a></dt>
  <dd>Returns the value of the read/write hint associated with the open file
      description referred to by <i>fd</i>.</dd>
  <dt id="F_SET_FILE_RW_HINT"><a class="permalink" href="#F_SET_FILE_RW_HINT"><b>F_SET_FILE_RW_HINT</b>
    (<i>uint64_t *</i>; since Linux 4.13)</a></dt>
  <dd>Sets the read/write hint value associated with the open file description
      referred to by <i>fd</i>.</dd>
</dl>
<p class="Pp">If an open file description has not been assigned a read/write
    hint, then it shall use the value assigned to the inode, if any.</p>
<p class="Pp">The following read/write hints are valid since Linux 4.13:</p>
<dl class="Bl-tag">
  <dt id="RWH_WRITE_LIFE_NOT_SET"><a class="permalink" href="#RWH_WRITE_LIFE_NOT_SET"><b>RWH_WRITE_LIFE_NOT_SET</b></a></dt>
  <dd>No specific hint has been set. This is the default value.</dd>
  <dt id="RWH_WRITE_LIFE_NONE"><a class="permalink" href="#RWH_WRITE_LIFE_NONE"><b>RWH_WRITE_LIFE_NONE</b></a></dt>
  <dd>No specific write lifetime is associated with this file or inode.</dd>
  <dt id="RWH_WRITE_LIFE_SHORT"><a class="permalink" href="#RWH_WRITE_LIFE_SHORT"><b>RWH_WRITE_LIFE_SHORT</b></a></dt>
  <dd>Data written to this inode or via this open file description is expected
      to have a short lifetime.</dd>
  <dt id="RWH_WRITE_LIFE_MEDIUM"><a class="permalink" href="#RWH_WRITE_LIFE_MEDIUM"><b>RWH_WRITE_LIFE_MEDIUM</b></a></dt>
  <dd>Data written to this inode or via this open file description is expected
      to have a lifetime longer than data written with
      <b>RWH_WRITE_LIFE_SHORT</b>.</dd>
  <dt id="RWH_WRITE_LIFE_LONG"><a class="permalink" href="#RWH_WRITE_LIFE_LONG"><b>RWH_WRITE_LIFE_LONG</b></a></dt>
  <dd>Data written to this inode or via this open file description is expected
      to have a lifetime longer than data written with
      <b>RWH_WRITE_LIFE_MEDIUM</b>.</dd>
  <dt id="RWH_WRITE_LIFE_EXTREME"><a class="permalink" href="#RWH_WRITE_LIFE_EXTREME"><b>RWH_WRITE_LIFE_EXTREME</b></a></dt>
  <dd>Data written to this inode or via this open file description is expected
      to have a lifetime longer than data written with
      <b>RWH_WRITE_LIFE_LONG</b>.</dd>
</dl>
<p class="Pp">All the write-specific hints are relative to each other, and no
    individual absolute meaning should be attributed to them.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">For a successful call, the return value depends on the
  operation:</p>
<dl class="Bl-tag">
  <dt id="F_DUPFD~2"><a class="permalink" href="#F_DUPFD~2"><b>F_DUPFD</b></a></dt>
  <dd>The new file descriptor.</dd>
  <dt id="F_GETFD~2"><a class="permalink" href="#F_GETFD~2"><b>F_GETFD</b></a></dt>
  <dd>Value of file descriptor flags.</dd>
  <dt id="F_GETFL~2"><a class="permalink" href="#F_GETFL~2"><b>F_GETFL</b></a></dt>
  <dd>Value of file status flags.</dd>
  <dt id="F_GETLEASE~2"><a class="permalink" href="#F_GETLEASE~2"><b>F_GETLEASE</b></a></dt>
  <dd>Type of lease held on file descriptor.</dd>
  <dt id="F_GETOWN~2"><a class="permalink" href="#F_GETOWN~2"><b>F_GETOWN</b></a></dt>
  <dd>Value of file descriptor owner.</dd>
  <dt id="F_GETSIG~2"><a class="permalink" href="#F_GETSIG~2"><b>F_GETSIG</b></a></dt>
  <dd>Value of signal sent when read or write becomes possible, or zero for
      traditional <b>SIGIO</b> behavior.</dd>
  <dt id="F_GETPIPE_SZ~2"><a class="permalink" href="#F_GETPIPE_SZ~2"><b>F_GETPIPE_SZ</b>,
    <b>F_SETPIPE_SZ</b></a></dt>
  <dd>The pipe capacity.</dd>
  <dt id="F_GET_SEALS~2"><a class="permalink" href="#F_GET_SEALS~2"><b>F_GET_SEALS</b></a></dt>
  <dd>A bit mask identifying the seals that have been set for the inode referred
      to by <i>fd</i>.</dd>
  <dt id="All"><a class="permalink" href="#All">All other commands</a></dt>
  <dd>Zero.</dd>
</dl>
<p class="Pp">On error, -1 is returned, and <i>errno</i> is set to indicate the
    error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<dl class="Bl-tag">
  <dt id="EACCES"><a class="permalink" href="#EACCES"><b>EACCES</b> or
    <b>EAGAIN</b></a></dt>
  <dd>Operation is prohibited by locks held by other processes.</dd>
  <dt id="EAGAIN"><a class="permalink" href="#EAGAIN"><b>EAGAIN</b></a></dt>
  <dd>The operation is prohibited because the file has been memory-mapped by
      another process.</dd>
  <dt id="EBADF"><a class="permalink" href="#EBADF"><b>EBADF</b></a></dt>
  <dd><i>fd</i> is not an open file descriptor</dd>
  <dt id="EBADF~2"><a class="permalink" href="#EBADF~2"><b>EBADF</b></a></dt>
  <dd><i>cmd</i> is <b>F_SETLK</b> or <b>F_SETLKW</b> and the file descriptor
      open mode doesn't match with the type of lock requested.</dd>
  <dt id="EBUSY"><a class="permalink" href="#EBUSY"><b>EBUSY</b></a></dt>
  <dd><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the new pipe capacity specified in
      <i>arg</i> is smaller than the amount of buffer space currently used to
      store data in the pipe.</dd>
  <dt id="EBUSY~2"><a class="permalink" href="#EBUSY~2"><b>EBUSY</b></a></dt>
  <dd><i>cmd</i> is <b>F_ADD_SEALS</b>, <i>arg</i> includes <b>F_SEAL_WRITE</b>,
      and there exists a writable, shared mapping on the file referred to by
      <i>fd</i>.</dd>
  <dt id="EDEADLK"><a class="permalink" href="#EDEADLK"><b>EDEADLK</b></a></dt>
  <dd>It was detected that the specified <b>F_SETLKW</b> command would cause a
      deadlock.</dd>
  <dt id="EFAULT"><a class="permalink" href="#EFAULT"><b>EFAULT</b></a></dt>
  <dd><i>lock</i> is outside your accessible address space.</dd>
  <dt id="EINTR"><a class="permalink" href="#EINTR"><b>EINTR</b></a></dt>
  <dd><i>cmd</i> is <b>F_SETLKW</b> or <b>F_OFD_SETLKW</b> and the operation was
      interrupted by a signal; see <b>signal</b>(7).</dd>
  <dt id="EINTR~2"><a class="permalink" href="#EINTR~2"><b>EINTR</b></a></dt>
  <dd><i>cmd</i> is <b>F_GETLK</b>, <b>F_SETLK</b>, <b>F_OFD_GETLK</b>, or
      <b>F_OFD_SETLK</b>, and the operation was interrupted by a signal before
      the lock was checked or acquired. Most likely when locking a remote file
      (e.g., locking over NFS), but can sometimes happen locally.</dd>
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>The value specified in <i>cmd</i> is not recognized by this kernel.</dd>
  <dt id="EINVAL~2"><a class="permalink" href="#EINVAL~2"><b>EINVAL</b></a></dt>
  <dd><i>cmd</i> is <b>F_ADD_SEALS</b> and <i>arg</i> includes an unrecognized
      sealing bit.</dd>
  <dt id="EINVAL~3"><a class="permalink" href="#EINVAL~3"><b>EINVAL</b></a></dt>
  <dd><i>cmd</i> is <b>F_ADD_SEALS</b> or <b>F_GET_SEALS</b> and the filesystem
      containing the inode referred to by <i>fd</i> does not support
    sealing.</dd>
  <dt id="EINVAL~4"><a class="permalink" href="#EINVAL~4"><b>EINVAL</b></a></dt>
  <dd><i>cmd</i> is <b>F_DUPFD</b> and <i>arg</i> is negative or is greater than
      the maximum allowable value (see the discussion of <b>RLIMIT_NOFILE</b> in
      <b>getrlimit</b>(2)).</dd>
  <dt id="EINVAL~5"><a class="permalink" href="#EINVAL~5"><b>EINVAL</b></a></dt>
  <dd><i>cmd</i> is <b>F_SETSIG</b> and <i>arg</i> is not an allowable signal
      number.</dd>
  <dt id="EINVAL~6"><a class="permalink" href="#EINVAL~6"><b>EINVAL</b></a></dt>
  <dd><i>cmd</i> is <b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, or
      <b>F_OFD_GETLK</b>, and <i>l_pid</i> was not specified as zero.</dd>
  <dt id="EMFILE"><a class="permalink" href="#EMFILE"><b>EMFILE</b></a></dt>
  <dd><i>cmd</i> is <b>F_DUPFD</b> and the per-process limit on the number of
      open file descriptors has been reached.</dd>
  <dt id="ENOLCK"><a class="permalink" href="#ENOLCK"><b>ENOLCK</b></a></dt>
  <dd>Too many segment locks open, lock table is full, or a remote locking
      protocol failed (e.g., locking over NFS).</dd>
  <dt id="ENOTDIR"><a class="permalink" href="#ENOTDIR"><b>ENOTDIR</b></a></dt>
  <dd><b>F_NOTIFY</b> was specified in <i>cmd</i>, but <i>fd</i> does not refer
      to a directory.</dd>
  <dt id="EPERM"><a class="permalink" href="#EPERM"><b>EPERM</b></a></dt>
  <dd><i>cmd</i> is <b>F_SETPIPE_SZ</b> and the soft or hard user pipe limit has
      been reached; see <b>pipe</b>(7).</dd>
  <dt id="EPERM~2"><a class="permalink" href="#EPERM~2"><b>EPERM</b></a></dt>
  <dd>Attempted to clear the <b>O_APPEND</b> flag on a file that has the
      append-only attribute set.</dd>
  <dt id="EPERM~3"><a class="permalink" href="#EPERM~3"><b>EPERM</b></a></dt>
  <dd><i>cmd</i> was <b>F_ADD_SEALS</b>, but <i>fd</i> was not open for writing
      or the current set of seals on the file already includes
      <b>F_SEAL_SEAL</b>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">SVr4, 4.3BSD, POSIX.1-2001. Only the operations <b>F_DUPFD</b>,
    <b>F_GETFD</b>, <b>F_SETFD</b>, <b>F_GETFL</b>, <b>F_SETFL</b>,
    <b>F_GETLK</b>, <b>F_SETLK</b>, and <b>F_SETLKW</b> are specified in
    POSIX.1-2001.</p>
<p class="Pp"><b>F_GETOWN</b> and <b>F_SETOWN</b> are specified in POSIX.1-2001.
    (To get their definitions, define either <b>_XOPEN_SOURCE</b> with the value
    500 or greater, or <b>_POSIX_C_SOURCE</b> with the value 200809L or
    greater.)</p>
<p class="Pp"><b>F_DUPFD_CLOEXEC</b> is specified in POSIX.1-2008. (To get this
    definition, define <b>_POSIX_C_SOURCE</b> with the value 200809L or greater,
    or <b>_XOPEN_SOURCE</b> with the value 700 or greater.)</p>
<p class="Pp"><b>F_GETOWN_EX</b>, <b>F_SETOWN_EX</b>, <b>F_SETPIPE_SZ</b>,
    <b>F_GETPIPE_SZ</b>, <b>F_GETSIG</b>, <b>F_SETSIG</b>, <b>F_NOTIFY</b>,
    <b>F_GETLEASE</b>, and <b>F_SETLEASE</b> are Linux-specific. (Define the
    <b>_GNU_SOURCE</b> macro to obtain these definitions.)</p>
<p class="Pp"><b>F_OFD_SETLK</b>, <b>F_OFD_SETLKW</b>, and <b>F_OFD_GETLK</b>
    are Linux-specific (and one must define <b>_GNU_SOURCE</b> to obtain their
    definitions), but work is being done to have them included in the next
    version of POSIX.1.</p>
<p class="Pp"><b>F_ADD_SEALS</b> and <b>F_GET_SEALS</b> are Linux-specific.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The errors returned by <b>dup2</b>(2) are different from those
    returned by <b>F_DUPFD</b>.</p>
<section class="Ss">
<h2 class="Ss" id="File_locking"><a class="permalink" href="#File_locking">File
  locking</a></h2>
<p class="Pp">The original Linux <b>fcntl</b>() system call was not designed to
    handle large file offsets (in the <i>flock</i> structure). Consequently, an
    <b>fcntl64</b>() system call was added in Linux 2.4. The newer system call
    employs a different structure for file locking, <i>flock64</i>, and
    corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and
    <b>F_SETLKW64</b>. However, these details can be ignored by applications
    using glibc, whose <b>fcntl</b>() wrapper function transparently employs the
    more recent system call where it is available.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Record_locks"><a class="permalink" href="#Record_locks">Record
  locks</a></h2>
<p class="Pp">Since Linux 2.0, there is no interaction between the types of lock
    placed by <b>flock</b>(2) and <b>fcntl</b>().</p>
<p class="Pp">Several systems have more fields in <i>struct flock</i> such as,
    for example, <i>l_sysid</i> (to identify the machine where the lock is
    held). Clearly, <i>l_pid</i> alone is not going to be very useful if the
    process holding the lock may live on a different machine; on Linux, while
    present on some architectures (such as MIPS32), this field is not used.</p>
<p class="Pp">The original Linux <b>fcntl</b>() system call was not designed to
    handle large file offsets (in the <i>flock</i> structure). Consequently, an
    <b>fcntl64</b>() system call was added in Linux 2.4. The newer system call
    employs a different structure for file locking, <i>flock64</i>, and
    corresponding commands, <b>F_GETLK64</b>, <b>F_SETLK64</b>, and
    <b>F_SETLKW64</b>. However, these details can be ignored by applications
    using glibc, whose <b>fcntl</b>() wrapper function transparently employs the
    more recent system call where it is available.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Record_locking_and_NFS"><a class="permalink" href="#Record_locking_and_NFS">Record
  locking and NFS</a></h2>
<p class="Pp">Before Linux 3.12, if an NFSv4 client loses contact with the
    server for a period of time (defined as more than 90 seconds with no
    communication), it might lose and regain a lock without ever being aware of
    the fact. (The period of time after which contact is assumed lost is known
    as the NFSv4 leasetime. On a Linux NFS server, this can be determined by
    looking at <i>/proc/fs/nfsd/nfsv4leasetime</i>, which expresses the period
    in seconds. The default value for this file is 90.) This scenario
    potentially risks data corruption, since another process might acquire a
    lock in the intervening period and perform file I/O.</p>
<p class="Pp">Since Linux 3.12, if an NFSv4 client loses contact with the
    server, any I/O to the file by a process which "thinks" it holds a
    lock will fail until that process closes and reopens the file. A kernel
    parameter, <i>nfs.recover_lost_locks</i>, can be set to 1 to obtain the
    pre-3.12 behavior, whereby the client will attempt to recover lost locks
    when contact is reestablished with the server. Because of the attendant risk
    of data corruption, this parameter defaults to 0 (disabled).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<section class="Ss">
<h2 class="Ss" id="F_SETFL~2"><a class="permalink" href="#F_SETFL~2">F_SETFL</a></h2>
<p class="Pp">It is not possible to use <b>F_SETFL</b> to change the state of
    the <b>O_DSYNC</b> and <b>O_SYNC</b> flags. Attempts to change the state of
    these flags are silently ignored.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="F_GETOWN~3"><a class="permalink" href="#F_GETOWN~3">F_GETOWN</a></h2>
<p class="Pp">A limitation of the Linux system call conventions on some
    architectures (notably i386) means that if a (negative) process group ID to
    be returned by <b>F_GETOWN</b> falls in the range -1 to -4095, then the
    return value is wrongly interpreted by glibc as an error in the system call;
    that is, the return value of <b>fcntl</b>() will be -1, and <i>errno</i>
    will contain the (positive) process group ID. The Linux-specific
    <b>F_GETOWN_EX</b> operation avoids this problem. Since glibc 2.11, glibc
    makes the kernel <b>F_GETOWN</b> problem invisible by implementing
    <b>F_GETOWN</b> using <b>F_GETOWN_EX</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="F_SETOWN~2"><a class="permalink" href="#F_SETOWN~2">F_SETOWN</a></h2>
<p class="Pp">In Linux 2.4 and earlier, there is bug that can occur when an
    unprivileged process uses <b>F_SETOWN</b> to specify the owner of a socket
    file descriptor as a process (group) other than the caller. In this case,
    <b>fcntl</b>() can return -1 with <i>errno</i> set to <b>EPERM</b>, even
    when the owner process (group) is one that the caller has permission to send
    signals to. Despite this error return, the file descriptor owner is set, and
    signals will be sent to the owner.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Deadlock_detection"><a class="permalink" href="#Deadlock_detection">Deadlock
  detection</a></h2>
<p class="Pp">The deadlock-detection algorithm employed by the kernel when
    dealing with <b>F_SETLKW</b> requests can yield both false negatives
    (failures to detect deadlocks, leaving a set of deadlocked processes blocked
    indefinitely) and false positives (<b>EDEADLK</b> errors when there is no
    deadlock). For example, the kernel limits the lock depth of its dependency
    search to 10 steps, meaning that circular deadlock chains that exceed that
    size will not be detected. In addition, the kernel may falsely indicate a
    deadlock when two or more processes created using the <b>clone</b>(2)
    <b>CLONE_FILES</b> flag place locks that appear (to the kernel) to
  conflict.</p>
</section>
<section class="Ss">
<h2 class="Ss">Mandatory locking</h2>
<p class="Pp">The Linux implementation of mandatory locking is subject to race
    conditions which render it unreliable: a <b>write</b>(2) call that overlaps
    with a lock may modify data after the mandatory lock is acquired; a
    <b>read</b>(2) call that overlaps with a lock may detect changes to data
    that were made only after a write lock was acquired. Similar races exist
    between mandatory locks and <b>mmap</b>(2). It is therefore inadvisable to
    rely on mandatory locking.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>dup2</b>(2), <b>flock</b>(2), <b>open</b>(2), <b>socket</b>(2),
    <b>lockf</b>(3), <b>capabilities</b>(7), <b>feature_test_macros</b>(7),
    <b>lslocks</b>(8)</p>
<p class="Pp"><i>locks.txt</i>, <i>mandatory-locking.txt</i>, and
    <i>dnotify.txt</i> in the Linux kernel source directory
    <i>Documentation/filesystems/</i> (on older kernels, these files are
    directly under the <i>Documentation/</i> directory, and
    <i>mandatory-locking.txt</i> is called <i>mandatory.txt</i>)</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>