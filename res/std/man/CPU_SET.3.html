<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (C) 2006 Michael Kerrisk
   and Copyright (C) 2008 Linux Foundation, written by Michael Kerrisk
       <mtk.manpages@gmail.com>
  
   SPDX-License-Identifier: Linux-man-pages-copyleft
   --><head>
<meta name="dc.identifier" content="res/4b3cc0c48486b090487c8463479e74b50ae4a9b2">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>CPU_SET(3)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">CPU_SET(3)</td>
    <td class="head-vol">Library Functions Manual</td>
    <td class="head-rtitle">CPU_SET(3)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">CPU_SET, CPU_CLR, CPU_ISSET, CPU_ZERO, CPU_COUNT, CPU_AND, CPU_OR,
    CPU_XOR, CPU_EQUAL, CPU_ALLOC, CPU_ALLOC_SIZE, CPU_FREE, CPU_SET_S,
    CPU_CLR_S, CPU_ISSET_S, CPU_ZERO_S, CPU_COUNT_S, CPU_AND_S, CPU_OR_S,
    CPU_XOR_S, CPU_EQUAL_S - macros for manipulating CPU sets</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Standard C library (<i>libc</i>, <i>-lc</i>)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#define _GNU_SOURCE</b>             /* See feature_test_macros(7) */
<b>#include &lt;sched.h&gt;</b></pre>
<pre><b>void CPU_ZERO(cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>void CPU_SET(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b>
<b>void CPU_CLR(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b>
<b>int  CPU_ISSET(int </b><i>cpu</i><b>, cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>int  CPU_COUNT(cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>void CPU_AND(cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b>
<b>void CPU_OR(cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b>
<b>void CPU_XOR(cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b></pre>
<pre><b>int  CPU_EQUAL(cpu_set_t *</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b></pre>
<pre><b>cpu_set_t *CPU_ALLOC(int </b><i>num_cpus</i><b>);</b>
<b>void CPU_FREE(cpu_set_t *</b><i>set</i><b>);</b>
<b>size_t CPU_ALLOC_SIZE(int </b><i>num_cpus</i><b>);</b></pre>
<pre><b>void CPU_ZERO_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>void CPU_SET_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b>
<b>void CPU_CLR_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b>
<b>int  CPU_ISSET_S(int </b><i>cpu</i><b>, size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>int  CPU_COUNT_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set</i><b>);</b></pre>
<pre><b>void CPU_AND_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b>
<b>void CPU_OR_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b>
<b>void CPU_XOR_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>destset</i><b>,</b>
<b>             cpu_set_t *</b><i>srcset1</i><b>, cpu_set_t *</b><i>srcset2</i><b>);</b></pre>
<pre><b>int  CPU_EQUAL_S(size_t </b><i>setsize</i><b>, cpu_set_t *</b><i>set1</i><b>, cpu_set_t *</b><i>set2</i><b>);</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <i>cpu_set_t</i> data structure represents a set of CPUs. CPU
    sets are used by <b>sched_setaffinity</b>(2) and similar interfaces.</p>
<p class="Pp">The <i>cpu_set_t</i> data type is implemented as a bit mask.
    However, the data structure should be treated as opaque: all manipulation of
    CPU sets should be done via the macros described in this page.</p>
<p class="Pp">The following macros are provided to operate on the CPU set
    <i>set</i>:</p>
<dl class="Bl-tag">
  <dt id="CPU_ZERO"><a class="permalink" href="#CPU_ZERO"><b>CPU_ZERO</b>()</a></dt>
  <dd>Clears <i>set</i>, so that it contains no CPUs.</dd>
  <dt id="CPU_SET"><a class="permalink" href="#CPU_SET"><b>CPU_SET</b>()</a></dt>
  <dd>Add CPU <i>cpu</i> to <i>set</i>.</dd>
  <dt id="CPU_CLR"><a class="permalink" href="#CPU_CLR"><b>CPU_CLR</b>()</a></dt>
  <dd>Remove CPU <i>cpu</i> from <i>set</i>.</dd>
  <dt id="CPU_ISSET"><a class="permalink" href="#CPU_ISSET"><b>CPU_ISSET</b>()</a></dt>
  <dd>Test to see if CPU <i>cpu</i> is a member of <i>set</i>.</dd>
  <dt id="CPU_COUNT"><a class="permalink" href="#CPU_COUNT"><b>CPU_COUNT</b>()</a></dt>
  <dd>Return the number of CPUs in <i>set</i>.</dd>
</dl>
<p class="Pp">Where a <i>cpu</i> argument is specified, it should not produce
    side effects, since the above macros may evaluate the argument more than
    once.</p>
<p class="Pp">The first CPU on the system corresponds to a <i>cpu</i> value of
    0, the next CPU corresponds to a <i>cpu</i> value of 1, and so on. No
    assumptions should be made about particular CPUs being available, or the set
    of CPUs being contiguous, since CPUs can be taken offline dynamically or be
    otherwise absent. The constant <b>CPU_SETSIZE</b> (currently 1024) specifies
    a value one greater than the maximum CPU number that can be stored in
    <i>cpu_set_t</i>.</p>
<p class="Pp">The following macros perform logical operations on CPU sets:</p>
<dl class="Bl-tag">
  <dt id="CPU_AND"><a class="permalink" href="#CPU_AND"><b>CPU_AND</b>()</a></dt>
  <dd>Store the intersection of the sets <i>srcset1</i> and <i>srcset2</i> in
      <i>destset</i> (which may be one of the source sets).</dd>
  <dt id="CPU_OR"><a class="permalink" href="#CPU_OR"><b>CPU_OR</b>()</a></dt>
  <dd>Store the union of the sets <i>srcset1</i> and <i>srcset2</i> in
      <i>destset</i> (which may be one of the source sets).</dd>
  <dt id="CPU_XOR"><a class="permalink" href="#CPU_XOR"><b>CPU_XOR</b>()</a></dt>
  <dd>Store the XOR of the sets <i>srcset1</i> and <i>srcset2</i> in
      <i>destset</i> (which may be one of the source sets). The XOR means the
      set of CPUs that are in either <i>srcset1</i> or <i>srcset2</i>, but not
      both.</dd>
  <dt id="CPU_EQUAL"><a class="permalink" href="#CPU_EQUAL"><b>CPU_EQUAL</b>()</a></dt>
  <dd>Test whether two CPU set contain exactly the same CPUs.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Dynamically_sized_CPU_sets"><a class="permalink" href="#Dynamically_sized_CPU_sets">Dynamically
  sized CPU sets</a></h2>
<p class="Pp">Because some applications may require the ability to dynamically
    size CPU sets (e.g., to allocate sets larger than that defined by the
    standard <i>cpu_set_t</i> data type), glibc nowadays provides a set of
    macros to support this.</p>
<p class="Pp">The following macros are used to allocate and deallocate CPU
  sets:</p>
<dl class="Bl-tag">
  <dt id="CPU_ALLOC"><a class="permalink" href="#CPU_ALLOC"><b>CPU_ALLOC</b>()</a></dt>
  <dd>Allocate a CPU set large enough to hold CPUs in the range 0 to
      <i>num_cpus-1</i>.</dd>
  <dt id="CPU_ALLOC_SIZE"><a class="permalink" href="#CPU_ALLOC_SIZE"><b>CPU_ALLOC_SIZE</b>()</a></dt>
  <dd>Return the size in bytes of the CPU set that would be needed to hold CPUs
      in the range 0 to <i>num_cpus-1</i>. This macro provides the value that
      can be used for the <i>setsize</i> argument in the <b>CPU_*_S</b>() macros
      described below.</dd>
  <dt id="CPU_FREE"><a class="permalink" href="#CPU_FREE"><b>CPU_FREE</b>()</a></dt>
  <dd>Free a CPU set previously allocated by <b>CPU_ALLOC</b>().</dd>
</dl>
<p class="Pp">The macros whose names end with "_S" are the analogs of
    the similarly named macros without the suffix. These macros perform the same
    tasks as their analogs, but operate on the dynamically allocated CPU set(s)
    whose size is <i>setsize</i> bytes.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp"><b>CPU_ISSET</b>() and <b>CPU_ISSET_S</b>() return nonzero if
    <i>cpu</i> is in <i>set</i>; otherwise, it returns 0.</p>
<p class="Pp"><b>CPU_COUNT</b>() and <b>CPU_COUNT_S</b>() return the number of
    CPUs in <i>set</i>.</p>
<p class="Pp"><b>CPU_EQUAL</b>() and <b>CPU_EQUAL_S</b>() return nonzero if the
    two CPU sets are equal; otherwise they return 0.</p>
<p class="Pp"><b>CPU_ALLOC</b>() returns a pointer on success, or NULL on
    failure. (Errors are as for <b>malloc</b>(3).)</p>
<p class="Pp"><b>CPU_ALLOC_SIZE</b>() returns the number of bytes required to
    store a CPU set of the specified cardinality.</p>
<p class="Pp">The other functions do not return a value.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSIONS"><a class="permalink" href="#VERSIONS">VERSIONS</a></h1>
<p class="Pp">The <b>CPU_ZERO</b>(), <b>CPU_SET</b>(), <b>CPU_CLR</b>(), and
    <b>CPU_ISSET</b>() macros were added in glibc 2.3.3.</p>
<p class="Pp"><b>CPU_COUNT</b>() first appeared in glibc 2.6.</p>
<p class="Pp"><b>CPU_AND</b>(), <b>CPU_OR</b>(), <b>CPU_XOR</b>(),
    <b>CPU_EQUAL</b>(), <b>CPU_ALLOC</b>(), <b>CPU_ALLOC_SIZE</b>(),
    <b>CPU_FREE</b>(), <b>CPU_ZERO_S</b>(), <b>CPU_SET_S</b>(),
    <b>CPU_CLR_S</b>(), <b>CPU_ISSET_S</b>(), <b>CPU_AND_S</b>(),
    <b>CPU_OR_S</b>(), <b>CPU_XOR_S</b>(), and <b>CPU_EQUAL_S</b>() first
    appeared in glibc 2.7.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">These interfaces are Linux-specific.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">To duplicate a CPU set, use <b>memcpy</b>(3).</p>
<p class="Pp">Since CPU sets are bit masks allocated in units of long words, the
    actual number of CPUs in a dynamically allocated CPU set will be rounded up
    to the next multiple of <i>sizeof(unsigned long)</i>. An application should
    consider the contents of these extra bits to be undefined.</p>
<p class="Pp">Notwithstanding the similarity in the names, note that the
    constant <b>CPU_SETSIZE</b> indicates the number of CPUs in the
    <i>cpu_set_t</i> data type (thus, it is effectively a count of the bits in
    the bit mask), while the <i>setsize</i> argument of the <b>CPU_*_S</b>()
    macros is a size in bytes.</p>
<p class="Pp">The data types for arguments and return values shown in the
    SYNOPSIS are hints what about is expected in each case. However, since these
    interfaces are implemented as macros, the compiler won't necessarily catch
    all type errors if you violate the suggestions.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">On 32-bit platforms with glibc 2.8 and earlier, <b>CPU_ALLOC</b>()
    allocates twice as much space as is required, and <b>CPU_ALLOC_SIZE</b>()
    returns a value twice as large as it should. This bug should not affect the
    semantics of a program, but does result in wasted memory and less efficient
    operation of the macros that operate on dynamically allocated CPU sets.
    These bugs are fixed in glibc 2.9.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following program demonstrates the use of some of the macros
    used for dynamically allocated CPU sets.</p>
<p class="Pp"></p>
<pre>#define _GNU_SOURCE
#include &lt;sched.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;assert.h&gt;
int
main(int argc, char *argv[])
{
<br>
    cpu_set_t *cpusetp;
<br>
    size_t size, num_cpus;
<br>
    if (argc &lt; 2) {
<br>
        fprintf(stderr, "Usage: %s &lt;num-cpus&gt;\n", argv[0]);
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    num_cpus = atoi(argv[1]);
<br>
    cpusetp = CPU_ALLOC(num_cpus);
<br>
    if (cpusetp == NULL) {
<br>
        perror("CPU_ALLOC");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    size = CPU_ALLOC_SIZE(num_cpus);
<br>
    CPU_ZERO_S(size, cpusetp);
<br>
    for (size_t cpu = 0; cpu &lt; num_cpus; cpu += 2)
<br>
        CPU_SET_S(cpu, size, cpusetp);
<br>
    printf("CPU_COUNT() of set:    %d\n", CPU_COUNT_S(size, cpusetp));
<br>
    CPU_FREE(cpusetp);
<br>
    exit(EXIT_SUCCESS);
}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>sched_setaffinity</b>(2),
    <b>pthread_attr_setaffinity_np</b>(3), <b>pthread_setaffinity_np</b>(3),
    <b>cpuset</b>(7)</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>