<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2013, 2014 by Michael Kerrisk <mtk.manpages@gmail.com>
   and Copyright (c) 2012, 2014 by Eric W. Biederman <ebiederm@xmission.com>
  
   SPDX-License-Identifier: Linux-man-pages-copyleft
   --><head>
<meta name="dc.identifier" content="res/c0f79a84701c8f027363f840c7c644ccf3463b9d">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>user_namespaces(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">user_namespaces(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">user_namespaces(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">user_namespaces - overview of Linux user namespaces</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">For an overview of namespaces, see <b>namespaces</b>(7).</p>
<p class="Pp">User namespaces isolate security-related identifiers and
    attributes, in particular, user IDs and group IDs (see
    <b>credentials</b>(7)), the root directory, keys (see <b>keyrings</b>(7)),
    and capabilities (see <b>capabilities</b>(7)). A process's user and group
    IDs can be different inside and outside a user namespace. In particular, a
    process can have a normal unprivileged user ID outside a user namespace
    while at the same time having a user ID of 0 inside the namespace; in other
    words, the process has full privileges for operations inside the user
    namespace, but is unprivileged for operations outside the namespace.</p>
<section class="Ss">
<h2 class="Ss" id="Nested_namespaces,_namespace_membership"><a class="permalink" href="#Nested_namespaces,_namespace_membership">Nested
  namespaces, namespace membership</a></h2>
<p class="Pp">User namespaces can be nested; that is, each user
    namespace—except the initial ("root") namespace—has
    a parent user namespace, and can have zero or more child user namespaces.
    The parent user namespace is the user namespace of the process that creates
    the user namespace via a call to <b>unshare</b>(2) or <b>clone</b>(2) with
    the <b>CLONE_NEWUSER</b> flag.</p>
<p class="Pp">The kernel imposes (since Linux 3.11) a limit of 32 nested levels
    of user namespaces. Calls to <b>unshare</b>(2) or <b>clone</b>(2) that would
    cause this limit to be exceeded fail with the error <b>EUSERS</b>.</p>
<p class="Pp">Each process is a member of exactly one user namespace. A process
    created via <b>fork</b>(2) or <b>clone</b>(2) without the
    <b>CLONE_NEWUSER</b> flag is a member of the same user namespace as its
    parent. A single-threaded process can join another user namespace with
    <b>setns</b>(2) if it has the <b>CAP_SYS_ADMIN</b> in that namespace; upon
    doing so, it gains a full set of capabilities in that namespace.</p>
<p class="Pp">A call to <b>clone</b>(2) or <b>unshare</b>(2) with the
    <b>CLONE_NEWUSER</b> flag makes the new child process (for <b>clone</b>(2))
    or the caller (for <b>unshare</b>(2)) a member of the new user namespace
    created by the call.</p>
<p class="Pp">The <b>NS_GET_PARENT</b> <b>ioctl</b>(2) operation can be used to
    discover the parental relationship between user namespaces; see
    <b>ioctl_ns</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Capabilities"><a class="permalink" href="#Capabilities">Capabilities</a></h2>
<p class="Pp">The child process created by <b>clone</b>(2) with the
    <b>CLONE_NEWUSER</b> flag starts out with a complete set of capabilities in
    the new user namespace. Likewise, a process that creates a new user
    namespace using <b>unshare</b>(2) or joins an existing user namespace using
    <b>setns</b>(2) gains a full set of capabilities in that namespace. On the
    other hand, that process has no capabilities in the parent (in the case of
    <b>clone</b>(2)) or previous (in the case of <b>unshare</b>(2) and
    <b>setns</b>(2)) user namespace, even if the new namespace is created or
    joined by the root user (i.e., a process with user ID 0 in the root
    namespace).</p>
<p class="Pp">Note that a call to <b>execve</b>(2) will cause a process's
    capabilities to be recalculated in the usual way (see
    <b>capabilities</b>(7)). Consequently, unless the process has a user ID of 0
    within the namespace, or the executable file has a nonempty inheritable
    capabilities mask, the process will lose all capabilities. See the
    discussion of user and group ID mappings, below.</p>
<p class="Pp">A call to <b>clone</b>(2) or <b>unshare</b>(2) using the
    <b>CLONE_NEWUSER</b> flag or a call to <b>setns</b>(2) that moves the caller
    into another user namespace sets the "securebits" flags (see
    <b>capabilities</b>(7)) to their default values (all flags disabled) in the
    child (for <b>clone</b>(2)) or caller (for <b>unshare</b>(2) or
    <b>setns</b>(2)). Note that because the caller no longer has capabilities in
    its original user namespace after a call to <b>setns</b>(2), it is not
    possible for a process to reset its "securebits" flags while
    retaining its user namespace membership by using a pair of <b>setns</b>(2)
    calls to move to another user namespace and then return to its original user
    namespace.</p>
<p class="Pp">The rules for determining whether or not a process has a
    capability in a particular user namespace are as follows:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>A process has a capability inside a user namespace if it is a member of
      that namespace and it has the capability in its effective capability set.
      A process can gain capabilities in its effective capability set in various
      ways. For example, it may execute a set-user-ID program or an executable
      with associated file capabilities. In addition, a process may gain
      capabilities via the effect of <b>clone</b>(2), <b>unshare</b>(2), or
      <b>setns</b>(2), as already described.</dd>
  <dt>•</dt>
  <dd>If a process has a capability in a user namespace, then it has that
      capability in all child (and further removed descendant) namespaces as
      well.</dd>
  <dt>•</dt>
  <dd>When a user namespace is created, the kernel records the effective user ID
      of the creating process as being the "owner" of the namespace. A
      process that resides in the parent of the user namespace and whose
      effective user ID matches the owner of the namespace has all capabilities
      in the namespace. By virtue of the previous rule, this means that the
      process has all capabilities in all further removed descendant user
      namespaces as well. The <b>NS_GET_OWNER_UID</b> <b>ioctl</b>(2) operation
      can be used to discover the user ID of the owner of the namespace; see
      <b>ioctl_ns</b>(2).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Effect_of_capabilities_within_a_user_namespace"><a class="permalink" href="#Effect_of_capabilities_within_a_user_namespace">Effect
  of capabilities within a user namespace</a></h2>
<p class="Pp">Having a capability inside a user namespace permits a process to
    perform operations (that require privilege) only on resources governed by
    that namespace. In other words, having a capability in a user namespace
    permits a process to perform privileged operations on resources that are
    governed by (nonuser) namespaces owned by (associated with) the user
    namespace (see the next subsection).</p>
<p class="Pp">On the other hand, there are many privileged operations that
    affect resources that are not associated with any namespace type, for
    example, changing the system (i.e., calendar) time (governed by
    <b>CAP_SYS_TIME</b>), loading a kernel module (governed by
    <b>CAP_SYS_MODULE</b>), and creating a device (governed by
    <b>CAP_MKNOD</b>). Only a process with privileges in the <i>initial</i> user
    namespace can perform such operations.</p>
<p class="Pp">Holding <b>CAP_SYS_ADMIN</b> within the user namespace that owns a
    process's mount namespace allows that process to create bind mounts and
    mount the following types of filesystems:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>/proc</i> (since Linux 3.8)</dd>
  <dt>•</dt>
  <dd><i>/sys</i> (since Linux 3.8)</dd>
  <dt>•</dt>
  <dd><i>devpts</i> (since Linux 3.9)</dd>
  <dt>•</dt>
  <dd><b>tmpfs</b>(5) (since Linux 3.9)</dd>
  <dt>•</dt>
  <dd><i>ramfs</i> (since Linux 3.9)</dd>
  <dt>•</dt>
  <dd><i>mqueue</i> (since Linux 3.9)</dd>
  <dt>•</dt>
  <dd><i>bpf</i> (since Linux 4.4)</dd>
  <dt>•</dt>
  <dd><i>overlayfs</i> (since Linux 5.11)</dd>
</dl>
</div>
<p class="Pp">Holding <b>CAP_SYS_ADMIN</b> within the user namespace that owns a
    process's cgroup namespace allows (since Linux 4.6) that process to the
    mount the cgroup version 2 filesystem and cgroup version 1 named hierarchies
    (i.e., cgroup filesystems mounted with the <i>"none,name="</i>
    option).</p>
<p class="Pp">Holding <b>CAP_SYS_ADMIN</b> within the user namespace that owns a
    process's PID namespace allows (since Linux 3.8) that process to mount
    <i>/proc</i> filesystems.</p>
<p class="Pp">Note, however, that mounting block-based filesystems can be done
    only by a process that holds <b>CAP_SYS_ADMIN</b> in the initial user
    namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interaction_of_user_namespaces_and_other_types_of_namespaces"><a class="permalink" href="#Interaction_of_user_namespaces_and_other_types_of_namespaces">Interaction
  of user namespaces and other types of namespaces</a></h2>
<p class="Pp">Starting in Linux 3.8, unprivileged processes can create user
    namespaces, and the other types of namespaces can be created with just the
    <b>CAP_SYS_ADMIN</b> capability in the caller's user namespace.</p>
<p class="Pp">When a nonuser namespace is created, it is owned by the user
    namespace in which the creating process was a member at the time of the
    creation of the namespace. Privileged operations on resources governed by
    the nonuser namespace require that the process has the necessary
    capabilities in the user namespace that owns the nonuser namespace.</p>
<p class="Pp">If <b>CLONE_NEWUSER</b> is specified along with other
    <b>CLONE_NEW*</b> flags in a single <b>clone</b>(2) or <b>unshare</b>(2)
    call, the user namespace is guaranteed to be created first, giving the child
    (<b>clone</b>(2)) or caller (<b>unshare</b>(2)) privileges over the
    remaining namespaces created by the call. Thus, it is possible for an
    unprivileged caller to specify this combination of flags.</p>
<p class="Pp">When a new namespace (other than a user namespace) is created via
    <b>clone</b>(2) or <b>unshare</b>(2), the kernel records the user namespace
    of the creating process as the owner of the new namespace. (This association
    can't be changed.) When a process in the new namespace subsequently performs
    privileged operations that operate on global resources isolated by the
    namespace, the permission checks are performed according to the process's
    capabilities in the user namespace that the kernel associated with the new
    namespace. For example, suppose that a process attempts to change the
    hostname (<b>sethostname</b>(2)), a resource governed by the UTS namespace.
    In this case, the kernel will determine which user namespace owns the
    process's UTS namespace, and check whether the process has the required
    capability (<b>CAP_SYS_ADMIN</b>) in that user namespace.</p>
<p class="Pp">The <b>NS_GET_USERNS</b> <b>ioctl</b>(2) operation can be used to
    discover the user namespace that owns a nonuser namespace; see
    <b>ioctl_ns</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="User_and_group_ID_mappings:_uid_map_and_gid_map"><a class="permalink" href="#User_and_group_ID_mappings:_uid_map_and_gid_map">User
  and group ID mappings: uid_map and gid_map</a></h2>
<p class="Pp">When a user namespace is created, it starts out without a mapping
    of user IDs (group IDs) to the parent user namespace. The
    <i>/proc/</i>pid<i>/uid_map</i> and <i>/proc/</i>pid<i>/gid_map</i> files
    (available since Linux 3.5) expose the mappings for user and group IDs
    inside the user namespace for the process <i>pid</i>. These files can be
    read to view the mappings in a user namespace and written to (once) to
    define the mappings.</p>
<p class="Pp">The description in the following paragraphs explains the details
    for <i>uid_map</i>; <i>gid_map</i> is exactly the same, but each instance of
    "user ID" is replaced by "group ID".</p>
<p class="Pp">The <i>uid_map</i> file exposes the mapping of user IDs from the
    user namespace of the process <i>pid</i> to the user namespace of the
    process that opened <i>uid_map</i> (but see a qualification to this point
    below). In other words, processes that are in different user namespaces will
    potentially see different values when reading from a particular
    <i>uid_map</i> file, depending on the user ID mappings for the user
    namespaces of the reading processes.</p>
<p class="Pp">Each line in the <i>uid_map</i> file specifies a 1-to-1 mapping of
    a range of contiguous user IDs between two user namespaces. (When a user
    namespace is first created, this file is empty.) The specification in each
    line takes the form of three numbers delimited by white space. The first two
    numbers specify the starting user ID in each of the two user namespaces. The
    third number specifies the length of the mapped range. In detail, the fields
    are interpreted as follows:</p>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>The start of the range of user IDs in the user namespace of the process
      <i>pid</i>.</dd>
  <dt>(2)</dt>
  <dd>The start of the range of user IDs to which the user IDs specified by
      field one map. How field two is interpreted depends on whether the process
      that opened <i>uid_map</i> and the process <i>pid</i> are in the same user
      namespace, as follows:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(a)</dt>
  <dd>If the two processes are in different user namespaces: field two is the
      start of a range of user IDs in the user namespace of the process that
      opened <i>uid_map</i>.</dd>
  <dt>(b)</dt>
  <dd>If the two processes are in the same user namespace: field two is the
      start of the range of user IDs in the parent user namespace of the process
      <i>pid</i>. This case enables the opener of <i>uid_map</i> (the common
      case here is opening <i>/proc/self/uid_map</i>) to see the mapping of user
      IDs into the user namespace of the process that created this user
      namespace.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(3)</dt>
  <dd>The length of the range of user IDs that is mapped between the two user
      namespaces.</dd>
</dl>
<p class="Pp">System calls that return user IDs (group IDs)—for example,
    <b>getuid</b>(2), <b>getgid</b>(2), and the credential fields in the
    structure returned by <b>stat</b>(2)—return the user ID (group ID)
    mapped into the caller's user namespace.</p>
<p class="Pp">When a process accesses a file, its user and group IDs are mapped
    into the initial user namespace for the purpose of permission checking and
    assigning IDs when creating a file. When a process retrieves file user and
    group IDs via <b>stat</b>(2), the IDs are mapped in the opposite direction,
    to produce values relative to the process user and group ID mappings.</p>
<p class="Pp">The initial user namespace has no parent namespace, but, for
    consistency, the kernel provides dummy user and group ID mapping files for
    this namespace. Looking at the <i>uid_map</i> file (<i>gid_map</i> is the
    same) from a shell in the initial namespace shows:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>cat /proc/$$/uid_map</b>
<br>
         0          0 4294967295
</pre>
<br>
<p class="Pp">This mapping tells us that the range starting at user ID 0 in this
    namespace maps to a range starting at 0 in the (nonexistent) parent
    namespace, and the length of the range is the largest 32-bit unsigned
    integer. This leaves 4294967295 (the 32-bit signed -1 value) unmapped. This
    is deliberate: <i>(uid_t)&nbsp;-1</i> is used in several interfaces (e.g.,
    <b>setreuid</b>(2)) as a way to specify "no user ID". Leaving
    <i>(uid_t)&nbsp;-1</i> unmapped and unusable guarantees that there will be
    no confusion when using these interfaces.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Defining_user_and_group_ID_mappings:_writing_to_uid_map_and_gid_map"><a class="permalink" href="#Defining_user_and_group_ID_mappings:_writing_to_uid_map_and_gid_map">Defining
  user and group ID mappings: writing to uid_map and gid_map</a></h2>
<p class="Pp">After the creation of a new user namespace, the <i>uid_map</i>
    file of <i>one</i> of the processes in the namespace may be written to
    <i>once</i> to define the mapping of user IDs in the new user namespace. An
    attempt to write more than once to a <i>uid_map</i> file in a user namespace
    fails with the error <b>EPERM</b>. Similar rules apply for <i>gid_map</i>
    files.</p>
<p class="Pp">The lines written to <i>uid_map</i> (<i>gid_map</i>) must conform
    to the following validity rules:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The three fields must be valid numbers, and the last field must be greater
      than 0.</dd>
  <dt>•</dt>
  <dd>Lines are terminated by newline characters.</dd>
  <dt>•</dt>
  <dd>There is a limit on the number of lines in the file. In Linux 4.14 and
      earlier, this limit was (arbitrarily) set at 5 lines. Since Linux 4.15,
      the limit is 340 lines. In addition, the number of bytes written to the
      file must be less than the system page size, and the write must be
      performed at the start of the file (i.e., <b>lseek</b>(2) and
      <b>pwrite</b>(2) can't be used to write to nonzero offsets in the
    file).</dd>
  <dt>•</dt>
  <dd>The range of user IDs (group IDs) specified in each line cannot overlap
      with the ranges in any other lines. In the initial implementation (Linux
      3.8), this requirement was satisfied by a simplistic implementation that
      imposed the further requirement that the values in both field 1 and field
      2 of successive lines must be in ascending numerical order, which
      prevented some otherwise valid maps from being created. Linux 3.9 and
      later fix this limitation, allowing any valid set of nonoverlapping
    maps.</dd>
  <dt>•</dt>
  <dd>At least one line must be written to the file.</dd>
</dl>
<p class="Pp">Writes that violate the above rules fail with the error
    <b>EINVAL</b>.</p>
<p class="Pp">In order for a process to write to the
    <i>/proc/</i>pid<i>/uid_map</i> (<i>/proc/</i>pid<i>/gid_map</i>) file, all
    of the following permission requirements must be met:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The writing process must have the <b>CAP_SETUID</b> (<b>CAP_SETGID</b>)
      capability in the user namespace of the process <i>pid</i>.</dd>
  <dt>•</dt>
  <dd>The writing process must either be in the user namespace of the process
      <i>pid</i> or be in the parent user namespace of the process
    <i>pid</i>.</dd>
  <dt>•</dt>
  <dd>The mapped user IDs (group IDs) must in turn have a mapping in the parent
      user namespace.</dd>
  <dt>•</dt>
  <dd>If updating <i>/proc/</i>pid<i>/uid_map</i> to create a mapping that maps
      UID 0 in the parent namespace, then one of the following must be
    true:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(a)</dt>
  <dd>if writing process is in the parent user namespace, then it must have the
      <b>CAP_SETFCAP</b> capability in that user namespace; or</dd>
  <dt>(b)</dt>
  <dd>if the writing process is in the child user namespace, then the process
      that created the user namespace must have had the <b>CAP_SETFCAP</b>
      capability when the namespace was created.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This rule has been in place since Linux 5.12. It eliminates an earlier
      security bug whereby a UID 0 process that lacks the <b>CAP_SETFCAP</b>
      capability, which is needed to create a binary with namespaced file
      capabilities (as described in <b>capabilities</b>(7)), could nevertheless
      create such a binary, by the following steps:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>Create a new user namespace with the identity mapping (i.e., UID 0 in the
      new user namespace maps to UID 0 in the parent namespace), so that UID 0
      in both namespaces is equivalent to the same root user ID.</dd>
  <dt>(2)</dt>
  <dd>Since the child process has the <b>CAP_SETFCAP</b> capability, it could
      create a binary with namespaced file capabilities that would then be
      effective in the parent user namespace (because the root user IDs are the
      same in the two namespaces).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>One of the following two cases applies:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(a)</dt>
  <dd><i>Either</i> the writing process has the <b>CAP_SETUID</b>
      (<b>CAP_SETGID</b>) capability in the <i>parent</i> user namespace.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>No further restrictions apply: the process can make mappings to arbitrary
      user IDs (group IDs) in the parent user namespace.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(b)</dt>
  <dd><i>Or</i> otherwise all of the following restrictions apply:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The data written to <i>uid_map</i> (<i>gid_map</i>) must consist of a
      single line that maps the writing process's effective user ID (group ID)
      in the parent user namespace to a user ID (group ID) in the user
      namespace.</dd>
  <dt>•</dt>
  <dd>The writing process must have the same effective user ID as the process
      that created the user namespace.</dd>
  <dt>•</dt>
  <dd>In the case of <i>gid_map</i>, use of the <b>setgroups</b>(2) system call
      must first be denied by writing "<i>deny</i>" to the
      <i>/proc/</i>pid<i>/setgroups</i> file (see below) before writing to
      <i>gid_map</i>.</dd>
</dl>
</div>
</div>
<p class="Pp">Writes that violate the above rules fail with the error
    <b>EPERM</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Project_ID_mappings:_projid_map"><a class="permalink" href="#Project_ID_mappings:_projid_map">Project
  ID mappings: projid_map</a></h2>
<p class="Pp">Similarly to user and group ID mappings, it is possible to create
    project ID mappings for a user namespace. (Project IDs are used for disk
    quotas; see <b>setquota</b>(8) and <b>quotactl</b>(2).)</p>
<p class="Pp">Project ID mappings are defined by writing to the
    <i>/proc/</i>pid<i>/projid_map</i> file (present since Linux 3.7).</p>
<p class="Pp">The validity rules for writing to the
    <i>/proc/</i>pid<i>/projid_map</i> file are as for writing to the
    <i>uid_map</i> file; violation of these rules causes <b>write</b>(2) to fail
    with the error <b>EINVAL</b>.</p>
<p class="Pp">The permission rules for writing to the
    <i>/proc/</i>pid<i>/projid_map</i> file are as follows:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The writing process must either be in the user namespace of the process
      <i>pid</i> or be in the parent user namespace of the process
    <i>pid</i>.</dd>
  <dt>•</dt>
  <dd>The mapped project IDs must in turn have a mapping in the parent user
      namespace.</dd>
</dl>
<p class="Pp">Violation of these rules causes <b>write</b>(2) to fail with the
    error <b>EPERM</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Interaction_with_system_calls_that_change_process_UIDs_or_GIDs"><a class="permalink" href="#Interaction_with_system_calls_that_change_process_UIDs_or_GIDs">Interaction
  with system calls that change process UIDs or GIDs</a></h2>
<p class="Pp">In a user namespace where the <i>uid_map</i> file has not been
    written, the system calls that change user IDs will fail. Similarly, if the
    <i>gid_map</i> file has not been written, the system calls that change group
    IDs will fail. After the <i>uid_map</i> and <i>gid_map</i> files have been
    written, only the mapped values may be used in system calls that change user
    and group IDs.</p>
<p class="Pp">For user IDs, the relevant system calls include <b>setuid</b>(2),
    <b>setfsuid</b>(2), <b>setreuid</b>(2), and <b>setresuid</b>(2). For group
    IDs, the relevant system calls include <b>setgid</b>(2), <b>setfsgid</b>(2),
    <b>setregid</b>(2), <b>setresgid</b>(2), and <b>setgroups</b>(2).</p>
<p class="Pp">Writing "<i>deny</i>" to the
    <i>/proc/</i>pid<i>/setgroups</i> file before writing to
    <i>/proc/</i>pid<i>/gid_map</i> will permanently disable <b>setgroups</b>(2)
    in a user namespace and allow writing to <i>/proc/</i>pid<i>/gid_map</i>
    without having the <b>CAP_SETGID</b> capability in the parent user
    namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_"><a class="permalink" href="#The_">The
  <i>/proc/</i>pid<i>/setgroups</i> file</a></h2>
<p class="Pp">The <i>/proc/</i>pid<i>/setgroups</i> file displays the string
    "<i>allow</i>" if processes in the user namespace that contains
    the process <i>pid</i> are permitted to employ the <b>setgroups</b>(2)
    system call; it displays "<i>deny</i>" if <b>setgroups</b>(2) is
    not permitted in that user namespace. Note that regardless of the value in
    the <i>/proc/</i>pid<i>/setgroups</i> file (and regardless of the process's
    capabilities), calls to <b>setgroups</b>(2) are also not permitted if
    <i>/proc/</i>pid<i>/gid_map</i> has not yet been set.</p>
<p class="Pp">A privileged process (one with the <b>CAP_SYS_ADMIN</b> capability
    in the namespace) may write either of the strings "<i>allow</i>"
    or "<i>deny</i>" to this file <i>before</i> writing a group ID
    mapping for this user namespace to the file <i>/proc/</i>pid<i>/gid_map</i>.
    Writing the string "<i>deny</i>" prevents any process in the user
    namespace from employing <b>setgroups</b>(2).</p>
<p class="Pp">The essence of the restrictions described in the preceding
    paragraph is that it is permitted to write to
    <i>/proc/</i>pid<i>/setgroups</i> only so long as calling
    <b>setgroups</b>(2) is disallowed because <i>/proc/</i>pid<i>/gid_map</i>
    has not been set. This ensures that a process cannot transition from a state
    where <b>setgroups</b>(2) is allowed to a state where <b>setgroups</b>(2) is
    denied; a process can transition only from <b>setgroups</b>(2) being
    disallowed to <b>setgroups</b>(2) being allowed.</p>
<p class="Pp">The default value of this file in the initial user namespace is
    "<i>allow</i>".</p>
<p class="Pp">Once <i>/proc/</i>pid<i>/gid_map</i> has been written to (which
    has the effect of enabling <b>setgroups</b>(2) in the user namespace), it is
    no longer possible to disallow <b>setgroups</b>(2) by writing
    "<i>deny</i>" to <i>/proc/</i>pid<i>/setgroups</i> (the write
    fails with the error <b>EPERM</b>).</p>
<p class="Pp">A child user namespace inherits the
    <i>/proc/</i>pid<i>/setgroups</i> setting from its parent.</p>
<p class="Pp">If the <i>setgroups</i> file has the value
    "<i>deny</i>", then the <b>setgroups</b>(2) system call can't
    subsequently be reenabled (by writing "<i>allow</i>" to the file)
    in this user namespace. (Attempts to do so fail with the error
    <b>EPERM</b>.) This restriction also propagates down to all child user
    namespaces of this user namespace.</p>
<p class="Pp">The <i>/proc/</i>pid<i>/setgroups</i> file was added in Linux
    3.19, but was backported to many earlier stable kernel series, because it
    addresses a security issue. The issue concerned files with permissions such
    as "rwx---rwx". Such files give fewer permissions to
    "group" than they do to "other". This means that
    dropping groups using <b>setgroups</b>(2) might allow a process file access
    that it did not formerly have. Before the existence of user namespaces this
    was not a concern, since only a privileged process (one with the
    <b>CAP_SETGID</b> capability) could call <b>setgroups</b>(2). However, with
    the introduction of user namespaces, it became possible for an unprivileged
    process to create a new namespace in which the user had all privileges. This
    then allowed formerly unprivileged users to drop groups and thus gain file
    access that they did not previously have. The
    <i>/proc/</i>pid<i>/setgroups</i> file was added to address this security
    issue, by denying any pathway for an unprivileged process to drop groups
    with <b>setgroups</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unmapped_user_and_group_IDs"><a class="permalink" href="#Unmapped_user_and_group_IDs">Unmapped
  user and group IDs</a></h2>
<p class="Pp">There are various places where an unmapped user ID (group ID) may
    be exposed to user space. For example, the first process in a new user
    namespace may call <b>getuid</b>(2) before a user ID mapping has been
    defined for the namespace. In most such cases, an unmapped user ID is
    converted to the overflow user ID (group ID); the default value for the
    overflow user ID (group ID) is 65534. See the descriptions of
    <i>/proc/sys/kernel/overflowuid</i> and <i>/proc/sys/kernel/overflowgid</i>
    in <b>proc</b>(5).</p>
<p class="Pp">The cases where unmapped IDs are mapped in this fashion include
    system calls that return user IDs (<b>getuid</b>(2), <b>getgid</b>(2), and
    similar), credentials passed over a UNIX domain socket, credentials returned
    by <b>stat</b>(2), <b>waitid</b>(2), and the System V IPC "ctl"
    <b>IPC_STAT</b> operations, credentials exposed by
    <i>/proc/</i>pid<i>/status</i> and the files in <i>/proc/sysvipc/*</i>,
    credentials returned via the <i>si_uid</i> field in the <i>siginfo_t</i>
    received with a signal (see <b>sigaction</b>(2)), credentials written to the
    process accounting file (see <b>acct</b>(5)), and credentials returned with
    POSIX message queue notifications (see <b>mq_notify</b>(3)).</p>
<p class="Pp">There is one notable case where unmapped user and group IDs are
    <i>not</i> converted to the corresponding overflow ID value. When viewing a
    <i>uid_map</i> or <i>gid_map</i> file in which there is no mapping for the
    second field, that field is displayed as 4294967295 (-1 as an unsigned
    integer).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Accessing_files"><a class="permalink" href="#Accessing_files">Accessing
  files</a></h2>
<p class="Pp">In order to determine permissions when an unprivileged process
    accesses a file, the process credentials (UID, GID) and the file credentials
    are in effect mapped back to what they would be in the initial user
    namespace and then compared to determine the permissions that the process
    has on the file. The same is also true of other objects that employ the
    credentials plus permissions mask accessibility model, such as System V IPC
    objects.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Operation_of_file-related_capabilities"><a class="permalink" href="#Operation_of_file-related_capabilities">Operation
  of file-related capabilities</a></h2>
<p class="Pp">Certain capabilities allow a process to bypass various
    kernel-enforced restrictions when performing operations on files owned by
    other users or groups. These capabilities are: <b>CAP_CHOWN</b>,
    <b>CAP_DAC_OVERRIDE</b>, <b>CAP_DAC_READ_SEARCH</b>, <b>CAP_FOWNER</b>, and
    <b>CAP_FSETID</b>.</p>
<p class="Pp">Within a user namespace, these capabilities allow a process to
    bypass the rules if the process has the relevant capability over the file,
    meaning that:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>the process has the relevant effective capability in its user namespace;
      and</dd>
  <dt>•</dt>
  <dd>the file's user ID and group ID both have valid mappings in the user
      namespace.</dd>
</dl>
<p class="Pp">The <b>CAP_FOWNER</b> capability is treated somewhat
    exceptionally: it allows a process to bypass the corresponding rules so long
    as at least the file's user ID has a mapping in the user namespace (i.e.,
    the file's group ID does not need to have a valid mapping).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Set-user-ID_and_set-group-ID_programs"><a class="permalink" href="#Set-user-ID_and_set-group-ID_programs">Set-user-ID
  and set-group-ID programs</a></h2>
<p class="Pp">When a process inside a user namespace executes a set-user-ID
    (set-group-ID) program, the process's effective user (group) ID inside the
    namespace is changed to whatever value is mapped for the user (group) ID of
    the file. However, if either the user <i>or</i> the group ID of the file has
    no mapping inside the namespace, the set-user-ID (set-group-ID) bit is
    silently ignored: the new program is executed, but the process's effective
    user (group) ID is left unchanged. (This mirrors the semantics of executing
    a set-user-ID or set-group-ID program that resides on a filesystem that was
    mounted with the <b>MS_NOSUID</b> flag, as described in
  <b>mount</b>(2).)</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous"><a class="permalink" href="#Miscellaneous">Miscellaneous</a></h2>
<p class="Pp">When a process's user and group IDs are passed over a UNIX domain
    socket to a process in a different user namespace (see the description of
    <b>SCM_CREDENTIALS</b> in <b>unix</b>(7)), they are translated into the
    corresponding values as per the receiving process's user and group ID
    mappings.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">Namespaces are a Linux-specific feature.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Over the years, there have been a lot of features that have been
    added to the Linux kernel that have been made available only to privileged
    users because of their potential to confuse set-user-ID-root applications.
    In general, it becomes safe to allow the root user in a user namespace to
    use those features because it is impossible, while in a user namespace, to
    gain more privilege than the root user of a user namespace has.</p>
<section class="Ss">
<h2 class="Ss" id="Global_root"><a class="permalink" href="#Global_root">Global
  root</a></h2>
<p class="Pp">The term "global root" is sometimes used as a shorthand
    for user ID 0 in the initial user namespace.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Availability"><a class="permalink" href="#Availability">Availability</a></h2>
<p class="Pp">Use of user namespaces requires a kernel that is configured with
    the <b>CONFIG_USER_NS</b> option. User namespaces require support in a range
    of subsystems across the kernel. When an unsupported subsystem is configured
    into the kernel, it is not possible to configure user namespaces
  support.</p>
<p class="Pp">As at Linux 3.8, most relevant subsystems supported user
    namespaces, but a number of filesystems did not have the infrastructure
    needed to map user and group IDs between user namespaces. Linux 3.9 added
    the required infrastructure support for many of the remaining unsupported
    filesystems (Plan 9 (9P), Andrew File System (AFS), Ceph, CIFS, CODA, NFS,
    and OCFS2). Linux 3.12 added support for the last of the unsupported major
    filesystems, XFS.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The program below is designed to allow experimenting with user
    namespaces, as well as other types of namespaces. It creates namespaces as
    specified by command-line options and then executes a command inside those
    namespaces. The comments and <i>usage</i>() function inside the program
    provide a full explanation of the program. The following shell session
    demonstrates its use.</p>
<p class="Pp">First, we look at the run-time environment:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>uname -rs</b>     # Need Linux 3.8 or later
Linux 3.8.0
$ <b>id -u</b>         # Running as unprivileged user
1000
$ <b>id -g</b>
1000
</pre>
<br>
<p class="Pp">Now start a new shell in new user (<i>-U</i>), mount (<i>-m</i>),
    and PID (<i>-p</i>) namespaces, with user ID (<i>-M</i>) and group ID
    (<i>-G</i>) 1000 mapped to 0 inside the user namespace:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>./userns_child_exec -p -m -U -M '0 1000 1' -G '0 1000 1' bash</b>
</pre>
<br>
<p class="Pp">The shell has PID 1, because it is the first process in the new
    PID namespace:</p>
<p class="Pp">
  <br>
</p>
<pre>bash$ <b>echo $$</b>
1
</pre>
<br>
<p class="Pp">Mounting a new <i>/proc</i> filesystem and listing all of the
    processes visible in the new PID namespace shows that the shell can't see
    any processes outside the PID namespace:</p>
<p class="Pp">
  <br>
</p>
<pre>bash$ <b>mount -t proc proc /proc</b>
bash$ <b>ps ax</b>
<br>
  PID TTY      STAT   TIME COMMAND
<br>
    1 pts/3    S      0:00 bash
<br>
   22 pts/3    R+     0:00 ps ax
</pre>
<br>
<p class="Pp">Inside the user namespace, the shell has user and group ID 0, and
    a full set of permitted and effective capabilities:</p>
<p class="Pp">
  <br>
</p>
<pre>bash$ <b>cat /proc/$$/status | egrep '^[UG]id'</b>
Uid:	0	0	0	0
Gid:	0	0	0	0
bash$ <b>cat /proc/$$/status | egrep '^Cap(Prm|Inh|Eff)'</b>
CapInh:	0000000000000000
CapPrm:	0000001fffffffff
CapEff:	0000001fffffffff
</pre>
<br>
<section class="Ss">
<h2 class="Ss" id="Program_source"><a class="permalink" href="#Program_source">Program
  source</a></h2>
<p class="Pp"></p>
<pre>/* userns_child_exec.c
<br>
   Licensed under GNU General Public License v2 or later
<br>
   Create a child process that executes a shell command in new
<br>
   namespace(s); allow UID and GID mappings to be specified when
<br>
   creating a user namespace.
*/
#define _GNU_SOURCE
#include &lt;err.h&gt;
#include &lt;sched.h&gt;
#include &lt;unistd.h&gt;
#include &lt;stdint.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/wait.h&gt;
#include &lt;signal.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;
#include &lt;errno.h&gt;
struct child_args {
<br>
    char **argv;        /* Command to be executed by child, with args */
<br>
    int    pipe_fd[2];  /* Pipe used to synchronize parent and child */
};
static int verbose;
static void
usage(char *pname)
{
<br>
    fprintf(stderr, "Usage: %s [options] cmd [arg...]\n\n", pname);
<br>
    fprintf(stderr, "Create a child process that executes a shell "
<br>
            "command in a new user namespace,\n"
<br>
            "and possibly also other new namespace(s).\n\n");
<br>
    fprintf(stderr, "Options can be:\n\n");
#define fpe(str) fprintf(stderr, "    %s", str);
<br>
    fpe("-i          New IPC namespace\n");
<br>
    fpe("-m          New mount namespace\n");
<br>
    fpe("-n          New network namespace\n");
<br>
    fpe("-p          New PID namespace\n");
<br>
    fpe("-u          New UTS namespace\n");
<br>
    fpe("-U          New user namespace\n");
<br>
    fpe("-M uid_map  Specify UID map for user namespace\n");
<br>
    fpe("-G gid_map  Specify GID map for user namespace\n");
<br>
    fpe("-z          Map user's UID and GID to 0 in user namespace\n");
<br>
    fpe("            (equivalent to: -M '0 &lt;uid&gt; 1' -G '0 &lt;gid&gt; 1')\n");
<br>
    fpe("-v          Display verbose messages\n");
<br>
    fpe("\n");
<br>
    fpe("If -z, -M, or -G is specified, -U is required.\n");
<br>
    fpe("It is not permitted to specify both -z and either -M or -G.\n");
<br>
    fpe("\n");
<br>
    fpe("Map strings for -M and -G consist of records of the form:\n");
<br>
    fpe("\n");
<br>
    fpe("    ID-inside-ns   ID-outside-ns   len\n");
<br>
    fpe("\n");
<br>
    fpe("A map string can contain multiple records, separated"
<br>
        " by commas;\n");
<br>
    fpe("the commas are replaced by newlines before writing"
<br>
        " to map files.\n");
<br>
    exit(EXIT_FAILURE);
}
/* Update the mapping file 'map_file', with the value provided in
<br>
   'mapping', a string that defines a UID or GID mapping. A UID or
<br>
   GID mapping consists of one or more newline-delimited records
<br>
   of the form:
<br>
       ID_inside-ns    ID-outside-ns   length
<br>
   Requiring the user to supply a string that contains newlines is
<br>
   of course inconvenient for command-line use. Thus, we permit the
<br>
   use of commas to delimit records in this string, and replace them
<br>
   with newlines before writing the string to the file. */
static void
update_map(char *mapping, char *map_file)
{
<br>
    int fd;
<br>
    size_t map_len;     /* Length of 'mapping' */
<br>
    /* Replace commas in mapping string with newlines. */
<br>
    map_len = strlen(mapping);
<br>
    for (size_t j = 0; j &lt; map_len; j++)
<br>
        if (mapping[j] == ',')
<br>
            mapping[j] = '\n';
<br>
    fd = open(map_file, O_RDWR);
<br>
    if (fd == -1) {
<br>
        fprintf(stderr, "ERROR: open %s: %s\n", map_file,
<br>
                strerror(errno));
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    if (write(fd, mapping, map_len) != map_len) {
<br>
        fprintf(stderr, "ERROR: write %s: %s\n", map_file,
<br>
                strerror(errno));
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    close(fd);
}
/* Linux 3.19 made a change in the handling of setgroups(2) and the
<br>
   'gid_map' file to address a security issue.  The issue allowed
<br>
   *unprivileged* users to employ user namespaces in order to drop groups.
<br>
   The upshot of the 3.19 changes is that in order to update the
<br>
   'gid_maps' file, use of the setgroups() system call in this
<br>
   user namespace must first be disabled by writing "deny" to one of
<br>
   the /proc/PID/setgroups files for this namespace.  That is the
<br>
   purpose of the following function. */
static void
proc_setgroups_write(pid_t child_pid, char *str)
{
<br>
    char setgroups_path[PATH_MAX];
<br>
    int fd;
<br>
    snprintf(setgroups_path, PATH_MAX, "/proc/%jd/setgroups",
<br>
            (intmax_t) child_pid);
<br>
    fd = open(setgroups_path, O_RDWR);
<br>
    if (fd == -1) {
<br>
        /* We may be on a system that doesn't support
<br>
           /proc/PID/setgroups. In that case, the file won't exist,
<br>
           and the system won't impose the restrictions that Linux 3.19
<br>
           added. That's fine: we don't need to do anything in order
<br>
           to permit 'gid_map' to be updated.
<br>
           However, if the error from open() was something other than
<br>
           the ENOENT error that is expected for that case,  let the
<br>
           user know. */
<br>
        if (errno != ENOENT)
<br>
            fprintf(stderr, "ERROR: open %s: %s\n", setgroups_path,
<br>
                strerror(errno));
<br>
        return;
<br>
    }
<br>
    if (write(fd, str, strlen(str)) == -1)
<br>
        fprintf(stderr, "ERROR: write %s: %s\n", setgroups_path,
<br>
            strerror(errno));
<br>
    close(fd);
}
static int              /* Start function for cloned child */
childFunc(void *arg)
{
<br>
    struct child_args *args = arg;
<br>
    char ch;
<br>
    /* Wait until the parent has updated the UID and GID mappings.
<br>
       See the comment in main(). We wait for end of file on a
<br>
       pipe that will be closed by the parent process once it has
<br>
       updated the mappings. */
<br>
    close(args-&gt;pipe_fd[1]);    /* Close our descriptor for the write
<br>
                                   end of the pipe so that we see EOF
<br>
                                   when parent closes its descriptor. */
<br>
    if (read(args-&gt;pipe_fd[0], &amp;ch, 1) != 0) {
<br>
        fprintf(stderr,
<br>
                "Failure in child: read from pipe returned != 0\n");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    close(args-&gt;pipe_fd[0]);
<br>
    /* Execute a shell command. */
<br>
    printf("About to exec %s\n", args-&gt;argv[0]);
<br>
    execvp(args-&gt;argv[0], args-&gt;argv);
<br>
    err(EXIT_FAILURE, "execvp");
}
#define STACK_SIZE (1024 * 1024)
static char child_stack[STACK_SIZE];    /* Space for child's stack */
int
main(int argc, char *argv[])
{
<br>
    int flags, opt, map_zero;
<br>
    pid_t child_pid;
<br>
    struct child_args args;
<br>
    char *uid_map, *gid_map;
<br>
    const int MAP_BUF_SIZE = 100;
<br>
    char map_buf[MAP_BUF_SIZE];
<br>
    char map_path[PATH_MAX];
<br>
    /* Parse command-line options. The initial '+' character in
<br>
       the final getopt() argument prevents GNU-style permutation
<br>
       of command-line options. That's useful, since sometimes
<br>
       the 'command' to be executed by this program itself
<br>
       has command-line options. We don't want getopt() to treat
<br>
       those as options to this program. */
<br>
    flags = 0;
<br>
    verbose = 0;
<br>
    gid_map = NULL;
<br>
    uid_map = NULL;
<br>
    map_zero = 0;
<br>
    while ((opt = getopt(argc, argv, "+imnpuUM:G:zv")) != -1) {
<br>
        switch (opt) {
<br>
        case 'i': flags |= CLONE_NEWIPC;        break;
<br>
        case 'm': flags |= CLONE_NEWNS;         break;
<br>
        case 'n': flags |= CLONE_NEWNET;        break;
<br>
        case 'p': flags |= CLONE_NEWPID;        break;
<br>
        case 'u': flags |= CLONE_NEWUTS;        break;
<br>
        case 'v': verbose = 1;                  break;
<br>
        case 'z': map_zero = 1;                 break;
<br>
        case 'M': uid_map = optarg;             break;
<br>
        case 'G': gid_map = optarg;             break;
<br>
        case 'U': flags |= CLONE_NEWUSER;       break;
<br>
        default:  usage(argv[0]);
<br>
        }
<br>
    }
<br>
    /* -M or -G without -U is nonsensical */
<br>
    if (((uid_map != NULL || gid_map != NULL || map_zero) &amp;&amp;
<br>
                !(flags &amp; CLONE_NEWUSER)) ||
<br>
            (map_zero &amp;&amp; (uid_map != NULL || gid_map != NULL)))
<br>
        usage(argv[0]);
<br>
    args.argv = &amp;argv[optind];
<br>
    /* We use a pipe to synchronize the parent and child, in order to
<br>
       ensure that the parent sets the UID and GID maps before the child
<br>
       calls execve(). This ensures that the child maintains its
<br>
       capabilities during the execve() in the common case where we
<br>
       want to map the child's effective user ID to 0 in the new user
<br>
       namespace. Without this synchronization, the child would lose
<br>
       its capabilities if it performed an execve() with nonzero
<br>
       user IDs (see the capabilities(7) man page for details of the
<br>
       transformation of a process's capabilities during execve()). */
<br>
    if (pipe(args.pipe_fd) == -1)
<br>
        err(EXIT_FAILURE, "pipe");
<br>
    /* Create the child in new namespace(s). */
<br>
    child_pid = clone(childFunc, child_stack + STACK_SIZE,
<br>
                      flags | SIGCHLD, &amp;args);
<br>
    if (child_pid == -1)
<br>
        err(EXIT_FAILURE, "clone");
<br>
    /* Parent falls through to here. */
<br>
    if (verbose)
<br>
        printf("%s: PID of child created by clone() is %jd\n",
<br>
                argv[0], (intmax_t) child_pid);
<br>
    /* Update the UID and GID maps in the child. */
<br>
    if (uid_map != NULL || map_zero) {
<br>
        snprintf(map_path, PATH_MAX, "/proc/%jd/uid_map",
<br>
                (intmax_t) child_pid);
<br>
        if (map_zero) {
<br>
            snprintf(map_buf, MAP_BUF_SIZE, "0 %jd 1",
<br>
                    (intmax_t) getuid());
<br>
            uid_map = map_buf;
<br>
        }
<br>
        update_map(uid_map, map_path);
<br>
    }
<br>
    if (gid_map != NULL || map_zero) {
<br>
        proc_setgroups_write(child_pid, "deny");
<br>
        snprintf(map_path, PATH_MAX, "/proc/%jd/gid_map",
<br>
                (intmax_t) child_pid);
<br>
        if (map_zero) {
<br>
            snprintf(map_buf, MAP_BUF_SIZE, "0 %ld 1",
<br>
                    (intmax_t) getgid());
<br>
            gid_map = map_buf;
<br>
        }
<br>
        update_map(gid_map, map_path);
<br>
    }
<br>
    /* Close the write end of the pipe, to signal to the child that we
<br>
       have updated the UID and GID maps. */
<br>
    close(args.pipe_fd[1]);
<br>
    if (waitpid(child_pid, NULL, 0) == -1)      /* Wait for child */
<br>
        err(EXIT_FAILURE, "waitpid");
<br>
    if (verbose)
<br>
        printf("%s: terminating\n", argv[0]);
<br>
    exit(EXIT_SUCCESS);
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>newgidmap</b>(1), <b>newuidmap</b>(1), <b>clone</b>(2),
    <b>ptrace</b>(2), <b>setns</b>(2), <b>unshare</b>(2), <b>proc</b>(5),
    <b>subgid</b>(5), <b>subuid</b>(5), <b>capabilities</b>(7),
    <b>cgroup_namespaces</b>(7), <b>credentials</b>(7), <b>namespaces</b>(7),
    <b>pid_namespaces</b>(7)</p>
<p class="Pp">The kernel source file
    <i>Documentation/admin-guide/namespaces/resource-control.rst</i>.</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>