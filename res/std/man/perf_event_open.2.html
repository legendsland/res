<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (c) 2012, Vincent Weaver
  
   SPDX-License-Identifier: GPL-2.0-or-later
  
   This document is based on the perf_event.h header file, the
   tools/perf/design.txt file, and a lot of bitter experience.
   --><head>
<meta name="dc.identifier" content="res/f541be803ee346ac01d055be4355ba04f0445a4e">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>perf_event_open(2)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">perf_event_open(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">perf_event_open(2)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">perf_event_open - set up performance monitoring</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Standard C library (<i>libc</i>, <i>-lc</i>)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;linux/perf_event.h&gt;</b>    /* Definition of <b>PERF_*</b> constants */
<b>#include &lt;linux/hw_breakpoint.h&gt;</b> /* Definition of <b>HW_*</b> constants */
<b>#include &lt;sys/syscall.h&gt;</b>         /* Definition of <b>SYS_*</b> constants */
<b>#include &lt;unistd.h&gt;</b></pre>
<pre><b>int syscall(SYS_perf_event_open, struct perf_event_attr *</b><i>attr</i><b>,</b>
<b>            pid_t </b><i>pid</i><b>, int </b><i>cpu</i><b>, int </b><i>group_fd</i><b>, unsigned long </b><i>flags</i><b>);</b></pre>
<p class="Pp"><i>Note</i>: glibc provides no wrapper for
    <b>perf_event_open</b>(), necessitating the use of <b>syscall</b>(2).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Given a list of parameters, <b>perf_event_open</b>() returns a
    file descriptor, for use in subsequent system calls (<b>read</b>(2),
    <b>mmap</b>(2), <b>prctl</b>(2), <b>fcntl</b>(2), etc.).</p>
<p class="Pp">A call to <b>perf_event_open</b>() creates a file descriptor that
    allows measuring performance information. Each file descriptor corresponds
    to one event that is measured; these can be grouped together to measure
    multiple events simultaneously.</p>
<p class="Pp">Events can be enabled and disabled in two ways: via
    <b>ioctl</b>(2) and via <b>prctl</b>(2). When an event is disabled it does
    not count or generate overflows but does continue to exist and maintain its
    count value.</p>
<p class="Pp">Events come in two flavors: counting and sampled. A
    <i>counting</i> event is one that is used for counting the aggregate number
    of events that occur. In general, counting event results are gathered with a
    <b>read</b>(2) call. A <i>sampling</i> event periodically writes
    measurements to a buffer that can then be accessed via <b>mmap</b>(2).</p>
<section class="Ss">
<h2 class="Ss" id="Arguments"><a class="permalink" href="#Arguments">Arguments</a></h2>
<p class="Pp">The <i>pid</i> and <i>cpu</i> arguments allow specifying which
    process and CPU to monitor:</p>
<dl class="Bl-tag">
  <dt><b>pid == 0</b> and <b>cpu == -1</b></dt>
  <dd>This measures the calling process/thread on any CPU.</dd>
  <dt><b>pid == 0</b> and <b>cpu &gt;= 0</b></dt>
  <dd>This measures the calling process/thread only when running on the
      specified CPU.</dd>
  <dt><b>pid &gt; 0</b> and <b>cpu == -1</b></dt>
  <dd>This measures the specified process/thread on any CPU.</dd>
  <dt><b>pid &gt; 0</b> and <b>cpu &gt;= 0</b></dt>
  <dd>This measures the specified process/thread only when running on the
      specified CPU.</dd>
  <dt><b>pid == -1</b> and <b>cpu &gt;= 0</b></dt>
  <dd>This measures all processes/threads on the specified CPU. This requires
      <b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b> capability or
      a <i>/proc/sys/kernel/perf_event_paranoid</i> value of less than 1.</dd>
  <dt><b>pid == -1</b> and <b>cpu == -1</b></dt>
  <dd>This setting is invalid and will return an error.</dd>
</dl>
<p class="Pp">When <i>pid</i> is greater than zero, permission to perform this
    system call is governed by <b>CAP_PERFMON</b> (since Linux 5.9) and a ptrace
    access mode <b>PTRACE_MODE_READ_REALCREDS</b> check on older Linux versions;
    see <b>ptrace</b>(2).</p>
<p class="Pp">The <i>group_fd</i> argument allows event groups to be created. An
    event group has one event which is the group leader. The leader is created
    first, with <i>group_fd</i> = -1. The rest of the group members are created
    with subsequent <b>perf_event_open</b>() calls with <i>group_fd</i> being
    set to the file descriptor of the group leader. (A single event on its own
    is created with <i>group_fd</i> = -1 and is considered to be a group with
    only 1 member.) An event group is scheduled onto the CPU as a unit: it will
    be put onto the CPU only if all of the events in the group can be put onto
    the CPU. This means that the values of the member events can be meaningfully
    compared —added, divided (to get ratios), and so on— with each
    other, since they have counted events for the same set of executed
    instructions.</p>
<p class="Pp">The <i>flags</i> argument is formed by ORing together zero or more
    of the following values:</p>
<dl class="Bl-tag">
  <dt id="PERF_FLAG_FD_CLOEXEC"><a class="permalink" href="#PERF_FLAG_FD_CLOEXEC"><b>PERF_FLAG_FD_CLOEXEC</b>
    (since Linux 3.14)</a></dt>
  <dd>This flag enables the close-on-exec flag for the created event file
      descriptor, so that the file descriptor is automatically closed on
      <b>execve</b>(2). Setting the close-on-exec flags at creation time, rather
      than later with <b>fcntl</b>(2), avoids potential race conditions where
      the calling thread invokes <b>perf_event_open</b>() and <b>fcntl</b>(2) at
      the same time as another thread calls <b>fork</b>(2) then
      <b>execve</b>(2).</dd>
  <dt id="PERF_FLAG_FD_NO_GROUP"><a class="permalink" href="#PERF_FLAG_FD_NO_GROUP"><b>PERF_FLAG_FD_NO_GROUP</b></a></dt>
  <dd>This flag tells the event to ignore the <i>group_fd</i> parameter except
      for the purpose of setting up output redirection using the
      <b>PERF_FLAG_FD_OUTPUT</b> flag.</dd>
  <dt id="PERF_FLAG_FD_OUTPUT"><a class="permalink" href="#PERF_FLAG_FD_OUTPUT"><b>PERF_FLAG_FD_OUTPUT</b>
    (broken since Linux 2.6.35)</a></dt>
  <dd>This flag re-routes the event's sampled output to instead be included in
      the mmap buffer of the event specified by <i>group_fd</i>.</dd>
  <dt id="PERF_FLAG_PID_CGROUP"><a class="permalink" href="#PERF_FLAG_PID_CGROUP"><b>PERF_FLAG_PID_CGROUP</b>
    (since Linux 2.6.39)</a></dt>
  <dd>This flag activates per-container system-wide monitoring. A container is
      an abstraction that isolates a set of resources for finer-grained control
      (CPUs, memory, etc.). In this mode, the event is measured only if the
      thread running on the monitored CPU belongs to the designated container
      (cgroup). The cgroup is identified by passing a file descriptor opened on
      its directory in the cgroupfs filesystem. For instance, if the cgroup to
      monitor is called <i>test</i>, then a file descriptor opened on
      <i>/dev/cgroup/test</i> (assuming cgroupfs is mounted on
      <i>/dev/cgroup</i>) must be passed as the <i>pid</i> parameter. cgroup
      monitoring is available only for system-wide events and may therefore
      require extra permissions.</dd>
</dl>
<p class="Pp">The <i>perf_event_attr</i> structure provides detailed
    configuration information for the event being created.</p>
<p class="Pp">
  <br>
</p>
<pre>struct perf_event_attr {
<br>
    __u32 type;                 /* Type of event */
<br>
    __u32 size;                 /* Size of attribute structure */
<br>
    __u64 config;               /* Type-specific configuration */
<br>
    union {
<br>
        __u64 sample_period;    /* Period of sampling */
<br>
        __u64 sample_freq;      /* Frequency of sampling */
<br>
    };
<br>
    __u64 sample_type;  /* Specifies values included in sample */
<br>
    __u64 read_format;  /* Specifies values returned in read */
<br>
    __u64 disabled       : 1,   /* off by default */
<br>
          inherit        : 1,   /* children inherit it */
<br>
          pinned         : 1,   /* must always be on PMU */
<br>
          exclusive      : 1,   /* only group on PMU */
<br>
          exclude_user   : 1,   /* don't count user */
<br>
          exclude_kernel : 1,   /* don't count kernel */
<br>
          exclude_hv     : 1,   /* don't count hypervisor */
<br>
          exclude_idle   : 1,   /* don't count when idle */
<br>
          mmap           : 1,   /* include mmap data */
<br>
          comm           : 1,   /* include comm data */
<br>
          freq           : 1,   /* use freq, not period */
<br>
          inherit_stat   : 1,   /* per task counts */
<br>
          enable_on_exec : 1,   /* next exec enables */
<br>
          task           : 1,   /* trace fork/exit */
<br>
          watermark      : 1,   /* wakeup_watermark */
<br>
          precise_ip     : 2,   /* skid constraint */
<br>
          mmap_data      : 1,   /* non-exec mmap data */
<br>
          sample_id_all  : 1,   /* sample_type all events */
<br>
          exclude_host   : 1,   /* don't count in host */
<br>
          exclude_guest  : 1,   /* don't count in guest */
<br>
          exclude_callchain_kernel : 1,
<br>
                                /* exclude kernel callchains */
<br>
          exclude_callchain_user   : 1,
<br>
                                /* exclude user callchains */
<br>
          mmap2          :  1,  /* include mmap with inode data */
<br>
          comm_exec      :  1,  /* flag comm events that are
<br>
                                   due to exec */
<br>
          use_clockid    :  1,  /* use clockid for time fields */
<br>
          context_switch :  1,  /* context switch data */
<br>
          write_backward :  1,  /* Write ring buffer from end
<br>
                                   to beginning */
<br>
          namespaces     :  1,  /* include namespaces data */
<br>
          ksymbol        :  1,  /* include ksymbol events */
<br>
          bpf_event      :  1,  /* include bpf events */
<br>
          aux_output     :  1,  /* generate AUX records
<br>
                                   instead of events */
<br>
          cgroup         :  1,  /* include cgroup events */
<br>
          text_poke      :  1,  /* include text poke events */
<br>
          build_id       :  1,  /* use build id in mmap2 events */
<br>
          inherit_thread :  1,  /* children only inherit */
<br>
                                /* if cloned with CLONE_THREAD */
<br>
          remove_on_exec :  1,  /* event is removed from task
<br>
                                   on exec */
<br>
          sigtrap        :  1,  /* send synchronous SIGTRAP
<br>
                                   on event */
<br>
          __reserved_1   : 26;
<br>
    union {
<br>
        __u32 wakeup_events;    /* wakeup every n events */
<br>
        __u32 wakeup_watermark; /* bytes before wakeup */
<br>
    };
<br>
    __u32     bp_type;          /* breakpoint type */
<br>
    union {
<br>
        __u64 bp_addr;          /* breakpoint address */
<br>
        __u64 kprobe_func;      /* for perf_kprobe */
<br>
        __u64 uprobe_path;      /* for perf_uprobe */
<br>
        __u64 config1;          /* extension of config */
<br>
    };
<br>
    union {
<br>
        __u64 bp_len;           /* breakpoint length */
<br>
        __u64 kprobe_addr;      /* with kprobe_func == NULL */
<br>
        __u64 probe_offset;     /* for perf_[k,u]probe */
<br>
        __u64 config2;          /* extension of config1 */
<br>
    };
<br>
    __u64 branch_sample_type;   /* enum perf_branch_sample_type */
<br>
    __u64 sample_regs_user;     /* user regs to dump on samples */
<br>
    __u32 sample_stack_user;    /* size of stack to dump on
<br>
                                   samples */
<br>
    __s32 clockid;              /* clock to use for time fields */
<br>
    __u64 sample_regs_intr;     /* regs to dump on samples */
<br>
    __u32 aux_watermark;        /* aux bytes before wakeup */
<br>
    __u16 sample_max_stack;     /* max frames in callchain */
<br>
    __u16 __reserved_2;         /* align to u64 */
<br>
    __u32 aux_sample_size;      /* max aux sample size */
<br>
    __u32 __reserved_3;         /* align to u64 */
<br>
    __u64 sig_data;             /* user data for sigtrap */
};
</pre>
<br>
<p class="Pp">The fields of the <i>perf_event_attr</i> structure are described
    in more detail below:</p>
<dl class="Bl-tag">
  <dt id="type"><a class="permalink" href="#type"><i>type</i></a></dt>
  <dd>This field specifies the overall event type. It has one of the following
      values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_TYPE_HARDWARE"><a class="permalink" href="#PERF_TYPE_HARDWARE"><b>PERF_TYPE_HARDWARE</b></a></dt>
  <dd>This indicates one of the "generalized" hardware events provided
      by the kernel. See the <i>config</i> field definition for more
    details.</dd>
  <dt id="PERF_TYPE_SOFTWARE"><a class="permalink" href="#PERF_TYPE_SOFTWARE"><b>PERF_TYPE_SOFTWARE</b></a></dt>
  <dd>This indicates one of the software-defined events provided by the kernel
      (even if no hardware support is available).</dd>
  <dt id="PERF_TYPE_TRACEPOINT"><a class="permalink" href="#PERF_TYPE_TRACEPOINT"><b>PERF_TYPE_TRACEPOINT</b></a></dt>
  <dd>This indicates a tracepoint provided by the kernel tracepoint
      infrastructure.</dd>
  <dt id="PERF_TYPE_HW_CACHE"><a class="permalink" href="#PERF_TYPE_HW_CACHE"><b>PERF_TYPE_HW_CACHE</b></a></dt>
  <dd>This indicates a hardware cache event. This has a special encoding,
      described in the <i>config</i> field definition.</dd>
  <dt id="PERF_TYPE_RAW"><a class="permalink" href="#PERF_TYPE_RAW"><b>PERF_TYPE_RAW</b></a></dt>
  <dd>This indicates a "raw" implementation-specific event in the
      <i>config</i> field.</dd>
  <dt id="PERF_TYPE_BREAKPOINT"><a class="permalink" href="#PERF_TYPE_BREAKPOINT"><b>PERF_TYPE_BREAKPOINT</b>
    (since Linux 2.6.33)</a></dt>
  <dd>This indicates a hardware breakpoint as provided by the CPU. Breakpoints
      can be read/write accesses to an address as well as execution of an
      instruction address.</dd>
  <dt id="dynamic"><a class="permalink" href="#dynamic">dynamic PMU</a></dt>
  <dd>Since Linux 2.6.38, <b>perf_event_open</b>() can support multiple PMUs. To
      enable this, a value exported by the kernel can be used in the <i>type</i>
      field to indicate which PMU to use. The value to use can be found in the
      sysfs filesystem: there is a subdirectory per PMU instance under
      <i>/sys/bus/event_source/devices</i>. In each subdirectory there is a
      <i>type</i> file whose content is an integer that can be used in the
      <i>type</i> field. For instance,
      <i>/sys/bus/event_source/devices/cpu/type</i> contains the value for the
      core CPU PMU, which is usually 4.</dd>
  <dt id="kprobe"><a class="permalink" href="#kprobe"><b>kprobe</b> and
    <b>uprobe</b> (since Linux 4.17)</a></dt>
  <dd>These two dynamic PMUs create a kprobe/uprobe and attach it to the file
      descriptor generated by perf_event_open. The kprobe/uprobe will be
      destroyed on the destruction of the file descriptor. See fields
      <i>kprobe_func</i>, <i>uprobe_path</i>, <i>kprobe_addr</i>, and
      <i>probe_offset</i> for more details.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="size"><a class="permalink" href="#size"><i>size</i></a></dt>
  <dd>The size of the <i>perf_event_attr</i> structure for forward/backward
      compatibility. Set this using <i>sizeof(struct perf_event_attr)</i> to
      allow the kernel to see the struct size at the time of compilation.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The related define <b>PERF_ATTR_SIZE_VER0</b> is set to 64; this was the
      size of the first published struct. <b>PERF_ATTR_SIZE_VER1</b> is 72,
      corresponding to the addition of breakpoints in Linux 2.6.33.
      <b>PERF_ATTR_SIZE_VER2</b> is 80 corresponding to the addition of branch
      sampling in Linux 3.4. <b>PERF_ATTR_SIZE_VER3</b> is 96 corresponding to
      the addition of <i>sample_regs_user</i> and <i>sample_stack_user</i> in
      Linux 3.7. <b>PERF_ATTR_SIZE_VER4</b> is 104 corresponding to the addition
      of <i>sample_regs_intr</i> in Linux 3.19. <b>PERF_ATTR_SIZE_VER5</b> is
      112 corresponding to the addition of <i>aux_watermark</i> in Linux
    4.1.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="config"><a class="permalink" href="#config"><i>config</i></a></dt>
  <dd>This specifies which event you want, in conjunction with the <i>type</i>
      field. The <i>config1</i> and <i>config2</i> fields are also taken into
      account in cases where 64 bits is not enough to fully specify the event.
      The encoding of these fields are event dependent.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>There are various ways to set the <i>config</i> field that are dependent
      on the value of the previously described <i>type</i> field. What follows
      are various possible settings for <i>config</i> separated out by
      <i>type</i>.</dd>
  <dt></dt>
  <dd>If <i>type</i> is <b>PERF_TYPE_HARDWARE</b>, we are measuring one of the
      generalized hardware CPU events. Not all of these are available on all
      platforms. Set <i>config</i> to one of the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_COUNT_HW_CPU_CYCLES"><a class="permalink" href="#PERF_COUNT_HW_CPU_CYCLES"><b>PERF_COUNT_HW_CPU_CYCLES</b></a></dt>
  <dd>Total cycles. Be wary of what happens during CPU frequency scaling.</dd>
  <dt id="PERF_COUNT_HW_INSTRUCTIONS"><a class="permalink" href="#PERF_COUNT_HW_INSTRUCTIONS"><b>PERF_COUNT_HW_INSTRUCTIONS</b></a></dt>
  <dd>Retired instructions. Be careful, these can be affected by various issues,
      most notably hardware interrupt counts.</dd>
  <dt id="PERF_COUNT_HW_CACHE_REFERENCES"><a class="permalink" href="#PERF_COUNT_HW_CACHE_REFERENCES"><b>PERF_COUNT_HW_CACHE_REFERENCES</b></a></dt>
  <dd>Cache accesses. Usually this indicates Last Level Cache accesses but this
      may vary depending on your CPU. This may include prefetches and coherency
      messages; again this depends on the design of your CPU.</dd>
  <dt id="PERF_COUNT_HW_CACHE_MISSES"><a class="permalink" href="#PERF_COUNT_HW_CACHE_MISSES"><b>PERF_COUNT_HW_CACHE_MISSES</b></a></dt>
  <dd>Cache misses. Usually this indicates Last Level Cache misses; this is
      intended to be used in conjunction with the
      <b>PERF_COUNT_HW_CACHE_REFERENCES</b> event to calculate cache miss
    rates.</dd>
  <dt id="PERF_COUNT_HW_BRANCH_INSTRUCTIONS"><a class="permalink" href="#PERF_COUNT_HW_BRANCH_INSTRUCTIONS"><b>PERF_COUNT_HW_BRANCH_INSTRUCTIONS</b></a></dt>
  <dd>Retired branch instructions. Prior to Linux 2.6.35, this used the wrong
      event on AMD processors.</dd>
  <dt id="PERF_COUNT_HW_BRANCH_MISSES"><a class="permalink" href="#PERF_COUNT_HW_BRANCH_MISSES"><b>PERF_COUNT_HW_BRANCH_MISSES</b></a></dt>
  <dd>Mispredicted branch instructions.</dd>
  <dt id="PERF_COUNT_HW_BUS_CYCLES"><a class="permalink" href="#PERF_COUNT_HW_BUS_CYCLES"><b>PERF_COUNT_HW_BUS_CYCLES</b></a></dt>
  <dd>Bus cycles, which can be different from total cycles.</dd>
  <dt id="PERF_COUNT_HW_STALLED_CYCLES_FRONTEND"><a class="permalink" href="#PERF_COUNT_HW_STALLED_CYCLES_FRONTEND"><b>PERF_COUNT_HW_STALLED_CYCLES_FRONTEND</b>
    (since Linux 3.0)</a></dt>
  <dd>Stalled cycles during issue.</dd>
  <dt id="PERF_COUNT_HW_STALLED_CYCLES_BACKEND"><a class="permalink" href="#PERF_COUNT_HW_STALLED_CYCLES_BACKEND"><b>PERF_COUNT_HW_STALLED_CYCLES_BACKEND</b>
    (since Linux 3.0)</a></dt>
  <dd>Stalled cycles during retirement.</dd>
  <dt id="PERF_COUNT_HW_REF_CPU_CYCLES"><a class="permalink" href="#PERF_COUNT_HW_REF_CPU_CYCLES"><b>PERF_COUNT_HW_REF_CPU_CYCLES</b>
    (since Linux 3.3)</a></dt>
  <dd>Total cycles; not affected by CPU frequency scaling.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <i>type</i> is <b>PERF_TYPE_SOFTWARE</b>, we are measuring software
      events provided by the kernel. Set <i>config</i> to one of the
    following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_COUNT_SW_CPU_CLOCK"><a class="permalink" href="#PERF_COUNT_SW_CPU_CLOCK"><b>PERF_COUNT_SW_CPU_CLOCK</b></a></dt>
  <dd>This reports the CPU clock, a high-resolution per-CPU timer.</dd>
  <dt id="PERF_COUNT_SW_TASK_CLOCK"><a class="permalink" href="#PERF_COUNT_SW_TASK_CLOCK"><b>PERF_COUNT_SW_TASK_CLOCK</b></a></dt>
  <dd>This reports a clock count specific to the task that is running.</dd>
  <dt id="PERF_COUNT_SW_PAGE_FAULTS"><a class="permalink" href="#PERF_COUNT_SW_PAGE_FAULTS"><b>PERF_COUNT_SW_PAGE_FAULTS</b></a></dt>
  <dd>This reports the number of page faults.</dd>
  <dt id="PERF_COUNT_SW_CONTEXT_SWITCHES"><a class="permalink" href="#PERF_COUNT_SW_CONTEXT_SWITCHES"><b>PERF_COUNT_SW_CONTEXT_SWITCHES</b></a></dt>
  <dd>This counts context switches. Until Linux 2.6.34, these were all reported
      as user-space events, after that they are reported as happening in the
      kernel.</dd>
  <dt id="PERF_COUNT_SW_CPU_MIGRATIONS"><a class="permalink" href="#PERF_COUNT_SW_CPU_MIGRATIONS"><b>PERF_COUNT_SW_CPU_MIGRATIONS</b></a></dt>
  <dd>This reports the number of times the process has migrated to a new
    CPU.</dd>
  <dt id="PERF_COUNT_SW_PAGE_FAULTS_MIN"><a class="permalink" href="#PERF_COUNT_SW_PAGE_FAULTS_MIN"><b>PERF_COUNT_SW_PAGE_FAULTS_MIN</b></a></dt>
  <dd>This counts the number of minor page faults. These did not require disk
      I/O to handle.</dd>
  <dt id="PERF_COUNT_SW_PAGE_FAULTS_MAJ"><a class="permalink" href="#PERF_COUNT_SW_PAGE_FAULTS_MAJ"><b>PERF_COUNT_SW_PAGE_FAULTS_MAJ</b></a></dt>
  <dd>This counts the number of major page faults. These required disk I/O to
      handle.</dd>
  <dt id="PERF_COUNT_SW_ALIGNMENT_FAULTS"><a class="permalink" href="#PERF_COUNT_SW_ALIGNMENT_FAULTS"><b>PERF_COUNT_SW_ALIGNMENT_FAULTS</b>
    (since Linux 2.6.33)</a></dt>
  <dd>This counts the number of alignment faults. These happen when unaligned
      memory accesses happen; the kernel can handle these but it reduces
      performance. This happens only on some architectures (never on x86).</dd>
  <dt id="PERF_COUNT_SW_EMULATION_FAULTS"><a class="permalink" href="#PERF_COUNT_SW_EMULATION_FAULTS"><b>PERF_COUNT_SW_EMULATION_FAULTS</b>
    (since Linux 2.6.33)</a></dt>
  <dd>This counts the number of emulation faults. The kernel sometimes traps on
      unimplemented instructions and emulates them for user space. This can
      negatively impact performance.</dd>
  <dt id="PERF_COUNT_SW_DUMMY"><a class="permalink" href="#PERF_COUNT_SW_DUMMY"><b>PERF_COUNT_SW_DUMMY</b>
    (since Linux 3.12)</a></dt>
  <dd>This is a placeholder event that counts nothing. Informational sample
      record types such as mmap or comm must be associated with an active event.
      This dummy event allows gathering such records without requiring a
      counting event.</dd>
  <dt id="PERF_COUNT_SW_BPF_OUTPUT"><a class="permalink" href="#PERF_COUNT_SW_BPF_OUTPUT"><b>PERF_COUNT_SW_BPF_OUTPUT</b>
    (since Linux 4.4)</a></dt>
  <dd>This is used to generate raw sample data from BPF. BPF programs can write
      to this event using <b>bpf_perf_event_output</b> helper.</dd>
  <dt id="PERF_COUNT_SW_CGROUP_SWITCHES"><a class="permalink" href="#PERF_COUNT_SW_CGROUP_SWITCHES"><b>PERF_COUNT_SW_CGROUP_SWITCHES</b>
    (since Linux 5.13)</a></dt>
  <dd>This counts context switches to a task in a different cgroup. In other
      words, if the next task is in the same cgroup, it won't count the
    switch.</dd>
</dl>
</div>
<p class="Pp"></p>
<div class="Bd-indent">If <i>type</i> is <b>PERF_TYPE_TRACEPOINT</b>, then we
  are measuring kernel tracepoints. The value to use in <i>config</i> can be
  obtained from under debugfs <i>tracing/events/*/*/id</i> if ftrace is enabled
  in the kernel.</div>
<p class="Pp"></p>
<div class="Bd-indent">If <i>type</i> is <b>PERF_TYPE_HW_CACHE</b>, then we are
  measuring a hardware CPU cache event. To calculate the appropriate
  <i>config</i> value, use the following equation:
<div class="Bd-indent">
<p class="Pp">
  <br>
</p>
<pre>config = (perf_hw_cache_id) |
<br>
         (perf_hw_cache_op_id &lt;&lt; 8) |
<br>
         (perf_hw_cache_op_result_id &lt;&lt; 16);
</pre>
<br>
<p class="Pp">where <i>perf_hw_cache_id</i> is one of:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_COUNT_HW_CACHE_L1D"><a class="permalink" href="#PERF_COUNT_HW_CACHE_L1D"><b>PERF_COUNT_HW_CACHE_L1D</b></a></dt>
  <dd>for measuring Level 1 Data Cache</dd>
  <dt id="PERF_COUNT_HW_CACHE_L1I"><a class="permalink" href="#PERF_COUNT_HW_CACHE_L1I"><b>PERF_COUNT_HW_CACHE_L1I</b></a></dt>
  <dd>for measuring Level 1 Instruction Cache</dd>
  <dt id="PERF_COUNT_HW_CACHE_LL"><a class="permalink" href="#PERF_COUNT_HW_CACHE_LL"><b>PERF_COUNT_HW_CACHE_LL</b></a></dt>
  <dd>for measuring Last-Level Cache</dd>
  <dt id="PERF_COUNT_HW_CACHE_DTLB"><a class="permalink" href="#PERF_COUNT_HW_CACHE_DTLB"><b>PERF_COUNT_HW_CACHE_DTLB</b></a></dt>
  <dd>for measuring the Data TLB</dd>
  <dt id="PERF_COUNT_HW_CACHE_ITLB"><a class="permalink" href="#PERF_COUNT_HW_CACHE_ITLB"><b>PERF_COUNT_HW_CACHE_ITLB</b></a></dt>
  <dd>for measuring the Instruction TLB</dd>
  <dt id="PERF_COUNT_HW_CACHE_BPU"><a class="permalink" href="#PERF_COUNT_HW_CACHE_BPU"><b>PERF_COUNT_HW_CACHE_BPU</b></a></dt>
  <dd>for measuring the branch prediction unit</dd>
  <dt id="PERF_COUNT_HW_CACHE_NODE"><a class="permalink" href="#PERF_COUNT_HW_CACHE_NODE"><b>PERF_COUNT_HW_CACHE_NODE</b>
    (since Linux 3.1)</a></dt>
  <dd>for measuring local memory accesses</dd>
</dl>
</div>
<p class="Pp">and <i>perf_hw_cache_op_id</i> is one of:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_COUNT_HW_CACHE_OP_READ"><a class="permalink" href="#PERF_COUNT_HW_CACHE_OP_READ"><b>PERF_COUNT_HW_CACHE_OP_READ</b></a></dt>
  <dd>for read accesses</dd>
  <dt id="PERF_COUNT_HW_CACHE_OP_WRITE"><a class="permalink" href="#PERF_COUNT_HW_CACHE_OP_WRITE"><b>PERF_COUNT_HW_CACHE_OP_WRITE</b></a></dt>
  <dd>for write accesses</dd>
  <dt id="PERF_COUNT_HW_CACHE_OP_PREFETCH"><a class="permalink" href="#PERF_COUNT_HW_CACHE_OP_PREFETCH"><b>PERF_COUNT_HW_CACHE_OP_PREFETCH</b></a></dt>
  <dd>for prefetch accesses</dd>
</dl>
</div>
<p class="Pp">and <i>perf_hw_cache_op_result_id</i> is one of:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_COUNT_HW_CACHE_RESULT_ACCESS"><a class="permalink" href="#PERF_COUNT_HW_CACHE_RESULT_ACCESS"><b>PERF_COUNT_HW_CACHE_RESULT_ACCESS</b></a></dt>
  <dd>to measure accesses</dd>
  <dt id="PERF_COUNT_HW_CACHE_RESULT_MISS"><a class="permalink" href="#PERF_COUNT_HW_CACHE_RESULT_MISS"><b>PERF_COUNT_HW_CACHE_RESULT_MISS</b></a></dt>
  <dd>to measure misses</dd>
</dl>
</div>
</div>
<p class="Pp">If <i>type</i> is <b>PERF_TYPE_RAW</b>, then a custom
    "raw" <i>config</i> value is needed. Most CPUs support events that
    are not covered by the "generalized" events. These are
    implementation defined; see your CPU manual (for example the Intel Volume 3B
    documentation or the AMD BIOS and Kernel Developer Guide). The libpfm4
    library can be used to translate from the name in the architectural manuals
    to the raw hex value <b>perf_event_open</b>() expects in this field.</p>
<p class="Pp">If <i>type</i> is <b>PERF_TYPE_BREAKPOINT</b>, then leave
    <i>config</i> set to zero. Its parameters are set in other places.</p>
<p class="Pp">If <i>type</i> is <b>kprobe</b> or <b>uprobe</b>, set
    <i>retprobe</i> (bit 0 of <i>config</i>, see
    <i>/sys/bus/event_source/devices/[k,u]probe/format/retprobe</i>) for
    kretprobe/uretprobe. See fields <i>kprobe_func</i>, <i>uprobe_path</i>,
    <i>kprobe_addr</i>, and <i>probe_offset</i> for more details.</p>
</div>
<dl class="Bl-tag">
  <dt id="kprobe_func"><a class="permalink" href="#kprobe_func"><i>kprobe_func</i>,
    <i>uprobe_path</i>, <i>kprobe_addr</i>, and <i>probe_offset</i></a></dt>
  <dd>These fields describe the kprobe/uprobe for dynamic PMUs <b>kprobe</b> and
      <b>uprobe</b>. For <b>kprobe</b>: use <i>kprobe_func</i> and
      <i>probe_offset</i>, or use <i>kprobe_addr</i> and leave
      <i>kprobe_func</i> as NULL. For <b>uprobe</b>: use <i>uprobe_path</i> and
      <i>probe_offset</i>.</dd>
  <dt id="sample_period"><a class="permalink" href="#sample_period"><i>sample_period</i>,
    <i>sample_freq</i></a></dt>
  <dd>A "sampling" event is one that generates an overflow
      notification every N events, where N is given by <i>sample_period</i>. A
      sampling event has <i>sample_period</i> &gt; 0. When an overflow occurs,
      requested data is recorded in the mmap buffer. The <i>sample_type</i>
      field controls what data is recorded on each overflow.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><i>sample_freq</i> can be used if you wish to use frequency rather than
      period. In this case, you set the <i>freq</i> flag. The kernel will adjust
      the sampling period to try and achieve the desired rate. The rate of
      adjustment is a timer tick.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="sample_type"><a class="permalink" href="#sample_type"><i>sample_type</i></a></dt>
  <dd>The various bits in this field specify which values to include in the
      sample. They will be recorded in a ring-buffer, which is available to user
      space using <b>mmap</b>(2). The order in which the values are saved in the
      sample are documented in the MMAP Layout subsection below; it is not the
      <i>enum perf_event_sample_format</i> order.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_IP"><a class="permalink" href="#PERF_SAMPLE_IP"><b>PERF_SAMPLE_IP</b></a></dt>
  <dd>Records instruction pointer.</dd>
  <dt id="PERF_SAMPLE_TID"><a class="permalink" href="#PERF_SAMPLE_TID"><b>PERF_SAMPLE_TID</b></a></dt>
  <dd>Records the process and thread IDs.</dd>
  <dt id="PERF_SAMPLE_TIME"><a class="permalink" href="#PERF_SAMPLE_TIME"><b>PERF_SAMPLE_TIME</b></a></dt>
  <dd>Records a timestamp.</dd>
  <dt id="PERF_SAMPLE_ADDR"><a class="permalink" href="#PERF_SAMPLE_ADDR"><b>PERF_SAMPLE_ADDR</b></a></dt>
  <dd>Records an address, if applicable.</dd>
  <dt id="PERF_SAMPLE_READ"><a class="permalink" href="#PERF_SAMPLE_READ"><b>PERF_SAMPLE_READ</b></a></dt>
  <dd>Record counter values for all events in a group, not just the group
      leader.</dd>
  <dt id="PERF_SAMPLE_CALLCHAIN"><a class="permalink" href="#PERF_SAMPLE_CALLCHAIN"><b>PERF_SAMPLE_CALLCHAIN</b></a></dt>
  <dd>Records the callchain (stack backtrace).</dd>
  <dt id="PERF_SAMPLE_ID"><a class="permalink" href="#PERF_SAMPLE_ID"><b>PERF_SAMPLE_ID</b></a></dt>
  <dd>Records a unique ID for the opened event's group leader.</dd>
  <dt id="PERF_SAMPLE_CPU"><a class="permalink" href="#PERF_SAMPLE_CPU"><b>PERF_SAMPLE_CPU</b></a></dt>
  <dd>Records CPU number.</dd>
  <dt id="PERF_SAMPLE_PERIOD"><a class="permalink" href="#PERF_SAMPLE_PERIOD"><b>PERF_SAMPLE_PERIOD</b></a></dt>
  <dd>Records the current sampling period.</dd>
  <dt id="PERF_SAMPLE_STREAM_ID"><a class="permalink" href="#PERF_SAMPLE_STREAM_ID"><b>PERF_SAMPLE_STREAM_ID</b></a></dt>
  <dd>Records a unique ID for the opened event. Unlike <b>PERF_SAMPLE_ID</b> the
      actual ID is returned, not the group leader. This ID is the same as the
      one returned by <b>PERF_FORMAT_ID</b>.</dd>
  <dt id="PERF_SAMPLE_RAW"><a class="permalink" href="#PERF_SAMPLE_RAW"><b>PERF_SAMPLE_RAW</b></a></dt>
  <dd>Records additional data, if applicable. Usually returned by tracepoint
      events.</dd>
  <dt id="PERF_SAMPLE_BRANCH_STACK"><a class="permalink" href="#PERF_SAMPLE_BRANCH_STACK"><b>PERF_SAMPLE_BRANCH_STACK</b>
    (since Linux 3.4)</a></dt>
  <dd>This provides a record of recent branches, as provided by CPU branch
      sampling hardware (such as Intel Last Branch Record). Not all hardware
      supports this feature.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>See the <i>branch_sample_type</i> field for how to filter which branches
      are reported.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_REGS_USER"><a class="permalink" href="#PERF_SAMPLE_REGS_USER"><b>PERF_SAMPLE_REGS_USER</b>
    (since Linux 3.7)</a></dt>
  <dd>Records the current user-level CPU register state (the values in the
      process before the kernel was called).</dd>
  <dt id="PERF_SAMPLE_STACK_USER"><a class="permalink" href="#PERF_SAMPLE_STACK_USER"><b>PERF_SAMPLE_STACK_USER</b>
    (since Linux 3.7)</a></dt>
  <dd>Records the user level stack, allowing stack unwinding.</dd>
  <dt id="PERF_SAMPLE_WEIGHT"><a class="permalink" href="#PERF_SAMPLE_WEIGHT"><b>PERF_SAMPLE_WEIGHT</b>
    (since Linux 3.10)</a></dt>
  <dd>Records a hardware provided weight value that expresses how costly the
      sampled event was. This allows the hardware to highlight expensive events
      in a profile.</dd>
  <dt id="PERF_SAMPLE_DATA_SRC"><a class="permalink" href="#PERF_SAMPLE_DATA_SRC"><b>PERF_SAMPLE_DATA_SRC</b>
    (since Linux 3.10)</a></dt>
  <dd>Records the data source: where in the memory hierarchy the data associated
      with the sampled instruction came from. This is available only if the
      underlying hardware supports this feature.</dd>
  <dt id="PERF_SAMPLE_IDENTIFIER"><a class="permalink" href="#PERF_SAMPLE_IDENTIFIER"><b>PERF_SAMPLE_IDENTIFIER</b>
    (since Linux 3.12)</a></dt>
  <dd>Places the <b>SAMPLE_ID</b> value in a fixed position in the record,
      either at the beginning (for sample events) or at the end (if a non-sample
      event).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This was necessary because a sample stream may have records from various
      different event sources with different <i>sample_type</i> settings.
      Parsing the event stream properly was not possible because the format of
      the record was needed to find <b>SAMPLE_ID</b>, but the format could not
      be found without knowing what event the sample belonged to (causing a
      circular dependency).</dd>
  <dt></dt>
  <dd>The <b>PERF_SAMPLE_IDENTIFIER</b> setting makes the event stream always
      parsable by putting <b>SAMPLE_ID</b> in a fixed location, even though it
      means having duplicate <b>SAMPLE_ID</b> values in records.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_TRANSACTION"><a class="permalink" href="#PERF_SAMPLE_TRANSACTION"><b>PERF_SAMPLE_TRANSACTION</b>
    (since Linux 3.13)</a></dt>
  <dd>Records reasons for transactional memory abort events (for example, from
      Intel TSX transactional memory support).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>precise_ip</i> setting must be greater than 0 and a transactional
      memory abort event must be measured or no values will be recorded. Also
      note that some perf_event measurements, such as sampled cycle counting,
      may cause extraneous aborts (by causing an interrupt during a
      transaction).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_REGS_INTR"><a class="permalink" href="#PERF_SAMPLE_REGS_INTR"><b>PERF_SAMPLE_REGS_INTR</b>
    (since Linux 3.19)</a></dt>
  <dd>Records a subset of the current CPU register state as specified by
      <i>sample_regs_intr</i>. Unlike <b>PERF_SAMPLE_REGS_USER</b> the register
      values will return kernel register state if the overflow happened while
      kernel code is running. If the CPU supports hardware sampling of register
      state (i.e., PEBS on Intel x86) and <i>precise_ip</i> is set higher than
      zero then the register values returned are those captured by hardware at
      the time of the sampled instruction's retirement.</dd>
  <dt id="PERF_SAMPLE_PHYS_ADDR"><a class="permalink" href="#PERF_SAMPLE_PHYS_ADDR"><b>PERF_SAMPLE_PHYS_ADDR</b>
    (since Linux 4.13)</a></dt>
  <dd>Records physical address of data like in <b>PERF_SAMPLE_ADDR</b>.</dd>
  <dt id="PERF_SAMPLE_CGROUP"><a class="permalink" href="#PERF_SAMPLE_CGROUP"><b>PERF_SAMPLE_CGROUP</b>
    (since Linux 5.7)</a></dt>
  <dd>Records (perf_event) cgroup ID of the process. This corresponds to the
      <i>id</i> field in the <b>PERF_RECORD_CGROUP</b> event.</dd>
  <dt id="PERF_SAMPLE_DATA_PAGE_SIZE"><a class="permalink" href="#PERF_SAMPLE_DATA_PAGE_SIZE"><b>PERF_SAMPLE_DATA_PAGE_SIZE</b>
    (since Linux 5.11)</a></dt>
  <dd>Records page size of data like in <b>PERF_SAMPLE_ADDR</b>.</dd>
  <dt id="PERF_SAMPLE_CODE_PAGE_SIZE"><a class="permalink" href="#PERF_SAMPLE_CODE_PAGE_SIZE"><b>PERF_SAMPLE_CODE_PAGE_SIZE</b>
    (since Linux 5.11)</a></dt>
  <dd>Records page size of ip like in <b>PERF_SAMPLE_IP</b>.</dd>
  <dt id="PERF_SAMPLE_WEIGHT_STRUCT"><a class="permalink" href="#PERF_SAMPLE_WEIGHT_STRUCT"><b>PERF_SAMPLE_WEIGHT_STRUCT</b>
    (since Linux 5.12)</a></dt>
  <dd>Records hardware provided weight values like in <b>PERF_SAMPLE_WEIGHT</b>,
      but it can represent multiple values in a struct. This shares the same
      space as <b>PERF_SAMPLE_WEIGHT</b>, so users can apply either of those,
      not both. It has the following format and the meaning of each field is
      dependent on the hardware implementation.</dd>
</dl>
<p class="Pp">
  <br>
</p>
<pre>union perf_sample_weight {
<br>
    u64  full;           /* PERF_SAMPLE_WEIGHT */
<br>
    struct {             /* PERF_SAMPLE_WEIGHT_STRUCT */
<br>
        u32  var1_dw;
<br>
        u16  var2_w;
<br>
        u16  var3_w;
<br>
    };
};
</pre>
<br>
</div>
<dl class="Bl-tag">
  <dt id="read_format"><a class="permalink" href="#read_format"><i>read_format</i></a></dt>
  <dd>This field specifies the format of the data returned by <b>read</b>(2) on
      a <b>perf_event_open</b>() file descriptor.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_FORMAT_TOTAL_TIME_ENABLED"><a class="permalink" href="#PERF_FORMAT_TOTAL_TIME_ENABLED"><b>PERF_FORMAT_TOTAL_TIME_ENABLED</b></a></dt>
  <dd>Adds the 64-bit <i>time_enabled</i> field. This can be used to calculate
      estimated totals if the PMU is overcommitted and multiplexing is
      happening.</dd>
  <dt id="PERF_FORMAT_TOTAL_TIME_RUNNING"><a class="permalink" href="#PERF_FORMAT_TOTAL_TIME_RUNNING"><b>PERF_FORMAT_TOTAL_TIME_RUNNING</b></a></dt>
  <dd>Adds the 64-bit <i>time_running</i> field. This can be used to calculate
      estimated totals if the PMU is overcommitted and multiplexing is
      happening.</dd>
  <dt id="PERF_FORMAT_ID"><a class="permalink" href="#PERF_FORMAT_ID"><b>PERF_FORMAT_ID</b></a></dt>
  <dd>Adds a 64-bit unique value that corresponds to the event group.</dd>
  <dt id="PERF_FORMAT_GROUP"><a class="permalink" href="#PERF_FORMAT_GROUP"><b>PERF_FORMAT_GROUP</b></a></dt>
  <dd>Allows all counter values in an event group to be read with one read.</dd>
  <dt id="PERF_FORMAT_LOST"><a class="permalink" href="#PERF_FORMAT_LOST"><b>PERF_FORMAT_LOST
    (since Linux 6.0)</b></a></dt>
  <dd>Adds a 64-bit value that is the number of lost samples for this event.
      This would be only meaningful when <i>sample_period</i> or
      <i>sample_freq</i> is set.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="disabled"><a class="permalink" href="#disabled"><i>disabled</i></a></dt>
  <dd>The <i>disabled</i> bit specifies whether the counter starts out disabled
      or enabled. If disabled, the event can later be enabled by
      <b>ioctl</b>(2), <b>prctl</b>(2), or <i>enable_on_exec</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When creating an event group, typically the group leader is initialized
      with <i>disabled</i> set to 1 and any child events are initialized with
      <i>disabled</i> set to 0. Despite <i>disabled</i> being 0, the child
      events will not start until the group leader is enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="inherit"><a class="permalink" href="#inherit"><i>inherit</i></a></dt>
  <dd>The <i>inherit</i> bit specifies that this counter should count events of
      child tasks as well as the task specified. This applies only to new
      children, not to any existing children at the time the counter is created
      (nor to any new children of existing children).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Inherit does not work for some combinations of <i>read_format</i> values,
      such as <b>PERF_FORMAT_GROUP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="pinned"><a class="permalink" href="#pinned"><i>pinned</i></a></dt>
  <dd>The <i>pinned</i> bit specifies that the counter should always be on the
      CPU if at all possible. It applies only to hardware counters and only to
      group leaders. If a pinned counter cannot be put onto the CPU (e.g.,
      because there are not enough hardware counters or because of a conflict
      with some other event), then the counter goes into an 'error' state, where
      reads return end-of-file (i.e., <b>read</b>(2) returns 0) until the
      counter is subsequently enabled or disabled.</dd>
  <dt id="exclusive"><a class="permalink" href="#exclusive"><i>exclusive</i></a></dt>
  <dd>The <i>exclusive</i> bit specifies that when this counter's group is on
      the CPU, it should be the only group using the CPU's counters. In the
      future this may allow monitoring programs to support PMU features that
      need to run alone so that they do not disrupt other hardware
    counters.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that many unexpected situations may prevent events with the
      <i>exclusive</i> bit set from ever running. This includes any users
      running a system-wide measurement as well as any kernel use of the
      performance counters (including the commonly enabled NMI Watchdog Timer
      interface).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="exclude_user"><a class="permalink" href="#exclude_user"><i>exclude_user</i></a></dt>
  <dd>If this bit is set, the count excludes events that happen in user
    space.</dd>
  <dt id="exclude_kernel"><a class="permalink" href="#exclude_kernel"><i>exclude_kernel</i></a></dt>
  <dd>If this bit is set, the count excludes events that happen in kernel
    space.</dd>
  <dt id="exclude_hv"><a class="permalink" href="#exclude_hv"><i>exclude_hv</i></a></dt>
  <dd>If this bit is set, the count excludes events that happen in the
      hypervisor. This is mainly for PMUs that have built-in support for
      handling this (such as POWER). Extra support is needed for handling
      hypervisor measurements on most machines.</dd>
  <dt id="exclude_idle"><a class="permalink" href="#exclude_idle"><i>exclude_idle</i></a></dt>
  <dd>If set, don't count when the CPU is running the idle task. While you can
      currently enable this for any event type, it is ignored for all but
      software events.</dd>
  <dt id="mmap"><a class="permalink" href="#mmap"><i>mmap</i></a></dt>
  <dd>The <i>mmap</i> bit enables generation of <b>PERF_RECORD_MMAP</b> samples
      for every <b>mmap</b>(2) call that has <b>PROT_EXEC</b> set. This allows
      tools to notice new executable code being mapped into a program (dynamic
      shared libraries for example) so that addresses can be mapped back to the
      original code.</dd>
  <dt id="comm"><a class="permalink" href="#comm"><i>comm</i></a></dt>
  <dd>The <i>comm</i> bit enables tracking of process command name as modified
      by the <b>execve</b>(2) and <b>prctl</b>(PR_SET_NAME) system calls as well
      as writing to <i>/proc/self/comm</i>. If the <i>comm_exec</i> flag is also
      successfully set (possible since Linux 3.16), then the misc flag
      <b>PERF_RECORD_MISC_COMM_EXEC</b> can be used to differentiate the
      <b>execve</b>(2) case from the others.</dd>
  <dt id="freq"><a class="permalink" href="#freq"><i>freq</i></a></dt>
  <dd>If this bit is set, then <i>sample_frequency</i> not <i>sample_period</i>
      is used when setting up the sampling interval.</dd>
  <dt id="inherit_stat"><a class="permalink" href="#inherit_stat"><i>inherit_stat</i></a></dt>
  <dd>This bit enables saving of event counts on context switch for inherited
      tasks. This is meaningful only if the <i>inherit</i> field is set.</dd>
  <dt id="enable_on_exec"><a class="permalink" href="#enable_on_exec"><i>enable_on_exec</i></a></dt>
  <dd>If this bit is set, a counter is automatically enabled after a call to
      <b>execve</b>(2).</dd>
  <dt id="task"><a class="permalink" href="#task"><i>task</i></a></dt>
  <dd>If this bit is set, then fork/exit notifications are included in the ring
      buffer.</dd>
  <dt id="watermark"><a class="permalink" href="#watermark"><i>watermark</i></a></dt>
  <dd>If set, have an overflow notification happen when we cross the
      <i>wakeup_watermark</i> boundary. Otherwise, overflow notifications happen
      after <i>wakeup_events</i> samples.</dd>
  <dt id="precise_ip"><a class="permalink" href="#precise_ip"><i>precise_ip</i>
    (since Linux 2.6.35)</a></dt>
  <dd>This controls the amount of skid. Skid is how many instructions execute
      between an event of interest happening and the kernel being able to stop
      and record the event. Smaller skid is better and allows more accurate
      reporting of which events correspond to which instructions, but hardware
      is often limited with how small this can be.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The possible values of this field are the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd><b>SAMPLE_IP</b> can have arbitrary skid.</dd>
  <dt><b>1</b></dt>
  <dd><b>SAMPLE_IP</b> must have constant skid.</dd>
  <dt><b>2</b></dt>
  <dd><b>SAMPLE_IP</b> requested to have 0 skid.</dd>
  <dt><b>3</b></dt>
  <dd><b>SAMPLE_IP</b> must have 0 skid. See also the description of
      <b>PERF_RECORD_MISC_EXACT_IP</b>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="mmap_data"><a class="permalink" href="#mmap_data"><i>mmap_data</i>
    (since Linux 2.6.36)</a></dt>
  <dd>This is the counterpart of the <i>mmap</i> field. This enables generation
      of <b>PERF_RECORD_MMAP</b> samples for <b>mmap</b>(2) calls that do not
      have <b>PROT_EXEC</b> set (for example data and SysV shared memory).</dd>
  <dt id="sample_id_all"><a class="permalink" href="#sample_id_all"><i>sample_id_all</i>
    (since Linux 2.6.38)</a></dt>
  <dd>If set, then TID, TIME, ID, STREAM_ID, and CPU can additionally be
      included in non-<b>PERF_RECORD_SAMPLE</b>s if the corresponding
      <i>sample_type</i> is selected.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <b>PERF_SAMPLE_IDENTIFIER</b> is specified, then an additional ID value
      is included as the last value to ease parsing the record stream. This may
      lead to the <i>id</i> value appearing twice.</dd>
  <dt></dt>
  <dd>The layout is described by this pseudo-structure:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>struct sample_id {
<br>
    { u32 pid, tid; }   /* if PERF_SAMPLE_TID set */
<br>
    { u64 time;     }   /* if PERF_SAMPLE_TIME set */
<br>
    { u64 id;       }   /* if PERF_SAMPLE_ID set */
<br>
    { u64 stream_id;}   /* if PERF_SAMPLE_STREAM_ID set  */
<br>
    { u32 cpu, res; }   /* if PERF_SAMPLE_CPU set */
<br>
    { u64 id;       }   /* if PERF_SAMPLE_IDENTIFIER set */
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="exclude_host"><a class="permalink" href="#exclude_host"><i>exclude_host</i>
    (since Linux 3.2)</a></dt>
  <dd>When conducting measurements that include processes running VM instances
      (i.e., have executed a <b>KVM_RUN</b> <b>ioctl</b>(2)), only measure
      events happening inside a guest instance. This is only meaningful outside
      the guests; this setting does not change counts gathered inside of a
      guest. Currently, this functionality is x86 only.</dd>
  <dt id="exclude_guest"><a class="permalink" href="#exclude_guest"><i>exclude_guest</i>
    (since Linux 3.2)</a></dt>
  <dd>When conducting measurements that include processes running VM instances
      (i.e., have executed a <b>KVM_RUN</b> <b>ioctl</b>(2)), do not measure
      events happening inside guest instances. This is only meaningful outside
      the guests; this setting does not change counts gathered inside of a
      guest. Currently, this functionality is x86 only.</dd>
  <dt id="exclude_callchain_kernel"><a class="permalink" href="#exclude_callchain_kernel"><i>exclude_callchain_kernel</i>
    (since Linux 3.7)</a></dt>
  <dd>Do not include kernel callchains.</dd>
  <dt id="exclude_callchain_user"><a class="permalink" href="#exclude_callchain_user"><i>exclude_callchain_user</i>
    (since Linux 3.7)</a></dt>
  <dd>Do not include user callchains.</dd>
  <dt id="mmap2"><a class="permalink" href="#mmap2"><i>mmap2</i> (since Linux
    3.16)</a></dt>
  <dd>Generate an extended executable mmap record that contains enough
      additional information to uniquely identify shared mappings. The
      <i>mmap</i> flag must also be set for this to work.</dd>
  <dt id="comm_exec"><a class="permalink" href="#comm_exec"><i>comm_exec</i>
    (since Linux 3.16)</a></dt>
  <dd>This is purely a feature-detection flag, it does not change kernel
      behavior. If this flag can successfully be set, then, when <i>comm</i> is
      enabled, the <b>PERF_RECORD_MISC_COMM_EXEC</b> flag will be set in the
      <i>misc</i> field of a comm record header if the rename event being
      reported was caused by a call to <b>execve</b>(2). This allows tools to
      distinguish between the various types of process renaming.</dd>
  <dt id="use_clockid"><a class="permalink" href="#use_clockid"><i>use_clockid</i>
    (since Linux 4.1)</a></dt>
  <dd>This allows selecting which internal Linux clock to use when generating
      timestamps via the <i>clockid</i> field. This can make it easier to
      correlate perf sample times with timestamps generated by other tools.</dd>
  <dt id="context_switch"><a class="permalink" href="#context_switch"><i>context_switch</i>
    (since Linux 4.3)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_SWITCH</b> records when a
      context switch occurs. It also enables the generation of
      <b>PERF_RECORD_SWITCH_CPU_WIDE</b> records when sampling in CPU-wide mode.
      This functionality is in addition to existing tracepoint and software
      events for measuring context switches. The advantage of this method is
      that it will give full information even with strict
      <i>perf_event_paranoid</i> settings.</dd>
  <dt id="write_backward"><a class="permalink" href="#write_backward"><i>write_backward</i>
    (since Linux 4.6)</a></dt>
  <dd>This causes the ring buffer to be written from the end to the beginning.
      This is to support reading from overwritable ring buffer.</dd>
  <dt id="namespaces"><a class="permalink" href="#namespaces"><i>namespaces</i>
    (since Linux 4.11)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_NAMESPACES</b> records when
      a task enters a new namespace. Each namespace has a combination of device
      and inode numbers.</dd>
  <dt id="ksymbol"><a class="permalink" href="#ksymbol"><i>ksymbol</i> (since
    Linux 5.0)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_KSYMBOL</b> records when new
      kernel symbols are registered or unregistered. This is analyzing dynamic
      kernel functions like eBPF.</dd>
  <dt id="bpf_event"><a class="permalink" href="#bpf_event"><i>bpf_event</i>
    (since Linux 5.0)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_BPF_EVENT</b> records when
      an eBPF program is loaded or unloaded.</dd>
  <dt id="aux_output"><a class="permalink" href="#aux_output"><i>aux_output</i>
    (since Linux 5.4)</a></dt>
  <dd>This allows normal (non-AUX) events to generate data for AUX events if the
      hardware supports it.</dd>
  <dt id="cgroup"><a class="permalink" href="#cgroup"><i>cgroup</i> (since Linux
    5.7)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_CGROUP</b> records when a
      new cgroup is created (and activated).</dd>
  <dt id="text_poke"><a class="permalink" href="#text_poke"><i>text_poke</i>
    (since Linux 5.8)</a></dt>
  <dd>This enables the generation of <b>PERF_RECORD_TEXT_POKE</b> records when
      there's a change to the kernel text (i.e., self-modifying code).</dd>
  <dt id="build_id"><a class="permalink" href="#build_id"><i>build_id</i> (since
    Linux 5.12)</a></dt>
  <dd>This changes the contents in the <b>PERF_RECORD_MMAP2</b> to have a
      build-id instead of device and inode numbers.</dd>
  <dt id="inherit_thread"><a class="permalink" href="#inherit_thread"><i>inherit_thread</i>
    (since Linux 5.13)</a></dt>
  <dd>This disables the inheritance of the event to a child process. Only new
      threads in the same process (which is cloned with <b>CLONE_THREAD</b>)
      will inherit the event.</dd>
  <dt id="remove_on_exec"><a class="permalink" href="#remove_on_exec"><i>remove_on_exec</i>
    (since Linux 5.13)</a></dt>
  <dd>This closes the event when it starts a new process image by
      <b>execve</b>(2).</dd>
  <dt id="sigtrap"><a class="permalink" href="#sigtrap"><i>sigtrap</i> (since
    Linux 5.13)</a></dt>
  <dd>This enables synchronous signal delivery of <b>SIGTRAP</b> on event
      overflow.</dd>
  <dt id="wakeup_events"><a class="permalink" href="#wakeup_events"><i>wakeup_events</i>,
    <i>wakeup_watermark</i></a></dt>
  <dd>This union sets how many samples (<i>wakeup_events</i>) or bytes
      (<i>wakeup_watermark</i>) happen before an overflow notification happens.
      Which one is used is selected by the <i>watermark</i> bit flag.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><i>wakeup_events</i> counts only <b>PERF_RECORD_SAMPLE</b> record types.
      To receive overflow notification for all <b>PERF_RECORD</b> types choose
      watermark and set <i>wakeup_watermark</i> to 1.</dd>
  <dt></dt>
  <dd>Prior to Linux 3.0, setting <i>wakeup_events</i> to 0 resulted in no
      overflow notifications; more recent kernels treat 0 the same as 1.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="bp_type"><a class="permalink" href="#bp_type"><i>bp_type</i> (since
    Linux 2.6.33)</a></dt>
  <dd>This chooses the breakpoint type. It is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="HW_BREAKPOINT_EMPTY"><a class="permalink" href="#HW_BREAKPOINT_EMPTY"><b>HW_BREAKPOINT_EMPTY</b></a></dt>
  <dd>No breakpoint.</dd>
  <dt id="HW_BREAKPOINT_R"><a class="permalink" href="#HW_BREAKPOINT_R"><b>HW_BREAKPOINT_R</b></a></dt>
  <dd>Count when we read the memory location.</dd>
  <dt id="HW_BREAKPOINT_W"><a class="permalink" href="#HW_BREAKPOINT_W"><b>HW_BREAKPOINT_W</b></a></dt>
  <dd>Count when we write the memory location.</dd>
  <dt id="HW_BREAKPOINT_RW"><a class="permalink" href="#HW_BREAKPOINT_RW"><b>HW_BREAKPOINT_RW</b></a></dt>
  <dd>Count when we read or write the memory location.</dd>
  <dt id="HW_BREAKPOINT_X"><a class="permalink" href="#HW_BREAKPOINT_X"><b>HW_BREAKPOINT_X</b></a></dt>
  <dd>Count when we execute code at the memory location.</dd>
</dl>
<p class="Pp">The values can be combined via a bitwise or, but the combination
    of <b>HW_BREAKPOINT_R</b> or <b>HW_BREAKPOINT_W</b> with
    <b>HW_BREAKPOINT_X</b> is not allowed.</p>
</div>
<dl class="Bl-tag">
  <dt id="bp_addr"><a class="permalink" href="#bp_addr"><i>bp_addr</i> (since
    Linux 2.6.33)</a></dt>
  <dd>This is the address of the breakpoint. For execution breakpoints, this is
      the memory address of the instruction of interest; for read and write
      breakpoints, it is the memory address of the memory location of
    interest.</dd>
  <dt id="config1"><a class="permalink" href="#config1"><i>config1</i> (since
    Linux 2.6.39)</a></dt>
  <dd><i>config1</i> is used for setting events that need an extra register or
      otherwise do not fit in the regular config field. Raw OFFCORE_EVENTS on
      Nehalem/Westmere/SandyBridge use this field on Linux 3.3 and later
      kernels.</dd>
  <dt id="bp_len"><a class="permalink" href="#bp_len"><i>bp_len</i> (since Linux
    2.6.33)</a></dt>
  <dd><i>bp_len</i> is the length of the breakpoint being measured if
      <i>type</i> is <b>PERF_TYPE_BREAKPOINT</b>. Options are
      <b>HW_BREAKPOINT_LEN_1</b>, <b>HW_BREAKPOINT_LEN_2</b>,
      <b>HW_BREAKPOINT_LEN_4</b>, and <b>HW_BREAKPOINT_LEN_8</b>. For an
      execution breakpoint, set this to <i>sizeof(long)</i>.</dd>
  <dt id="config2"><a class="permalink" href="#config2"><i>config2</i> (since
    Linux 2.6.39)</a></dt>
  <dd><i>config2</i> is a further extension of the <i>config1</i> field.</dd>
  <dt id="branch_sample_type"><a class="permalink" href="#branch_sample_type"><i>branch_sample_type</i>
    (since Linux 3.4)</a></dt>
  <dd>If <b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then this specifies what
      branches to include in the branch record.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The first part of the value is the privilege level, which is a combination
      of one of the values listed below. If the user does not set privilege
      level explicitly, the kernel will use the event's privilege level. Event
      and branch privilege levels do not have to match.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_BRANCH_USER"><a class="permalink" href="#PERF_SAMPLE_BRANCH_USER"><b>PERF_SAMPLE_BRANCH_USER</b></a></dt>
  <dd>Branch target is in user space.</dd>
  <dt id="PERF_SAMPLE_BRANCH_KERNEL"><a class="permalink" href="#PERF_SAMPLE_BRANCH_KERNEL"><b>PERF_SAMPLE_BRANCH_KERNEL</b></a></dt>
  <dd>Branch target is in kernel space.</dd>
  <dt id="PERF_SAMPLE_BRANCH_HV"><a class="permalink" href="#PERF_SAMPLE_BRANCH_HV"><b>PERF_SAMPLE_BRANCH_HV</b></a></dt>
  <dd>Branch target is in hypervisor.</dd>
  <dt id="PERF_SAMPLE_BRANCH_PLM_ALL"><a class="permalink" href="#PERF_SAMPLE_BRANCH_PLM_ALL"><b>PERF_SAMPLE_BRANCH_PLM_ALL</b></a></dt>
  <dd>A convenience value that is the three preceding values ORed together.</dd>
</dl>
<p class="Pp">In addition to the privilege value, at least one or more of the
    following bits must be set.</p>
<dl class="Bl-tag">
  <dt id="PERF_SAMPLE_BRANCH_ANY"><a class="permalink" href="#PERF_SAMPLE_BRANCH_ANY"><b>PERF_SAMPLE_BRANCH_ANY</b></a></dt>
  <dd>Any branch type.</dd>
  <dt id="PERF_SAMPLE_BRANCH_ANY_CALL"><a class="permalink" href="#PERF_SAMPLE_BRANCH_ANY_CALL"><b>PERF_SAMPLE_BRANCH_ANY_CALL</b></a></dt>
  <dd>Any call branch (includes direct calls, indirect calls, and far
    jumps).</dd>
  <dt id="PERF_SAMPLE_BRANCH_IND_CALL"><a class="permalink" href="#PERF_SAMPLE_BRANCH_IND_CALL"><b>PERF_SAMPLE_BRANCH_IND_CALL</b></a></dt>
  <dd>Indirect calls.</dd>
  <dt id="PERF_SAMPLE_BRANCH_CALL"><a class="permalink" href="#PERF_SAMPLE_BRANCH_CALL"><b>PERF_SAMPLE_BRANCH_CALL</b>
    (since Linux 4.4)</a></dt>
  <dd>Direct calls.</dd>
  <dt id="PERF_SAMPLE_BRANCH_ANY_RETURN"><a class="permalink" href="#PERF_SAMPLE_BRANCH_ANY_RETURN"><b>PERF_SAMPLE_BRANCH_ANY_RETURN</b></a></dt>
  <dd>Any return branch.</dd>
  <dt id="PERF_SAMPLE_BRANCH_IND_JUMP"><a class="permalink" href="#PERF_SAMPLE_BRANCH_IND_JUMP"><b>PERF_SAMPLE_BRANCH_IND_JUMP</b>
    (since Linux 4.2)</a></dt>
  <dd>Indirect jumps.</dd>
  <dt id="PERF_SAMPLE_BRANCH_COND"><a class="permalink" href="#PERF_SAMPLE_BRANCH_COND"><b>PERF_SAMPLE_BRANCH_COND</b>
    (since Linux 3.16)</a></dt>
  <dd>Conditional branches.</dd>
  <dt id="PERF_SAMPLE_BRANCH_ABORT_TX"><a class="permalink" href="#PERF_SAMPLE_BRANCH_ABORT_TX"><b>PERF_SAMPLE_BRANCH_ABORT_TX</b>
    (since Linux 3.11)</a></dt>
  <dd>Transactional memory aborts.</dd>
  <dt id="PERF_SAMPLE_BRANCH_IN_TX"><a class="permalink" href="#PERF_SAMPLE_BRANCH_IN_TX"><b>PERF_SAMPLE_BRANCH_IN_TX</b>
    (since Linux 3.11)</a></dt>
  <dd>Branch in transactional memory transaction.</dd>
  <dt id="PERF_SAMPLE_BRANCH_NO_TX"><a class="permalink" href="#PERF_SAMPLE_BRANCH_NO_TX"><b>PERF_SAMPLE_BRANCH_NO_TX</b>
    (since Linux 3.11)</a></dt>
  <dd>Branch not in transactional memory transaction.
      <b>PERF_SAMPLE_BRANCH_CALL_STACK</b> (since Linux 4.1) Branch is part of a
      hardware-generated call stack. This requires hardware support, currently
      only found on Intel x86 Haswell or newer.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="sample_regs_user"><a class="permalink" href="#sample_regs_user"><i>sample_regs_user</i>
    (since Linux 3.7)</a></dt>
  <dd>This bit mask defines the set of user CPU registers to dump on samples.
      The layout of the register mask is architecture-specific and is described
      in the kernel header file
    <i>arch/ARCH/include/uapi/asm/perf_regs.h</i>.</dd>
  <dt id="sample_stack_user"><a class="permalink" href="#sample_stack_user"><i>sample_stack_user</i>
    (since Linux 3.7)</a></dt>
  <dd>This defines the size of the user stack to dump if
      <b>PERF_SAMPLE_STACK_USER</b> is specified.</dd>
  <dt id="clockid"><a class="permalink" href="#clockid"><i>clockid</i> (since
    Linux 4.1)</a></dt>
  <dd>If <i>use_clockid</i> is set, then this field selects which internal Linux
      timer to use for timestamps. The available timers are defined in
      <i>linux/time.h</i>, with <b>CLOCK_MONOTONIC</b>,
      <b>CLOCK_MONOTONIC_RAW</b>, <b>CLOCK_REALTIME</b>, <b>CLOCK_BOOTTIME</b>,
      and <b>CLOCK_TAI</b> currently supported.</dd>
  <dt id="aux_watermark"><a class="permalink" href="#aux_watermark"><i>aux_watermark</i>
    (since Linux 4.1)</a></dt>
  <dd>This specifies how much data is required to trigger a
      <b>PERF_RECORD_AUX</b> sample.</dd>
  <dt id="sample_max_stack"><a class="permalink" href="#sample_max_stack"><i>sample_max_stack</i>
    (since Linux 4.8)</a></dt>
  <dd>When <i>sample_type</i> includes <b>PERF_SAMPLE_CALLCHAIN</b>, this field
      specifies how many stack frames to report when generating the
    callchain.</dd>
  <dt id="aux_sample_size"><a class="permalink" href="#aux_sample_size"><i>aux_sample_size</i>
    (since Linux 5.5)</a></dt>
  <dd>When <b>PERF_SAMPLE_AUX</b> flag is set, specify the desired size of AUX
      data. Note that it can get smaller data than the specified size.</dd>
  <dt id="sig_data"><a class="permalink" href="#sig_data"><i>sig_data</i> (since
    Linux 5.13)</a></dt>
  <dd>This data will be copied to user's signal handler (through <i>si_perf</i>
      in the <i>siginfo_t</i>) to disambiguate which event triggered the
    signal.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Reading_results"><a class="permalink" href="#Reading_results">Reading
  results</a></h2>
<p class="Pp">Once a <b>perf_event_open</b>() file descriptor has been opened,
    the values of the events can be read from the file descriptor. The values
    that are there are specified by the <i>read_format</i> field in the
    <i>attr</i> structure at open time.</p>
<p class="Pp">If you attempt to read into a buffer that is not big enough to
    hold the data, the error <b>ENOSPC</b> results.</p>
<p class="Pp">Here is the layout of the data returned by a read:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If <b>PERF_FORMAT_GROUP</b> was specified to allow reading all events in a
      group at once:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>struct read_format {
<br>
    u64 nr;            /* The number of events */
<br>
    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
<br>
    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
<br>
    struct {
<br>
        u64 value;     /* The value of the event */
<br>
        u64 id;        /* if PERF_FORMAT_ID */
<br>
        u64 lost;      /* if PERF_FORMAT_LOST */
<br>
    } values[nr];
};
    </pre>
    <br>
  </dd>
  <dt>•</dt>
  <dd>If <b>PERF_FORMAT_GROUP</b> was <i>not</i> specified:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>struct read_format {
<br>
    u64 value;         /* The value of the event */
<br>
    u64 time_enabled;  /* if PERF_FORMAT_TOTAL_TIME_ENABLED */
<br>
    u64 time_running;  /* if PERF_FORMAT_TOTAL_TIME_RUNNING */
<br>
    u64 id;            /* if PERF_FORMAT_ID */
<br>
    u64 lost;          /* if PERF_FORMAT_LOST */
};
    </pre>
    <br>
  </dd>
</dl>
<p class="Pp">The values read are as follows:</p>
<dl class="Bl-tag">
  <dt id="nr"><a class="permalink" href="#nr"><i>nr</i></a></dt>
  <dd>The number of events in this file descriptor. Available only if
      <b>PERF_FORMAT_GROUP</b> was specified.</dd>
  <dt id="time_enabled"><a class="permalink" href="#time_enabled"><i>time_enabled</i>,
    <i>time_running</i></a></dt>
  <dd>Total time the event was enabled and running. Normally these values are
      the same. Multiplexing happens if the number of events is more than the
      number of available PMU counter slots. In that case the events run only
      part of the time and the <i>time_enabled</i> and <i>time running</i>
      values can be used to scale an estimated value for the count.</dd>
  <dt id="value"><a class="permalink" href="#value"><i>value</i></a></dt>
  <dd>An unsigned 64-bit value containing the counter result.</dd>
  <dt id="id"><a class="permalink" href="#id"><i>id</i></a></dt>
  <dd>A globally unique value for this particular event; only present if
      <b>PERF_FORMAT_ID</b> was specified in <i>read_format</i>.</dd>
  <dt id="lost"><a class="permalink" href="#lost"><i>lost</i></a></dt>
  <dd>The number of lost samples of this event; only present if
      <b>PERF_FORMAT_LOST</b> was specified in <i>read_format</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="MMAP_layout"><a class="permalink" href="#MMAP_layout">MMAP
  layout</a></h2>
<p class="Pp">When using <b>perf_event_open</b>() in sampled mode, asynchronous
    events (like counter overflow or <b>PROT_EXEC</b> mmap tracking) are logged
    into a ring-buffer. This ring-buffer is created and accessed through
    <b>mmap</b>(2).</p>
<p class="Pp">The mmap size should be 1+2^n pages, where the first page is a
    metadata page (<i>struct perf_event_mmap_page</i>) that contains various
    bits of information such as where the ring-buffer head is.</p>
<p class="Pp">Before Linux 2.6.39, there is a bug that means you must allocate
    an mmap ring buffer when sampling even if you do not plan to access it.</p>
<p class="Pp">The structure of the first metadata mmap page is as follows:</p>
<p class="Pp">
  <br>
</p>
<pre>struct perf_event_mmap_page {
<br>
    __u32 version;        /* version number of this structure */
<br>
    __u32 compat_version; /* lowest version this is compat with */
<br>
    __u32 lock;           /* seqlock for synchronization */
<br>
    __u32 index;          /* hardware counter identifier */
<br>
    __s64 offset;         /* add to hardware counter value */
<br>
    __u64 time_enabled;   /* time event active */
<br>
    __u64 time_running;   /* time event on CPU */
<br>
    union {
<br>
        __u64   capabilities;
<br>
        struct {
<br>
            __u64 cap_usr_time / cap_usr_rdpmc / cap_bit0 : 1,
<br>
                  cap_bit0_is_deprecated : 1,
<br>
                  cap_user_rdpmc         : 1,
<br>
                  cap_user_time          : 1,
<br>
                  cap_user_time_zero     : 1,
<br>
        };
<br>
    };
<br>
    __u16 pmc_width;
<br>
    __u16 time_shift;
<br>
    __u32 time_mult;
<br>
    __u64 time_offset;
<br>
    __u64 __reserved[120];   /* Pad to 1 k */
<br>
    __u64 data_head;         /* head in the data section */
<br>
    __u64 data_tail;         /* user-space written tail */
<br>
    __u64 data_offset;       /* where the buffer starts */
<br>
    __u64 data_size;         /* data buffer size */
<br>
    __u64 aux_head;
<br>
    __u64 aux_tail;
<br>
    __u64 aux_offset;
<br>
    __u64 aux_size;
}
</pre>
<br>
<p class="Pp">The following list describes the fields in the
    <i>perf_event_mmap_page</i> structure in more detail:</p>
<dl class="Bl-tag">
  <dt id="version"><a class="permalink" href="#version"><i>version</i></a></dt>
  <dd>Version number of this structure.</dd>
  <dt id="compat_version"><a class="permalink" href="#compat_version"><i>compat_version</i></a></dt>
  <dd>The lowest version this is compatible with.</dd>
  <dt id="lock"><a class="permalink" href="#lock"><i>lock</i></a></dt>
  <dd>A seqlock for synchronization.</dd>
  <dt id="index"><a class="permalink" href="#index"><i>index</i></a></dt>
  <dd>A unique hardware counter identifier.</dd>
  <dt id="offset"><a class="permalink" href="#offset"><i>offset</i></a></dt>
  <dd>When using rdpmc for reads this offset value must be added to the one
      returned by rdpmc to get the current total event count.</dd>
  <dt id="time_enabled~2"><a class="permalink" href="#time_enabled~2"><i>time_enabled</i></a></dt>
  <dd>Time the event was active.</dd>
  <dt id="time_running"><a class="permalink" href="#time_running"><i>time_running</i></a></dt>
  <dd>Time the event was running.</dd>
  <dt id="cap_usr_time"><a class="permalink" href="#cap_usr_time"><i>cap_usr_time</i>
    / <i>cap_usr_rdpmc</i> / <i>cap_bit0</i> (since Linux 3.4)</a></dt>
  <dd>There was a bug in the definition of <i>cap_usr_time</i> and
      <i>cap_usr_rdpmc</i> from Linux 3.4 until Linux 3.11. Both bits were
      defined to point to the same location, so it was impossible to know if
      <i>cap_usr_time</i> or <i>cap_usr_rdpmc</i> were actually set.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Starting with Linux 3.12, these are renamed to <i>cap_bit0</i> and you
      should use the <i>cap_user_time</i> and <i>cap_user_rdpmc</i> fields
      instead.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="cap_bit0_is_deprecated"><a class="permalink" href="#cap_bit0_is_deprecated"><i>cap_bit0_is_deprecated</i>
    (since Linux 3.12)</a></dt>
  <dd>If set, this bit indicates that the kernel supports the properly separated
      <i>cap_user_time</i> and <i>cap_user_rdpmc</i> bits.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If not-set, it indicates an older kernel where <i>cap_usr_time</i> and
      <i>cap_usr_rdpmc</i> map to the same bit and thus both features should be
      used with caution.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="cap_user_rdpmc"><a class="permalink" href="#cap_user_rdpmc"><i>cap_user_rdpmc</i>
    (since Linux 3.12)</a></dt>
  <dd>If the hardware supports user-space read of performance counters without
      syscall (this is the "rdpmc" instruction on x86), then the
      following code can be used to do a read:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>u32 seq, time_mult, time_shift, idx, width;
u64 count, enabled, running;
u64 cyc, time_offset;
do {
<br>
    seq = pc-&gt;lock;
<br>
    barrier();
<br>
    enabled = pc-&gt;time_enabled;
<br>
    running = pc-&gt;time_running;
<br>
    if (pc-&gt;cap_usr_time &amp;&amp; enabled != running) {
<br>
        cyc = rdtsc();
<br>
        time_offset = pc-&gt;time_offset;
<br>
        time_mult   = pc-&gt;time_mult;
<br>
        time_shift  = pc-&gt;time_shift;
<br>
    }
<br>
    idx = pc-&gt;index;
<br>
    count = pc-&gt;offset;
<br>
    if (pc-&gt;cap_usr_rdpmc &amp;&amp; idx) {
<br>
        width = pc-&gt;pmc_width;
<br>
        count += rdpmc(idx - 1);
<br>
    }
<br>
    barrier();
} while (pc-&gt;lock != seq);
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="cap_user_time"><a class="permalink" href="#cap_user_time"><i>cap_user_time</i>
    (since Linux 3.12)</a></dt>
  <dd>This bit indicates the hardware has a constant, nonstop timestamp counter
      (TSC on x86).</dd>
  <dt id="cap_user_time_zero"><a class="permalink" href="#cap_user_time_zero"><i>cap_user_time_zero</i>
    (since Linux 3.12)</a></dt>
  <dd>Indicates the presence of <i>time_zero</i> which allows mapping timestamp
      values to the hardware clock.</dd>
  <dt id="pmc_width"><a class="permalink" href="#pmc_width"><i>pmc_width</i></a></dt>
  <dd>If <i>cap_usr_rdpmc</i>, this field provides the bit-width of the value
      read using the rdpmc or equivalent instruction. This can be used to sign
      extend the result like:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>pmc &lt;&lt;= 64 - pmc_width;
pmc &gt;&gt;= 64 - pmc_width; // signed shift right
count += pmc;
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="time_shift"><a class="permalink" href="#time_shift"><i>time_shift</i>,
    <i>time_mult</i>, <i>time_offset</i></a></dt>
  <dd></dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <i>cap_usr_time</i>, these fields can be used to compute the time delta
      since <i>time_enabled</i> (in nanoseconds) using rdtsc or similar.</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>u64 quot, rem;
u64 delta;
quot  = cyc &gt;&gt; time_shift;
rem   = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
delta = time_offset + quot * time_mult +
<br>
        ((rem * time_mult) &gt;&gt; time_shift);
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>Where <i>time_offset</i>, <i>time_mult</i>, <i>time_shift</i>, and
      <i>cyc</i> are read in the seqcount loop described above. This delta can
      then be added to enabled and possible running (if idx), improving the
      scaling:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>enabled += delta;
if (idx)
<br>
    running += delta;
quot  = count / running;
rem   = count % running;
count = quot * enabled + (rem * enabled) / running;
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="time_zero"><a class="permalink" href="#time_zero"><i>time_zero</i>
    (since Linux 3.12)</a></dt>
  <dd></dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <i>cap_usr_time_zero</i> is set, then the hardware clock (the TSC
      timestamp counter on x86) can be calculated from the <i>time_zero</i>,
      <i>time_mult</i>, and <i>time_shift</i> values:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>time = timestamp - time_zero;
quot = time / time_mult;
rem  = time % time_mult;
cyc  = (quot &lt;&lt; time_shift) + (rem &lt;&lt; time_shift) / time_mult;
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>And vice versa:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>quot = cyc &gt;&gt; time_shift;
rem  = cyc &amp; (((u64)1 &lt;&lt; time_shift) - 1);
timestamp = time_zero + quot * time_mult +
<br>
            ((rem * time_mult) &gt;&gt; time_shift);
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="data_head"><a class="permalink" href="#data_head"><i>data_head</i></a></dt>
  <dd>This points to the head of the data section. The value continuously
      increases, it does not wrap. The value needs to be manually wrapped by the
      size of the mmap buffer before accessing the samples.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>On SMP-capable platforms, after reading the <i>data_head</i> value, user
      space should issue an rmb().</dd>
</dl>
<dl class="Bl-tag">
  <dt id="data_tail"><a class="permalink" href="#data_tail"><i>data_tail</i></a></dt>
  <dd>When the mapping is <b>PROT_WRITE</b>, the <i>data_tail</i> value should
      be written by user space to reflect the last read data. In this case, the
      kernel will not overwrite unread data.</dd>
  <dt id="data_offset"><a class="permalink" href="#data_offset"><i>data_offset</i>
    (since Linux 4.1)</a></dt>
  <dd>Contains the offset of the location in the mmap buffer where perf sample
      data begins.</dd>
  <dt id="data_size"><a class="permalink" href="#data_size"><i>data_size</i>
    (since Linux 4.1)</a></dt>
  <dd>Contains the size of the perf sample region within the mmap buffer.</dd>
  <dt id="aux_head"><a class="permalink" href="#aux_head"><i>aux_head</i>,
    <i>aux_tail</i>, <i>aux_offset</i>, <i>aux_size</i> (since Linux
    4.1)</a></dt>
  <dd>The AUX region allows <b>mmap</b>(2)-ing a separate sample buffer for
      high-bandwidth data streams (separate from the main perf sample buffer).
      An example of a high-bandwidth stream is instruction tracing support, as
      is found in newer Intel processors.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>To set up an AUX area, first <i>aux_offset</i> needs to be set with an
      offset greater than <i>data_offset</i>+<i>data_size</i> and
      <i>aux_size</i> needs to be set to the desired buffer size. The desired
      offset and size must be page aligned, and the size must be a power of two.
      These values are then passed to mmap in order to map the AUX buffer. Pages
      in the AUX buffer are included as part of the <b>RLIMIT_MEMLOCK</b>
      resource limit (see <b>setrlimit</b>(2)), and also as part of the
      <i>perf_event_mlock_kb</i> allowance.</dd>
  <dt></dt>
  <dd>By default, the AUX buffer will be truncated if it will not fit in the
      available space in the ring buffer. If the AUX buffer is mapped as a read
      only buffer, then it will operate in ring buffer mode where old data will
      be overwritten by new. In overwrite mode, it might not be possible to
      infer where the new data began, and it is the consumer's job to disable
      measurement while reading to avoid possible data races.</dd>
  <dt></dt>
  <dd>The <i>aux_head</i> and <i>aux_tail</i> ring buffer pointers have the same
      behavior and ordering rules as the previous described <i>data_head</i> and
      <i>data_tail</i>.</dd>
</dl>
<p class="Pp">The following 2^n ring-buffer pages have the layout described
    below.</p>
<p class="Pp">If <i>perf_event_attr.sample_id_all</i> is set, then all event
    types will have the sample_type selected fields related to where/when
    (identity) an event took place (TID, TIME, ID, CPU, STREAM_ID) described in
    <b>PERF_RECORD_SAMPLE</b> below, it will be stashed just after the
    <i>perf_event_header</i> and the fields already present for the existing
    fields, that is, at the end of the payload. This allows a newer perf.data
    file to be supported by older perf tools, with the new optional fields being
    ignored.</p>
<p class="Pp">The mmap values start with a header:</p>
<p class="Pp">
  <br>
</p>
<pre>struct perf_event_header {
<br>
    __u32   type;
<br>
    __u16   misc;
<br>
    __u16   size;
};
</pre>
<br>
<p class="Pp">Below, we describe the <i>perf_event_header</i> fields in more
    detail. For ease of reading, the fields with shorter descriptions are
    presented first.</p>
<dl class="Bl-tag">
  <dt id="size~2"><a class="permalink" href="#size~2"><i>size</i></a></dt>
  <dd>This indicates the size of the record.</dd>
  <dt id="misc"><a class="permalink" href="#misc"><i>misc</i></a></dt>
  <dd>The <i>misc</i> field contains additional information about the
    sample.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The CPU mode can be determined from this value by masking with
      <b>PERF_RECORD_MISC_CPUMODE_MASK</b> and looking for one of the following
      (note these are not bit masks, only one can be set at a time):</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_RECORD_MISC_CPUMODE_UNKNOWN"><a class="permalink" href="#PERF_RECORD_MISC_CPUMODE_UNKNOWN"><b>PERF_RECORD_MISC_CPUMODE_UNKNOWN</b></a></dt>
  <dd>Unknown CPU mode.</dd>
  <dt id="PERF_RECORD_MISC_KERNEL"><a class="permalink" href="#PERF_RECORD_MISC_KERNEL"><b>PERF_RECORD_MISC_KERNEL</b></a></dt>
  <dd>Sample happened in the kernel.</dd>
  <dt id="PERF_RECORD_MISC_USER"><a class="permalink" href="#PERF_RECORD_MISC_USER"><b>PERF_RECORD_MISC_USER</b></a></dt>
  <dd>Sample happened in user code.</dd>
  <dt id="PERF_RECORD_MISC_HYPERVISOR"><a class="permalink" href="#PERF_RECORD_MISC_HYPERVISOR"><b>PERF_RECORD_MISC_HYPERVISOR</b></a></dt>
  <dd>Sample happened in the hypervisor.</dd>
  <dt id="PERF_RECORD_MISC_GUEST_KERNEL"><a class="permalink" href="#PERF_RECORD_MISC_GUEST_KERNEL"><b>PERF_RECORD_MISC_GUEST_KERNEL</b>
    (since Linux 2.6.35)</a></dt>
  <dd>Sample happened in the guest kernel.</dd>
  <dt id="PERF_RECORD_MISC_GUEST_USER"><a class="permalink" href="#PERF_RECORD_MISC_GUEST_USER"><b>PERF_RECORD_MISC_GUEST_USER
    (since Linux 2.6.35)</b></a></dt>
  <dd>Sample happened in guest user code.</dd>
</dl>
</div>
<p class="Pp"></p>
<div class="Bd-indent">Since the following three statuses are generated by
  different record types, they alias to the same bit:
<dl class="Bl-tag">
  <dt id="PERF_RECORD_MISC_MMAP_DATA"><a class="permalink" href="#PERF_RECORD_MISC_MMAP_DATA"><b>PERF_RECORD_MISC_MMAP_DATA</b>
    (since Linux 3.10)</a></dt>
  <dd>This is set when the mapping is not executable; otherwise the mapping is
      executable.</dd>
  <dt id="PERF_RECORD_MISC_COMM_EXEC"><a class="permalink" href="#PERF_RECORD_MISC_COMM_EXEC"><b>PERF_RECORD_MISC_COMM_EXEC</b>
    (since Linux 3.16)</a></dt>
  <dd>This is set for a <b>PERF_RECORD_COMM</b> record on kernels more recent
      than Linux 3.16 if a process name change was caused by an <b>execve</b>(2)
      system call.</dd>
  <dt id="PERF_RECORD_MISC_SWITCH_OUT"><a class="permalink" href="#PERF_RECORD_MISC_SWITCH_OUT"><b>PERF_RECORD_MISC_SWITCH_OUT</b>
    (since Linux 4.3)</a></dt>
  <dd>When a <b>PERF_RECORD_SWITCH</b> or <b>PERF_RECORD_SWITCH_CPU_WIDE</b>
      record is generated, this bit indicates that the context switch is away
      from the current process (instead of into the current process).</dd>
</dl>
</div>
<p class="Pp"></p>
<div class="Bd-indent">In addition, the following bits can be set:
<dl class="Bl-tag">
  <dt id="PERF_RECORD_MISC_EXACT_IP"><a class="permalink" href="#PERF_RECORD_MISC_EXACT_IP"><b>PERF_RECORD_MISC_EXACT_IP</b></a></dt>
  <dd>This indicates that the content of <b>PERF_SAMPLE_IP</b> points to the
      actual instruction that triggered the event. See also
      <i>perf_event_attr.precise_ip</i>.</dd>
  <dt id="PERF_RECORD_MISC_SWITCH_OUT_PREEMPT"><a class="permalink" href="#PERF_RECORD_MISC_SWITCH_OUT_PREEMPT"><b>PERF_RECORD_MISC_SWITCH_OUT_PREEMPT</b>
    (since Linux 4.17)</a></dt>
  <dd>When a <b>PERF_RECORD_SWITCH</b> or <b>PERF_RECORD_SWITCH_CPU_WIDE</b>
      record is generated, this indicates the context switch was a
    preemption.</dd>
  <dt id="PERF_RECORD_MISC_MMAP_BUILD_ID"><a class="permalink" href="#PERF_RECORD_MISC_MMAP_BUILD_ID"><b>PERF_RECORD_MISC_MMAP_BUILD_ID</b>
    (since Linux 5.12)</a></dt>
  <dd>This indicates that the content of <b>PERF_SAMPLE_MMAP2</b> contains
      build-ID data instead of device major and minor numbers as well as the
      inode number.</dd>
  <dt id="PERF_RECORD_MISC_EXT_RESERVED"><a class="permalink" href="#PERF_RECORD_MISC_EXT_RESERVED"><b>PERF_RECORD_MISC_EXT_RESERVED</b>
    (since Linux 2.6.35)</a></dt>
  <dd>This indicates there is extended data available (currently not used).</dd>
  <dt id="PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT"><a class="permalink" href="#PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT"><b>PERF_RECORD_MISC_PROC_MAP_PARSE_TIMEOUT</b></a></dt>
  <dd>This bit is not set by the kernel. It is reserved for the user-space perf
      utility to indicate that <i>/proc/i[pid]/maps</i> parsing was taking too
      long and was stopped, and thus the mmap records may be truncated.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="type~2"><a class="permalink" href="#type~2"><i>type</i></a></dt>
  <dd>The <i>type</i> value is one of the below. The values in the corresponding
      record (that follows the header) depend on the <i>type</i> selected as
      shown.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_RECORD_MMAP"><a class="permalink" href="#PERF_RECORD_MMAP"><b>PERF_RECORD_MMAP</b></a></dt>
  <dd>The MMAP events record the <b>PROT_EXEC</b> mappings so that we can
      correlate user-space IPs to code. They have the following structure:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid, tid;
<br>
    u64    addr;
<br>
    u64    len;
<br>
    u64    pgoff;
<br>
    char   filename[];
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="pid"><a class="permalink" href="#pid"><i>pid</i></a></dt>
  <dd>is the process ID.</dd>
  <dt id="tid"><a class="permalink" href="#tid"><i>tid</i></a></dt>
  <dd>is the thread ID.</dd>
  <dt id="addr"><a class="permalink" href="#addr"><i>addr</i></a></dt>
  <dd>is the address of the allocated memory. <i>len</i> is the length of the
      allocated memory. <i>pgoff</i> is the page offset of the allocated memory.
      <i>filename</i> is a string describing the backing of the allocated
      memory.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_LOST"><a class="permalink" href="#PERF_RECORD_LOST"><b>PERF_RECORD_LOST</b></a></dt>
  <dd>This record indicates when events are lost.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    id;
<br>
    u64    lost;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="id~2"><a class="permalink" href="#id~2"><i>id</i></a></dt>
  <dd>is the unique event ID for the samples that were lost.</dd>
  <dt id="lost~2"><a class="permalink" href="#lost~2"><i>lost</i></a></dt>
  <dd>is the number of events that were lost.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_COMM"><a class="permalink" href="#PERF_RECORD_COMM"><b>PERF_RECORD_COMM</b></a></dt>
  <dd>This record indicates a change in the process name.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid;
<br>
    u32    tid;
<br>
    char   comm[];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="pid~2"><a class="permalink" href="#pid~2"><i>pid</i></a></dt>
  <dd>is the process ID.</dd>
  <dt id="tid~2"><a class="permalink" href="#tid~2"><i>tid</i></a></dt>
  <dd>is the thread ID.</dd>
  <dt id="comm~2"><a class="permalink" href="#comm~2"><i>comm</i></a></dt>
  <dd>is a string containing the new name of the process.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_EXIT"><a class="permalink" href="#PERF_RECORD_EXIT"><b>PERF_RECORD_EXIT</b></a></dt>
  <dd>This record indicates a process exit event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid, ppid;
<br>
    u32    tid, ptid;
<br>
    u64    time;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_THROTTLE"><a class="permalink" href="#PERF_RECORD_THROTTLE"><b>PERF_RECORD_THROTTLE</b>,
    <b>PERF_RECORD_UNTHROTTLE</b></a></dt>
  <dd>This record indicates a throttle/unthrottle event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    time;
<br>
    u64    id;
<br>
    u64    stream_id;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_FORK"><a class="permalink" href="#PERF_RECORD_FORK"><b>PERF_RECORD_FORK</b></a></dt>
  <dd>This record indicates a fork event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid, ppid;
<br>
    u32    tid, ptid;
<br>
    u64    time;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_READ"><a class="permalink" href="#PERF_RECORD_READ"><b>PERF_RECORD_READ</b></a></dt>
  <dd>This record indicates a read event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid, tid;
<br>
    struct read_format values;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_SAMPLE"><a class="permalink" href="#PERF_RECORD_SAMPLE"><b>PERF_RECORD_SAMPLE</b></a></dt>
  <dd>This record indicates a sample.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    sample_id;   /* if PERF_SAMPLE_IDENTIFIER */
<br>
    u64    ip;          /* if PERF_SAMPLE_IP */
<br>
    u32    pid, tid;    /* if PERF_SAMPLE_TID */
<br>
    u64    time;        /* if PERF_SAMPLE_TIME */
<br>
    u64    addr;        /* if PERF_SAMPLE_ADDR */
<br>
    u64    id;          /* if PERF_SAMPLE_ID */
<br>
    u64    stream_id;   /* if PERF_SAMPLE_STREAM_ID */
<br>
    u32    cpu, res;    /* if PERF_SAMPLE_CPU */
<br>
    u64    period;      /* if PERF_SAMPLE_PERIOD */
<br>
    struct read_format v;
<br>
                        /* if PERF_SAMPLE_READ */
<br>
    u64    nr;          /* if PERF_SAMPLE_CALLCHAIN */
<br>
    u64    ips[nr];     /* if PERF_SAMPLE_CALLCHAIN */
<br>
    u32    size;        /* if PERF_SAMPLE_RAW */
<br>
    char   data[size];  /* if PERF_SAMPLE_RAW */
<br>
    u64    bnr;         /* if PERF_SAMPLE_BRANCH_STACK */
<br>
    struct perf_branch_entry lbr[bnr];
<br>
                        /* if PERF_SAMPLE_BRANCH_STACK */
<br>
    u64    abi;         /* if PERF_SAMPLE_REGS_USER */
<br>
    u64    regs[weight(mask)];
<br>
                        /* if PERF_SAMPLE_REGS_USER */
<br>
    u64    size;        /* if PERF_SAMPLE_STACK_USER */
<br>
    char   data[size];  /* if PERF_SAMPLE_STACK_USER */
<br>
    u64    dyn_size;    /* if PERF_SAMPLE_STACK_USER &amp;&amp;
<br>
                           size != 0 */
<br>
    union perf_sample_weight weight;
<br>
                        /* if PERF_SAMPLE_WEIGHT */
<br>
                        /* || PERF_SAMPLE_WEIGHT_STRUCT */
<br>
    u64    data_src;    /* if PERF_SAMPLE_DATA_SRC */
<br>
    u64    transaction; /* if PERF_SAMPLE_TRANSACTION */
<br>
    u64    abi;         /* if PERF_SAMPLE_REGS_INTR */
<br>
    u64    regs[weight(mask)];
<br>
                        /* if PERF_SAMPLE_REGS_INTR */
<br>
    u64    phys_addr;   /* if PERF_SAMPLE_PHYS_ADDR */
<br>
    u64    cgroup;      /* if PERF_SAMPLE_CGROUP */
<br>
    u64    data_page_size;
<br>
                      /* if PERF_SAMPLE_DATA_PAGE_SIZE */
<br>
    u64    code_page_size;
<br>
                      /* if PERF_SAMPLE_CODE_PAGE_SIZE */
<br>
    u64    size;        /* if PERF_SAMPLE_AUX */
<br>
    char   data[size];  /* if PERF_SAMPLE_AUX */
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="sample_id"><a class="permalink" href="#sample_id"><i>sample_id</i></a></dt>
  <dd>If <b>PERF_SAMPLE_IDENTIFIER</b> is enabled, a 64-bit unique ID is
      included. This is a duplication of the <b>PERF_SAMPLE_ID</b> <i>id</i>
      value, but included at the beginning of the sample so parsers can easily
      obtain the value.</dd>
  <dt id="ip"><a class="permalink" href="#ip"><i>ip</i></a></dt>
  <dd>If <b>PERF_SAMPLE_IP</b> is enabled, then a 64-bit instruction pointer
      value is included.</dd>
  <dt id="pid~3"><a class="permalink" href="#pid~3"><i>pid</i>,
    <i>tid</i></a></dt>
  <dd>If <b>PERF_SAMPLE_TID</b> is enabled, then a 32-bit process ID and 32-bit
      thread ID are included.</dd>
  <dt id="time"><a class="permalink" href="#time"><i>time</i></a></dt>
  <dd>If <b>PERF_SAMPLE_TIME</b> is enabled, then a 64-bit timestamp is
      included. This is obtained via local_clock() which is a hardware timestamp
      if available and the jiffies value if not.</dd>
  <dt id="addr~2"><a class="permalink" href="#addr~2"><i>addr</i></a></dt>
  <dd>If <b>PERF_SAMPLE_ADDR</b> is enabled, then a 64-bit address is included.
      This is usually the address of a tracepoint, breakpoint, or software
      event; otherwise the value is 0.</dd>
  <dt id="id~3"><a class="permalink" href="#id~3"><i>id</i></a></dt>
  <dd>If <b>PERF_SAMPLE_ID</b> is enabled, a 64-bit unique ID is included. If
      the event is a member of an event group, the group leader ID is returned.
      This ID is the same as the one returned by <b>PERF_FORMAT_ID</b>.</dd>
  <dt id="stream_id"><a class="permalink" href="#stream_id"><i>stream_id</i></a></dt>
  <dd>If <b>PERF_SAMPLE_STREAM_ID</b> is enabled, a 64-bit unique ID is
      included. Unlike <b>PERF_SAMPLE_ID</b> the actual ID is returned, not the
      group leader. This ID is the same as the one returned by
      <b>PERF_FORMAT_ID</b>.</dd>
  <dt id="cpu"><a class="permalink" href="#cpu"><i>cpu</i>, <i>res</i></a></dt>
  <dd>If <b>PERF_SAMPLE_CPU</b> is enabled, this is a 32-bit value indicating
      which CPU was being used, in addition to a reserved (unused) 32-bit
    value.</dd>
  <dt id="period"><a class="permalink" href="#period"><i>period</i></a></dt>
  <dd>If <b>PERF_SAMPLE_PERIOD</b> is enabled, a 64-bit value indicating the
      current sampling period is written.</dd>
  <dt id="v"><a class="permalink" href="#v"><i>v</i></a></dt>
  <dd>If <b>PERF_SAMPLE_READ</b> is enabled, a structure of type read_format is
      included which has values for all events in the event group. The values
      included depend on the <i>read_format</i> value used at
      <b>perf_event_open</b>() time.</dd>
  <dt id="nr~2"><a class="permalink" href="#nr~2"><i>nr</i>,
    <i>ips[nr]</i></a></dt>
  <dd>If <b>PERF_SAMPLE_CALLCHAIN</b> is enabled, then a 64-bit number is
      included which indicates how many following 64-bit instruction pointers
      will follow. This is the current callchain.</dd>
  <dt id="size~3"><a class="permalink" href="#size~3"><i>size</i>,
    <i>data[size]</i></a></dt>
  <dd>If <b>PERF_SAMPLE_RAW</b> is enabled, then a 32-bit value indicating size
      is included followed by an array of 8-bit values of length size. The
      values are padded with 0 to have 64-bit alignment.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This RAW record data is opaque with respect to the ABI. The ABI doesn't
      make any promises with respect to the stability of its content, it may
      vary depending on event, hardware, and kernel version.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="bnr"><a class="permalink" href="#bnr"><i>bnr</i>,
    <i>lbr[bnr]</i></a></dt>
  <dd>If <b>PERF_SAMPLE_BRANCH_STACK</b> is enabled, then a 64-bit value
      indicating the number of records is included, followed by <i>bnr</i>
      <i>perf_branch_entry</i> structures which each include the fields:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="from"><a class="permalink" href="#from"><i>from</i></a></dt>
  <dd>This indicates the source instruction (may not be a branch).</dd>
  <dt id="to"><a class="permalink" href="#to"><i>to</i></a></dt>
  <dd>The branch target.</dd>
  <dt id="mispred"><a class="permalink" href="#mispred"><i>mispred</i></a></dt>
  <dd>The branch target was mispredicted.</dd>
  <dt id="predicted"><a class="permalink" href="#predicted"><i>predicted</i></a></dt>
  <dd>The branch target was predicted.</dd>
  <dt id="in_tx"><a class="permalink" href="#in_tx"><i>in_tx</i> (since Linux
    3.11)</a></dt>
  <dd>The branch was in a transactional memory transaction.</dd>
  <dt id="abort"><a class="permalink" href="#abort"><i>abort</i> (since Linux
    3.11)</a></dt>
  <dd>The branch was in an aborted transactional memory transaction.</dd>
  <dt id="cycles"><a class="permalink" href="#cycles"><i>cycles</i> (since Linux
    4.3)</a></dt>
  <dd>This reports the number of cycles elapsed since the previous branch stack
      update.</dd>
</dl>
<p class="Pp">The entries are from most to least recent, so the first entry has
    the most recent branch.</p>
<p class="Pp">Support for <i>mispred</i>, <i>predicted</i>, and <i>cycles</i> is
    optional; if not supported, those values will be 0.</p>
<p class="Pp">The type of branches recorded is specified by the
    <i>branch_sample_type</i> field.</p>
</div>
<dl class="Bl-tag">
  <dt id="abi"><a class="permalink" href="#abi"><i>abi</i>,
    <i>regs[weight(mask)]</i></a></dt>
  <dd>If <b>PERF_SAMPLE_REGS_USER</b> is enabled, then the user CPU registers
      are recorded.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
      <b>PERF_SAMPLE_REGS_ABI_32</b>, or <b>PERF_SAMPLE_REGS_ABI_64</b>.</dd>
  <dt></dt>
  <dd>The <i>regs</i> field is an array of the CPU registers that were specified
      by the <i>sample_regs_user</i> attr field. The number of values is the
      number of bits set in the <i>sample_regs_user</i> bit mask.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="size~4"><a class="permalink" href="#size~4"><i>size</i>,
    <i>data[size]</i>, <i>dyn_size</i></a></dt>
  <dd>If <b>PERF_SAMPLE_STACK_USER</b> is enabled, then the user stack is
      recorded. This can be used to generate stack backtraces. <i>size</i> is
      the size requested by the user in <i>sample_stack_user</i> or else the
      maximum record size. <i>data</i> is the stack data (a raw dump of the
      memory pointed to by the stack pointer at the time of sampling).
      <i>dyn_size</i> is the amount of data actually dumped (can be less than
      <i>size</i>). Note that <i>dyn_size</i> is omitted if <i>size</i> is
    0.</dd>
  <dt id="weight"><a class="permalink" href="#weight"><i>weight</i></a></dt>
  <dd>If <b>PERF_SAMPLE_WEIGHT</b> or <b>PERF_SAMPLE_WEIGHT_STRUCT</b> is
      enabled, then a 64-bit value provided by the hardware is recorded that
      indicates how costly the event was. This allows expensive events to stand
      out more clearly in profiles.</dd>
  <dt id="data_src"><a class="permalink" href="#data_src"><i>data_src</i></a></dt>
  <dd>If <b>PERF_SAMPLE_DATA_SRC</b> is enabled, then a 64-bit value is recorded
      that is made up of the following fields:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="mem_op"><a class="permalink" href="#mem_op"><i>mem_op</i></a></dt>
  <dd>Type of opcode, a bitwise combination of:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_MEM_OP_NA"><a class="permalink" href="#PERF_MEM_OP_NA"><b>PERF_MEM_OP_NA</b></a></dt>
  <dd>Not available</dd>
  <dt id="PERF_MEM_OP_LOAD"><a class="permalink" href="#PERF_MEM_OP_LOAD"><b>PERF_MEM_OP_LOAD</b></a></dt>
  <dd>Load instruction</dd>
  <dt id="PERF_MEM_OP_STORE"><a class="permalink" href="#PERF_MEM_OP_STORE"><b>PERF_MEM_OP_STORE</b></a></dt>
  <dd>Store instruction</dd>
  <dt id="PERF_MEM_OP_PFETCH"><a class="permalink" href="#PERF_MEM_OP_PFETCH"><b>PERF_MEM_OP_PFETCH</b></a></dt>
  <dd>Prefetch</dd>
  <dt id="PERF_MEM_OP_EXEC"><a class="permalink" href="#PERF_MEM_OP_EXEC"><b>PERF_MEM_OP_EXEC</b></a></dt>
  <dd>Executable code</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="mem_lvl"><a class="permalink" href="#mem_lvl"><i>mem_lvl</i></a></dt>
  <dd>Memory hierarchy level hit or miss, a bitwise combination of the
      following, shifted left by <b>PERF_MEM_LVL_SHIFT</b>:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_MEM_LVL_NA"><a class="permalink" href="#PERF_MEM_LVL_NA"><b>PERF_MEM_LVL_NA</b></a></dt>
  <dd>Not available</dd>
  <dt id="PERF_MEM_LVL_HIT"><a class="permalink" href="#PERF_MEM_LVL_HIT"><b>PERF_MEM_LVL_HIT</b></a></dt>
  <dd>Hit</dd>
  <dt id="PERF_MEM_LVL_MISS"><a class="permalink" href="#PERF_MEM_LVL_MISS"><b>PERF_MEM_LVL_MISS</b></a></dt>
  <dd>Miss</dd>
  <dt id="PERF_MEM_LVL_L1"><a class="permalink" href="#PERF_MEM_LVL_L1"><b>PERF_MEM_LVL_L1</b></a></dt>
  <dd>Level 1 cache</dd>
  <dt id="PERF_MEM_LVL_LFB"><a class="permalink" href="#PERF_MEM_LVL_LFB"><b>PERF_MEM_LVL_LFB</b></a></dt>
  <dd>Line fill buffer</dd>
  <dt id="PERF_MEM_LVL_L2"><a class="permalink" href="#PERF_MEM_LVL_L2"><b>PERF_MEM_LVL_L2</b></a></dt>
  <dd>Level 2 cache</dd>
  <dt id="PERF_MEM_LVL_L3"><a class="permalink" href="#PERF_MEM_LVL_L3"><b>PERF_MEM_LVL_L3</b></a></dt>
  <dd>Level 3 cache</dd>
  <dt id="PERF_MEM_LVL_LOC_RAM"><a class="permalink" href="#PERF_MEM_LVL_LOC_RAM"><b>PERF_MEM_LVL_LOC_RAM</b></a></dt>
  <dd>Local DRAM</dd>
  <dt id="PERF_MEM_LVL_REM_RAM1"><a class="permalink" href="#PERF_MEM_LVL_REM_RAM1"><b>PERF_MEM_LVL_REM_RAM1</b></a></dt>
  <dd>Remote DRAM 1 hop</dd>
  <dt id="PERF_MEM_LVL_REM_RAM2"><a class="permalink" href="#PERF_MEM_LVL_REM_RAM2"><b>PERF_MEM_LVL_REM_RAM2</b></a></dt>
  <dd>Remote DRAM 2 hops</dd>
  <dt id="PERF_MEM_LVL_REM_CCE1"><a class="permalink" href="#PERF_MEM_LVL_REM_CCE1"><b>PERF_MEM_LVL_REM_CCE1</b></a></dt>
  <dd>Remote cache 1 hop</dd>
  <dt id="PERF_MEM_LVL_REM_CCE2"><a class="permalink" href="#PERF_MEM_LVL_REM_CCE2"><b>PERF_MEM_LVL_REM_CCE2</b></a></dt>
  <dd>Remote cache 2 hops</dd>
  <dt id="PERF_MEM_LVL_IO"><a class="permalink" href="#PERF_MEM_LVL_IO"><b>PERF_MEM_LVL_IO</b></a></dt>
  <dd>I/O memory</dd>
  <dt id="PERF_MEM_LVL_UNC"><a class="permalink" href="#PERF_MEM_LVL_UNC"><b>PERF_MEM_LVL_UNC</b></a></dt>
  <dd>Uncached memory</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="mem_snoop"><a class="permalink" href="#mem_snoop"><i>mem_snoop</i></a></dt>
  <dd>Snoop mode, a bitwise combination of the following, shifted left by
      <b>PERF_MEM_SNOOP_SHIFT</b>:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_MEM_SNOOP_NA"><a class="permalink" href="#PERF_MEM_SNOOP_NA"><b>PERF_MEM_SNOOP_NA</b></a></dt>
  <dd>Not available</dd>
  <dt id="PERF_MEM_SNOOP_NONE"><a class="permalink" href="#PERF_MEM_SNOOP_NONE"><b>PERF_MEM_SNOOP_NONE</b></a></dt>
  <dd>No snoop</dd>
  <dt id="PERF_MEM_SNOOP_HIT"><a class="permalink" href="#PERF_MEM_SNOOP_HIT"><b>PERF_MEM_SNOOP_HIT</b></a></dt>
  <dd>Snoop hit</dd>
  <dt id="PERF_MEM_SNOOP_MISS"><a class="permalink" href="#PERF_MEM_SNOOP_MISS"><b>PERF_MEM_SNOOP_MISS</b></a></dt>
  <dd>Snoop miss</dd>
  <dt id="PERF_MEM_SNOOP_HITM"><a class="permalink" href="#PERF_MEM_SNOOP_HITM"><b>PERF_MEM_SNOOP_HITM</b></a></dt>
  <dd>Snoop hit modified</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="mem_lock"><a class="permalink" href="#mem_lock"><i>mem_lock</i></a></dt>
  <dd>Lock instruction, a bitwise combination of the following, shifted left by
      <b>PERF_MEM_LOCK_SHIFT</b>:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_MEM_LOCK_NA"><a class="permalink" href="#PERF_MEM_LOCK_NA"><b>PERF_MEM_LOCK_NA</b></a></dt>
  <dd>Not available</dd>
  <dt id="PERF_MEM_LOCK_LOCKED"><a class="permalink" href="#PERF_MEM_LOCK_LOCKED"><b>PERF_MEM_LOCK_LOCKED</b></a></dt>
  <dd>Locked transaction</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="mem_dtlb"><a class="permalink" href="#mem_dtlb"><i>mem_dtlb</i></a></dt>
  <dd>TLB access hit or miss, a bitwise combination of the following, shifted
      left by <b>PERF_MEM_TLB_SHIFT</b>:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_MEM_TLB_NA"><a class="permalink" href="#PERF_MEM_TLB_NA"><b>PERF_MEM_TLB_NA</b></a></dt>
  <dd>Not available</dd>
  <dt id="PERF_MEM_TLB_HIT"><a class="permalink" href="#PERF_MEM_TLB_HIT"><b>PERF_MEM_TLB_HIT</b></a></dt>
  <dd>Hit</dd>
  <dt id="PERF_MEM_TLB_MISS"><a class="permalink" href="#PERF_MEM_TLB_MISS"><b>PERF_MEM_TLB_MISS</b></a></dt>
  <dd>Miss</dd>
  <dt id="PERF_MEM_TLB_L1"><a class="permalink" href="#PERF_MEM_TLB_L1"><b>PERF_MEM_TLB_L1</b></a></dt>
  <dd>Level 1 TLB</dd>
  <dt id="PERF_MEM_TLB_L2"><a class="permalink" href="#PERF_MEM_TLB_L2"><b>PERF_MEM_TLB_L2</b></a></dt>
  <dd>Level 2 TLB</dd>
  <dt id="PERF_MEM_TLB_WK"><a class="permalink" href="#PERF_MEM_TLB_WK"><b>PERF_MEM_TLB_WK</b></a></dt>
  <dd>Hardware walker</dd>
  <dt id="PERF_MEM_TLB_OS"><a class="permalink" href="#PERF_MEM_TLB_OS"><b>PERF_MEM_TLB_OS</b></a></dt>
  <dd>OS fault handler</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt id="transaction"><a class="permalink" href="#transaction"><i>transaction</i></a></dt>
  <dd>If the <b>PERF_SAMPLE_TRANSACTION</b> flag is set, then a 64-bit field is
      recorded describing the sources of any transactional memory aborts.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The field is a bitwise combination of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_TXN_ELISION"><a class="permalink" href="#PERF_TXN_ELISION"><b>PERF_TXN_ELISION</b></a></dt>
  <dd>Abort from an elision type transaction (Intel-CPU-specific).</dd>
  <dt id="PERF_TXN_TRANSACTION"><a class="permalink" href="#PERF_TXN_TRANSACTION"><b>PERF_TXN_TRANSACTION</b></a></dt>
  <dd>Abort from a generic transaction.</dd>
  <dt id="PERF_TXN_SYNC"><a class="permalink" href="#PERF_TXN_SYNC"><b>PERF_TXN_SYNC</b></a></dt>
  <dd>Synchronous abort (related to the reported instruction).</dd>
  <dt id="PERF_TXN_ASYNC"><a class="permalink" href="#PERF_TXN_ASYNC"><b>PERF_TXN_ASYNC</b></a></dt>
  <dd>Asynchronous abort (not related to the reported instruction).</dd>
  <dt id="PERF_TXN_RETRY"><a class="permalink" href="#PERF_TXN_RETRY"><b>PERF_TXN_RETRY</b></a></dt>
  <dd>Retryable abort (retrying the transaction may have succeeded).</dd>
  <dt id="PERF_TXN_CONFLICT"><a class="permalink" href="#PERF_TXN_CONFLICT"><b>PERF_TXN_CONFLICT</b></a></dt>
  <dd>Abort due to memory conflicts with other threads.</dd>
  <dt id="PERF_TXN_CAPACITY_WRITE"><a class="permalink" href="#PERF_TXN_CAPACITY_WRITE"><b>PERF_TXN_CAPACITY_WRITE</b></a></dt>
  <dd>Abort due to write capacity overflow.</dd>
  <dt id="PERF_TXN_CAPACITY_READ"><a class="permalink" href="#PERF_TXN_CAPACITY_READ"><b>PERF_TXN_CAPACITY_READ</b></a></dt>
  <dd>Abort due to read capacity overflow.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>In addition, a user-specified abort code can be obtained from the high 32
      bits of the field by shifting right by <b>PERF_TXN_ABORT_SHIFT</b> and
      masking with the value <b>PERF_TXN_ABORT_MASK</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="abi~2"><a class="permalink" href="#abi~2"><i>abi</i>,
    <i>regs[weight(mask)]</i></a></dt>
  <dd>If <b>PERF_SAMPLE_REGS_INTR</b> is enabled, then the user CPU registers
      are recorded.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>abi</i> field is one of <b>PERF_SAMPLE_REGS_ABI_NONE</b>,
      <b>PERF_SAMPLE_REGS_ABI_32</b>, or <b>PERF_SAMPLE_REGS_ABI_64</b>.</dd>
  <dt></dt>
  <dd>The <i>regs</i> field is an array of the CPU registers that were specified
      by the <i>sample_regs_intr</i> attr field. The number of values is the
      number of bits set in the <i>sample_regs_intr</i> bit mask.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="phys_addr"><a class="permalink" href="#phys_addr"><i>phys_addr</i></a></dt>
  <dd>If the <b>PERF_SAMPLE_PHYS_ADDR</b> flag is set, then the 64-bit physical
      address is recorded.</dd>
  <dt id="cgroup~2"><a class="permalink" href="#cgroup~2"><i>cgroup</i></a></dt>
  <dd>If the <b>PERF_SAMPLE_CGROUP</b> flag is set, then the 64-bit cgroup ID
      (for the perf_event subsystem) is recorded. To get the pathname of the
      cgroup, the ID should match to one in a <b>PERF_RECORD_CGROUP</b>.</dd>
  <dt id="data_page_size"><a class="permalink" href="#data_page_size"><i>data_page_size</i></a></dt>
  <dd>If the <b>PERF_SAMPLE_DATA_PAGE_SIZE</b> flag is set, then the 64-bit page
      size value of the <b>data</b> address is recorded.</dd>
  <dt id="code_page_size"><a class="permalink" href="#code_page_size"><i>code_page_size</i></a></dt>
  <dd>If the <b>PERF_SAMPLE_CODE_PAGE_SIZE</b> flag is set, then the 64-bit page
      size value of the <b>ip</b> address is recorded.</dd>
  <dt id="size~5"><a class="permalink" href="#size~5"><i>size</i></a></dt>
  <dd></dd>
  <dt id="data"><a class="permalink" href="#data"><i>data</i>[<i>size</i>]</a></dt>
  <dd>If <b>PERF_SAMPLE_AUX</b> is enabled, a snapshot of the aux buffer is
      recorded.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_MMAP2"><a class="permalink" href="#PERF_RECORD_MMAP2"><b>PERF_RECORD_MMAP2</b></a></dt>
  <dd>This record includes extended information on <b>mmap</b>(2) calls
      returning executable mappings. The format is similar to that of the
      <b>PERF_RECORD_MMAP</b> record, but includes extra values that allow
      uniquely identifying shared mappings. Depending on the
      <b>PERF_RECORD_MISC_MMAP_BUILD_ID</b> bit in the header, the extra values
      have different layout and meanings.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid;
<br>
    u32    tid;
<br>
    u64    addr;
<br>
    u64    len;
<br>
    u64    pgoff;
<br>
    union {
<br>
        struct {
<br>
            u32    maj;
<br>
            u32    min;
<br>
            u64    ino;
<br>
            u64    ino_generation;
<br>
        };
<br>
        struct {   /* if PERF_RECORD_MISC_MMAP_BUILD_ID */
<br>
            u8     build_id_size;
<br>
            u8     __reserved_1;
<br>
            u16    __reserved_2;
<br>
            u8     build_id[20];
<br>
        };
<br>
    };
<br>
    u32    prot;
<br>
    u32    flags;
<br>
    char   filename[];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="pid~4"><a class="permalink" href="#pid~4"><i>pid</i></a></dt>
  <dd>is the process ID.</dd>
  <dt id="tid~3"><a class="permalink" href="#tid~3"><i>tid</i></a></dt>
  <dd>is the thread ID.</dd>
  <dt id="addr~3"><a class="permalink" href="#addr~3"><i>addr</i></a></dt>
  <dd>is the address of the allocated memory.</dd>
  <dt id="len"><a class="permalink" href="#len"><i>len</i></a></dt>
  <dd>is the length of the allocated memory.</dd>
  <dt id="pgoff"><a class="permalink" href="#pgoff"><i>pgoff</i></a></dt>
  <dd>is the page offset of the allocated memory.</dd>
  <dt id="maj"><a class="permalink" href="#maj"><i>maj</i></a></dt>
  <dd>is the major ID of the underlying device.</dd>
  <dt id="min"><a class="permalink" href="#min"><i>min</i></a></dt>
  <dd>is the minor ID of the underlying device.</dd>
  <dt id="ino"><a class="permalink" href="#ino"><i>ino</i></a></dt>
  <dd>is the inode number.</dd>
  <dt id="ino_generation"><a class="permalink" href="#ino_generation"><i>ino_generation</i></a></dt>
  <dd>is the inode generation.</dd>
  <dt id="build_id_size"><a class="permalink" href="#build_id_size"><i>build_id_size</i></a></dt>
  <dd>is the actual size of <i>build_id</i> field (up to 20).</dd>
  <dt id="build_id~2"><a class="permalink" href="#build_id~2"><i>build_id</i></a></dt>
  <dd>is a raw data to identify a binary.</dd>
  <dt id="prot"><a class="permalink" href="#prot"><i>prot</i></a></dt>
  <dd>is the protection information.</dd>
  <dt id="flags"><a class="permalink" href="#flags"><i>flags</i></a></dt>
  <dd>is the flags information.</dd>
  <dt id="filename"><a class="permalink" href="#filename"><i>filename</i></a></dt>
  <dd>is a string describing the backing of the allocated memory.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_AUX"><a class="permalink" href="#PERF_RECORD_AUX"><b>PERF_RECORD_AUX</b>
    (since Linux 4.1)</a></dt>
  <dd>This record reports that new data is available in the separate AUX buffer
      region.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    aux_offset;
<br>
    u64    aux_size;
<br>
    u64    flags;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="aux_offset"><a class="permalink" href="#aux_offset"><i>aux_offset</i></a></dt>
  <dd>offset in the AUX mmap region where the new data begins.</dd>
  <dt id="aux_size"><a class="permalink" href="#aux_size"><i>aux_size</i></a></dt>
  <dd>size of the data made available.</dd>
  <dt id="flags~2"><a class="permalink" href="#flags~2"><i>flags</i></a></dt>
  <dd>describes the AUX update.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_AUX_FLAG_TRUNCATED"><a class="permalink" href="#PERF_AUX_FLAG_TRUNCATED"><b>PERF_AUX_FLAG_TRUNCATED</b></a></dt>
  <dd>if set, then the data returned was truncated to fit the available buffer
      size.</dd>
  <dt id="PERF_AUX_FLAG_OVERWRITE"><a class="permalink" href="#PERF_AUX_FLAG_OVERWRITE"><b>PERF_AUX_FLAG_OVERWRITE</b></a></dt>
  <dd>if set, then the data returned has overwritten previous data.</dd>
</dl>
</div>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_ITRACE_START"><a class="permalink" href="#PERF_RECORD_ITRACE_START"><b>PERF_RECORD_ITRACE_START</b>
    (since Linux 4.1)</a></dt>
  <dd>This record indicates which process has initiated an instruction trace
      event, allowing tools to properly correlate the instruction addresses in
      the AUX buffer with the proper executable.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid;
<br>
    u32    tid;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="pid~5"><a class="permalink" href="#pid~5"><i>pid</i></a></dt>
  <dd>process ID of the thread starting an instruction trace.</dd>
  <dt id="tid~4"><a class="permalink" href="#tid~4"><i>tid</i></a></dt>
  <dd>thread ID of the thread starting an instruction trace.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_LOST_SAMPLES"><a class="permalink" href="#PERF_RECORD_LOST_SAMPLES"><b>PERF_RECORD_LOST_SAMPLES</b>
    (since Linux 4.2)</a></dt>
  <dd>When using hardware sampling (such as Intel PEBS) this record indicates
      some number of samples that may have been lost.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    lost;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="lost~3"><a class="permalink" href="#lost~3"><i>lost</i></a></dt>
  <dd>the number of potentially lost samples.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_SWITCH"><a class="permalink" href="#PERF_RECORD_SWITCH"><b>PERF_RECORD_SWITCH</b>
    (since Linux 4.3)</a></dt>
  <dd>This record indicates a context switch has happened. The
      <b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in the <i>misc</i> field indicates
      whether it was a context switch into or away from the current
    process.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_SWITCH_CPU_WIDE"><a class="permalink" href="#PERF_RECORD_SWITCH_CPU_WIDE"><b>PERF_RECORD_SWITCH_CPU_WIDE</b>
    (since Linux 4.3)</a></dt>
  <dd>As with <b>PERF_RECORD_SWITCH</b> this record indicates a context switch
      has happened, but it only occurs when sampling in CPU-wide mode and
      provides additional information on the process being switched to/from. The
      <b>PERF_RECORD_MISC_SWITCH_OUT</b> bit in the <i>misc</i> field indicates
      whether it was a context switch into or away from the current
    process.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32 next_prev_pid;
<br>
    u32 next_prev_tid;
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="next_prev_pid"><a class="permalink" href="#next_prev_pid"><i>next_prev_pid</i></a></dt>
  <dd>The process ID of the previous (if switching in) or next (if switching
      out) process on the CPU.</dd>
  <dt id="next_prev_tid"><a class="permalink" href="#next_prev_tid"><i>next_prev_tid</i></a></dt>
  <dd>The thread ID of the previous (if switching in) or next (if switching out)
      thread on the CPU.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_NAMESPACES"><a class="permalink" href="#PERF_RECORD_NAMESPACES"><b>PERF_RECORD_NAMESPACES</b>
    (since Linux 4.11)</a></dt>
  <dd>This record includes various namespace information of a process.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u32    pid;
<br>
    u32    tid;
<br>
    u64    nr_namespaces;
<br>
    struct { u64 dev, inode } [nr_namespaces];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="pid~6"><a class="permalink" href="#pid~6"><i>pid</i></a></dt>
  <dd>is the process ID</dd>
  <dt id="tid~5"><a class="permalink" href="#tid~5"><i>tid</i></a></dt>
  <dd>is the thread ID</dd>
  <dt id="nr_namespace"><a class="permalink" href="#nr_namespace"><i>nr_namespace</i></a></dt>
  <dd>is the number of namespaces in this record</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Each namespace has <i>dev</i> and <i>inode</i> fields and is recorded in
      the fixed position like below:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="NET_NS_INDEX"><a class="permalink" href="#NET_NS_INDEX"><b>NET_NS_INDEX</b>=<b>0</b></a></dt>
  <dd>Network namespace</dd>
  <dt id="UTS_NS_INDEX"><a class="permalink" href="#UTS_NS_INDEX"><b>UTS_NS_INDEX</b>=<b>1</b></a></dt>
  <dd>UTS namespace</dd>
  <dt id="IPC_NS_INDEX"><a class="permalink" href="#IPC_NS_INDEX"><b>IPC_NS_INDEX</b>=<b>2</b></a></dt>
  <dd>IPC namespace</dd>
  <dt id="PID_NS_INDEX"><a class="permalink" href="#PID_NS_INDEX"><b>PID_NS_INDEX</b>=<b>3</b></a></dt>
  <dd>PID namespace</dd>
  <dt id="USER_NS_INDEX"><a class="permalink" href="#USER_NS_INDEX"><b>USER_NS_INDEX</b>=<b>4</b></a></dt>
  <dd>User namespace</dd>
  <dt id="MNT_NS_INDEX"><a class="permalink" href="#MNT_NS_INDEX"><b>MNT_NS_INDEX</b>=<b>5</b></a></dt>
  <dd>Mount namespace</dd>
  <dt id="CGROUP_NS_INDEX"><a class="permalink" href="#CGROUP_NS_INDEX"><b>CGROUP_NS_INDEX</b>=<b>6</b></a></dt>
  <dd>Cgroup namespace</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_KSYMBOL"><a class="permalink" href="#PERF_RECORD_KSYMBOL"><b>PERF_RECORD_KSYMBOL</b>
    (since Linux 5.0)</a></dt>
  <dd>This record indicates kernel symbol register/unregister events.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    addr;
<br>
    u32    len;
<br>
    u16    ksym_type;
<br>
    u16    flags;
<br>
    char   name[];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="addr~4"><a class="permalink" href="#addr~4"><i>addr</i></a></dt>
  <dd>is the address of the kernel symbol.</dd>
  <dt id="len~2"><a class="permalink" href="#len~2"><i>len</i></a></dt>
  <dd>is the length of the kernel symbol.</dd>
  <dt id="ksym_type"><a class="permalink" href="#ksym_type"><i>ksym_type</i></a></dt>
  <dd>is the type of the kernel symbol. Currently the following types are
      available:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_RECORD_KSYMBOL_TYPE_BPF"><a class="permalink" href="#PERF_RECORD_KSYMBOL_TYPE_BPF"><b>PERF_RECORD_KSYMBOL_TYPE_BPF</b></a></dt>
  <dd>The kernel symbol is a BPF function.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="flags~3"><a class="permalink" href="#flags~3"><i>flags</i></a></dt>
  <dd>If the <b>PERF_RECORD_KSYMBOL_FLAGS_UNREGISTER</b> is set, then this event
      is for unregistering the kernel symbol.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_BPF_EVENT"><a class="permalink" href="#PERF_RECORD_BPF_EVENT"><b>PERF_RECORD_BPF_EVENT</b>
    (since Linux 5.0)</a></dt>
  <dd>This record indicates BPF program is loaded or unloaded.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u16 type;
<br>
    u16 flags;
<br>
    u32 id;
<br>
    u8 tag[BPF_TAG_SIZE];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="type~3"><a class="permalink" href="#type~3"><i>type</i></a></dt>
  <dd>is one of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PERF_BPF_EVENT_PROG_LOAD"><a class="permalink" href="#PERF_BPF_EVENT_PROG_LOAD"><b>PERF_BPF_EVENT_PROG_LOAD</b></a></dt>
  <dd>A BPF program is loaded</dd>
  <dt id="PERF_BPF_EVENT_PROG_UNLOAD"><a class="permalink" href="#PERF_BPF_EVENT_PROG_UNLOAD"><b>PERF_BPF_EVENT_PROG_UNLOAD</b></a></dt>
  <dd>A BPF program is unloaded</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="id~4"><a class="permalink" href="#id~4"><i>id</i></a></dt>
  <dd>is the ID of the BPF program.</dd>
  <dt id="tag"><a class="permalink" href="#tag"><i>tag</i></a></dt>
  <dd>is the tag of the BPF program. Currently, <b>BPF_TAG_SIZE</b> is defined
      as 8.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_CGROUP"><a class="permalink" href="#PERF_RECORD_CGROUP"><b>PERF_RECORD_CGROUP</b>
    (since Linux 5.7)</a></dt>
  <dd>This record indicates a new cgroup is created and activated.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    id;
<br>
    char   path[];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="id~5"><a class="permalink" href="#id~5"><i>id</i></a></dt>
  <dd>is the cgroup identifier. This can be also retrieved by
      <b>name_to_handle_at</b>(2) on the cgroup path (as a file handle).</dd>
  <dt id="path"><a class="permalink" href="#path"><i>path</i></a></dt>
  <dd>is the path of the cgroup from the root.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="PERF_RECORD_TEXT_POKE"><a class="permalink" href="#PERF_RECORD_TEXT_POKE"><b>PERF_RECORD_TEXT_POKE</b>
    (since Linux 5.8)</a></dt>
  <dd>This record indicates a change in the kernel text. This includes addition
      and removal of the text and the corresponding length is zero in this
    case.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct {
<br>
    struct perf_event_header header;
<br>
    u64    addr;
<br>
    u16    old_len;
<br>
    u16    new_len;
<br>
    u8     bytes[];
<br>
    struct sample_id sample_id;
};
    </pre>
    <br>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="addr~5"><a class="permalink" href="#addr~5"><i>addr</i></a></dt>
  <dd>is the address of the change</dd>
  <dt id="old_len"><a class="permalink" href="#old_len"><i>old_len</i></a></dt>
  <dd>is the old length</dd>
  <dt id="new_len"><a class="permalink" href="#new_len"><i>new_len</i></a></dt>
  <dd>is the new length</dd>
  <dt id="bytes"><a class="permalink" href="#bytes"><i>bytes</i></a></dt>
  <dd>contains old bytes immediately followed by new bytes.</dd>
</dl>
</div>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="Overflow_handling"><a class="permalink" href="#Overflow_handling">Overflow
  handling</a></h2>
<p class="Pp">Events can be set to notify when a threshold is crossed,
    indicating an overflow. Overflow conditions can be captured by monitoring
    the event file descriptor with <b>poll</b>(2), <b>select</b>(2), or
    <b>epoll</b>(7). Alternatively, the overflow events can be captured via sa
    signal handler, by enabling I/O signaling on the file descriptor; see the
    discussion of the <b>F_SETOWN</b> and <b>F_SETSIG</b> operations in
    <b>fcntl</b>(2).</p>
<p class="Pp">Overflows are generated only by sampling events
    (<i>sample_period</i> must have a nonzero value).</p>
<p class="Pp">There are two ways to generate overflow notifications.</p>
<p class="Pp">The first is to set a <i>wakeup_events</i> or
    <i>wakeup_watermark</i> value that will trigger if a certain number of
    samples or bytes have been written to the mmap ring buffer. In this case,
    <b>POLL_IN</b> is indicated.</p>
<p class="Pp">The other way is by use of the <b>PERF_EVENT_IOC_REFRESH</b>
    ioctl. This ioctl adds to a counter that decrements each time the event
    overflows. When nonzero, <b>POLL_IN</b> is indicated, but once the counter
    reaches 0 <b>POLL_HUP</b> is indicated and the underlying event is
  disabled.</p>
<p class="Pp">Refreshing an event group leader refreshes all siblings and
    refreshing with a parameter of 0 currently enables infinite refreshes; these
    behaviors are unsupported and should not be relied on.</p>
<p class="Pp">Starting with Linux 3.18, <b>POLL_HUP</b> is indicated if the
    event being monitored is attached to a different process and that process
    exits.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="rdpmc_instruction"><a class="permalink" href="#rdpmc_instruction">rdpmc
  instruction</a></h2>
<p class="Pp">Starting with Linux 3.4 on x86, you can use the <i>rdpmc</i>
    instruction to get low-latency reads without having to enter the kernel.
    Note that using <i>rdpmc</i> is not necessarily faster than other methods
    for reading event values.</p>
<p class="Pp">Support for this can be detected with the <i>cap_usr_rdpmc</i>
    field in the mmap page; documentation on how to calculate event values can
    be found in that section.</p>
<p class="Pp">Originally, when rdpmc support was enabled, any process (not just
    ones with an active perf event) could use the rdpmc instruction to access
    the counters. Starting with Linux 4.0, rdpmc support is only allowed if an
    event is currently enabled in a process's context. To restore the old
    behavior, write the value 2 to <i>/sys/devices/cpu/rdpmc</i>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="perf_event_ioctl_calls"><a class="permalink" href="#perf_event_ioctl_calls">perf_event
  ioctl calls</a></h2>
<p class="Pp">Various ioctls act on <b>perf_event_open</b>() file
  descriptors:</p>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_ENABLE"><a class="permalink" href="#PERF_EVENT_IOC_ENABLE"><b>PERF_EVENT_IOC_ENABLE</b></a></dt>
  <dd>This enables the individual event or event group specified by the file
      descriptor argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the <b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument, then
      all events in a group are enabled, even if the event specified is not the
      group leader (but see BUGS).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_DISABLE"><a class="permalink" href="#PERF_EVENT_IOC_DISABLE"><b>PERF_EVENT_IOC_DISABLE</b></a></dt>
  <dd>This disables the individual counter or event group specified by the file
      descriptor argument.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Enabling or disabling the leader of a group enables or disables the entire
      group; that is, while the group leader is disabled, none of the counters
      in the group will count. Enabling or disabling a member of a group other
      than the leader affects only that counter; disabling a non-leader stops
      that counter from counting but doesn't affect any other counter.</dd>
  <dt></dt>
  <dd>If the <b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument, then
      all events in a group are disabled, even if the event specified is not the
      group leader (but see BUGS).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_REFRESH"><a class="permalink" href="#PERF_EVENT_IOC_REFRESH"><b>PERF_EVENT_IOC_REFRESH</b></a></dt>
  <dd>Non-inherited overflow counters can use this to enable a counter for a
      number of overflows specified by the argument, after which it is disabled.
      Subsequent calls of this ioctl add the argument value to the current
      count. An overflow notification with <b>POLL_IN</b> set will happen on
      each overflow until the count reaches 0; when that happens a notification
      with <b>POLL_HUP</b> set is sent and the event is disabled. Using an
      argument of 0 is considered undefined behavior.</dd>
  <dt id="PERF_EVENT_IOC_RESET"><a class="permalink" href="#PERF_EVENT_IOC_RESET"><b>PERF_EVENT_IOC_RESET</b></a></dt>
  <dd>Reset the event count specified by the file descriptor argument to zero.
      This resets only the counts; there is no way to reset the multiplexing
      <i>time_enabled</i> or <i>time_running</i> values.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the <b>PERF_IOC_FLAG_GROUP</b> bit is set in the ioctl argument, then
      all events in a group are reset, even if the event specified is not the
      group leader (but see BUGS).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_PERIOD"><a class="permalink" href="#PERF_EVENT_IOC_PERIOD"><b>PERF_EVENT_IOC_PERIOD</b></a></dt>
  <dd>This updates the overflow period for the event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Since Linux 3.7 (on ARM) and Linux 3.14 (all other architectures), the new
      period takes effect immediately. On older kernels, the new period did not
      take effect until after the next overflow.</dd>
  <dt></dt>
  <dd>The argument is a pointer to a 64-bit value containing the desired new
      period.</dd>
  <dt></dt>
  <dd>Prior to Linux 2.6.36, this ioctl always failed due to a bug in the
      kernel.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_SET_OUTPUT"><a class="permalink" href="#PERF_EVENT_IOC_SET_OUTPUT"><b>PERF_EVENT_IOC_SET_OUTPUT</b></a></dt>
  <dd>This tells the kernel to report event notifications to the specified file
      descriptor rather than the default one. The file descriptors must all be
      on the same CPU.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument specifies the desired file descriptor, or -1 if output should
      be ignored.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_SET_FILTER"><a class="permalink" href="#PERF_EVENT_IOC_SET_FILTER"><b>PERF_EVENT_IOC_SET_FILTER</b>
    (since Linux 2.6.33)</a></dt>
  <dd>This adds an ftrace filter to this event.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is a pointer to the desired ftrace filter.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_ID"><a class="permalink" href="#PERF_EVENT_IOC_ID"><b>PERF_EVENT_IOC_ID</b>
    (since Linux 3.12)</a></dt>
  <dd>This returns the event ID value for the given event file descriptor.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is a pointer to a 64-bit unsigned integer to hold the
    result.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_SET_BPF"><a class="permalink" href="#PERF_EVENT_IOC_SET_BPF"><b>PERF_EVENT_IOC_SET_BPF</b>
    (since Linux 4.1)</a></dt>
  <dd>This allows attaching a Berkeley Packet Filter (BPF) program to an
      existing kprobe tracepoint event. You need <b>CAP_PERFMON</b> (since Linux
      5.8) or <b>CAP_SYS_ADMIN</b> privileges to use this ioctl.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is a BPF program file descriptor that was created by a
      previous <b>bpf</b>(2) system call.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_PAUSE_OUTPUT"><a class="permalink" href="#PERF_EVENT_IOC_PAUSE_OUTPUT"><b>PERF_EVENT_IOC_PAUSE_OUTPUT</b>
    (since Linux 4.7)</a></dt>
  <dd>This allows pausing and resuming the event's ring-buffer. A paused
      ring-buffer does not prevent generation of samples, but simply discards
      them. The discarded samples are considered lost, and cause a
      <b>PERF_RECORD_LOST</b> sample to be generated when possible. An overflow
      signal may still be triggered by the discarded sample even though the
      ring-buffer remains empty.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is an unsigned 32-bit integer. A nonzero value pauses the
      ring-buffer, while a zero value resumes the ring-buffer.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_MODIFY_ATTRIBUTES"><a class="permalink" href="#PERF_EVENT_MODIFY_ATTRIBUTES"><b>PERF_EVENT_MODIFY_ATTRIBUTES</b>
    (since Linux 4.17)</a></dt>
  <dd>This allows modifying an existing event without the overhead of closing
      and reopening a new event. Currently this is supported only for breakpoint
      events.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is a pointer to a <i>perf_event_attr</i> structure containing
      the updated event settings.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="PERF_EVENT_IOC_QUERY_BPF"><a class="permalink" href="#PERF_EVENT_IOC_QUERY_BPF"><b>PERF_EVENT_IOC_QUERY_BPF</b>
    (since Linux 4.16)</a></dt>
  <dd>This allows querying which Berkeley Packet Filter (BPF) programs are
      attached to an existing kprobe tracepoint. You can only attach one BPF
      program per event, but you can have multiple events attached to a
      tracepoint. Querying this value on one tracepoint event returns the ID of
      all BPF programs in all events attached to the tracepoint. You need
      <b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b> privileges to
      use this ioctl.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument is a pointer to a structure
    <br>
    <pre>struct perf_event_query_bpf {
<br>
    __u32    ids_len;
<br>
    __u32    prog_cnt;
<br>
    __u32    ids[0];
};
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The <i>ids_len</i> field indicates the number of ids that can fit in the
      provided <i>ids</i> array. The <i>prog_cnt</i> value is filled in by the
      kernel with the number of attached BPF programs. The <i>ids</i> array is
      filled with the ID of each attached BPF program. If there are more
      programs than will fit in the array, then the kernel will return
      <b>ENOSPC</b> and <i>ids_len</i> will indicate the number of program IDs
      that were successfully copied.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_prctl(2)"><a class="permalink" href="#Using_prctl(2)">Using
  prctl(2)</a></h2>
<p class="Pp">A process can enable or disable all currently open event groups
    using the <b>prctl</b>(2) <b>PR_TASK_PERF_EVENTS_ENABLE</b> and
    <b>PR_TASK_PERF_EVENTS_DISABLE</b> operations. This applies only to events
    created locally by the calling process. This does not apply to events
    created by other processes attached to the calling process or inherited
    events from a parent process. Only group leaders are enabled and disabled,
    not any other members of the groups.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="perf_event_related_configuration_files"><a class="permalink" href="#perf_event_related_configuration_files">perf_event
  related configuration files</a></h2>
<p class="Pp">Files in <i>/proc/sys/kernel/</i></p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><i>/proc/sys/kernel/perf_event_paranoid</i></dt>
  <dd>The <i>perf_event_paranoid</i> file can be set to restrict access to the
      performance counters.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>2</b></dt>
  <dd>allow only user-space measurements (default since Linux 4.6).</dd>
  <dt><b>1</b></dt>
  <dd>allow both kernel and user measurements (default before Linux 4.6).</dd>
  <dt><b>0</b></dt>
  <dd>allow access to CPU-specific data but not raw tracepoint samples.</dd>
  <dt><b>-1</b></dt>
  <dd>no restrictions.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The existence of the <i>perf_event_paranoid</i> file is the official
      method for determining if a kernel supports <b>perf_event_open</b>().</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>/proc/sys/kernel/perf_event_max_sample_rate</i></dt>
  <dd>This sets the maximum sample rate. Setting this too high can allow users
      to sample at a rate that impacts overall machine performance and
      potentially lock up the machine. The default value is 100000 (samples per
      second).</dd>
  <dt><i>/proc/sys/kernel/perf_event_max_stack</i></dt>
  <dd>This file sets the maximum depth of stack frame entries reported when
      generating a call trace.</dd>
  <dt><i>/proc/sys/kernel/perf_event_mlock_kb</i></dt>
  <dd>Maximum number of pages an unprivileged user can <b>mlock</b>(2). The
      default is 516 (kB).</dd>
</dl>
</div>
<p class="Pp">Files in <i>/sys/bus/event_source/devices/</i></p>
<p class="Pp"></p>
<div class="Bd-indent">Since Linux 2.6.34, the kernel supports having multiple
  PMUs available for monitoring. Information on how to program these PMUs can be
  found under <i>/sys/bus/event_source/devices/</i>. Each subdirectory
  corresponds to a different PMU.
<dl class="Bl-tag">
  <dt><i>/sys/bus/event_source/devices/*/type</i> (since Linux 2.6.38)</dt>
  <dd>This contains an integer that can be used in the <i>type</i> field of
      <i>perf_event_attr</i> to indicate that you wish to use this PMU.</dd>
  <dt><i>/sys/bus/event_source/devices/cpu/rdpmc</i> (since Linux 3.4)</dt>
  <dd>If this file is 1, then direct user-space access to the performance
      counter registers is allowed via the rdpmc instruction. This can be
      disabled by echoing 0 to the file.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>As of Linux 4.0 the behavior has changed, so that 1 now means only allow
      access to processes with active perf events, with 2 indicating the old
      allow-anyone-access behavior.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>/sys/bus/event_source/devices/*/format/</i> (since Linux 3.4)</dt>
  <dd>This subdirectory contains information on the architecture-specific
      subfields available for programming the various <i>config</i> fields in
      the <i>perf_event_attr</i> struct.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The content of each file is the name of the config field, followed by a
      colon, followed by a series of integer bit ranges separated by commas. For
      example, the file <i>event</i> may contain the value
      <i>config1:1,6-10,44</i> which indicates that event is an attribute that
      occupies bits 1,6–10, and 44 of
    <i>perf_event_attr::config1</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>/sys/bus/event_source/devices/*/events/</i> (since Linux 3.4)</dt>
  <dd>This subdirectory contains files with predefined events. The contents are
      strings describing the event settings expressed in terms of the fields
      found in the previously mentioned <i>./format/</i> directory. These are
      not necessarily complete lists of all events supported by a PMU, but
      usually a subset of events deemed useful or interesting.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The content of each file is a list of attribute names separated by commas.
      Each entry has an optional value (either hex or decimal). If no value is
      specified, then it is assumed to be a single-bit field with a value of 1.
      An example entry may look like this: <i>event=0x2,inv,ldlat=3</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt><i>/sys/bus/event_source/devices/*/uevent</i></dt>
  <dd>This file is the standard kernel device interface for injecting hotplug
      events.</dd>
  <dt><i>/sys/bus/event_source/devices/*/cpumask</i> (since Linux 3.7)</dt>
  <dd>The <i>cpumask</i> file contains a comma-separated list of integers that
      indicate a representative CPU number for each socket (package) on the
      motherboard. This is needed when setting up uncore or northbridge events,
      as those PMUs present socket-wide events.</dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">On success, <b>perf_event_open</b>() returns the new file
    descriptor. On error, -1 is returned and <i>errno</i> is set to indicate the
    error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">The errors returned by <b>perf_event_open</b>() can be
    inconsistent, and may vary across processor architectures and performance
    monitoring units.</p>
<dl class="Bl-tag">
  <dt id="E2BIG"><a class="permalink" href="#E2BIG"><b>E2BIG</b></a></dt>
  <dd>Returned if the <i>perf_event_attr</i> <i>size</i> value is too small
      (smaller than <b>PERF_ATTR_SIZE_VER0</b>), too big (larger than the page
      size), or larger than the kernel supports and the extra bytes are not
      zero. When <b>E2BIG</b> is returned, the <i>perf_event_attr</i>
      <i>size</i> field is overwritten by the kernel to be the size of the
      structure it was expecting.</dd>
  <dt id="EACCES"><a class="permalink" href="#EACCES"><b>EACCES</b></a></dt>
  <dd>Returned when the requested event requires <b>CAP_PERFMON</b> (since Linux
      5.8) or <b>CAP_SYS_ADMIN</b> permissions (or a more permissive perf_event
      paranoid setting). Some common cases where an unprivileged process may
      encounter this error: attaching to a process owned by a different user;
      monitoring all processes on a given CPU (i.e., specifying the <i>pid</i>
      argument as -1); and not setting <i>exclude_kernel</i> when the paranoid
      setting requires it.</dd>
  <dt id="EBADF"><a class="permalink" href="#EBADF"><b>EBADF</b></a></dt>
  <dd>Returned if the <i>group_fd</i> file descriptor is not valid, or, if
      <b>PERF_FLAG_PID_CGROUP</b> is set, the cgroup file descriptor in
      <i>pid</i> is not valid.</dd>
  <dt id="EBUSY"><a class="permalink" href="#EBUSY"><b>EBUSY</b> (since Linux
    4.1)</a></dt>
  <dd>Returned if another event already has exclusive access to the PMU.</dd>
  <dt id="EFAULT"><a class="permalink" href="#EFAULT"><b>EFAULT</b></a></dt>
  <dd>Returned if the <i>attr</i> pointer points at an invalid memory
    address.</dd>
  <dt id="EINTR"><a class="permalink" href="#EINTR"><b>EINTR</b></a></dt>
  <dd>Returned when trying to mix perf and ftrace handling for a uprobe.</dd>
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>Returned if the specified event is invalid. There are many possible
      reasons for this. A not-exhaustive list: <i>sample_freq</i> is higher than
      the maximum setting; the <i>cpu</i> to monitor does not exist;
      <i>read_format</i> is out of range; <i>sample_type</i> is out of range;
      the <i>flags</i> value is out of range; <i>exclusive</i> or <i>pinned</i>
      set and the event is not a group leader; the event <i>config</i> values
      are out of range or set reserved bits; the generic event selected is not
      supported; or there is not enough room to add the selected event.</dd>
  <dt id="EMFILE"><a class="permalink" href="#EMFILE"><b>EMFILE</b></a></dt>
  <dd>Each opened event uses one file descriptor. If a large number of events
      are opened, the per-process limit on the number of open file descriptors
      will be reached, and no more events can be created.</dd>
  <dt id="ENODEV"><a class="permalink" href="#ENODEV"><b>ENODEV</b></a></dt>
  <dd>Returned when the event involves a feature not supported by the current
      CPU.</dd>
  <dt id="ENOENT"><a class="permalink" href="#ENOENT"><b>ENOENT</b></a></dt>
  <dd>Returned if the <i>type</i> setting is not valid. This error is also
      returned for some unsupported generic events.</dd>
  <dt id="ENOSPC"><a class="permalink" href="#ENOSPC"><b>ENOSPC</b></a></dt>
  <dd>Prior to Linux 3.3, if there was not enough room for the event,
      <b>ENOSPC</b> was returned. In Linux 3.3, this was changed to
      <b>EINVAL</b>. <b>ENOSPC</b> is still returned if you try to add more
      breakpoint events than supported by the hardware.</dd>
  <dt id="ENOSYS"><a class="permalink" href="#ENOSYS"><b>ENOSYS</b></a></dt>
  <dd>Returned if <b>PERF_SAMPLE_STACK_USER</b> is set in <i>sample_type</i> and
      it is not supported by hardware.</dd>
  <dt id="EOPNOTSUPP"><a class="permalink" href="#EOPNOTSUPP"><b>EOPNOTSUPP</b></a></dt>
  <dd>Returned if an event requiring a specific hardware feature is requested
      but there is no hardware support. This includes requesting low-skid events
      if not supported, branch tracing if it is not available, sampling if no
      PMU interrupt is available, and branch stacks for software events.</dd>
  <dt id="EOVERFLOW"><a class="permalink" href="#EOVERFLOW"><b>EOVERFLOW</b>
    (since Linux 4.8)</a></dt>
  <dd>Returned if <b>PERF_SAMPLE_CALLCHAIN</b> is requested and
      <i>sample_max_stack</i> is larger than the maximum specified in
      <i>/proc/sys/kernel/perf_event_max_stack</i>.</dd>
  <dt id="EPERM"><a class="permalink" href="#EPERM"><b>EPERM</b></a></dt>
  <dd>Returned on many (but not all) architectures when an unsupported
      <i>exclude_hv</i>, <i>exclude_idle</i>, <i>exclude_user</i>, or
      <i>exclude_kernel</i> setting is specified.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>It can also happen, as with <b>EACCES</b>, when the requested event
      requires <b>CAP_PERFMON</b> (since Linux 5.8) or <b>CAP_SYS_ADMIN</b>
      permissions (or a more permissive perf_event paranoid setting). This
      includes setting a breakpoint on a kernel address, and (since Linux 3.13)
      setting a kernel function-trace tracepoint.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="ESRCH"><a class="permalink" href="#ESRCH"><b>ESRCH</b></a></dt>
  <dd>Returned if attempting to attach to a process that does not exist.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSION"><a class="permalink" href="#VERSION">VERSION</a></h1>
<p class="Pp"><b>perf_event_open</b>() was introduced in Linux 2.6.31 but was
    called <b>perf_counter_open</b>(). It was renamed in Linux 2.6.32.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">This <b>perf_event_open</b>() system call Linux-specific and
    should not be used in programs intended to be portable.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The official way of knowing if <b>perf_event_open</b>() support is
    enabled is checking for the existence of the file
    <i>/proc/sys/kernel/perf_event_paranoid</i>.</p>
<p class="Pp"><b>CAP_PERFMON</b> capability (since Linux 5.8) provides secure
    approach to performance monitoring and observability operations in a system
    according to the principal of least privilege (POSIX IEEE 1003.1e).
    Accessing system performance monitoring and observability operations using
    <b>CAP_PERFMON</b> rather than the much more powerful <b>CAP_SYS_ADMIN</b>
    excludes chances to misuse credentials and makes operations more secure.
    <b>CAP_SYS_ADMIN</b> usage for secure system performance monitoring and
    observability is discouraged in favor of the <b>CAP_PERFMON</b>
  capability.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">The <b>F_SETOWN_EX</b> option to <b>fcntl</b>(2) is needed to
    properly get overflow signals in threads. This was introduced in Linux
    2.6.32.</p>
<p class="Pp">Prior to Linux 2.6.33 (at least for x86), the kernel did not check
    if events could be scheduled together until read time. The same happens on
    all known kernels if the NMI watchdog is enabled. This means to see if a
    given set of events works you have to <b>perf_event_open</b>(), start, then
    read before you know for sure you can get valid measurements.</p>
<p class="Pp">Prior to Linux 2.6.34, event constraints were not enforced by the
    kernel. In that case, some events would silently return "0" if the
    kernel scheduled them in an improper counter slot.</p>
<p class="Pp">Prior to Linux 2.6.34, there was a bug when multiplexing where the
    wrong results could be returned.</p>
<p class="Pp">Kernels from Linux 2.6.35 to Linux 2.6.39 can quickly crash the
    kernel if "inherit" is enabled and many threads are started.</p>
<p class="Pp">Prior to Linux 2.6.35, <b>PERF_FORMAT_GROUP</b> did not work with
    attached processes.</p>
<p class="Pp">There is a bug in the kernel code between Linux 2.6.36 and Linux
    3.0 that ignores the "watermark" field and acts as if a
    wakeup_event was chosen if the union has a nonzero value in it.</p>
<p class="Pp">From Linux 2.6.31 to Linux 3.4, the <b>PERF_IOC_FLAG_GROUP</b>
    ioctl argument was broken and would repeatedly operate on the event
    specified rather than iterating across all sibling events in a group.</p>
<p class="Pp">From Linux 3.4 to Linux 3.11, the mmap <i>cap_usr_rdpmc</i> and
    <i>cap_usr_time</i> bits mapped to the same location. Code should migrate to
    the new <i>cap_user_rdpmc</i> and <i>cap_user_time</i> fields instead.</p>
<p class="Pp">Always double-check your results! Various generalized events have
    had wrong values. For example, retired branches measured the wrong thing on
    AMD machines until Linux 2.6.35.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The following is a short example that measures the total
    instruction count of a call to <b>printf</b>(3).</p>
<p class="Pp"></p>
<pre>#include &lt;linux/perf_event.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;
#include &lt;sys/ioctl.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;
static long
perf_event_open(struct perf_event_attr *hw_event, pid_t pid,
<br>
                int cpu, int group_fd, unsigned long flags)
{
<br>
    int ret;
<br>
    ret = syscall(SYS_perf_event_open, hw_event, pid, cpu,
<br>
                  group_fd, flags);
<br>
    return ret;
}
int
main(void)
{
<br>
    int                     fd;
<br>
    long long               count;
<br>
    struct perf_event_attr  pe;
<br>
    memset(&amp;pe, 0, sizeof(pe));
<br>
    pe.type = PERF_TYPE_HARDWARE;
<br>
    pe.size = sizeof(pe);
<br>
    pe.config = PERF_COUNT_HW_INSTRUCTIONS;
<br>
    pe.disabled = 1;
<br>
    pe.exclude_kernel = 1;
<br>
    pe.exclude_hv = 1;
<br>
    fd = perf_event_open(&amp;pe, 0, -1, -1, 0);
<br>
    if (fd == -1) {
<br>
       fprintf(stderr, "Error opening leader %llx\n", pe.config);
<br>
       exit(EXIT_FAILURE);
<br>
    }
<br>
    ioctl(fd, PERF_EVENT_IOC_RESET, 0);
<br>
    ioctl(fd, PERF_EVENT_IOC_ENABLE, 0);
<br>
    printf("Measuring instruction count for this printf\n");
<br>
    ioctl(fd, PERF_EVENT_IOC_DISABLE, 0);
<br>
    read(fd, &amp;count, sizeof(count));
<br>
    printf("Used %lld instructions\n", count);
<br>
    close(fd);
}
</pre>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>perf</b>(1), <b>fcntl</b>(2), <b>mmap</b>(2), <b>open</b>(2),
    <b>prctl</b>(2), <b>read</b>(2)</p>
<p class="Pp"><i>Documentation/admin-guide/perf-security.rst</i> in the kernel
    source tree</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>