<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   t
   This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
  
   %%%LICENSE_START(VERBATIM_ONE_PARA)
   Permission is granted to distribute possibly modified copies
   of this page provided the header is included verbatim,
   and in case of nontrivial modification author and date
   of the modification is added to the header.
   %%%LICENSE_END
  
   $Id: ip.7,v 1.19 2000/12/20 18:10:31 ak Exp $
  
   FIXME The following socket options are yet to be documented
  
   	IP_XFRM_POLICY (2.5.48)
  	    Needs CAP_NET_ADMIN
  
   	IP_IPSEC_POLICY (2.5.47)
  	    Needs CAP_NET_ADMIN
  
  	IP_MINTTL (2.6.34)
  	    commit d218d11133d888f9745802146a50255a4781d37a
  	    Author: Stephen Hemminger <shemminger@vyatta.com>
  
  	MCAST_JOIN_GROUP (2.4.22 / 2.6)
  
  	MCAST_BLOCK_SOURCE (2.4.22 / 2.6)
  
  	MCAST_UNBLOCK_SOURCE (2.4.22 / 2.6)
  
  	MCAST_LEAVE_GROUP (2.4.22 / 2.6)
  
  	MCAST_JOIN_SOURCE_GROUP (2.4.22 / 2.6)
  
  	MCAST_LEAVE_SOURCE_GROUP (2.4.22 / 2.6)
  
  	MCAST_MSFILTER (2.4.22 / 2.6)
  
  	IP_UNICAST_IF (3.4)
  	    commit 76e21053b5bf33a07c76f99d27a74238310e3c71
  	    Author: Erich E. Hoover <ehoover@mines.edu>
   --><head>
<meta name="dc.identifier" content="res/179368a1e1544af0f596103e3c46365ef81e3c82">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>ip(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">ip(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">ip(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">ip - Linux IPv4 protocol implementation</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;sys/socket.h&gt;</b>
<b>#include &lt;netinet/in.h&gt;</b>
<b>#include &lt;netinet/ip.h&gt; /* superset of previous */</b></pre>
<pre><i>tcp_socket</i><b> = socket(AF_INET, SOCK_STREAM, 0);</b>
<i>udp_socket</i><b> = socket(AF_INET, SOCK_DGRAM, 0);</b>
<i>raw_socket</i><b> = socket(AF_INET, SOCK_RAW, </b><i>protocol</i><b>);</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Linux implements the Internet Protocol, version 4, described in
    RFC&nbsp;791 and RFC&nbsp;1122. <b>ip</b> contains a level 2
    multicasting implementation conforming to RFC&nbsp;1112. It also contains
    an IP router including a packet filter.</p>
<p class="Pp">The programming interface is BSD-sockets compatible. For more
    information on sockets, see <b>socket</b>(7).</p>
<p class="Pp">An IP socket is created using <b>socket</b>(2):</p>
<p class="Pp">
  <br>
</p>
<pre>socket(AF_INET, socket_type, protocol);
</pre>
<br>
<p class="Pp">Valid socket types include <b>SOCK_STREAM</b> to open a stream
    socket, <b>SOCK_DGRAM</b> to open a datagram socket, and <b>SOCK_RAW</b> to
    open a <b>raw</b>(7) socket to access the IP protocol directly.</p>
<p class="Pp"><i>protocol</i> is the IP protocol in the IP header to be received
    or sent. Valid values for <i>protocol</i> include:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>0 and <b>IPPROTO_TCP</b> for <b>tcp</b>(7) stream sockets;</dd>
  <dt>•</dt>
  <dd>0 and <b>IPPROTO_UDP</b> for <b>udp</b>(7) datagram sockets;</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_SCTP</b> for <b>sctp</b>(7) stream sockets; and</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_UDPLITE</b> for <b>udplite</b>(7) datagram sockets.</dd>
</dl>
<p class="Pp">For <b>SOCK_RAW</b> you may specify a valid IANA IP protocol
    defined in RFC&nbsp;1700 assigned numbers.</p>
<p class="Pp">When a process wants to receive new incoming packets or
    connections, it should bind a socket to a local interface address using
    <b>bind</b>(2). In this case, only one IP socket may be bound to any given
    local (address, port) pair. When <b>INADDR_ANY</b> is specified in the bind
    call, the socket will be bound to <i>all</i> local interfaces. When
    <b>listen</b>(2) is called on an unbound socket, the socket is automatically
    bound to a random free port with the local address set to <b>INADDR_ANY</b>.
    When <b>connect</b>(2) is called on an unbound socket, the socket is
    automatically bound to a random free port or to a usable shared port with
    the local address set to <b>INADDR_ANY</b>.</p>
<p class="Pp">A TCP local socket address that has been bound is unavailable for
    some time after closing, unless the <b>SO_REUSEADDR</b> flag has been set.
    Care should be taken when using this flag as it makes TCP less reliable.</p>
<section class="Ss">
<h2 class="Ss" id="Address_format"><a class="permalink" href="#Address_format">Address
  format</a></h2>
<p class="Pp">An IP socket address is defined as a combination of an IP
    interface address and a 16-bit port number. The basic IP protocol does not
    supply port numbers, they are implemented by higher level protocols like
    <b>udp</b>(7) and <b>tcp</b>(7). On raw sockets <i>sin_port</i> is set to
    the IP protocol.</p>
<p class="Pp">
  <br>
</p>
<pre>struct sockaddr_in {
<br>
    sa_family_t    sin_family; /* address family: AF_INET */
<br>
    in_port_t      sin_port;   /* port in network byte order */
<br>
    struct in_addr sin_addr;   /* internet address */
};
/* Internet address */
struct in_addr {
<br>
    uint32_t       s_addr;     /* address in network byte order */
};
</pre>
<br>
<p class="Pp"><i>sin_family</i> is always set to <b>AF_INET</b>. This is
    required; in Linux 2.2 most networking functions return <b>EINVAL</b> when
    this setting is missing. <i>sin_port</i> contains the port in network byte
    order. The port numbers below 1024 are called <i>privileged ports</i> (or
    sometimes: <i>reserved ports</i>). Only a privileged process (on Linux: a
    process that has the <b>CAP_NET_BIND_SERVICE</b> capability in the user
    namespace governing its network namespace) may <b>bind</b>(2) to these
    sockets. Note that the raw IPv4 protocol as such has no concept of a port,
    they are implemented only by higher protocols like <b>tcp</b>(7) and
    <b>udp</b>(7).</p>
<p class="Pp"><i>sin_addr</i> is the IP host address. The <i>s_addr</i> member
    of <i>struct in_addr</i> contains the host interface address in network byte
    order. <i>in_addr</i> should be assigned one of the <b>INADDR_*</b> values
    (e.g., <b>INADDR_LOOPBACK</b>) using <b>htonl</b>(3) or set using the
    <b>inet_aton</b>(3), <b>inet_addr</b>(3), <b>inet_makeaddr</b>(3) library
    functions or directly with the name resolver (see
  <b>gethostbyname</b>(3)).</p>
<p class="Pp">IPv4 addresses are divided into unicast, broadcast, and multicast
    addresses. Unicast addresses specify a single interface of a host, broadcast
    addresses specify all hosts on a network, and multicast addresses address
    all hosts in a multicast group. Datagrams to broadcast addresses can be sent
    or received only when the <b>SO_BROADCAST</b> socket flag is set. In the
    current implementation, connection-oriented sockets are allowed to use only
    unicast addresses.</p>
<p class="Pp">Note that the address and the port are always stored in network
    byte order. In particular, this means that you need to call <b>htons</b>(3)
    on the number that is assigned to a port. All address/port manipulation
    functions in the standard library work in network byte order.</p>
<p class="Pp">There are several special addresses: <b>INADDR_LOOPBACK</b>
    (127.0.0.1) always refers to the local host via the loopback device;
    <b>INADDR_ANY</b> (0.0.0.0) means any address for binding;
    <b>INADDR_BROADCAST</b> (255.255.255.255) means any host and has the same
    effect on bind as <b>INADDR_ANY</b> for historical reasons.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Socket_options"><a class="permalink" href="#Socket_options">Socket
  options</a></h2>
<p class="Pp">IP supports some protocol-specific socket options that can be set
    with <b>setsockopt</b>(2) and read with <b>getsockopt</b>(2). The socket
    option level for IP is <b>IPPROTO_IP</b>. A boolean integer flag is zero
    when it is false, otherwise true.</p>
<p class="Pp">When an invalid socket option is specified, <b>getsockopt</b>(2)
    and <b>setsockopt</b>(2) fail with the error <b>ENOPROTOOPT</b>.</p>
<dl class="Bl-tag">
  <dt id="IP_ADD_MEMBERSHIP"><a class="permalink" href="#IP_ADD_MEMBERSHIP"><b>IP_ADD_MEMBERSHIP</b>
    (since Linux 1.2)</a></dt>
  <dd>Join a multicast group. Argument is an <i>ip_mreqn</i> structure.</dd>
</dl>
<p class="Pp">
  <br>
</p>
<pre>struct ip_mreqn {
<br>
    struct in_addr imr_multiaddr; /* IP multicast group
<br>
                                     address */
<br>
    struct in_addr imr_address;   /* IP address of local
<br>
                                     interface */
<br>
    int            imr_ifindex;   /* interface index */
};
</pre>
<br>
<p class="Pp"><i>imr_multiaddr</i> contains the address of the multicast group
    the application wants to join or leave. It must be a valid multicast address
    (or <b>setsockopt</b>(2) fails with the error <b>EINVAL</b>).
    <i>imr_address</i> is the address of the local interface with which the
    system should join the multicast group; if it is equal to <b>INADDR_ANY</b>,
    an appropriate interface is chosen by the system. <i>imr_ifindex</i> is the
    interface index of the interface that should join/leave the
    <i>imr_multiaddr</i> group, or 0 to indicate any interface.</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <i>ip_mreqn</i> structure is available only since Linux 2.2. For
      compatibility, the old <i>ip_mreq</i> structure (present since Linux 1.2)
      is still supported; it differs from <i>ip_mreqn</i> only by not including
      the <i>imr_ifindex</i> field. (The kernel determines which structure is
      being passed based on the size passed in <i>optlen</i>.)</dd>
  <dt></dt>
  <dd><b>IP_ADD_MEMBERSHIP</b> is valid only for <b>setsockopt</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_ADD_SOURCE_MEMBERSHIP"><a class="permalink" href="#IP_ADD_SOURCE_MEMBERSHIP"><b>IP_ADD_SOURCE_MEMBERSHIP</b>
    (since Linux 2.4.22 / Linux 2.5.68)</a></dt>
  <dd>Join a multicast group and allow receiving data only from a specified
      source. Argument is an <i>ip_mreq_source</i> structure.</dd>
</dl>
<p class="Pp">
  <br>
</p>
<pre>struct ip_mreq_source {
<br>
    struct in_addr imr_multiaddr;  /* IP multicast group
<br>
                                      address */
<br>
    struct in_addr imr_interface;  /* IP address of local
<br>
                                      interface */
<br>
    struct in_addr imr_sourceaddr; /* IP address of
<br>
                                      multicast source */
};
</pre>
<br>
<p class="Pp">The <i>ip_mreq_source</i> structure is similar to <i>ip_mreqn</i>
    described under <b>IP_ADD_MEMBERSHIP</b>. The <i>imr_multiaddr</i> field
    contains the address of the multicast group the application wants to join or
    leave. The <i>imr_interface</i> field is the address of the local interface
    with which the system should join the multicast group. Finally, the
    <i>imr_sourceaddr</i> field contains the address of the source the
    application wants to receive data from.</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This option can be used multiple times to allow receiving data from more
      than one source.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_BIND_ADDRESS_NO_PORT"><a class="permalink" href="#IP_BIND_ADDRESS_NO_PORT"><b>IP_BIND_ADDRESS_NO_PORT</b>
    (since Linux 4.2)</a></dt>
  <dd>Inform the kernel to not reserve an ephemeral port when using
      <b>bind</b>(2) with a port number of 0. The port will later be
      automatically chosen at <b>connect</b>(2) time, in a way that allows
      sharing a source port as long as the 4-tuple is unique.</dd>
  <dt id="IP_BLOCK_SOURCE"><a class="permalink" href="#IP_BLOCK_SOURCE"><b>IP_BLOCK_SOURCE</b>
    (since Linux 2.4.22 / 2.5.68)</a></dt>
  <dd>Stop receiving multicast data from a specific source in a given group.
      This is valid only after the application has subscribed to the multicast
      group using either <b>IP_ADD_MEMBERSHIP</b> or
      <b>IP_ADD_SOURCE_MEMBERSHIP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Argument is an <i>ip_mreq_source</i> structure as described under
      <b>IP_ADD_SOURCE_MEMBERSHIP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_DROP_MEMBERSHIP"><a class="permalink" href="#IP_DROP_MEMBERSHIP"><b>IP_DROP_MEMBERSHIP</b>
    (since Linux 1.2)</a></dt>
  <dd>Leave a multicast group. Argument is an <i>ip_mreqn</i> or <i>ip_mreq</i>
      structure similar to <b>IP_ADD_MEMBERSHIP</b>.</dd>
  <dt id="IP_DROP_SOURCE_MEMBERSHIP"><a class="permalink" href="#IP_DROP_SOURCE_MEMBERSHIP"><b>IP_DROP_SOURCE_MEMBERSHIP</b>
    (since Linux 2.4.22 / 2.5.68)</a></dt>
  <dd>Leave a source-specific group—that is, stop receiving data from a
      given multicast group that come from a given source. If the application
      has subscribed to multiple sources within the same group, data from the
      remaining sources will still be delivered. To stop receiving data from all
      sources at once, use <b>IP_DROP_MEMBERSHIP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Argument is an <i>ip_mreq_source</i> structure as described under
      <b>IP_ADD_SOURCE_MEMBERSHIP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_FREEBIND"><a class="permalink" href="#IP_FREEBIND"><b>IP_FREEBIND</b>
    (since Linux 2.4)</a></dt>
  <dd>If enabled, this boolean option allows binding to an IP address that is
      nonlocal or does not (yet) exist. This permits listening on a socket,
      without requiring the underlying network interface or the specified
      dynamic IP address to be up at the time that the application is trying to
      bind to it. This option is the per-socket equivalent of the
      <i>ip_nonlocal_bind</i> <i>/proc</i> interface described below.</dd>
  <dt id="IP_HDRINCL"><a class="permalink" href="#IP_HDRINCL"><b>IP_HDRINCL</b>
    (since Linux 2.0)</a></dt>
  <dd>If enabled, the user supplies an IP header in front of the user data.
      Valid only for <b>SOCK_RAW</b> sockets; see <b>raw</b>(7) for more
      information. When this flag is enabled, the values set by
      <b>IP_OPTIONS</b>, <b>IP_TTL</b>, and <b>IP_TOS</b> are ignored.</dd>
  <dt id="IP_MSFILTER"><a class="permalink" href="#IP_MSFILTER"><b>IP_MSFILTER</b>
    (since Linux 2.4.22 / 2.5.68)</a></dt>
  <dd>This option provides access to the advanced full-state filtering API.
      Argument is an <i>ip_msfilter</i> structure.</dd>
</dl>
<p class="Pp">
  <br>
</p>
<pre>struct ip_msfilter {
<br>
    struct in_addr imsf_multiaddr; /* IP multicast group
<br>
                                      address */
<br>
    struct in_addr imsf_interface; /* IP address of local
<br>
                                      interface */
<br>
    uint32_t       imsf_fmode;     /* Filter-mode */
<br>
    uint32_t       imsf_numsrc;    /* Number of sources in
<br>
                                      the following array */
<br>
    struct in_addr imsf_slist[1];  /* Array of source
<br>
                                      addresses */
};
</pre>
<br>
<p class="Pp">There are two macros, <b>MCAST_INCLUDE</b> and
    <b>MCAST_EXCLUDE</b>, which can be used to specify the filtering mode.
    Additionally, the <b>IP_MSFILTER_SIZE</b>(n) macro exists to determine how
    much memory is needed to store <i>ip_msfilter</i> structure with <i>n</i>
    sources in the source list.</p>
<dl class="Bl-tag">
  <dt></dt>
  <dd>For the full description of multicast source filtering refer to RFC
    3376.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_MTU"><a class="permalink" href="#IP_MTU"><b>IP_MTU</b> (since Linux
    2.2)</a></dt>
  <dd>Retrieve the current known path MTU of the current socket. Returns an
      integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd><b>IP_MTU</b> is valid only for <b>getsockopt</b>(2) and can be employed
      only when the socket has been connected.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_MTU_DISCOVER"><a class="permalink" href="#IP_MTU_DISCOVER"><b>IP_MTU_DISCOVER</b>
    (since Linux 2.2)</a></dt>
  <dd>Set or receive the Path MTU Discovery setting for a socket. When enabled,
      Linux will perform Path MTU Discovery as defined in RFC&nbsp;1191 on
      <b>SOCK_STREAM</b> sockets. For non-<b>SOCK_STREAM</b> sockets,
      <b>IP_PMTUDISC_DO</b> forces the don't-fragment flag to be set on all
      outgoing packets. It is the user's responsibility to packetize the data in
      MTU-sized chunks and to do the retransmits if necessary. The kernel will
      reject (with <b>EMSGSIZE</b>) datagrams that are bigger than the known
      path MTU. <b>IP_PMTUDISC_WANT</b> will fragment a datagram if needed
      according to the path MTU, or will set the don't-fragment flag
    otherwise.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The system-wide default can be toggled between <b>IP_PMTUDISC_WANT</b> and
      <b>IP_PMTUDISC_DONT</b> by writing (respectively, zero and nonzero values)
      to the <i>/proc/sys/net/ipv4/ip_no_pmtu_disc</i> file.
    <table class="tbl">
      <tbody><tr>
        <td style="text-align: center;">Path MTU discovery value</td>
        <td>Meaning</td>
      </tr>
      <tr>
        <td>IP_PMTUDISC_WANT</td>
        <td>Use per-route settings.</td>
      </tr>
      <tr>
        <td>IP_PMTUDISC_DONT</td>
        <td>Never do Path MTU Discovery.</td>
      </tr>
      <tr>
        <td>IP_PMTUDISC_DO</td>
        <td>Always do Path MTU Discovery.</td>
      </tr>
      <tr>
        <td>IP_PMTUDISC_PROBE</td>
        <td>Set DF but ignore Path MTU.</td>
      </tr>
    </tbody></table>
    <p class="Pp">When PMTU discovery is enabled, the kernel automatically keeps
        track of the path MTU per destination host. When it is connected to a
        specific peer with <b>connect</b>(2), the currently known path MTU can
        be retrieved conveniently using the <b>IP_MTU</b> socket option (e.g.,
        after an <b>EMSGSIZE</b> error occurred). The path MTU may change over
        time. For connectionless sockets with many destinations, the new MTU for
        a given destination can also be accessed using the error queue (see
        <b>IP_RECVERR</b>). A new error will be queued for every incoming MTU
        update.</p>
  </dd>
  <dt></dt>
  <dd>While MTU discovery is in progress, initial packets from datagram sockets
      may be dropped. Applications using UDP should be aware of this and not
      take it into account for their packet retransmit strategy.</dd>
  <dt></dt>
  <dd>To bootstrap the path MTU discovery process on unconnected sockets, it is
      possible to start with a big datagram size (headers up to 64 kilobytes
      long) and let it shrink by updates of the path MTU.</dd>
  <dt></dt>
  <dd>To get an initial estimate of the path MTU, connect a datagram socket to
      the destination address using <b>connect</b>(2) and retrieve the MTU by
      calling <b>getsockopt</b>(2) with the <b>IP_MTU</b> option.</dd>
  <dt></dt>
  <dd>It is possible to implement RFC 4821 MTU probing with <b>SOCK_DGRAM</b> or
      <b>SOCK_RAW</b> sockets by setting a value of <b>IP_PMTUDISC_PROBE</b>
      (available since Linux 2.6.22). This is also particularly useful for
      diagnostic tools such as <b>tracepath</b>(8) that wish to deliberately
      send probe packets larger than the observed Path MTU.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_MULTICAST_ALL"><a class="permalink" href="#IP_MULTICAST_ALL"><b>IP_MULTICAST_ALL</b>
    (since Linux 2.6.31)</a></dt>
  <dd>This option can be used to modify the delivery policy of multicast
      messages. The argument is a boolean integer (defaults to 1). If set to 1,
      the socket will receive messages from all the groups that have been joined
      globally on the whole system. Otherwise, it will deliver messages only
      from the groups that have been explicitly joined (for example via the
      <b>IP_ADD_MEMBERSHIP</b> option) on this particular socket.</dd>
  <dt id="IP_MULTICAST_IF"><a class="permalink" href="#IP_MULTICAST_IF"><b>IP_MULTICAST_IF</b>
    (since Linux 1.2)</a></dt>
  <dd>Set the local device for a multicast socket. The argument for
      <b>setsockopt</b>(2) is an <i>ip_mreqn</i> or (since Linux 3.5)
      <i>ip_mreq</i> structure similar to <b>IP_ADD_MEMBERSHIP</b>, or an
      <i>in_addr</i> structure. (The kernel determines which structure is being
      passed based on the size passed in <i>optlen</i>.) For
      <b>getsockopt</b>(2), the argument is an <i>in_addr</i> structure.</dd>
  <dt id="IP_MULTICAST_LOOP"><a class="permalink" href="#IP_MULTICAST_LOOP"><b>IP_MULTICAST_LOOP</b>
    (since Linux 1.2)</a></dt>
  <dd>Set or read a boolean integer argument that determines whether sent
      multicast packets should be looped back to the local sockets.</dd>
  <dt id="IP_MULTICAST_TTL"><a class="permalink" href="#IP_MULTICAST_TTL"><b>IP_MULTICAST_TTL</b>
    (since Linux 1.2)</a></dt>
  <dd>Set or read the time-to-live value of outgoing multicast packets for this
      socket. It is very important for multicast packets to set the smallest TTL
      possible. The default is 1 which means that multicast packets don't leave
      the local network unless the user program explicitly requests it. Argument
      is an integer.</dd>
  <dt id="IP_NODEFRAG"><a class="permalink" href="#IP_NODEFRAG"><b>IP_NODEFRAG</b>
    (since Linux 2.6.36)</a></dt>
  <dd>If enabled (argument is nonzero), the reassembly of outgoing packets is
      disabled in the netfilter layer. The argument is an integer.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This option is valid only for <b>SOCK_RAW</b> sockets.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_OPTIONS"><a class="permalink" href="#IP_OPTIONS"><b>IP_OPTIONS</b>
    (since Linux 2.0)</a></dt>
  <dd>Set or get the IP options to be sent with every packet from this socket.
      The arguments are a pointer to a memory buffer containing the options and
      the option length. The <b>setsockopt</b>(2) call sets the IP options
      associated with a socket. The maximum option size for IPv4 is 40 bytes.
      See RFC&nbsp;791 for the allowed options. When the initial connection
      request packet for a <b>SOCK_STREAM</b> socket contains IP options, the IP
      options will be set automatically to the options from the initial packet
      with routing headers reversed. Incoming packets are not allowed to change
      options after the connection is established. The processing of all
      incoming source routing options is disabled by default and can be enabled
      by using the <i>accept_source_route</i> <i>/proc</i> interface. Other
      options like timestamps are still handled. For datagram sockets, IP
      options can be set only by the local user. Calling <b>getsockopt</b>(2)
      with <b>IP_OPTIONS</b> puts the current IP options used for sending into
      the supplied buffer.</dd>
  <dt id="IP_PASSSEC"><a class="permalink" href="#IP_PASSSEC"><b>IP_PASSSEC</b>
    (since Linux 2.6.17)</a></dt>
  <dd>If labeled IPSEC or NetLabel is configured on the sending and receiving
      hosts, this option enables receiving of the security context of the peer
      socket in an ancillary message of type <b>SCM_SECURITY</b> retrieved using
      <b>recvmsg</b>(2). This option is supported only for UDP sockets; for TCP
      or SCTP sockets, see the description of the <b>SO_PEERSEC</b> option
      below.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The value given as an argument to <b>setsockopt</b>(2) and returned as the
      result of <b>getsockopt</b>(2) is an integer boolean flag.</dd>
  <dt></dt>
  <dd>The security context returned in the <b>SCM_SECURITY</b> ancillary message
      is of the same format as the one described under the <b>SO_PEERSEC</b>
      option below.</dd>
  <dt></dt>
  <dd>Note: the reuse of the <b>SCM_SECURITY</b> message type for the
      <b>IP_PASSSEC</b> socket option was likely a mistake, since other IP
      control messages use their own numbering scheme in the IP namespace and
      often use the socket option value as the message type. There is no
      conflict currently since the IP option with the same value as
      <b>SCM_SECURITY</b> is <b>IP_HDRINCL</b> and this is never used for a
      control message type.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_PKTINFO"><a class="permalink" href="#IP_PKTINFO"><b>IP_PKTINFO</b>
    (since Linux 2.2)</a></dt>
  <dd>Pass an <b>IP_PKTINFO</b> ancillary message that contains a <i>pktinfo</i>
      structure that supplies some information about the incoming packet. This
      works only for datagram oriented sockets. The argument is a flag that
      tells the socket whether the <b>IP_PKTINFO</b> message should be passed or
      not. The message itself can be sent/retrieved only as a control message
      with a packet using <b>recvmsg</b>(2) or <b>sendmsg</b>(2).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>struct in_pktinfo {
<br>
    unsigned int   ipi_ifindex;  /* Interface index */
<br>
    struct in_addr ipi_spec_dst; /* Local address */
<br>
    struct in_addr ipi_addr;     /* Header Destination
<br>
                                    address */
};
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd><i>ipi_ifindex</i> is the unique index of the interface the packet was
      received on. <i>ipi_spec_dst</i> is the local address of the packet and
      <i>ipi_addr</i> is the destination address in the packet header. If
      <b>IP_PKTINFO</b> is passed to <b>sendmsg</b>(2) and <i>ipi_spec_dst</i>
      is not zero, then it is used as the local source address for the routing
      table lookup and for setting up IP source route options. When
      <i>ipi_ifindex</i> is not zero, the primary local address of the interface
      specified by the index overwrites <i>ipi_spec_dst</i> for the routing
      table lookup.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_RECVERR"><a class="permalink" href="#IP_RECVERR"><b>IP_RECVERR</b>
    (since Linux 2.2)</a></dt>
  <dd>Enable extended reliable error message passing. When enabled on a datagram
      socket, all generated errors will be queued in a per-socket error queue.
      When the user receives an error from a socket operation, the errors can be
      received by calling <b>recvmsg</b>(2) with the <b>MSG_ERRQUEUE</b> flag
      set. The <i>sock_extended_err</i> structure describing the error will be
      passed in an ancillary message with the type <b>IP_RECVERR</b> and the
      level <b>IPPROTO_IP</b>. This is useful for reliable error handling on
      unconnected sockets. The received data portion of the error queue contains
      the error packet.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The <b>IP_RECVERR</b> control message contains a <i>sock_extended_err</i>
      structure:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>#define SO_EE_ORIGIN_NONE    0
#define SO_EE_ORIGIN_LOCAL   1
#define SO_EE_ORIGIN_ICMP    2
#define SO_EE_ORIGIN_ICMP6   3
struct sock_extended_err {
<br>
    uint32_t ee_errno;   /* error number */
<br>
    uint8_t  ee_origin;  /* where the error originated */
<br>
    uint8_t  ee_type;    /* type */
<br>
    uint8_t  ee_code;    /* code */
<br>
    uint8_t  ee_pad;
<br>
    uint32_t ee_info;    /* additional information */
<br>
    uint32_t ee_data;    /* other data */
<br>
    /* More data may follow */
};
struct sockaddr *SO_EE_OFFENDER(struct sock_extended_err *);
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd><i>ee_errno</i> contains the <i>errno</i> number of the queued error.
      <i>ee_origin</i> is the origin code of where the error originated. The
      other fields are protocol-specific. The macro <b>SO_EE_OFFENDER</b>
      returns a pointer to the address of the network object where the error
      originated from given a pointer to the ancillary message. If this address
      is not known, the <i>sa_family</i> member of the <i>sockaddr</i> contains
      <b>AF_UNSPEC</b> and the other fields of the <i>sockaddr</i> are
      undefined.</dd>
  <dt></dt>
  <dd>IP uses the <i>sock_extended_err</i> structure as follows:
      <i>ee_origin</i> is set to <b>SO_EE_ORIGIN_ICMP</b> for errors received as
      an ICMP packet, or <b>SO_EE_ORIGIN_LOCAL</b> for locally generated errors.
      Unknown values should be ignored. <i>ee_type</i> and <i>ee_code</i> are
      set from the type and code fields of the ICMP header. <i>ee_info</i>
      contains the discovered MTU for <b>EMSGSIZE</b> errors. The message also
      contains the <i>sockaddr_in of the node</i> caused the error, which can be
      accessed with the <b>SO_EE_OFFENDER</b> macro. The <i>sin_family</i> field
      of the <b>SO_EE_OFFENDER</b> address is <b>AF_UNSPEC</b> when the source
      was unknown. When the error originated from the network, all IP options
      (<b>IP_OPTIONS</b>, <b>IP_TTL</b>, etc.) enabled on the socket and
      contained in the error packet are passed as control messages. The payload
      of the packet causing the error is returned as normal payload. Note that
      TCP has no error queue; <b>MSG_ERRQUEUE</b> is not permitted on
      <b>SOCK_STREAM</b> sockets. <b>IP_RECVERR</b> is valid for TCP, but all
      errors are returned by socket function return or <b>SO_ERROR</b>
    only.</dd>
  <dt></dt>
  <dd>For raw sockets, <b>IP_RECVERR</b> enables passing of all received ICMP
      errors to the application, otherwise errors are reported only on connected
      sockets</dd>
  <dt></dt>
  <dd>It sets or retrieves an integer boolean flag. <b>IP_RECVERR</b> defaults
      to off.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_RECVOPTS"><a class="permalink" href="#IP_RECVOPTS"><b>IP_RECVOPTS</b>
    (since Linux 2.2)</a></dt>
  <dd>Pass all incoming IP options to the user in a <b>IP_OPTIONS</b> control
      message. The routing header and other options are already filled in for
      the local host. Not supported for <b>SOCK_STREAM</b> sockets.</dd>
  <dt id="IP_RECVORIGDSTADDR"><a class="permalink" href="#IP_RECVORIGDSTADDR"><b>IP_RECVORIGDSTADDR</b>
    (since Linux 2.6.29)</a></dt>
  <dd>This boolean option enables the <b>IP_ORIGDSTADDR</b> ancillary message in
      <b>recvmsg</b>(2), in which the kernel returns the original destination
      address of the datagram being received. The ancillary message contains a
      <i>struct sockaddr_in</i>.</dd>
  <dt id="IP_RECVTOS"><a class="permalink" href="#IP_RECVTOS"><b>IP_RECVTOS</b>
    (since Linux 2.2)</a></dt>
  <dd>If enabled, the <b>IP_TOS</b> ancillary message is passed with incoming
      packets. It contains a byte which specifies the Type of Service/Precedence
      field of the packet header. Expects a boolean integer flag.</dd>
  <dt id="IP_RECVTTL"><a class="permalink" href="#IP_RECVTTL"><b>IP_RECVTTL</b>
    (since Linux 2.2)</a></dt>
  <dd>When this flag is set, pass a <b>IP_TTL</b> control message with the
      time-to-live field of the received packet as a 32 bit integer. Not
      supported for <b>SOCK_STREAM</b> sockets.</dd>
  <dt id="IP_RETOPTS"><a class="permalink" href="#IP_RETOPTS"><b>IP_RETOPTS</b>
    (since Linux 2.2)</a></dt>
  <dd>Identical to <b>IP_RECVOPTS</b>, but returns raw unprocessed options with
      timestamp and route record options not filled in for this hop.</dd>
  <dt id="IP_ROUTER_ALERT"><a class="permalink" href="#IP_ROUTER_ALERT"><b>IP_ROUTER_ALERT</b>
    (since Linux 2.2)</a></dt>
  <dd>Pass all to-be forwarded packets with the IP Router Alert option set to
      this socket. Valid only for raw sockets. This is useful, for instance, for
      user-space RSVP daemons. The tapped packets are not forwarded by the
      kernel; it is the user's responsibility to send them out again. Socket
      binding is ignored, such packets are filtered only by protocol. Expects an
      integer flag.</dd>
  <dt id="IP_TOS"><a class="permalink" href="#IP_TOS"><b>IP_TOS</b> (since Linux
    1.0)</a></dt>
  <dd>Set or receive the Type-Of-Service (TOS) field that is sent with every IP
      packet originating from this socket. It is used to prioritize packets on
      the network. TOS is a byte. There are some standard TOS flags defined:
      <b>IPTOS_LOWDELAY</b> to minimize delays for interactive traffic,
      <b>IPTOS_THROUGHPUT</b> to optimize throughput, <b>IPTOS_RELIABILITY</b>
      to optimize for reliability, <b>IPTOS_MINCOST</b> should be used for
      "filler data" where slow transmission doesn't matter. At most
      one of these TOS values can be specified. Other bits are invalid and shall
      be cleared. Linux sends <b>IPTOS_LOWDELAY</b> datagrams first by default,
      but the exact behavior depends on the configured queueing discipline. Some
      high-priority levels may require superuser privileges (the
      <b>CAP_NET_ADMIN</b> capability).</dd>
  <dt id="IP_TRANSPARENT"><a class="permalink" href="#IP_TRANSPARENT"><b>IP_TRANSPARENT</b>
    (since Linux 2.6.24)</a></dt>
  <dd>Setting this boolean option enables transparent proxying on this socket.
      This socket option allows the calling application to bind to a nonlocal IP
      address and operate both as a client and a server with the foreign address
      as the local endpoint. NOTE: this requires that routing be set up in a way
      that packets going to the foreign address are routed through the TProxy
      box (i.e., the system hosting the application that employs the
      <b>IP_TRANSPARENT</b> socket option). Enabling this socket option requires
      superuser privileges (the <b>CAP_NET_ADMIN</b> capability).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>TProxy redirection with the iptables TPROXY target also requires that this
      option be set on the redirected socket.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="IP_TTL"><a class="permalink" href="#IP_TTL"><b>IP_TTL</b> (since Linux
    1.0)</a></dt>
  <dd>Set or retrieve the current time-to-live field that is used in every
      packet sent from this socket.</dd>
  <dt id="IP_UNBLOCK_SOURCE"><a class="permalink" href="#IP_UNBLOCK_SOURCE"><b>IP_UNBLOCK_SOURCE</b>
    (since Linux 2.4.22 / 2.5.68)</a></dt>
  <dd>Unblock previously blocked multicast source. Returns <b>EADDRNOTAVAIL</b>
      when given source is not being blocked.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Argument is an <i>ip_mreq_source</i> structure as described under
      <b>IP_ADD_SOURCE_MEMBERSHIP</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SO_PEERSEC"><a class="permalink" href="#SO_PEERSEC"><b>SO_PEERSEC</b>
    (since Linux 2.6.17)</a></dt>
  <dd>If labeled IPSEC or NetLabel is configured on both the sending and
      receiving hosts, this read-only socket option returns the security context
      of the peer socket connected to this socket. By default, this will be the
      same as the security context of the process that created the peer socket
      unless overridden by the policy or by a process with the required
      permissions.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The argument to <b>getsockopt</b>(2) is a pointer to a buffer of the
      specified length in bytes into which the security context string will be
      copied. If the buffer length is less than the length of the security
      context string, then <b>getsockopt</b>(2) returns -1, sets <i>errno</i> to
      <b>ERANGE</b>, and returns the required length via <i>optlen</i>. The
      caller should allocate at least <b>NAME_MAX</b> bytes for the buffer
      initially, although this is not guaranteed to be sufficient. Resizing the
      buffer to the returned length and retrying may be necessary.</dd>
  <dt></dt>
  <dd>The security context string may include a terminating null character in
      the returned length, but is not guaranteed to do so: a security context
      "foo" might be represented as either {'f','o','o'} of length 3
      or {'f','o','o','\0'} of length 4, which are considered to be
      interchangeable. The string is printable, does not contain non-terminating
      null characters, and is in an unspecified encoding (in particular, it is
      not guaranteed to be ASCII or UTF-8).</dd>
  <dt></dt>
  <dd>The use of this option for sockets in the <b>AF_INET</b> address family is
      supported since Linux 2.6.17 for TCP sockets, and since Linux 4.17 for
      SCTP sockets.</dd>
  <dt></dt>
  <dd>For SELinux, NetLabel conveys only the MLS portion of the security context
      of the peer across the wire, defaulting the rest of the security context
      to the values defined in the policy for the netmsg initial security
      identifier (SID). However, NetLabel can be configured to pass full
      security contexts over loopback. Labeled IPSEC always passes full security
      contexts as part of establishing the security association (SA) and looks
      them up based on the association for each packet.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="/proc_interfaces"><a class="permalink" href="#/proc_interfaces">/proc
  interfaces</a></h2>
<p class="Pp">The IP protocol supports a set of <i>/proc</i> interfaces to
    configure some global parameters. The parameters can be accessed by reading
    or writing files in the directory <i>/proc/sys/net/ipv4/</i>. Interfaces
    described as <i>Boolean</i> take an integer value, with a nonzero value
    ("true") meaning that the corresponding option is enabled, and a
    zero value ("false") meaning that the option is disabled.</p>
<dl class="Bl-tag">
  <dt id="ip_always_defrag"><a class="permalink" href="#ip_always_defrag"><i>ip_always_defrag</i>
    (Boolean; since Linux 2.2.13)</a></dt>
  <dd>[New with Linux 2.2.13; in earlier kernel versions this feature was
      controlled at compile time by the <b>CONFIG_IP_ALWAYS_DEFRAG</b> option;
      this option is not present in Linux 2.4.x and later]</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When this boolean flag is enabled (not equal 0), incoming fragments (parts
      of IP packets that arose when some host between origin and destination
      decided that the packets were too large and cut them into pieces) will be
      reassembled (defragmented) before being processed, even if they are about
      to be forwarded.</dd>
  <dt></dt>
  <dd>Enable only if running either a firewall that is the sole link to your
      network or a transparent proxy; never ever use it for a normal router or
      host. Otherwise, fragmented communication can be disturbed if the
      fragments travel over different links. Defragmentation also has a large
      memory and CPU time cost.</dd>
  <dt></dt>
  <dd>This is automagically turned on when masquerading or transparent proxying
      are configured.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="ip_autoconfig"><a class="permalink" href="#ip_autoconfig"><i>ip_autoconfig</i>
    (since Linux 2.2 to Linux 2.6.17)</a></dt>
  <dd>Not documented.</dd>
  <dt id="ip_default_ttl"><a class="permalink" href="#ip_default_ttl"><i>ip_default_ttl</i>
    (integer; default: 64; since Linux 2.2)</a></dt>
  <dd>Set the default time-to-live value of outgoing packets. This can be
      changed per socket with the <b>IP_TTL</b> option.</dd>
  <dt id="ip_dynaddr"><a class="permalink" href="#ip_dynaddr"><i>ip_dynaddr</i>
    (Boolean; default: disabled; since Linux 2.0.31)</a></dt>
  <dd>Enable dynamic socket address and masquerading entry rewriting on
      interface address change. This is useful for dialup interface with
      changing IP addresses. 0 means no rewriting, 1 turns it on and 2 enables
      verbose mode.</dd>
  <dt id="ip_forward"><a class="permalink" href="#ip_forward"><i>ip_forward</i>
    (Boolean; default: disabled; since Linux 1.2)</a></dt>
  <dd>Enable IP forwarding with a boolean flag. IP forwarding can be also set on
      a per-interface basis.</dd>
  <dt id="ip_local_port_range"><a class="permalink" href="#ip_local_port_range"><i>ip_local_port_range</i>
    (since Linux 2.2)</a></dt>
  <dd>This file contains two integers that define the default local port range
      allocated to sockets that are not explicitly bound to a port
      number—that is, the range used for <i>ephemeral ports</i>. An
      ephemeral port is allocated to a socket in the following
    circumstances:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>the port number in a socket address is specified as 0 when calling
      <b>bind</b>(2);</dd>
  <dt>•</dt>
  <dd><b>listen</b>(2) is called on a stream socket that was not previously
      bound;</dd>
  <dt>•</dt>
  <dd><b>connect</b>(2) was called on a socket that was not previously
    bound;</dd>
  <dt>•</dt>
  <dd><b>sendto</b>(2) is called on a datagram socket that was not previously
      bound.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Allocation of ephemeral ports starts with the first number in
      <i>ip_local_port_range</i> and ends with the second number. If the range
      of ephemeral ports is exhausted, then the relevant system call returns an
      error (but see BUGS).</dd>
  <dt></dt>
  <dd>Note that the port range in <i>ip_local_port_range</i> should not conflict
      with the ports used by masquerading (although the case is handled). Also,
      arbitrary choices may cause problems with some firewall packet filters
      that make assumptions about the local ports in use. The first number
      should be at least greater than 1024, or better, greater than 4096, to
      avoid clashes with well known ports and to minimize firewall
    problems.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="ip_no_pmtu_disc"><a class="permalink" href="#ip_no_pmtu_disc"><i>ip_no_pmtu_disc</i>
    (Boolean; default: disabled; since Linux 2.2)</a></dt>
  <dd>If enabled, don't do Path MTU Discovery for TCP sockets by default. Path
      MTU discovery may fail if misconfigured firewalls (that drop all ICMP
      packets) or misconfigured interfaces (e.g., a point-to-point link where
      the both ends don't agree on the MTU) are on the path. It is better to fix
      the broken routers on the path than to turn off Path MTU Discovery
      globally, because not doing it incurs a high cost to the network.</dd>
  <dt id="ip_nonlocal_bind"><a class="permalink" href="#ip_nonlocal_bind"><i>ip_nonlocal_bind</i>
    (Boolean; default: disabled; since Linux 2.4)</a></dt>
  <dd>If set, allows processes to <b>bind</b>(2) to nonlocal IP addresses, which
      can be quite useful, but may break some applications.</dd>
  <dt id="ip6frag_time"><a class="permalink" href="#ip6frag_time"><i>ip6frag_time</i>
    (integer; default: 30)</a></dt>
  <dd>Time in seconds to keep an IPv6 fragment in memory.</dd>
  <dt id="ip6frag_secret_interval"><a class="permalink" href="#ip6frag_secret_interval"><i>ip6frag_secret_interval</i>
    (integer; default: 600)</a></dt>
  <dd>Regeneration interval (in seconds) of the hash secret (or lifetime for the
      hash secret) for IPv6 fragments.</dd>
  <dt id="ipfrag_high_thresh"><a class="permalink" href="#ipfrag_high_thresh"><i>ipfrag_high_thresh</i>
    (integer), <i>ipfrag_low_thresh</i> (integer)</a></dt>
  <dd>If the amount of queued IP fragments reaches <i>ipfrag_high_thresh</i>,
      the queue is pruned down to <i>ipfrag_low_thresh</i>. Contains an integer
      with the number of bytes.</dd>
  <dt id="neigh/*"><a class="permalink" href="#neigh/*"><i>neigh/*</i></a></dt>
  <dd>See <b>arp</b>(7).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Ioctls"><a class="permalink" href="#Ioctls">Ioctls</a></h2>
<p class="Pp">All ioctls described in <b>socket</b>(7) apply to <b>ip</b>.</p>
<p class="Pp">Ioctls to configure generic device parameters are described in
    <b>netdevice</b>(7).</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<dl class="Bl-tag">
  <dt id="EACCES"><a class="permalink" href="#EACCES"><b>EACCES</b></a></dt>
  <dd>The user tried to execute an operation without the necessary permissions.
      These include: sending a packet to a broadcast address without having the
      <b>SO_BROADCAST</b> flag set; sending a packet via a <i>prohibit</i>
      route; modifying firewall settings without superuser privileges (the
      <b>CAP_NET_ADMIN</b> capability); binding to a privileged port without
      superuser privileges (the <b>CAP_NET_BIND_SERVICE</b> capability).</dd>
  <dt id="EADDRINUSE"><a class="permalink" href="#EADDRINUSE"><b>EADDRINUSE</b></a></dt>
  <dd>Tried to bind to an address already in use.</dd>
  <dt id="EADDRNOTAVAIL"><a class="permalink" href="#EADDRNOTAVAIL"><b>EADDRNOTAVAIL</b></a></dt>
  <dd>A nonexistent interface was requested or the requested source address was
      not local.</dd>
  <dt id="EAGAIN"><a class="permalink" href="#EAGAIN"><b>EAGAIN</b></a></dt>
  <dd>Operation on a nonblocking socket would block.</dd>
  <dt id="EALREADY"><a class="permalink" href="#EALREADY"><b>EALREADY</b></a></dt>
  <dd>A connection operation on a nonblocking socket is already in
    progress.</dd>
  <dt id="ECONNABORTED"><a class="permalink" href="#ECONNABORTED"><b>ECONNABORTED</b></a></dt>
  <dd>A connection was closed during an <b>accept</b>(2).</dd>
  <dt id="EHOSTUNREACH"><a class="permalink" href="#EHOSTUNREACH"><b>EHOSTUNREACH</b></a></dt>
  <dd>No valid routing table entry matches the destination address. This error
      can be caused by an ICMP message from a remote router or for the local
      routing table.</dd>
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>Invalid argument passed. For send operations this can be caused by sending
      to a <i>blackhole</i> route.</dd>
  <dt id="EISCONN"><a class="permalink" href="#EISCONN"><b>EISCONN</b></a></dt>
  <dd><b>connect</b>(2) was called on an already connected socket.</dd>
  <dt id="EMSGSIZE"><a class="permalink" href="#EMSGSIZE"><b>EMSGSIZE</b></a></dt>
  <dd>Datagram is bigger than an MTU on the path and it cannot be
    fragmented.</dd>
  <dt id="ENOBUFS"><a class="permalink" href="#ENOBUFS"><b>ENOBUFS</b>,
    <b>ENOMEM</b></a></dt>
  <dd>Not enough free memory. This often means that the memory allocation is
      limited by the socket buffer limits, not by the system memory, but this is
      not 100% consistent.</dd>
  <dt id="ENOENT"><a class="permalink" href="#ENOENT"><b>ENOENT</b></a></dt>
  <dd><b>SIOCGSTAMP</b> was called on a socket where no packet arrived.</dd>
  <dt id="ENOPKG"><a class="permalink" href="#ENOPKG"><b>ENOPKG</b></a></dt>
  <dd>A kernel subsystem was not configured.</dd>
  <dt id="ENOPROTOOPT"><a class="permalink" href="#ENOPROTOOPT"><b>ENOPROTOOPT</b>
    and <b>EOPNOTSUPP</b></a></dt>
  <dd>Invalid socket option passed.</dd>
  <dt id="ENOTCONN"><a class="permalink" href="#ENOTCONN"><b>ENOTCONN</b></a></dt>
  <dd>The operation is defined only on a connected socket, but the socket wasn't
      connected.</dd>
  <dt id="EPERM"><a class="permalink" href="#EPERM"><b>EPERM</b></a></dt>
  <dd>User doesn't have permission to set high priority, change configuration,
      or send signals to the requested process or group.</dd>
  <dt id="EPIPE"><a class="permalink" href="#EPIPE"><b>EPIPE</b></a></dt>
  <dd>The connection was unexpectedly closed or shut down by the other end.</dd>
  <dt id="ESOCKTNOSUPPORT"><a class="permalink" href="#ESOCKTNOSUPPORT"><b>ESOCKTNOSUPPORT</b></a></dt>
  <dd>The socket is not configured or an unknown socket type was requested.</dd>
</dl>
<p class="Pp">Other errors may be generated by the overlaying protocols; see
    <b>tcp</b>(7), <b>raw</b>(7), <b>udp</b>(7), and <b>socket</b>(7).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp"><b>IP_FREEBIND</b>, <b>IP_MSFILTER</b>, <b>IP_MTU</b>,
    <b>IP_MTU_DISCOVER</b>, <b>IP_RECVORIGDSTADDR</b>, <b>IP_PASSSEC</b>,
    <b>IP_PKTINFO</b>, <b>IP_RECVERR</b>, <b>IP_ROUTER_ALERT</b>, and
    <b>IP_TRANSPARENT</b> are Linux-specific.</p>
<p class="Pp">Be very careful with the <b>SO_BROADCAST</b> option - it is not
    privileged in Linux. It is easy to overload the network with careless
    broadcasts. For new application protocols it is better to use a multicast
    group instead of broadcasting. Broadcasting is discouraged.</p>
<p class="Pp">Some other BSD sockets implementations provide
    <b>IP_RCVDSTADDR</b> and <b>IP_RECVIF</b> socket options to get the
    destination address and the interface of received datagrams. Linux has the
    more general <b>IP_PKTINFO</b> for the same task.</p>
<p class="Pp">Some BSD sockets implementations also provide an <b>IP_RECVTTL</b>
    option, but an ancillary message with type <b>IP_RECVTTL</b> is passed with
    the incoming packet. This is different from the <b>IP_TTL</b> option used in
    Linux.</p>
<p class="Pp">Using the <b>SOL_IP</b> socket options level isn't portable;
    BSD-based stacks use the <b>IPPROTO_IP</b> level.</p>
<p class="Pp"><b>INADDR_ANY</b> (0.0.0.0) and <b>INADDR_BROADCAST</b>
    (255.255.255.255) are byte-order-neutral. This means <b>htonl</b>(3) has no
    effect on them.</p>
<section class="Ss">
<h2 class="Ss" id="Compatibility"><a class="permalink" href="#Compatibility">Compatibility</a></h2>
<p class="Pp">For compatibility with Linux 2.0, the obsolete <b>socket(AF_INET,
    SOCK_PACKET, </b><i>protocol</i><b>)</b> syntax is still supported to open a
    <b>packet</b>(7) socket. This is deprecated and should be replaced by
    <b>socket(AF_PACKET, SOCK_RAW, </b><i>protocol</i><b>)</b> instead. The main
    difference is the new <i>sockaddr_ll</i> address structure for generic link
    layer information instead of the old <b>sockaddr_pkt</b>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">There are too many inconsistent error values.</p>
<p class="Pp">The error used to diagnose exhaustion of the ephemeral port range
    differs across the various system calls (<b>connect</b>(2), <b>bind</b>(2),
    <b>listen</b>(2), <b>sendto</b>(2)) that can assign ephemeral ports.</p>
<p class="Pp">The ioctls to configure IP-specific interface options and ARP
    tables are not described.</p>
<p class="Pp">Receiving the original destination address with
    <b>MSG_ERRQUEUE</b> in <i>msg_name</i> by <b>recvmsg</b>(2) does not work in
    some Linux 2.2 kernels.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>recvmsg</b>(2), <b>sendmsg</b>(2), <b>byteorder</b>(3),
    <b>capabilities</b>(7), <b>icmp</b>(7), <b>ipv6</b>(7), <b>netdevice</b>(7),
    <b>netlink</b>(7), <b>raw</b>(7), <b>socket</b>(7), <b>tcp</b>(7),
    <b>udp</b>(7), <b>ip</b>(8)</p>
<p class="Pp">The kernel source file
    <i>Documentation/networking/ip-sysctl.txt</i>.</p>
<p class="Pp">RFC&nbsp;791 for the original IP specification. RFC&nbsp;1122
    for the IPv4 host requirements. RFC&nbsp;1812 for the IPv4 router
    requirements.</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>