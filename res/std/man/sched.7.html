<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (C) 2014 Michael Kerrisk <mtk.manpages@gmail.com>
   and Copyright (C) 2014 Peter Zijlstra <peterz@infradead.org>
   and Copyright (C) 2014 Juri Lelli <juri.lelli@gmail.com>
   Various pieces from the old sched_setscheduler(2) page
   	Copyright (C) Tom Bjorkholm, Markus Kuhn & David A. Wheeler 1996-1999
   	and Copyright (C) 2007 Carsten Emde <Carsten.Emde@osadl.org>
   	and Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
  
   SPDX-License-Identifier: GPL-2.0-or-later
  
   Worth looking at: http://rt.wiki.kernel.org/index.php
   --><head>
<meta name="dc.identifier" content="res/129b9f1204a5ee89094b4a104e2f66a522c6b74d">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>sched(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">sched(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">sched(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">sched - overview of CPU scheduling</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Since Linux 2.6.23, the default scheduler is CFS, the
    "Completely Fair Scheduler". The CFS scheduler replaced the
    earlier "O(1)" scheduler.</p>
<section class="Ss">
<h2 class="Ss" id="API_summary"><a class="permalink" href="#API_summary">API
  summary</a></h2>
<p class="Pp">Linux provides the following system calls for controlling the CPU
    scheduling behavior, policy, and priority of processes (or, more precisely,
    threads).</p>
<dl class="Bl-tag">
  <dt id="nice"><a class="permalink" href="#nice"><b>nice</b>(2)</a></dt>
  <dd>Set a new nice value for the calling thread, and return the new nice
      value.</dd>
  <dt id="getpriority"><a class="permalink" href="#getpriority"><b>getpriority</b>(2)</a></dt>
  <dd>Return the nice value of a thread, a process group, or the set of threads
      owned by a specified user.</dd>
  <dt id="setpriority"><a class="permalink" href="#setpriority"><b>setpriority</b>(2)</a></dt>
  <dd>Set the nice value of a thread, a process group, or the set of threads
      owned by a specified user.</dd>
  <dt id="sched_setscheduler"><a class="permalink" href="#sched_setscheduler"><b>sched_setscheduler</b>(2)</a></dt>
  <dd>Set the scheduling policy and parameters of a specified thread.</dd>
  <dt id="sched_getscheduler"><a class="permalink" href="#sched_getscheduler"><b>sched_getscheduler</b>(2)</a></dt>
  <dd>Return the scheduling policy of a specified thread.</dd>
  <dt id="sched_setparam"><a class="permalink" href="#sched_setparam"><b>sched_setparam</b>(2)</a></dt>
  <dd>Set the scheduling parameters of a specified thread.</dd>
  <dt id="sched_getparam"><a class="permalink" href="#sched_getparam"><b>sched_getparam</b>(2)</a></dt>
  <dd>Fetch the scheduling parameters of a specified thread.</dd>
  <dt id="sched_get_priority_max"><a class="permalink" href="#sched_get_priority_max"><b>sched_get_priority_max</b>(2)</a></dt>
  <dd>Return the maximum priority available in a specified scheduling
    policy.</dd>
  <dt id="sched_get_priority_min"><a class="permalink" href="#sched_get_priority_min"><b>sched_get_priority_min</b>(2)</a></dt>
  <dd>Return the minimum priority available in a specified scheduling
    policy.</dd>
  <dt id="sched_rr_get_interval"><a class="permalink" href="#sched_rr_get_interval"><b>sched_rr_get_interval</b>(2)</a></dt>
  <dd>Fetch the quantum used for threads that are scheduled under the
      "round-robin" scheduling policy.</dd>
  <dt id="sched_yield"><a class="permalink" href="#sched_yield"><b>sched_yield</b>(2)</a></dt>
  <dd>Cause the caller to relinquish the CPU, so that some other thread be
      executed.</dd>
  <dt id="sched_setaffinity"><a class="permalink" href="#sched_setaffinity"><b>sched_setaffinity</b>(2)</a></dt>
  <dd>(Linux-specific) Set the CPU affinity of a specified thread.</dd>
  <dt id="sched_getaffinity"><a class="permalink" href="#sched_getaffinity"><b>sched_getaffinity</b>(2)</a></dt>
  <dd>(Linux-specific) Get the CPU affinity of a specified thread.</dd>
  <dt id="sched_setattr"><a class="permalink" href="#sched_setattr"><b>sched_setattr</b>(2)</a></dt>
  <dd>Set the scheduling policy and parameters of a specified thread. This
      (Linux-specific) system call provides a superset of the functionality of
      <b>sched_setscheduler</b>(2) and <b>sched_setparam</b>(2).</dd>
  <dt id="sched_getattr"><a class="permalink" href="#sched_getattr"><b>sched_getattr</b>(2)</a></dt>
  <dd>Fetch the scheduling policy and parameters of a specified thread. This
      (Linux-specific) system call provides a superset of the functionality of
      <b>sched_getscheduler</b>(2) and <b>sched_getparam</b>(2).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Scheduling_policies"><a class="permalink" href="#Scheduling_policies">Scheduling
  policies</a></h2>
<p class="Pp">The scheduler is the kernel component that decides which runnable
    thread will be executed by the CPU next. Each thread has an associated
    scheduling policy and a <i>static</i> scheduling priority,
    <i>sched_priority</i>. The scheduler makes its decisions based on knowledge
    of the scheduling policy and static priority of all threads on the
  system.</p>
<p class="Pp">For threads scheduled under one of the normal scheduling policies
    (<b>SCHED_OTHER</b>, <b>SCHED_IDLE</b>, <b>SCHED_BATCH</b>),
    <i>sched_priority</i> is not used in scheduling decisions (it must be
    specified as 0).</p>
<p class="Pp">Processes scheduled under one of the real-time policies
    (<b>SCHED_FIFO</b>, <b>SCHED_RR</b>) have a <i>sched_priority</i> value in
    the range 1 (low) to 99 (high). (As the numbers imply, real-time threads
    always have higher priority than normal threads.) Note well: POSIX.1
    requires an implementation to support only a minimum 32 distinct priority
    levels for the real-time policies, and some systems supply just this
    minimum. Portable programs should use <b>sched_get_priority_min</b>(2) and
    <b>sched_get_priority_max</b>(2) to find the range of priorities supported
    for a particular policy.</p>
<p class="Pp">Conceptually, the scheduler maintains a list of runnable threads
    for each possible <i>sched_priority</i> value. In order to determine which
    thread runs next, the scheduler looks for the nonempty list with the highest
    static priority and selects the thread at the head of this list.</p>
<p class="Pp">A thread's scheduling policy determines where it will be inserted
    into the list of threads with equal static priority and how it will move
    inside this list.</p>
<p class="Pp">All scheduling is preemptive: if a thread with a higher static
    priority becomes ready to run, the currently running thread will be
    preempted and returned to the wait list for its static priority level. The
    scheduling policy determines the ordering only within the list of runnable
    threads with equal static priority.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_FIFO:_First_in-first_out_scheduling"><a class="permalink" href="#SCHED_FIFO:_First_in-first_out_scheduling">SCHED_FIFO:
  First in-first out scheduling</a></h2>
<p class="Pp"><b>SCHED_FIFO</b> can be used only with static priorities higher
    than 0, which means that when a <b>SCHED_FIFO</b> thread becomes runnable,
    it will always immediately preempt any currently running <b>SCHED_OTHER</b>,
    <b>SCHED_BATCH</b>, or <b>SCHED_IDLE</b> thread. <b>SCHED_FIFO</b> is a
    simple scheduling algorithm without time slicing. For threads scheduled
    under the <b>SCHED_FIFO</b> policy, the following rules apply:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>A running <b>SCHED_FIFO</b> thread that has been preempted by another
      thread of higher priority will stay at the head of the list for its
      priority and will resume execution as soon as all threads of higher
      priority are blocked again.</dd>
  <dt>•</dt>
  <dd>When a blocked <b>SCHED_FIFO</b> thread becomes runnable, it will be
      inserted at the end of the list for its priority.</dd>
  <dt>•</dt>
  <dd>If a call to <b>sched_setscheduler</b>(2), <b>sched_setparam</b>(2),
      <b>sched_setattr</b>(2), <b>pthread_setschedparam</b>(3), or
      <b>pthread_setschedprio</b>(3) changes the priority of the running or
      runnable <b>SCHED_FIFO</b> thread identified by <i>pid</i> the effect on
      the thread's position in the list depends on the direction of the change
      to threads priority:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>(a)</dt>
  <dd>If the thread's priority is raised, it is placed at the end of the list
      for its new priority. As a consequence, it may preempt a currently running
      thread with the same priority.</dd>
  <dt>(b)</dt>
  <dd>If the thread's priority is unchanged, its position in the run list is
      unchanged.</dd>
  <dt>(c)</dt>
  <dd>If the thread's priority is lowered, it is placed at the front of the list
      for its new priority.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>According to POSIX.1-2008, changes to a thread's priority (or policy)
      using any mechanism other than <b>pthread_setschedprio</b>(3) should
      result in the thread being placed at the end of the list for its
    priority.</dd>
  <dt>•</dt>
  <dd>A thread calling <b>sched_yield</b>(2) will be put at the end of the
    list.</dd>
</dl>
<p class="Pp">No other events will move a thread scheduled under the
    <b>SCHED_FIFO</b> policy in the wait list of runnable threads with equal
    static priority.</p>
<p class="Pp">A <b>SCHED_FIFO</b> thread runs until either it is blocked by an
    I/O request, it is preempted by a higher priority thread, or it calls
    <b>sched_yield</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_RR:_Round-robin_scheduling"><a class="permalink" href="#SCHED_RR:_Round-robin_scheduling">SCHED_RR:
  Round-robin scheduling</a></h2>
<p class="Pp"><b>SCHED_RR</b> is a simple enhancement of <b>SCHED_FIFO</b>.
    Everything described above for <b>SCHED_FIFO</b> also applies to
    <b>SCHED_RR</b>, except that each thread is allowed to run only for a
    maximum time quantum. If a <b>SCHED_RR</b> thread has been running for a
    time period equal to or longer than the time quantum, it will be put at the
    end of the list for its priority. A <b>SCHED_RR</b> thread that has been
    preempted by a higher priority thread and subsequently resumes execution as
    a running thread will complete the unexpired portion of its round-robin time
    quantum. The length of the time quantum can be retrieved using
    <b>sched_rr_get_interval</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_DEADLINE:_Sporadic_task_model_deadline_scheduling"><a class="permalink" href="#SCHED_DEADLINE:_Sporadic_task_model_deadline_scheduling">SCHED_DEADLINE:
  Sporadic task model deadline scheduling</a></h2>
<p class="Pp">Since Linux 3.14, Linux provides a deadline scheduling policy
    (<b>SCHED_DEADLINE</b>). This policy is currently implemented using GEDF
    (Global Earliest Deadline First) in conjunction with CBS (Constant Bandwidth
    Server). To set and fetch this policy and associated attributes, one must
    use the Linux-specific <b>sched_setattr</b>(2) and <b>sched_getattr</b>(2)
    system calls.</p>
<p class="Pp">A sporadic task is one that has a sequence of jobs, where each job
    is activated at most once per period. Each job also has a <i>relative
    deadline</i>, before which it should finish execution, and a <i>computation
    time</i>, which is the CPU time necessary for executing the job. The moment
    when a task wakes up because a new job has to be executed is called the
    <i>arrival time</i> (also referred to as the request time or release time).
    The <i>start time</i> is the time at which a task starts its execution. The
    <i>absolute deadline</i> is thus obtained by adding the relative deadline to
    the arrival time.</p>
<p class="Pp">The following diagram clarifies these terms:</p>
<p class="Pp">
  <br>
</p>
<pre>arrival/wakeup                    absolute deadline
<br>
     |    start time                    |
<br>
     |        |                         |
<br>
     v        v                         v
-----x--------xooooooooooooooooo--------x--------x---
<br>
              |&lt;- comp. time -&gt;|
<br>
     |&lt;------- relative deadline ------&gt;|
<br>
     |&lt;-------------- period -------------------&gt;|
</pre>
<br>
<p class="Pp">When setting a <b>SCHED_DEADLINE</b> policy for a thread using
    <b>sched_setattr</b>(2), one can specify three parameters: <i>Runtime</i>,
    <i>Deadline</i>, and <i>Period</i>. These parameters do not necessarily
    correspond to the aforementioned terms: usual practice is to set Runtime to
    something bigger than the average computation time (or worst-case execution
    time for hard real-time tasks), Deadline to the relative deadline, and
    Period to the period of the task. Thus, for <b>SCHED_DEADLINE</b>
    scheduling, we have:</p>
<p class="Pp">
  <br>
</p>
<pre>arrival/wakeup                    absolute deadline
<br>
     |    start time                    |
<br>
     |        |                         |
<br>
     v        v                         v
-----x--------xooooooooooooooooo--------x--------x---
<br>
              |&lt;-- Runtime -------&gt;|
<br>
     |&lt;----------- Deadline -----------&gt;|
<br>
     |&lt;-------------- Period -------------------&gt;|
</pre>
<br>
<p class="Pp">The three deadline-scheduling parameters correspond to the
    <i>sched_runtime</i>, <i>sched_deadline</i>, and <i>sched_period</i> fields
    of the <i>sched_attr</i> structure; see <b>sched_setattr</b>(2). These
    fields express values in nanoseconds. If <i>sched_period</i> is specified as
    0, then it is made the same as <i>sched_deadline</i>.</p>
<p class="Pp">The kernel requires that:</p>
<p class="Pp">
  <br>
</p>
<pre>sched_runtime &lt;= sched_deadline &lt;= sched_period
</pre>
<br>
<p class="Pp">In addition, under the current implementation, all of the
    parameter values must be at least 1024 (i.e., just over one microsecond,
    which is the resolution of the implementation), and less than 2^63. If any
    of these checks fails, <b>sched_setattr</b>(2) fails with the error
    <b>EINVAL</b>.</p>
<p class="Pp">The CBS guarantees non-interference between tasks, by throttling
    threads that attempt to over-run their specified Runtime.</p>
<p class="Pp">To ensure deadline scheduling guarantees, the kernel must prevent
    situations where the set of <b>SCHED_DEADLINE</b> threads is not feasible
    (schedulable) within the given constraints. The kernel thus performs an
    admittance test when setting or changing <b>SCHED_DEADLINE</b> policy and
    attributes. This admission test calculates whether the change is feasible;
    if it is not, <b>sched_setattr</b>(2) fails with the error <b>EBUSY</b>.</p>
<p class="Pp">For example, it is required (but not necessarily sufficient) for
    the total utilization to be less than or equal to the total number of CPUs
    available, where, since each thread can maximally run for Runtime per
    Period, that thread's utilization is its Runtime divided by its Period.</p>
<p class="Pp">In order to fulfill the guarantees that are made when a thread is
    admitted to the <b>SCHED_DEADLINE</b> policy, <b>SCHED_DEADLINE</b> threads
    are the highest priority (user controllable) threads in the system; if any
    <b>SCHED_DEADLINE</b> thread is runnable, it will preempt any thread
    scheduled under one of the other policies.</p>
<p class="Pp">A call to <b>fork</b>(2) by a thread scheduled under the
    <b>SCHED_DEADLINE</b> policy fails with the error <b>EAGAIN</b>, unless the
    thread has its reset-on-fork flag set (see below).</p>
<p class="Pp">A <b>SCHED_DEADLINE</b> thread that calls <b>sched_yield</b>(2)
    will yield the current job and wait for a new period to begin.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_OTHER:_Default_Linux_time-sharing_scheduling"><a class="permalink" href="#SCHED_OTHER:_Default_Linux_time-sharing_scheduling">SCHED_OTHER:
  Default Linux time-sharing scheduling</a></h2>
<p class="Pp"><b>SCHED_OTHER</b> can be used at only static priority 0 (i.e.,
    threads under real-time policies always have priority over
    <b>SCHED_OTHER</b> processes). <b>SCHED_OTHER</b> is the standard Linux
    time-sharing scheduler that is intended for all threads that do not require
    the special real-time mechanisms.</p>
<p class="Pp">The thread to run is chosen from the static priority 0 list based
    on a <i>dynamic</i> priority that is determined only inside this list. The
    dynamic priority is based on the nice value (see below) and is increased for
    each time quantum the thread is ready to run, but denied to run by the
    scheduler. This ensures fair progress among all <b>SCHED_OTHER</b>
  threads.</p>
<p class="Pp">In the Linux kernel source code, the <b>SCHED_OTHER</b> policy is
    actually named <b>SCHED_NORMAL</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_nice_value"><a class="permalink" href="#The_nice_value">The
  nice value</a></h2>
<p class="Pp">The nice value is an attribute that can be used to influence the
    CPU scheduler to favor or disfavor a process in scheduling decisions. It
    affects the scheduling of <b>SCHED_OTHER</b> and <b>SCHED_BATCH</b> (see
    below) processes. The nice value can be modified using <b>nice</b>(2),
    <b>setpriority</b>(2), or <b>sched_setattr</b>(2).</p>
<p class="Pp">According to POSIX.1, the nice value is a per-process attribute;
    that is, the threads in a process should share a nice value. However, on
    Linux, the nice value is a per-thread attribute: different threads in the
    same process may have different nice values.</p>
<p class="Pp">The range of the nice value varies across UNIX systems. On modern
    Linux, the range is -20 (high priority) to +19 (low priority). On some other
    systems, the range is -20..20. Very early Linux kernels (before Linux 2.0)
    had the range -infinity..15.</p>
<p class="Pp">The degree to which the nice value affects the relative scheduling
    of <b>SCHED_OTHER</b> processes likewise varies across UNIX systems and
    across Linux kernel versions.</p>
<p class="Pp">With the advent of the CFS scheduler in Linux 2.6.23, Linux
    adopted an algorithm that causes relative differences in nice values to have
    a much stronger effect. In the current implementation, each unit of
    difference in the nice values of two processes results in a factor of 1.25
    in the degree to which the scheduler favors the higher priority process.
    This causes very low nice values (+19) to truly provide little CPU to a
    process whenever there is any other higher priority load on the system, and
    makes high nice values (-20) deliver most of the CPU to applications that
    require it (e.g., some audio applications).</p>
<p class="Pp">On Linux, the <b>RLIMIT_NICE</b> resource limit can be used to
    define a limit to which an unprivileged process's nice value can be raised;
    see <b>setrlimit</b>(2) for details.</p>
<p class="Pp">For further details on the nice value, see the subsections on the
    autogroup feature and group scheduling, below.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_BATCH:_Scheduling_batch_processes"><a class="permalink" href="#SCHED_BATCH:_Scheduling_batch_processes">SCHED_BATCH:
  Scheduling batch processes</a></h2>
<p class="Pp">(Since Linux 2.6.16.) <b>SCHED_BATCH</b> can be used only at
    static priority 0. This policy is similar to <b>SCHED_OTHER</b> in that it
    schedules the thread according to its dynamic priority (based on the nice
    value). The difference is that this policy will cause the scheduler to
    always assume that the thread is CPU-intensive. Consequently, the scheduler
    will apply a small scheduling penalty with respect to wakeup behavior, so
    that this thread is mildly disfavored in scheduling decisions.</p>
<p class="Pp">This policy is useful for workloads that are noninteractive, but
    do not want to lower their nice value, and for workloads that want a
    deterministic scheduling policy without interactivity causing extra
    preemptions (between the workload's tasks).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="SCHED_IDLE:_Scheduling_very_low_priority_jobs"><a class="permalink" href="#SCHED_IDLE:_Scheduling_very_low_priority_jobs">SCHED_IDLE:
  Scheduling very low priority jobs</a></h2>
<p class="Pp">(Since Linux 2.6.23.) <b>SCHED_IDLE</b> can be used only at static
    priority 0; the process nice value has no influence for this policy.</p>
<p class="Pp">This policy is intended for running jobs at extremely low priority
    (lower even than a +19 nice value with the <b>SCHED_OTHER</b> or
    <b>SCHED_BATCH</b> policies).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Resetting_scheduling_policy_for_child_processes"><a class="permalink" href="#Resetting_scheduling_policy_for_child_processes">Resetting
  scheduling policy for child processes</a></h2>
<p class="Pp">Each thread has a reset-on-fork scheduling flag. When this flag is
    set, children created by <b>fork</b>(2) do not inherit privileged scheduling
    policies. The reset-on-fork flag can be set by either:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>ORing the <b>SCHED_RESET_ON_FORK</b> flag into the <i>policy</i> argument
      when calling <b>sched_setscheduler</b>(2) (since Linux 2.6.32); or</dd>
  <dt>•</dt>
  <dd>specifying the <b>SCHED_FLAG_RESET_ON_FORK</b> flag in
      <i>attr.sched_flags</i> when calling <b>sched_setattr</b>(2).</dd>
</dl>
<p class="Pp">Note that the constants used with these two APIs have different
    names. The state of the reset-on-fork flag can analogously be retrieved
    using <b>sched_getscheduler</b>(2) and <b>sched_getattr</b>(2).</p>
<p class="Pp">The reset-on-fork feature is intended for media-playback
    applications, and can be used to prevent applications evading the
    <b>RLIMIT_RTTIME</b> resource limit (see <b>getrlimit</b>(2)) by creating
    multiple child processes.</p>
<p class="Pp">More precisely, if the reset-on-fork flag is set, the following
    rules apply for subsequently created children:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If the calling thread has a scheduling policy of <b>SCHED_FIFO</b> or
      <b>SCHED_RR</b>, the policy is reset to <b>SCHED_OTHER</b> in child
      processes.</dd>
  <dt>•</dt>
  <dd>If the calling process has a negative nice value, the nice value is reset
      to zero in child processes.</dd>
</dl>
<p class="Pp">After the reset-on-fork flag has been enabled, it can be reset
    only if the thread has the <b>CAP_SYS_NICE</b> capability. This flag is
    disabled in child processes created by <b>fork</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Privileges_and_resource_limits"><a class="permalink" href="#Privileges_and_resource_limits">Privileges
  and resource limits</a></h2>
<p class="Pp">Before Linux 2.6.12, only privileged (<b>CAP_SYS_NICE</b>) threads
    can set a nonzero static priority (i.e., set a real-time scheduling policy).
    The only change that an unprivileged thread can make is to set the
    <b>SCHED_OTHER</b> policy, and this can be done only if the effective user
    ID of the caller matches the real or effective user ID of the target thread
    (i.e., the thread specified by <i>pid</i>) whose policy is being
  changed.</p>
<p class="Pp">A thread must be privileged (<b>CAP_SYS_NICE</b>) in order to set
    or modify a <b>SCHED_DEADLINE</b> policy.</p>
<p class="Pp">Since Linux 2.6.12, the <b>RLIMIT_RTPRIO</b> resource limit
    defines a ceiling on an unprivileged thread's static priority for the
    <b>SCHED_RR</b> and <b>SCHED_FIFO</b> policies. The rules for changing
    scheduling policy and priority are as follows:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If an unprivileged thread has a nonzero <b>RLIMIT_RTPRIO</b> soft limit,
      then it can change its scheduling policy and priority, subject to the
      restriction that the priority cannot be set to a value higher than the
      maximum of its current priority and its <b>RLIMIT_RTPRIO</b> soft
    limit.</dd>
  <dt>•</dt>
  <dd>If the <b>RLIMIT_RTPRIO</b> soft limit is 0, then the only permitted
      changes are to lower the priority, or to switch to a non-real-time
    policy.</dd>
  <dt>•</dt>
  <dd>Subject to the same rules, another unprivileged thread can also make these
      changes, as long as the effective user ID of the thread making the change
      matches the real or effective user ID of the target thread.</dd>
  <dt>•</dt>
  <dd>Special rules apply for the <b>SCHED_IDLE</b> policy. Before Linux 2.6.39,
      an unprivileged thread operating under this policy cannot change its
      policy, regardless of the value of its <b>RLIMIT_RTPRIO</b> resource
      limit. Since Linux 2.6.39, an unprivileged thread can switch to either the
      <b>SCHED_BATCH</b> or the <b>SCHED_OTHER</b> policy so long as its nice
      value falls within the range permitted by its <b>RLIMIT_NICE</b> resource
      limit (see <b>getrlimit</b>(2)).</dd>
</dl>
<p class="Pp">Privileged (<b>CAP_SYS_NICE</b>) threads ignore the
    <b>RLIMIT_RTPRIO</b> limit; as with older kernels, they can make arbitrary
    changes to scheduling policy and priority. See <b>getrlimit</b>(2) for
    further information on <b>RLIMIT_RTPRIO</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Limiting_the_CPU_usage_of_real-time_and_deadline_processes"><a class="permalink" href="#Limiting_the_CPU_usage_of_real-time_and_deadline_processes">Limiting
  the CPU usage of real-time and deadline processes</a></h2>
<p class="Pp">A nonblocking infinite loop in a thread scheduled under the
    <b>SCHED_FIFO</b>, <b>SCHED_RR</b>, or <b>SCHED_DEADLINE</b> policy can
    potentially block all other threads from accessing the CPU forever. Before
    Linux 2.6.25, the only way of preventing a runaway real-time process from
    freezing the system was to run (at the console) a shell scheduled under a
    higher static priority than the tested application. This allows an emergency
    kill of tested real-time applications that do not block or terminate as
    expected.</p>
<p class="Pp">Since Linux 2.6.25, there are other techniques for dealing with
    runaway real-time and deadline processes. One of these is to use the
    <b>RLIMIT_RTTIME</b> resource limit to set a ceiling on the CPU time that a
    real-time process may consume. See <b>getrlimit</b>(2) for details.</p>
<p class="Pp">Since Linux 2.6.25, Linux also provides two <i>/proc</i> files
    that can be used to reserve a certain amount of CPU time to be used by
    non-real-time processes. Reserving CPU time in this fashion allows some CPU
    time to be allocated to (say) a root shell that can be used to kill a
    runaway process. Both of these files specify time values in
  microseconds:</p>
<dl class="Bl-tag">
  <dt><i>/proc/sys/kernel/sched_rt_period_us</i></dt>
  <dd>This file specifies a scheduling period that is equivalent to 100% CPU
      bandwidth. The value in this file can range from 1 to <b>INT_MAX</b>,
      giving an operating range of 1 microsecond to around 35 minutes. The
      default value in this file is 1,000,000 (1 second).</dd>
  <dt><i>/proc/sys/kernel/sched_rt_runtime_us</i></dt>
  <dd>The value in this file specifies how much of the "period" time
      can be used by all real-time and deadline scheduled processes on the
      system. The value in this file can range from -1 to <b>INT_MAX</b>-1.
      Specifying -1 makes the run time the same as the period; that is, no CPU
      time is set aside for non-real-time processes (which was the behavior
      before Linux 2.6.25). The default value in this file is 950,000 (0.95
      seconds), meaning that 5% of the CPU time is reserved for processes that
      don't run under a real-time or deadline scheduling policy.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Response_time"><a class="permalink" href="#Response_time">Response
  time</a></h2>
<p class="Pp">A blocked high priority thread waiting for I/O has a certain
    response time before it is scheduled again. The device driver writer can
    greatly reduce this response time by using a "slow interrupt"
    interrupt handler.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Miscellaneous"><a class="permalink" href="#Miscellaneous">Miscellaneous</a></h2>
<p class="Pp">Child processes inherit the scheduling policy and parameters
    across a <b>fork</b>(2). The scheduling policy and parameters are preserved
    across <b>execve</b>(2).</p>
<p class="Pp">Memory locking is usually needed for real-time processes to avoid
    paging delays; this can be done with <b>mlock</b>(2) or
  <b>mlockall</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_autogroup_feature"><a class="permalink" href="#The_autogroup_feature">The
  autogroup feature</a></h2>
<p class="Pp">Since Linux 2.6.38, the kernel provides a feature known as
    autogrouping to improve interactive desktop performance in the face of
    multiprocess, CPU-intensive workloads such as building the Linux kernel with
    large numbers of parallel build processes (i.e., the <b>make</b>(1)
    <b>-j</b> flag).</p>
<p class="Pp">This feature operates in conjunction with the CFS scheduler and
    requires a kernel that is configured with <b>CONFIG_SCHED_AUTOGROUP</b>. On
    a running system, this feature is enabled or disabled via the file
    <i>/proc/sys/kernel/sched_autogroup_enabled</i>; a value of 0 disables the
    feature, while a value of 1 enables it. The default value in this file is 1,
    unless the kernel was booted with the <i>noautogroup</i> parameter.</p>
<p class="Pp">A new autogroup is created when a new session is created via
    <b>setsid</b>(2); this happens, for example, when a new terminal window is
    started. A new process created by <b>fork</b>(2) inherits its parent's
    autogroup membership. Thus, all of the processes in a session are members of
    the same autogroup. An autogroup is automatically destroyed when the last
    process in the group terminates.</p>
<p class="Pp">When autogrouping is enabled, all of the members of an autogroup
    are placed in the same kernel scheduler "task group". The CFS
    scheduler employs an algorithm that equalizes the distribution of CPU cycles
    across task groups. The benefits of this for interactive desktop performance
    can be described via the following example.</p>
<p class="Pp">Suppose that there are two autogroups competing for the same CPU
    (i.e., presume either a single CPU system or the use of <b>taskset</b>(1) to
    confine all the processes to the same CPU on an SMP system). The first group
    contains ten CPU-bound processes from a kernel build started with
    <i>make&nbsp;-j10</i>. The other contains a single CPU-bound process: a
    video player. The effect of autogrouping is that the two groups will each
    receive half of the CPU cycles. That is, the video player will receive 50%
    of the CPU cycles, rather than just 9% of the cycles, which would likely
    lead to degraded video playback. The situation on an SMP system is more
    complex, but the general effect is the same: the scheduler distributes CPU
    cycles across task groups such that an autogroup that contains a large
    number of CPU-bound processes does not end up hogging CPU cycles at the
    expense of the other jobs on the system.</p>
<p class="Pp">A process's autogroup (task group) membership can be viewed via
    the file <i>/proc/</i>pid<i>/autogroup</i>:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>cat /proc/1/autogroup</b>
/autogroup-1 nice 0
</pre>
<br>
<p class="Pp">This file can also be used to modify the CPU bandwidth allocated
    to an autogroup. This is done by writing a number in the "nice"
    range to the file to set the autogroup's nice value. The allowed range is
    from +19 (low priority) to -20 (high priority). (Writing values outside of
    this range causes <b>write</b>(2) to fail with the error <b>EINVAL</b>.)</p>
<p class="Pp">The autogroup nice setting has the same meaning as the process
    nice value, but applies to distribution of CPU cycles to the autogroup as a
    whole, based on the relative nice values of other autogroups. For a process
    inside an autogroup, the CPU cycles that it receives will be a product of
    the autogroup's nice value (compared to other autogroups) and the process's
    nice value (compared to other processes in the same autogroup.</p>
<p class="Pp">The use of the <b>cgroups</b>(7) CPU controller to place processes
    in cgroups other than the root CPU cgroup overrides the effect of
    autogrouping.</p>
<p class="Pp">The autogroup feature groups only processes scheduled under
    non-real-time policies (<b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and
    <b>SCHED_IDLE</b>). It does not group processes scheduled under real-time
    and deadline policies. Those processes are scheduled according to the rules
    described earlier.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_nice_value_and_group_scheduling"><a class="permalink" href="#The_nice_value_and_group_scheduling">The
  nice value and group scheduling</a></h2>
<p class="Pp">When scheduling non-real-time processes (i.e., those scheduled
    under the <b>SCHED_OTHER</b>, <b>SCHED_BATCH</b>, and <b>SCHED_IDLE</b>
    policies), the CFS scheduler employs a technique known as "group
    scheduling", if the kernel was configured with the
    <b>CONFIG_FAIR_GROUP_SCHED</b> option (which is typical).</p>
<p class="Pp">Under group scheduling, threads are scheduled in "task
    groups". Task groups have a hierarchical relationship, rooted under the
    initial task group on the system, known as the "root task group".
    Task groups are formed in the following circumstances:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>All of the threads in a CPU cgroup form a task group. The parent of this
      task group is the task group of the corresponding parent cgroup.</dd>
  <dt>•</dt>
  <dd>If autogrouping is enabled, then all of the threads that are (implicitly)
      placed in an autogroup (i.e., the same session, as created by
      <b>setsid</b>(2)) form a task group. Each new autogroup is thus a separate
      task group. The root task group is the parent of all such autogroups.</dd>
  <dt>•</dt>
  <dd>If autogrouping is enabled, then the root task group consists of all
      processes in the root CPU cgroup that were not otherwise implicitly placed
      into a new autogroup.</dd>
  <dt>•</dt>
  <dd>If autogrouping is disabled, then the root task group consists of all
      processes in the root CPU cgroup.</dd>
  <dt>•</dt>
  <dd>If group scheduling was disabled (i.e., the kernel was configured without
      <b>CONFIG_FAIR_GROUP_SCHED</b>), then all of the processes on the system
      are notionally placed in a single task group.</dd>
</dl>
<p class="Pp">Under group scheduling, a thread's nice value has an effect for
    scheduling decisions <i>only relative to other threads in the same task
    group</i>. This has some surprising consequences in terms of the traditional
    semantics of the nice value on UNIX systems. In particular, if autogrouping
    is enabled (which is the default in various distributions), then employing
    <b>setpriority</b>(2) or <b>nice</b>(1) on a process has an effect only for
    scheduling relative to other processes executed in the same session
    (typically: the same terminal window).</p>
<p class="Pp">Conversely, for two processes that are (for example) the sole
    CPU-bound processes in different sessions (e.g., different terminal windows,
    each of whose jobs are tied to different autogroups), <i>modifying the nice
    value of the process in one of the sessions</i> <i>has no effect</i> in
    terms of the scheduler's decisions relative to the process in the other
    session. A possibly useful workaround here is to use a command such as the
    following to modify the autogroup nice value for <i>all</i> of the processes
    in a terminal session:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>echo 10 &gt; /proc/self/autogroup</b>
</pre>
<br>
</section>
<section class="Ss">
<h2 class="Ss" id="Real-time_features_in_the_mainline_Linux_kernel"><a class="permalink" href="#Real-time_features_in_the_mainline_Linux_kernel">Real-time
  features in the mainline Linux kernel</a></h2>
<p class="Pp">Since Linux 2.6.18, Linux is gradually becoming equipped with
    real-time capabilities, most of which are derived from the former
    <i>realtime-preempt</i> patch set. Until the patches have been completely
    merged into the mainline kernel, they must be installed to achieve the best
    real-time performance. These patches are named:</p>
<p class="Pp">
  <br>
</p>
<pre>patch-<i>kernelversion</i>-rt<i>patchversion</i>
</pre>
<br>
<p class="Pp">and can be downloaded from
    <a class="Lk" href="http://www.kernel.org/pub/linux/kernel/projects/rt/">http://www.kernel.org/pub/linux/kernel/projects/rt/</a>.</p>
<p class="Pp">Without the patches and prior to their full inclusion into the
    mainline kernel, the kernel configuration offers only the three preemption
    classes <b>CONFIG_PREEMPT_NONE</b>, <b>CONFIG_PREEMPT_VOLUNTARY</b>, and
    <b>CONFIG_PREEMPT_DESKTOP</b> which respectively provide no, some, and
    considerable reduction of the worst-case scheduling latency.</p>
<p class="Pp">With the patches applied or after their full inclusion into the
    mainline kernel, the additional configuration item <b>CONFIG_PREEMPT_RT</b>
    becomes available. If this is selected, Linux is transformed into a regular
    real-time operating system. The FIFO and RR scheduling policies are then
    used to run a thread with true real-time priority and a minimum worst-case
    scheduling latency.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The <b>cgroups</b>(7) CPU controller can be used to limit the CPU
    consumption of groups of processes.</p>
<p class="Pp">Originally, Standard Linux was intended as a general-purpose
    operating system being able to handle background processes, interactive
    applications, and less demanding real-time applications (applications that
    need to usually meet timing deadlines). Although the Linux 2.6 allowed for
    kernel preemption and the newly introduced O(1) scheduler ensures that the
    time needed to schedule is fixed and deterministic irrespective of the
    number of active tasks, true real-time computing was not possible up to
    Linux 2.6.17.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>chcpu</b>(1), <b>chrt</b>(1), <b>lscpu</b>(1), <b>ps</b>(1),
    <b>taskset</b>(1), <b>top</b>(1), <b>getpriority</b>(2), <b>mlock</b>(2),
    <b>mlockall</b>(2), <b>munlock</b>(2), <b>munlockall</b>(2), <b>nice</b>(2),
    <b>sched_get_priority_max</b>(2), <b>sched_get_priority_min</b>(2),
    <b>sched_getaffinity</b>(2), <b>sched_getparam</b>(2),
    <b>sched_getscheduler</b>(2), <b>sched_rr_get_interval</b>(2),
    <b>sched_setaffinity</b>(2), <b>sched_setparam</b>(2),
    <b>sched_setscheduler</b>(2), <b>sched_yield</b>(2), <b>setpriority</b>(2),
    <b>pthread_getaffinity_np</b>(3), <b>pthread_getschedparam</b>(3),
    <b>pthread_setaffinity_np</b>(3), <b>sched_getcpu</b>(3),
    <b>capabilities</b>(7), <b>cpuset</b>(7)</p>
<p class="Pp"><i>Programming for the real world - POSIX.4</i> by Bill O.
    Gallmeister, O'Reilly &amp; Associates, Inc., ISBN 1-56592-074-0.</p>
<p class="Pp">The Linux kernel source files
    <i>Documentation/scheduler/sched-deadline.txt</i>,
    <i>Documentation/scheduler/sched-rt-group.txt</i>,
    <i>Documentation/scheduler/sched-design-CFS.txt</i>, and
    <i>Documentation/scheduler/sched-nice-design.txt</i></p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>