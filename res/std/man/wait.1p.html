<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   et
 --><head>
<meta name="dc.identifier" content="res/89b3b2925665e38cfe7371440b7c7aa9b6b99155">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>WAIT(1P)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">WAIT(1P)</td>
    <td class="head-vol">POSIX Programmer's Manual</td>
    <td class="head-rtitle">WAIT(1P)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="PROLOG"><a class="permalink" href="#PROLOG">PROLOG</a></h1>
<p class="Pp">This manual page is part of the POSIX Programmer's Manual. The
    Linux implementation of this interface may differ (consult the corresponding
    Linux manual page for details of Linux behavior), or the interface may not
    be implemented on Linux.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">wait — await process completion</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre>wait <b>[</b><i>pid</i>...<b>]</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">When an asynchronous list (see <i>Section 2.9.3.1</i>,
    <i>Examples</i>) is started by the shell, the process ID of the last command
    in each element of the asynchronous list shall become known in the current
    shell execution environment; see <i>Section 2.12</i>, <i>Shell Execution
    Environment</i>.</p>
<p class="Pp">If the <i>wait</i> utility is invoked with no operands, it shall
    wait until all process IDs known to the invoking shell have terminated and
    exit with a zero exit status.</p>
<p class="Pp">If one or more <i>pid</i> operands are specified that represent
    known process IDs, the <i>wait</i> utility shall wait until all of them have
    terminated. If one or more <i>pid</i> operands are specified that represent
    unknown process IDs, <i>wait</i> shall treat them as if they were known
    process IDs that exited with exit status 127. The exit status returned by
    the <i>wait</i> utility shall be the exit status of the process requested by
    the last <i>pid</i> operand.</p>
<p class="Pp">The known process IDs are applicable only for invocations of
    <i>wait</i> in the current shell execution environment.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPTIONS"><a class="permalink" href="#OPTIONS">OPTIONS</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OPERANDS"><a class="permalink" href="#OPERANDS">OPERANDS</a></h1>
<p class="Pp">The following operand shall be supported:</p>
<dl class="Bl-tag">
  <dt id="pid"><a class="permalink" href="#pid"><i>pid</i></a></dt>
  <dd>One of the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt> 1.</dt>
  <dd>The unsigned decimal integer process ID of a command, for which the
      utility is to wait for the termination.</dd>
  <dt> 2.</dt>
  <dd>A job control job ID (see the Base Definitions volume of
      POSIX.1‐2017, <i>Section 3.204</i>, <i>Job Control Job ID</i>) that
      identifies a background process group to be waited for. The job control
      job ID notation is applicable only for invocations of <i>wait</i> in the
      current shell execution environment; see <i>Section 2.12</i>, <i>Shell
      Execution Environment</i>. The exit status of <i>wait</i> shall be
      determined by the last command in the pipeline.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Note:"><a class="permalink" href="#Note:"><b>Note:</b></a></dt>
  <dd>The job control job ID type of <i>pid</i> is only available on systems
      supporting the User Portability Utilities option.</dd>
</dl>
</div>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="STDIN"><a class="permalink" href="#STDIN">STDIN</a></h1>
<p class="Pp">Not used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="INPUT_FILES"><a class="permalink" href="#INPUT_FILES">INPUT
  FILES</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ENVIRONMENT_VARIABLES"><a class="permalink" href="#ENVIRONMENT_VARIABLES">ENVIRONMENT
  VARIABLES</a></h1>
<p class="Pp">The following environment variables shall affect the execution of
    <i>wait</i>:</p>
<dl class="Bl-tag">
  <dt id="LANG"><a class="permalink" href="#LANG"><i>LANG</i></a></dt>
  <dd>Provide a default value for the internationalization variables that are
      unset or null. (See the Base Definitions volume of POSIX.1‐2017,
      <i>Section 8.2</i>, <i>Internationalization Variables</i> for the
      precedence of internationalization variables used to determine the values
      of locale categories.)</dd>
  <dt id="LC_ALL"><a class="permalink" href="#LC_ALL"><i>LC_ALL</i></a></dt>
  <dd>If set to a non-empty string value, override the values of all the other
      internationalization variables.</dd>
  <dt id="LC_CTYPE"><a class="permalink" href="#LC_CTYPE"><i>LC_CTYPE</i></a></dt>
  <dd>Determine the locale for the interpretation of sequences of bytes of text
      data as characters (for example, single-byte as opposed to multi-byte
      characters in arguments).</dd>
  <dt id="LC_MESSAGES"><a class="permalink" href="#LC_MESSAGES"><i>LC_MESSAGES</i></a></dt>
  <dd>
    <br>
    Determine the locale that should be used to affect the format and contents
      of diagnostic messages written to standard error.</dd>
  <dt id="NLSPATH"><a class="permalink" href="#NLSPATH"><i>NLSPATH</i></a></dt>
  <dd>Determine the location of message catalogs for the processing of
      <i>LC_MESSAGES</i>.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="ASYNCHRONOUS_EVENTS"><a class="permalink" href="#ASYNCHRONOUS_EVENTS">ASYNCHRONOUS
  EVENTS</a></h1>
<p class="Pp">Default.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STDOUT"><a class="permalink" href="#STDOUT">STDOUT</a></h1>
<p class="Pp">Not used.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STDERR"><a class="permalink" href="#STDERR">STDERR</a></h1>
<p class="Pp">The standard error shall be used only for diagnostic messages.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="OUTPUT_FILES"><a class="permalink" href="#OUTPUT_FILES">OUTPUT
  FILES</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXTENDED_DESCRIPTION"><a class="permalink" href="#EXTENDED_DESCRIPTION">EXTENDED
  DESCRIPTION</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXIT_STATUS"><a class="permalink" href="#EXIT_STATUS">EXIT
  STATUS</a></h1>
<p class="Pp">If one or more operands were specified, all of them have
    terminated or were not known by the invoking shell, and the status of the
    last operand specified is known, then the exit status of <i>wait</i> shall
    be the exit status information of the command indicated by the last operand
    specified. If the process terminated abnormally due to the receipt of a
    signal, the exit status shall be greater than 128 and shall be distinct from
    the exit status generated by other signals, but the exact value is
    unspecified. (See the <i>kill</i> <b>-l</b> option.) Otherwise, the
    <i>wait</i> utility shall exit with one of the following values:</p>
<dl class="Bl-tag">
  <dt>&nbsp;&nbsp;&nbsp;&nbsp;0</dt>
  <dd>The <i>wait</i> utility was invoked with no operands and all process IDs
      known by the invoking shell have terminated.</dd>
  <dt>1‐126</dt>
  <dd>The <i>wait</i> utility detected an error.</dd>
  <dt>&nbsp;&nbsp;127</dt>
  <dd>The command identified by the last <i>pid</i> operand specified is
      unknown.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="CONSEQUENCES_OF_ERRORS"><a class="permalink" href="#CONSEQUENCES_OF_ERRORS">CONSEQUENCES
  OF ERRORS</a></h1>
<p class="Pp">Default.</p>
<p class="Pp"><i>The following sections are informative.</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="APPLICATION_USAGE"><a class="permalink" href="#APPLICATION_USAGE">APPLICATION
  USAGE</a></h1>
<p class="Pp">On most implementations, <i>wait</i> is a shell built-in. If it is
    called in a subshell or separate utility execution environment, such as one
    of the following:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>(wait)
nohup wait ...
find . -exec wait ... \;</pre>
</div>
<p class="Pp">it returns immediately because there are no known process IDs to
    wait for in those environments.</p>
<p class="Pp">Historical implementations of interactive shells have discarded
    the exit status of terminated background processes before each shell prompt.
    Therefore, the status of background processes was usually lost unless it
    terminated while <i>wait</i> was waiting for it. This could be a serious
    problem when a job that was expected to run for a long time actually
    terminated quickly with a syntax or initialization error because the exit
    status returned was usually zero if the requested process ID was not found.
    This volume of POSIX.1‐2017 requires the implementation to keep the
    status of terminated jobs available until the status is requested, so that
    scripts like:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>j1&amp;
p1=$!
j2&amp;
wait $p1
echo Job 1 exited with status $?
wait $!
echo Job 2 exited with status $?</pre>
</div>
<p class="Pp">work without losing status on any of the jobs. The shell is
    allowed to discard the status of any process if it determines that the
    application cannot get the process ID for that process from the shell. It is
    also required to remember only {CHILD_MAX} number of processes in this way.
    Since the only way to get the process ID from the shell is by using the
    <b>'!'</b> shell parameter, the shell is allowed to discard the status of an
    asynchronous list if <b>"$!"</b> was not referenced before another
    asynchronous list was started. (This means that the shell only has to keep
    the status of the last asynchronous list started if the application did not
    reference <b>"$!"</b>. If the implementation of the shell is smart
    enough to determine that a reference to <b>"$!"</b> was not saved
    anywhere that the application can retrieve it later, it can use this
    information to trim the list of saved information. Note also that a
    successful call to <i>wait</i> with no operands discards the exit status of
    all asynchronous lists.)</p>
<p class="Pp">If the exit status of <i>wait</i> is greater than 128, there is no
    way for the application to know if the waited-for process exited with that
    value or was killed by a signal. Since most utilities exit with small
    values, there is seldom any ambiguity. Even in the ambiguous cases, most
    applications just need to know that the asynchronous job failed; it does not
    matter whether it detected an error and failed or was killed and did not
    complete its job normally.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Although the exact value used when a process is terminated by a
    signal is unspecified, if it is known that a signal terminated a process, a
    script can still reliably determine which signal by using <i>kill</i> as
    shown by the following script:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>sleep 1000&amp;
pid=$!
kill -kill $pid
wait $pid
echo $pid was terminated by a SIG$(kill -l $?) signal.</pre>
</div>
<p class="Pp">If the following sequence of commands is run in less than 31
    seconds:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>sleep 257 | sleep 31 &amp;
jobs -l %%</pre>
</div>
<p class="Pp">either of the following commands returns the exit status of the
    second <i>sleep</i> in the pipeline:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>wait <i>&lt;pid of sleep 31&gt;</i>
wait %%</pre>
</div>
</section>
<section class="Sh">
<h1 class="Sh" id="RATIONALE"><a class="permalink" href="#RATIONALE">RATIONALE</a></h1>
<p class="Pp">The description of <i>wait</i> does not refer to the
    <i>waitpid</i>() function from the System Interfaces volume of
    POSIX.1‐2017 because that would needlessly overspecify this
    interface. However, the wording means that <i>wait</i> is required to wait
    for an explicit process when it is given an argument so that the status
    information of other processes is not consumed. Historical implementations
    use the <i>wait</i>() function defined in the System Interfaces volume of
    POSIX.1‐2017 until <i>wait</i>() returns the requested process ID or
    finds that the requested process does not exist. Because this means that a
    shell script could not reliably get the status of all background children if
    a second background job was ever started before the first job finished, it
    is recommended that the <i>wait</i> utility use a method such as the
    functionality provided by the <i>waitpid</i>() function.</p>
<p class="Pp">The ability to wait for multiple <i>pid</i> operands was adopted
    from the KornShell.</p>
<p class="Pp">This new functionality was added because it is needed to determine
    the exit status of any asynchronous list accurately. The only compatibility
    problem that this change creates is for a script like</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre>while sleep 60 do
<br>
    job&amp; echo Job started $(date) as $!  done</pre>
</div>
<p class="Pp">which causes the shell to monitor all of the jobs started until
    the script terminates or runs out of memory. This would not be a problem if
    the loop did not reference <b>"$!"</b> or if the script would
    occasionally <i>wait</i> for jobs it started.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="FUTURE_DIRECTIONS"><a class="permalink" href="#FUTURE_DIRECTIONS">FUTURE
  DIRECTIONS</a></h1>
<p class="Pp">None.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><i>Chapter 2</i>, <i>Shell Command Language</i>,
    <i><i>kill</i></i>, <i><i>sh</i></i></p>
<p class="Pp">The Base Definitions volume of POSIX.1‐2017, <i>Section
    3.204</i>, <i>Job Control Job ID</i>, <i>Chapter 8</i>, <i>Environment
    Variables</i></p>
<p class="Pp">The System Interfaces volume of POSIX.1‐2017,
    <i><i>wait</i>()</i></p>
</section>
<section class="Sh">
<h1 class="Sh" id="COPYRIGHT"><a class="permalink" href="#COPYRIGHT">COPYRIGHT</a></h1>
<p class="Pp">Portions of this text are reprinted and reproduced in electronic
    form from IEEE Std 1003.1-2017, Standard for Information Technology --
    Portable Operating System Interface (POSIX), The Open Group Base
    Specifications Issue 7, 2018 Edition, Copyright (C) 2018 by the Institute of
    Electrical and Electronics Engineers, Inc and The Open Group. In the event
    of any discrepancy between this version and the original IEEE and The Open
    Group Standard, the original IEEE and The Open Group Standard is the referee
    document. The original Standard can be obtained online at
    http://www.opengroup.org/unix/online.html .</p>
<p class="Pp">Any typographical or formatting errors that appear in this page
    are most likely to have been introduced during the conversion of the source
    files to man page format. To report such errors, see
    https://www.kernel.org/doc/man-pages/reporting_bugs.html .</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">2017</td>
    <td class="foot-os">IEEE/The Open Group</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>