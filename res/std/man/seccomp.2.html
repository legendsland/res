<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (C) 2014 Kees Cook <keescook@chromium.org>
   and Copyright (C) 2012 Will Drewry <wad@chromium.org>
   and Copyright (C) 2008, 2014,2017 Michael Kerrisk <mtk.manpages@gmail.com>
   and Copyright (C) 2017 Tyler Hicks <tyhicks@canonical.com>
   and Copyright (C) 2020 Tycho Andersen <tycho@tycho.ws>
  
   SPDX-License-Identifier: Linux-man-pages-copyleft
   --><head>
<meta name="dc.identifier" content="res/8506f8043b021dc1034e82013c4ea62ee997ee0f">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>seccomp(2)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">seccomp(2)</td>
    <td class="head-vol">System Calls Manual</td>
    <td class="head-rtitle">seccomp(2)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">seccomp - operate on Secure Computing state of the process</p>
</section>
<section class="Sh">
<h1 class="Sh" id="LIBRARY"><a class="permalink" href="#LIBRARY">LIBRARY</a></h1>
<p class="Pp">Standard C library (<i>libc</i>, <i>-lc</i>)</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;linux/seccomp.h&gt;</b>  /* Definition of <b>SECCOMP_*</b> constants */
<b>#include &lt;linux/filter.h&gt;</b>   /* Definition of <b>struct sock_fprog</b> */
<b>#include &lt;linux/audit.h&gt;</b>    /* Definition of <b>AUDIT_*</b> constants */
<b>#include &lt;linux/signal.h&gt;</b>   /* Definition of <b>SIG*</b> constants */
<b>#include &lt;sys/ptrace.h&gt;</b>     /* Definition of <b>PTRACE_*</b> constants */
<b>#include &lt;sys/syscall.h&gt;</b>    /* Definition of <b>SYS_*</b> constants */
<b>#include &lt;unistd.h&gt;</b></pre>
<pre><b>int syscall(SYS_seccomp, unsigned int </b><i>operation</i><b>, unsigned int </b><i>flags</i><b>,</b>
<b>            void *</b><i>args</i><b>);</b></pre>
<p class="Pp"><i>Note</i>: glibc provides no wrapper for <b>seccomp</b>(),
    necessitating the use of <b>syscall</b>(2).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The <b>seccomp</b>() system call operates on the Secure Computing
    (seccomp) state of the calling process.</p>
<p class="Pp">Currently, Linux supports the following <i>operation</i>
  values:</p>
<dl class="Bl-tag">
  <dt id="SECCOMP_SET_MODE_STRICT"><a class="permalink" href="#SECCOMP_SET_MODE_STRICT"><b>SECCOMP_SET_MODE_STRICT</b></a></dt>
  <dd>The only system calls that the calling thread is permitted to make are
      <b>read</b>(2), <b>write</b>(2), <b>_exit</b>(2) (but not
      <b>exit_group</b>(2)), and <b>sigreturn</b>(2). Other system calls result
      in the termination of the calling thread, or termination of the entire
      process with the <b>SIGKILL</b> signal when there is only one thread.
      Strict secure computing mode is useful for number-crunching applications
      that may need to execute untrusted byte code, perhaps obtained by reading
      from a pipe or socket.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that although the calling thread can no longer call
      <b>sigprocmask</b>(2), it can use <b>sigreturn</b>(2) to block all signals
      apart from <b>SIGKILL</b> and <b>SIGSTOP</b>. This means that
      <b>alarm</b>(2) (for example) is not sufficient for restricting the
      process's execution time. Instead, to reliably terminate the process,
      <b>SIGKILL</b> must be used. This can be done by using
      <b>timer_create</b>(2) with <b>SIGEV_SIGNAL</b> and <i>sigev_signo</i> set
      to <b>SIGKILL</b>, or by using <b>setrlimit</b>(2) to set the hard limit
      for <b>RLIMIT_CPU</b>.</dd>
  <dt></dt>
  <dd>This operation is available only if the kernel is configured with
      <b>CONFIG_SECCOMP</b> enabled.</dd>
  <dt></dt>
  <dd>The value of <i>flags</i> must be 0, and <i>args</i> must be NULL.</dd>
  <dt></dt>
  <dd>This operation is functionally identical to the call:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>prctl(PR_SET_SECCOMP, SECCOMP_MODE_STRICT);
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_SET_MODE_FILTER"><a class="permalink" href="#SECCOMP_SET_MODE_FILTER"><b>SECCOMP_SET_MODE_FILTER</b></a></dt>
  <dd>The system calls allowed are defined by a pointer to a Berkeley Packet
      Filter (BPF) passed via <i>args</i>. This argument is a pointer to a
      <i>struct&nbsp;sock_fprog</i>; it can be designed to filter arbitrary
      system calls and system call arguments. If the filter is invalid,
      <b>seccomp</b>() fails, returning <b>EINVAL</b> in <i>errno</i>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If <b>fork</b>(2) or <b>clone</b>(2) is allowed by the filter, any child
      processes will be constrained to the same system call filters as the
      parent. If <b>execve</b>(2) is allowed, the existing filters will be
      preserved across a call to <b>execve</b>(2).</dd>
  <dt></dt>
  <dd>In order to use the <b>SECCOMP_SET_MODE_FILTER</b> operation, either the
      calling thread must have the <b>CAP_SYS_ADMIN</b> capability in its user
      namespace, or the thread must already have the <i>no_new_privs</i> bit
      set. If that bit was not already set by an ancestor of this thread, the
      thread must make the following call:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>prctl(PR_SET_NO_NEW_PRIVS, 1);
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>Otherwise, the <b>SECCOMP_SET_MODE_FILTER</b> operation fails and returns
      <b>EACCES</b> in <i>errno</i>. This requirement ensures that an
      unprivileged process cannot apply a malicious filter and then invoke a
      set-user-ID or other privileged program using <b>execve</b>(2), thus
      potentially compromising that program. (Such a malicious filter might, for
      example, cause an attempt to use <b>setuid</b>(2) to set the caller's user
      IDs to nonzero values to instead return 0 without actually making the
      system call. Thus, the program might be tricked into retaining superuser
      privileges in circumstances where it is possible to influence it to do
      dangerous things because it did not actually drop privileges.)</dd>
  <dt></dt>
  <dd>If <b>prctl</b>(2) or <b>seccomp</b>() is allowed by the attached filter,
      further filters may be added. This will increase evaluation time, but
      allows for further reduction of the attack surface during execution of a
      thread.</dd>
  <dt></dt>
  <dd>The <b>SECCOMP_SET_MODE_FILTER</b> operation is available only if the
      kernel is configured with <b>CONFIG_SECCOMP_FILTER</b> enabled.</dd>
  <dt></dt>
  <dd>When <i>flags</i> is 0, this operation is functionally identical to the
      call:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, args);
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The recognized <i>flags</i> are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="SECCOMP_FILTER_FLAG_LOG"><a class="permalink" href="#SECCOMP_FILTER_FLAG_LOG"><b>SECCOMP_FILTER_FLAG_LOG</b>
    (since Linux 4.14)</a></dt>
  <dd>All filter return actions except <b>SECCOMP_RET_ALLOW</b> should be
      logged. An administrator may override this filter flag by preventing
      specific actions from being logged via the
      <i>/proc/sys/kernel/seccomp/actions_logged</i> file.</dd>
  <dt id="SECCOMP_FILTER_FLAG_NEW_LISTENER"><a class="permalink" href="#SECCOMP_FILTER_FLAG_NEW_LISTENER"><b>SECCOMP_FILTER_FLAG_NEW_LISTENER</b>
    (since Linux 5.0)</a></dt>
  <dd>After successfully installing the filter program, return a new user-space
      notification file descriptor. (The close-on-exec flag is set for the file
      descriptor.) When the filter returns <b>SECCOMP_RET_USER_NOTIF</b> a
      notification will be sent to this file descriptor.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>At most one seccomp filter using the
      <b>SECCOMP_FILTER_FLAG_NEW_LISTENER</b> flag can be installed for a
      thread.</dd>
  <dt></dt>
  <dd>See <b>seccomp_unotify</b>(2) for further details.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_FILTER_FLAG_SPEC_ALLOW"><a class="permalink" href="#SECCOMP_FILTER_FLAG_SPEC_ALLOW"><b>SECCOMP_FILTER_FLAG_SPEC_ALLOW</b>
    (since Linux 4.17)</a></dt>
  <dd>Disable Speculative Store Bypass mitigation.</dd>
  <dt id="SECCOMP_FILTER_FLAG_TSYNC"><a class="permalink" href="#SECCOMP_FILTER_FLAG_TSYNC"><b>SECCOMP_FILTER_FLAG_TSYNC</b></a></dt>
  <dd>When adding a new filter, synchronize all other threads of the calling
      process to the same seccomp filter tree. A "filter tree" is the
      ordered list of filters attached to a thread. (Attaching identical filters
      in separate <b>seccomp</b>() calls results in different filters from this
      perspective.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If any thread cannot synchronize to the same filter tree, the call will
      not attach the new seccomp filter, and will fail, returning the first
      thread ID found that cannot synchronize. Synchronization will fail if
      another thread in the same process is in <b>SECCOMP_MODE_STRICT</b> or if
      it has attached new seccomp filters to itself, diverging from the calling
      thread's filter tree.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="SECCOMP_GET_ACTION_AVAIL"><a class="permalink" href="#SECCOMP_GET_ACTION_AVAIL"><b>SECCOMP_GET_ACTION_AVAIL</b>
    (since Linux 4.14)</a></dt>
  <dd>Test to see if an action is supported by the kernel. This operation is
      helpful to confirm that the kernel knows of a more recently added filter
      return action since the kernel treats all unknown actions as
      <b>SECCOMP_RET_KILL_PROCESS</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The value of <i>flags</i> must be 0, and <i>args</i> must be a pointer to
      an unsigned 32-bit filter return action.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_GET_NOTIF_SIZES"><a class="permalink" href="#SECCOMP_GET_NOTIF_SIZES"><b>SECCOMP_GET_NOTIF_SIZES</b>
    (since Linux 5.0)</a></dt>
  <dd>Get the sizes of the seccomp user-space notification structures. Since
      these structures may evolve and grow over time, this command can be used
      to determine how much memory to allocate for sending and receiving
      notifications.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The value of <i>flags</i> must be 0, and <i>args</i> must be a pointer to
      a <i>struct seccomp_notif_sizes</i>, which has the following form:</dd>
  <dt></dt>
  <dd>
    <pre>struct seccomp_notif_sizes
<br>
    __u16 seccomp_notif;      /* Size of notification structure */
<br>
    __u16 seccomp_notif_resp; /* Size of response structure */
<br>
    __u16 seccomp_data;       /* Size of 'struct seccomp_data' */
};
    </pre>
  </dd>
  <dt></dt>
  <dd>See <b>seccomp_unotify</b>(2) for further details.</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Filters"><a class="permalink" href="#Filters">Filters</a></h2>
<p class="Pp">When adding filters via <b>SECCOMP_SET_MODE_FILTER</b>,
    <i>args</i> points to a filter program:</p>
<p class="Pp">
  <br>
</p>
<pre>struct sock_fprog {
<br>
    unsigned short      len;    /* Number of BPF instructions */
<br>
    struct sock_filter *filter; /* Pointer to array of
<br>
                                   BPF instructions */
};
</pre>
<br>
<p class="Pp">Each program must contain one or more BPF instructions:</p>
<p class="Pp">
  <br>
</p>
<pre>struct sock_filter {            /* Filter block */
<br>
    __u16 code;                 /* Actual filter code */
<br>
    __u8  jt;                   /* Jump true */
<br>
    __u8  jf;                   /* Jump false */
<br>
    __u32 k;                    /* Generic multiuse field */
};
</pre>
<br>
<p class="Pp">When executing the instructions, the BPF program operates on the
    system call information made available (i.e., use the <b>BPF_ABS</b>
    addressing mode) as a (read-only) buffer of the following form:</p>
<p class="Pp">
  <br>
</p>
<pre>struct seccomp_data {
<br>
    int   nr;                   /* System call number */
<br>
    __u32 arch;                 /* AUDIT_ARCH_* value
<br>
                                   (see &lt;linux/audit.h&gt;) */
<br>
    __u64 instruction_pointer;  /* CPU instruction pointer */
<br>
    __u64 args[6];              /* Up to 6 system call arguments */
};
</pre>
<br>
<p class="Pp">Because numbering of system calls varies between architectures and
    some architectures (e.g., x86-64) allow user-space code to use the calling
    conventions of multiple architectures (and the convention being used may
    vary over the life of a process that uses <b>execve</b>(2) to execute
    binaries that employ the different conventions), it is usually necessary to
    verify the value of the <i>arch</i> field.</p>
<p class="Pp">It is strongly recommended to use an allow-list approach whenever
    possible because such an approach is more robust and simple. A deny-list
    will have to be updated whenever a potentially dangerous system call is
    added (or a dangerous flag or option if those are deny-listed), and it is
    often possible to alter the representation of a value without altering its
    meaning, leading to a deny-list bypass. See also <i>Caveats</i> below.</p>
<p class="Pp">The <i>arch</i> field is not unique for all calling conventions.
    The x86-64 ABI and the x32 ABI both use <b>AUDIT_ARCH_X86_64</b> as
    <i>arch</i>, and they run on the same processors. Instead, the mask
    <b>__X32_SYSCALL_BIT</b> is used on the system call number to tell the two
    ABIs apart.</p>
<p class="Pp">This means that a policy must either deny all syscalls with
    <b>__X32_SYSCALL_BIT</b> or it must recognize syscalls with and without
    <b>__X32_SYSCALL_BIT</b> set. A list of system calls to be denied based on
    <i>nr</i> that does not also contain <i>nr</i> values with
    <b>__X32_SYSCALL_BIT</b> set can be bypassed by a malicious program that
    sets <b>__X32_SYSCALL_BIT</b>.</p>
<p class="Pp">Additionally, kernels prior to Linux 5.4 incorrectly permitted
    <i>nr</i> in the ranges 512-547 as well as the corresponding non-x32
    syscalls ORed with <b>__X32_SYSCALL_BIT</b>. For example, <i>nr</i> == 521
    and <i>nr</i> == (101 | <b>__X32_SYSCALL_BIT</b>) would result in
    invocations of <b>ptrace</b>(2) with potentially confused x32-vs-x86_64
    semantics in the kernel. Policies intended to work on kernels before Linux
    5.4 must ensure that they deny or otherwise correctly handle these system
    calls. On Linux 5.4 and newer, such system calls will fail with the error
    <b>ENOSYS</b>, without doing anything.</p>
<p class="Pp">The <i>instruction_pointer</i> field provides the address of the
    machine-language instruction that performed the system call. This might be
    useful in conjunction with the use of <i>/proc/</i>pid<i>/maps</i> to
    perform checks based on which region (mapping) of the program made the
    system call. (Probably, it is wise to lock down the <b>mmap</b>(2) and
    <b>mprotect</b>(2) system calls to prevent the program from subverting such
    checks.)</p>
<p class="Pp">When checking values from <i>args</i>, keep in mind that arguments
    are often silently truncated before being processed, but after the seccomp
    check. For example, this happens if the i386 ABI is used on an x86-64
    kernel: although the kernel will normally not look beyond the 32 lowest bits
    of the arguments, the values of the full 64-bit registers will be present in
    the seccomp data. A less surprising example is that if the x86-64 ABI is
    used to perform a system call that takes an argument of type <i>int</i>, the
    more-significant half of the argument register is ignored by the system
    call, but visible in the seccomp data.</p>
<p class="Pp">A seccomp filter returns a 32-bit value consisting of two parts:
    the most significant 16 bits (corresponding to the mask defined by the
    constant <b>SECCOMP_RET_ACTION_FULL</b>) contain one of the
    "action" values listed below; the least significant 16-bits
    (defined by the constant <b>SECCOMP_RET_DATA</b>) are "data" to be
    associated with this return value.</p>
<p class="Pp">If multiple filters exist, they are <i>all</i> executed, in
    reverse order of their addition to the filter tree—that is, the most
    recently installed filter is executed first. (Note that all filters will be
    called even if one of the earlier filters returns <b>SECCOMP_RET_KILL</b>.
    This is done to simplify the kernel code and to provide a tiny speed-up in
    the execution of sets of filters by avoiding a check for this uncommon
    case.) The return value for the evaluation of a given system call is the
    first-seen action value of highest precedence (along with its accompanying
    data) returned by execution of all of the filters.</p>
<p class="Pp">In decreasing order of precedence, the action values that may be
    returned by a seccomp filter are:</p>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_KILL_PROCESS"><a class="permalink" href="#SECCOMP_RET_KILL_PROCESS"><b>SECCOMP_RET_KILL_PROCESS</b>
    (since Linux 4.14)</a></dt>
  <dd>This value results in immediate termination of the process, with a core
      dump. The system call is not executed. By contrast with
      <b>SECCOMP_RET_KILL_THREAD</b> below, all threads in the thread group are
      terminated. (For a discussion of thread groups, see the description of the
      <b>CLONE_THREAD</b> flag in <b>clone</b>(2).)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The process terminates <i>as though</i> killed by a <b>SIGSYS</b> signal.
      Even if a signal handler has been registered for <b>SIGSYS</b>, the
      handler will be ignored in this case and the process always terminates. To
      a parent process that is waiting on this process (using <b>waitpid</b>(2)
      or similar), the returned <i>wstatus</i> will indicate that its child was
      terminated as though by a <b>SIGSYS</b> signal.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_KILL_THREAD"><a class="permalink" href="#SECCOMP_RET_KILL_THREAD"><b>SECCOMP_RET_KILL_THREAD</b>
    (or <b>SECCOMP_RET_KILL</b>)</a></dt>
  <dd>This value results in immediate termination of the thread that made the
      system call. The system call is not executed. Other threads in the same
      thread group will continue to execute.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The thread terminates <i>as though</i> killed by a <b>SIGSYS</b> signal.
      See <b>SECCOMP_RET_KILL_PROCESS</b> above.</dd>
  <dt></dt>
  <dd>Before Linux 4.11, any process terminated in this way would not trigger a
      coredump (even though <b>SIGSYS</b> is documented in <b>signal</b>(7) as
      having a default action of termination with a core dump). Since Linux
      4.11, a single-threaded process will dump core if terminated in this
    way.</dd>
  <dt></dt>
  <dd>With the addition of <b>SECCOMP_RET_KILL_PROCESS</b> in Linux 4.14,
      <b>SECCOMP_RET_KILL_THREAD</b> was added as a synonym for
      <b>SECCOMP_RET_KILL</b>, in order to more clearly distinguish the two
      actions.</dd>
  <dt></dt>
  <dd><b>Note</b>: the use of <b>SECCOMP_RET_KILL_THREAD</b> to kill a single
      thread in a multithreaded process is likely to leave the process in a
      permanently inconsistent and possibly corrupt state.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_TRAP"><a class="permalink" href="#SECCOMP_RET_TRAP"><b>SECCOMP_RET_TRAP</b></a></dt>
  <dd>This value results in the kernel sending a thread-directed <b>SIGSYS</b>
      signal to the triggering thread. (The system call is not executed.)
      Various fields will be set in the <i>siginfo_t</i> structure (see
      <b>sigaction</b>(2)) associated with signal:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>si_signo</i> will contain <b>SIGSYS</b>.</dd>
  <dt>•</dt>
  <dd><i>si_call_addr</i> will show the address of the system call
    instruction.</dd>
  <dt>•</dt>
  <dd><i>si_syscall</i> and <i>si_arch</i> will indicate which system call was
      attempted.</dd>
  <dt>•</dt>
  <dd><i>si_code</i> will contain <b>SYS_SECCOMP</b>.</dd>
  <dt>•</dt>
  <dd><i>si_errno</i> will contain the <b>SECCOMP_RET_DATA</b> portion of the
      filter return value.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The program counter will be as though the system call happened (i.e., the
      program counter will not point to the system call instruction). The return
      value register will contain an architecture-dependent value; if resuming
      execution, set it to something appropriate for the system call. (The
      architecture dependency is because replacing it with <b>ENOSYS</b> could
      overwrite some useful information.)</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_ERRNO"><a class="permalink" href="#SECCOMP_RET_ERRNO"><b>SECCOMP_RET_ERRNO</b></a></dt>
  <dd>This value results in the <b>SECCOMP_RET_DATA</b> portion of the filter's
      return value being passed to user space as the <i>errno</i> value without
      executing the system call.</dd>
  <dt id="SECCOMP_RET_USER_NOTIF"><a class="permalink" href="#SECCOMP_RET_USER_NOTIF"><b>SECCOMP_RET_USER_NOTIF</b>
    (since Linux 5.0)</a></dt>
  <dd>Forward the system call to an attached user-space supervisor process to
      allow that process to decide what to do with the system call. If there is
      no attached supervisor (either because the filter was not installed with
      the <b>SECCOMP_FILTER_FLAG_NEW_LISTENER</b> flag or because the file
      descriptor was closed), the filter returns <b>ENOSYS</b> (similar to what
      happens when a filter returns <b>SECCOMP_RET_TRACE</b> and there is no
      tracer). See <b>seccomp_unotify</b>(2) for further details.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that the supervisor process will not be notified if another filter
      returns an action value with a precedence greater than
      <b>SECCOMP_RET_USER_NOTIF</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_TRACE"><a class="permalink" href="#SECCOMP_RET_TRACE"><b>SECCOMP_RET_TRACE</b></a></dt>
  <dd>When returned, this value will cause the kernel to attempt to notify a
      <b>ptrace</b>(2)-based tracer prior to executing the system call. If there
      is no tracer present, the system call is not executed and returns a
      failure status with <i>errno</i> set to <b>ENOSYS</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>A tracer will be notified if it requests <b>PTRACE_O_TRACESECCOMP</b>
      using <i>ptrace(PTRACE_SETOPTIONS)</i>. The tracer will be notified of a
      <b>PTRACE_EVENT_SECCOMP</b> and the <b>SECCOMP_RET_DATA</b> portion of the
      filter's return value will be available to the tracer via
      <b>PTRACE_GETEVENTMSG</b>.</dd>
  <dt></dt>
  <dd>The tracer can skip the system call by changing the system call number to
      -1. Alternatively, the tracer can change the system call requested by
      changing the system call to a valid system call number. If the tracer asks
      to skip the system call, then the system call will appear to return the
      value that the tracer puts in the return value register.</dd>
  <dt></dt>
  <dd>Before Linux 4.8, the seccomp check will not be run again after the tracer
      is notified. (This means that, on older kernels, seccomp-based sandboxes
      <b>must not</b> allow use of <b>ptrace</b>(2)—even of other
      sandboxed processes—without extreme care; ptracers can use this
      mechanism to escape from the seccomp sandbox.)</dd>
  <dt></dt>
  <dd>Note that a tracer process will not be notified if another filter returns
      an action value with a precedence greater than
    <b>SECCOMP_RET_TRACE</b>.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SECCOMP_RET_LOG"><a class="permalink" href="#SECCOMP_RET_LOG"><b>SECCOMP_RET_LOG</b>
    (since Linux 4.14)</a></dt>
  <dd>This value results in the system call being executed after the filter
      return action is logged. An administrator may override the logging of this
      action via the <i>/proc/sys/kernel/seccomp/actions_logged</i> file.</dd>
  <dt id="SECCOMP_RET_ALLOW"><a class="permalink" href="#SECCOMP_RET_ALLOW"><b>SECCOMP_RET_ALLOW</b></a></dt>
  <dd>This value results in the system call being executed.</dd>
</dl>
<p class="Pp">If an action value other than one of the above is specified, then
    the filter action is treated as either <b>SECCOMP_RET_KILL_PROCESS</b>
    (since Linux 4.14) or <b>SECCOMP_RET_KILL_THREAD</b> (in Linux 4.13 and
    earlier).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="/proc_interfaces"><a class="permalink" href="#/proc_interfaces">/proc
  interfaces</a></h2>
<p class="Pp">The files in the directory <i>/proc/sys/kernel/seccomp</i> provide
    additional seccomp information and configuration:</p>
<dl class="Bl-tag">
  <dt id="actions_avail"><a class="permalink" href="#actions_avail"><i>actions_avail</i>
    (since Linux 4.14)</a></dt>
  <dd>A read-only ordered list of seccomp filter return actions in string form.
      The ordering, from left-to-right, is in decreasing order of precedence.
      The list represents the set of seccomp filter return actions supported by
      the kernel.</dd>
  <dt id="actions_logged"><a class="permalink" href="#actions_logged"><i>actions_logged</i>
    (since Linux 4.14)</a></dt>
  <dd>A read-write ordered list of seccomp filter return actions that are
      allowed to be logged. Writes to the file do not need to be in ordered form
      but reads from the file will be ordered in the same way as the
      <i>actions_avail</i> file.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>It is important to note that the value of <i>actions_logged</i> does not
      prevent certain filter return actions from being logged when the audit
      subsystem is configured to audit a task. If the action is not found in the
      <i>actions_logged</i> file, the final decision on whether to audit the
      action for that task is ultimately left up to the audit subsystem to
      decide for all filter return actions other than
    <b>SECCOMP_RET_ALLOW</b>.</dd>
  <dt></dt>
  <dd>The "allow" string is not accepted in the <i>actions_logged</i>
      file as it is not possible to log <b>SECCOMP_RET_ALLOW</b> actions.
      Attempting to write "allow" to the file will fail with the error
      <b>EINVAL</b>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Audit_logging_of_seccomp_actions"><a class="permalink" href="#Audit_logging_of_seccomp_actions">Audit
  logging of seccomp actions</a></h2>
<p class="Pp">Since Linux 4.14, the kernel provides the facility to log the
    actions returned by seccomp filters in the audit log. The kernel makes the
    decision to log an action based on the action type, whether or not the
    action is present in the <i>actions_logged</i> file, and whether kernel
    auditing is enabled (e.g., via the kernel boot option <i>audit=1</i>). The
    rules are as follows:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If the action is <b>SECCOMP_RET_ALLOW</b>, the action is not logged.</dd>
  <dt>•</dt>
  <dd>Otherwise, if the action is either <b>SECCOMP_RET_KILL_PROCESS</b> or
      <b>SECCOMP_RET_KILL_THREAD</b>, and that action appears in the
      <i>actions_logged</i> file, the action is logged.</dd>
  <dt>•</dt>
  <dd>Otherwise, if the filter has requested logging (the
      <b>SECCOMP_FILTER_FLAG_LOG</b> flag) and the action appears in the
      <i>actions_logged</i> file, the action is logged.</dd>
  <dt>•</dt>
  <dd>Otherwise, if kernel auditing is enabled and the process is being audited
      (<b>autrace</b>(8)), the action is logged.</dd>
  <dt>•</dt>
  <dd>Otherwise, the action is not logged.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="RETURN_VALUE"><a class="permalink" href="#RETURN_VALUE">RETURN
  VALUE</a></h1>
<p class="Pp">On success, <b>seccomp</b>() returns 0. On error, if
    <b>SECCOMP_FILTER_FLAG_TSYNC</b> was used, the return value is the ID of the
    thread that caused the synchronization failure. (This ID is a kernel thread
    ID of the type returned by <b>clone</b>(2) and <b>gettid</b>(2).) On other
    errors, -1 is returned, and <i>errno</i> is set to indicate the error.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp"><b>seccomp</b>() can fail for the following reasons:</p>
<dl class="Bl-tag">
  <dt id="EACCES"><a class="permalink" href="#EACCES"><b>EACCES</b></a></dt>
  <dd>The caller did not have the <b>CAP_SYS_ADMIN</b> capability in its user
      namespace, or had not set <i>no_new_privs</i> before using
      <b>SECCOMP_SET_MODE_FILTER</b>.</dd>
  <dt id="EBUSY"><a class="permalink" href="#EBUSY"><b>EBUSY</b></a></dt>
  <dd>While installing a new filter, the <b>SECCOMP_FILTER_FLAG_NEW_LISTENER</b>
      flag was specified, but a previous filter had already been installed with
      that flag.</dd>
  <dt id="EFAULT"><a class="permalink" href="#EFAULT"><b>EFAULT</b></a></dt>
  <dd><i>args</i> was not a valid address.</dd>
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd><i>operation</i> is unknown or is not supported by this kernel version or
      configuration.</dd>
  <dt id="EINVAL~2"><a class="permalink" href="#EINVAL~2"><b>EINVAL</b></a></dt>
  <dd>The specified <i>flags</i> are invalid for the given
    <i>operation</i>.</dd>
  <dt id="EINVAL~3"><a class="permalink" href="#EINVAL~3"><b>EINVAL</b></a></dt>
  <dd><i>operation</i> included <b>BPF_ABS</b>, but the specified offset was not
      aligned to a 32-bit boundary or exceeded
      <i>sizeof(struct&nbsp;seccomp_data)</i>.</dd>
  <dt id="EINVAL~4"><a class="permalink" href="#EINVAL~4"><b>EINVAL</b></a></dt>
  <dd>A secure computing mode has already been set, and <i>operation</i> differs
      from the existing setting.</dd>
  <dt id="EINVAL~5"><a class="permalink" href="#EINVAL~5"><b>EINVAL</b></a></dt>
  <dd><i>operation</i> specified <b>SECCOMP_SET_MODE_FILTER</b>, but the filter
      program pointed to by <i>args</i> was not valid or the length of the
      filter program was zero or exceeded <b>BPF_MAXINSNS</b> (4096)
      instructions.</dd>
  <dt id="ENOMEM"><a class="permalink" href="#ENOMEM"><b>ENOMEM</b></a></dt>
  <dd>Out of memory.</dd>
  <dt id="ENOMEM~2"><a class="permalink" href="#ENOMEM~2"><b>ENOMEM</b></a></dt>
  <dd>The total length of all filter programs attached to the calling thread
      would exceed <b>MAX_INSNS_PER_PATH</b> (32768) instructions. Note that for
      the purposes of calculating this limit, each already existing filter
      program incurs an overhead penalty of 4 instructions.</dd>
  <dt id="EOPNOTSUPP"><a class="permalink" href="#EOPNOTSUPP"><b>EOPNOTSUPP</b></a></dt>
  <dd><i>operation</i> specified <b>SECCOMP_GET_ACTION_AVAIL</b>, but the kernel
      does not support the filter return action specified by <i>args</i>.</dd>
  <dt id="ESRCH"><a class="permalink" href="#ESRCH"><b>ESRCH</b></a></dt>
  <dd>Another thread caused a failure during thread sync, but its ID could not
      be determined.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSIONS"><a class="permalink" href="#VERSIONS">VERSIONS</a></h1>
<p class="Pp">The <b>seccomp</b>() system call first appeared in Linux 3.17.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">The <b>seccomp</b>() system call is a nonstandard Linux
  extension.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">Rather than hand-coding seccomp filters as shown in the example
    below, you may prefer to employ the <i>libseccomp</i> library, which
    provides a front-end for generating seccomp filters.</p>
<p class="Pp">The <i>Seccomp</i> field of the <i>/proc/</i>pid<i>/status</i>
    file provides a method of viewing the seccomp mode of a process; see
    <b>proc</b>(5).</p>
<p class="Pp"><b>seccomp</b>() provides a superset of the functionality provided
    by the <b>prctl</b>(2) <b>PR_SET_SECCOMP</b> operation (which does not
    support <i>flags</i>).</p>
<p class="Pp">Since Linux 4.4, the <b>ptrace</b>(2)
    <b>PTRACE_SECCOMP_GET_FILTER</b> operation can be used to dump a process's
    seccomp filters.</p>
<section class="Ss">
<h2 class="Ss" id="Architecture_support_for_seccomp_BPF"><a class="permalink" href="#Architecture_support_for_seccomp_BPF">Architecture
  support for seccomp BPF</a></h2>
<p class="Pp">Architecture support for seccomp BPF filtering is available on the
    following architectures:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>x86-64, i386, x32 (since Linux 3.5)</dd>
  <dt>•</dt>
  <dd>ARM (since Linux 3.8)</dd>
  <dt>•</dt>
  <dd>s390 (since Linux 3.8)</dd>
  <dt>•</dt>
  <dd>MIPS (since Linux 3.16)</dd>
  <dt>•</dt>
  <dd>ARM-64 (since Linux 3.19)</dd>
  <dt>•</dt>
  <dd>PowerPC (since Linux 4.3)</dd>
  <dt>•</dt>
  <dd>Tile (since Linux 4.3)</dd>
  <dt>•</dt>
  <dd>PA-RISC (since Linux 4.6)</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Caveats"><a class="permalink" href="#Caveats">Caveats</a></h2>
<p class="Pp">There are various subtleties to consider when applying seccomp
    filters to a program, including the following:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>Some traditional system calls have user-space implementations in the
      <b>vdso</b>(7) on many architectures. Notable examples include
      <b>clock_gettime</b>(2), <b>gettimeofday</b>(2), and <b>time</b>(2). On
      such architectures, seccomp filtering for these system calls will have no
      effect. (However, there are cases where the <b>vdso</b>(7) implementations
      may fall back to invoking the true system call, in which case seccomp
      filters would see the system call.)</dd>
  <dt>•</dt>
  <dd>Seccomp filtering is based on system call numbers. However, applications
      typically do not directly invoke system calls, but instead call wrapper
      functions in the C library which in turn invoke the system calls.
      Consequently, one must be aware of the following:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The glibc wrappers for some traditional system calls may actually employ
      system calls with different names in the kernel. For example, the
      <b>exit</b>(2) wrapper function actually employs the <b>exit_group</b>(2)
      system call, and the <b>fork</b>(2) wrapper function actually calls
      <b>clone</b>(2).</dd>
  <dt>•</dt>
  <dd>The behavior of wrapper functions may vary across architectures, according
      to the range of system calls provided on those architectures. In other
      words, the same wrapper function may invoke different system calls on
      different architectures.</dd>
  <dt>•</dt>
  <dd>Finally, the behavior of wrapper functions can change across glibc
      versions. For example, in older versions, the glibc wrapper function for
      <b>open</b>(2) invoked the system call of the same name, but starting in
      glibc 2.26, the implementation switched to calling <b>openat</b>(2) on all
      architectures.</dd>
</dl>
</div>
<p class="Pp">The consequence of the above points is that it may be necessary to
    filter for a system call other than might be expected. Various manual pages
    in Section 2 provide helpful details about the differences between wrapper
    functions and the underlying system calls in subsections entitled <i>C
    library/kernel differences</i>.</p>
<p class="Pp">Furthermore, note that the application of seccomp filters even
    risks causing bugs in an application, when the filters cause unexpected
    failures for legitimate operations that the application might need to
    perform. Such bugs may not easily be discovered when testing the seccomp
    filters if the bugs occur in rarely used application code paths.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Seccomp-specific_BPF_details"><a class="permalink" href="#Seccomp-specific_BPF_details">Seccomp-specific
  BPF details</a></h2>
<p class="Pp">Note the following BPF details specific to seccomp filters:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The <b>BPF_H</b> and <b>BPF_B</b> size modifiers are not supported: all
      operations must load and store (4-byte) words (<b>BPF_W</b>).</dd>
  <dt>•</dt>
  <dd>To access the contents of the <i>seccomp_data</i> buffer, use the
      <b>BPF_ABS</b> addressing mode modifier.</dd>
  <dt>•</dt>
  <dd>The <b>BPF_LEN</b> addressing mode modifier yields an immediate mode
      operand whose value is the size of the <i>seccomp_data</i> buffer.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The program below accepts four or more arguments. The first three
    arguments are a system call number, a numeric architecture identifier, and
    an error number. The program uses these values to construct a BPF filter
    that is used at run time to perform the following checks:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>If the program is not running on the specified architecture, the BPF
      filter causes system calls to fail with the error <b>ENOSYS</b>.</dd>
  <dt>•</dt>
  <dd>If the program attempts to execute the system call with the specified
      number, the BPF filter causes the system call to fail, with <i>errno</i>
      being set to the specified error number.</dd>
</dl>
<p class="Pp">The remaining command-line arguments specify the pathname and
    additional arguments of a program that the example program should attempt to
    execute using <b>execv</b>(3) (a library function that employs the
    <b>execve</b>(2) system call). Some example runs of the program are shown
    below.</p>
<p class="Pp">First, we display the architecture that we are running on (x86-64)
    and then construct a shell function that looks up system call numbers on
    this architecture:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>uname -m</b>
x86_64
$ <b>syscall_nr() {</b>
<br>
<b>    cat /usr/src/linux/arch/x86/syscalls/syscall_64.tbl | \</b>
<br>
<b>    awk '$2 != "x32" &amp;&amp; $3 == "'$1'" { print $1 }'</b>
<b>}</b>
</pre>
<br>
<p class="Pp">When the BPF filter rejects a system call (case [2] above), it
    causes the system call to fail with the error number specified on the
    command line. In the experiments shown here, we'll use error number 99:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>errno 99</b>
EADDRNOTAVAIL 99 Cannot assign requested address
</pre>
<br>
<p class="Pp">In the following example, we attempt to run the command
    <b>whoami</b>(1), but the BPF filter rejects the <b>execve</b>(2) system
    call, so that the command is not even executed:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>syscall_nr execve</b>
59
$ <b>./a.out</b>
Usage: ./a.out &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]
Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x40000003
<br>
                 AUDIT_ARCH_X86_64: 0xC000003E
$ <b>./a.out 59 0xC000003E 99 /bin/whoami</b>
execv: Cannot assign requested address
</pre>
<br>
<p class="Pp">In the next example, the BPF filter rejects the <b>write</b>(2)
    system call, so that, although it is successfully started, the
    <b>whoami</b>(1) command is not able to write output:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>syscall_nr write</b>
1
$ <b>./a.out 1 0xC000003E 99 /bin/whoami</b>
</pre>
<br>
<p class="Pp">In the final example, the BPF filter rejects a system call that is
    not used by the <b>whoami</b>(1) command, so it is able to successfully
    execute and produce output:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>syscall_nr preadv</b>
295
$ <b>./a.out 295 0xC000003E 99 /bin/whoami</b>
cecilia
</pre>
<br>
<section class="Ss">
<h2 class="Ss" id="Program_source"><a class="permalink" href="#Program_source">Program
  source</a></h2>
<pre>#include &lt;linux/audit.h&gt;
#include &lt;linux/filter.h&gt;
#include &lt;linux/seccomp.h&gt;
#include &lt;stddef.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/prctl.h&gt;
#include &lt;sys/syscall.h&gt;
#include &lt;unistd.h&gt;
#define X32_SYSCALL_BIT 0x40000000
#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
static int
install_filter(int syscall_nr, unsigned int t_arch, int f_errno)
{
<br>
    unsigned int upper_nr_limit = 0xffffffff;
<br>
    /* Assume that AUDIT_ARCH_X86_64 means the normal x86-64 ABI
<br>
       (in the x32 ABI, all system calls have bit 30 set in the
<br>
       'nr' field, meaning the numbers are &gt;= X32_SYSCALL_BIT). */
<br>
    if (t_arch == AUDIT_ARCH_X86_64)
<br>
        upper_nr_limit = X32_SYSCALL_BIT - 1;
<br>
    struct sock_filter filter[] = {
<br>
        /* [0] Load architecture from 'seccomp_data' buffer into
<br>
               accumulator. */
<br>
        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
<br>
                 (offsetof(struct seccomp_data, arch))),
<br>
        /* [1] Jump forward 5 instructions if architecture does not
<br>
               match 't_arch'. */
<br>
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, t_arch, 0, 5),
<br>
        /* [2] Load system call number from 'seccomp_data' buffer into
<br>
               accumulator. */
<br>
        BPF_STMT(BPF_LD | BPF_W | BPF_ABS,
<br>
                 (offsetof(struct seccomp_data, nr))),
<br>
        /* [3] Check ABI - only needed for x86-64 in deny-list use
<br>
               cases.  Use BPF_JGT instead of checking against the bit
<br>
               mask to avoid having to reload the syscall number. */
<br>
        BPF_JUMP(BPF_JMP | BPF_JGT | BPF_K, upper_nr_limit, 3, 0),
<br>
        /* [4] Jump forward 1 instruction if system call number
<br>
               does not match 'syscall_nr'. */
<br>
        BPF_JUMP(BPF_JMP | BPF_JEQ | BPF_K, syscall_nr, 0, 1),
<br>
        /* [5] Matching architecture and system call: don't execute
<br>
           the system call, and return 'f_errno' in 'errno'. */
<br>
        BPF_STMT(BPF_RET | BPF_K,
<br>
                 SECCOMP_RET_ERRNO | (f_errno &amp; SECCOMP_RET_DATA)),
<br>
        /* [6] Destination of system call number mismatch: allow other
<br>
               system calls. */
<br>
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_ALLOW),
<br>
        /* [7] Destination of architecture mismatch: kill process. */
<br>
        BPF_STMT(BPF_RET | BPF_K, SECCOMP_RET_KILL_PROCESS),
<br>
    };
<br>
    struct sock_fprog prog = {
<br>
        .len = ARRAY_SIZE(filter),
<br>
        .filter = filter,
<br>
    };
<br>
    if (syscall(SYS_seccomp, SECCOMP_SET_MODE_FILTER, 0, &amp;prog)) {
<br>
        perror("seccomp");
<br>
        return 1;
<br>
    }
<br>
    return 0;
}
int
main(int argc, char *argv[])
{
<br>
    if (argc &lt; 5) {
<br>
        fprintf(stderr, "Usage: "
<br>
                "%s &lt;syscall_nr&gt; &lt;arch&gt; &lt;errno&gt; &lt;prog&gt; [&lt;args&gt;]\n"
<br>
                "Hint for &lt;arch&gt;: AUDIT_ARCH_I386: 0x%X\n"
<br>
                "                 AUDIT_ARCH_X86_64: 0x%X\n"
<br>
                "\n", argv[0], AUDIT_ARCH_I386, AUDIT_ARCH_X86_64);
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0)) {
<br>
        perror("prctl");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    if (install_filter(strtol(argv[1], NULL, 0),
<br>
                       strtoul(argv[2], NULL, 0),
<br>
                       strtol(argv[3], NULL, 0)))
<br>
        exit(EXIT_FAILURE);
<br>
    execv(argv[4], &amp;argv[4]);
<br>
    perror("execv");
<br>
    exit(EXIT_FAILURE);
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>bpfc</b>(1), <b>strace</b>(1), <b>bpf</b>(2), <b>prctl</b>(2),
    <b>ptrace</b>(2), <b>seccomp_unotify</b>(2), <b>sigaction</b>(2),
    <b>proc</b>(5), <b>signal</b>(7), <b>socket</b>(7)</p>
<p class="Pp">Various pages from the <i>libseccomp</i> library, including:
    <b>scmp_sys_resolver</b>(1), <b>seccomp_export_bpf</b>(3),
    <b>seccomp_init</b>(3), <b>seccomp_load</b>(3), and
    <b>seccomp_rule_add</b>(3).</p>
<p class="Pp">The kernel source files <i>Documentation/networking/filter.txt</i>
    and <i>Documentation/userspace-api/seccomp_filter.rst</i> (or
    <i>Documentation/prctl/seccomp_filter.txt</i> before Linux 4.13).</p>
<p class="Pp">McCanne, S. and Jacobson, V. (1992) <i>The BSD Packet Filter: A
    New Architecture for User-level Packet Capture</i>, Proceedings of the
    USENIX Winter 1993 Conference
    <a class="Lk" href="http://www.tcpdump.org/papers/bpf-usenix93.pdf">http://www.tcpdump.org/papers/bpf-usenix93.pdf</a></p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>