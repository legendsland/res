<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (C) 2015 Serge Hallyn <serge@hallyn.com>
   and Copyright (C) 2016, 2017 Michael Kerrisk <mtk.manpages@gmail.com>
  
   SPDX-License-Identifier: Linux-man-pages-copyleft
   --><head>
<meta name="dc.identifier" content="res/bc4560666a031669f8665cb3b281b6f4f7696b74">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>cgroups(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">cgroups(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">cgroups(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">cgroups - Linux control groups</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">Control groups, usually referred to as cgroups, are a Linux kernel
    feature which allow processes to be organized into hierarchical groups whose
    usage of various types of resources can then be limited and monitored. The
    kernel's cgroup interface is provided through a pseudo-filesystem called
    cgroupfs. Grouping is implemented in the core cgroup kernel code, while
    resource tracking and limits are implemented in a set of per-resource-type
    subsystems (memory, CPU, and so on).</p>
<section class="Ss">
<h2 class="Ss" id="Terminology"><a class="permalink" href="#Terminology">Terminology</a></h2>
<p class="Pp">A <i>cgroup</i> is a collection of processes that are bound to a
    set of limits or parameters defined via the cgroup filesystem.</p>
<p class="Pp">A <i>subsystem</i> is a kernel component that modifies the
    behavior of the processes in a cgroup. Various subsystems have been
    implemented, making it possible to do things such as limiting the amount of
    CPU time and memory available to a cgroup, accounting for the CPU time used
    by a cgroup, and freezing and resuming execution of the processes in a
    cgroup. Subsystems are sometimes also known as <i>resource controllers</i>
    (or simply, controllers).</p>
<p class="Pp">The cgroups for a controller are arranged in a <i>hierarchy</i>.
    This hierarchy is defined by creating, removing, and renaming subdirectories
    within the cgroup filesystem. At each level of the hierarchy, attributes
    (e.g., limits) can be defined. The limits, control, and accounting provided
    by cgroups generally have effect throughout the subhierarchy underneath the
    cgroup where the attributes are defined. Thus, for example, the limits
    placed on a cgroup at a higher level in the hierarchy cannot be exceeded by
    descendant cgroups.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_version_1_and_version_2"><a class="permalink" href="#Cgroups_version_1_and_version_2">Cgroups
  version 1 and version 2</a></h2>
<p class="Pp">The initial release of the cgroups implementation was in Linux
    2.6.24. Over time, various cgroup controllers have been added to allow the
    management of various types of resources. However, the development of these
    controllers was largely uncoordinated, with the result that many
    inconsistencies arose between controllers and management of the cgroup
    hierarchies became rather complex. A longer description of these problems
    can be found in the kernel source file
    <i>Documentation/admin-guide/cgroup-v2.rst</i> (or
    <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and earlier).</p>
<p class="Pp">Because of the problems with the initial cgroups implementation
    (cgroups version 1), starting in Linux 3.10, work began on a new, orthogonal
    implementation to remedy these problems. Initially marked experimental, and
    hidden behind the <i>-o&nbsp;__DEVEL__sane_behavior</i> mount option, the
    new version (cgroups version 2) was eventually made official with the
    release of Linux 4.5. Differences between the two versions are described in
    the text below. The file <i>cgroup.sane_behavior</i>, present in cgroups v1,
    is a relic of this mount option. The file always reports "0" and
    is only retained for backward compatibility.</p>
<p class="Pp">Although cgroups v2 is intended as a replacement for cgroups v1,
    the older system continues to exist (and for compatibility reasons is
    unlikely to be removed). Currently, cgroups v2 implements only a subset of
    the controllers available in cgroups v1. The two systems are implemented so
    that both v1 controllers and v2 controllers can be mounted on the same
    system. Thus, for example, it is possible to use those controllers that are
    supported under version 2, while also using version 1 controllers where
    version 2 does not yet support those controllers. The only restriction here
    is that a controller can't be simultaneously employed in both a cgroups v1
    hierarchy and in the cgroups v2 hierarchy.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CGROUPS_VERSION_1"><a class="permalink" href="#CGROUPS_VERSION_1">CGROUPS
  VERSION 1</a></h1>
<p class="Pp">Under cgroups v1, each controller may be mounted against a
    separate cgroup filesystem that provides its own hierarchical organization
    of the processes on the system. It is also possible to comount multiple (or
    even all) cgroups v1 controllers against the same cgroup filesystem, meaning
    that the comounted controllers manage the same hierarchical organization of
    processes.</p>
<p class="Pp">For each mounted hierarchy, the directory tree mirrors the control
    group hierarchy. Each control group is represented by a directory, with each
    of its child control cgroups represented as a child directory. For instance,
    <i>/user/joe/1.session</i> represents control group <i>1.session</i>, which
    is a child of cgroup <i>joe</i>, which is a child of <i>/user</i>. Under
    each cgroup directory is a set of files which can be read or written to,
    reflecting resource limits and a few general cgroup properties.</p>
<section class="Ss">
<h2 class="Ss" id="Tasks_(threads)_versus_processes"><a class="permalink" href="#Tasks_(threads)_versus_processes">Tasks
  (threads) versus processes</a></h2>
<p class="Pp">In cgroups v1, a distinction is drawn between <i>processes</i> and
    <i>tasks</i>. In this view, a process can consist of multiple tasks (more
    commonly called threads, from a user-space perspective, and called such in
    the remainder of this man page). In cgroups v1, it is possible to
    independently manipulate the cgroup memberships of the threads in a
  process.</p>
<p class="Pp">The cgroups v1 ability to split threads across different cgroups
    caused problems in some cases. For example, it made no sense for the
    <i>memory</i> controller, since all of the threads of a process share a
    single address space. Because of these problems, the ability to
    independently manipulate the cgroup memberships of the threads in a process
    was removed in the initial cgroups v2 implementation, and subsequently
    restored in a more limited form (see the discussion of "thread
    mode" below).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Mounting_v1_controllers"><a class="permalink" href="#Mounting_v1_controllers">Mounting
  v1 controllers</a></h2>
<p class="Pp">The use of cgroups requires a kernel built with the
    <b>CONFIG_CGROUP</b> option. In addition, each of the v1 controllers has an
    associated configuration option that must be set in order to employ that
    controller.</p>
<p class="Pp">In order to use a v1 controller, it must be mounted against a
    cgroup filesystem. The usual place for such mounts is under a
    <b>tmpfs</b>(5) filesystem mounted at <i>/sys/fs/cgroup</i>. Thus, one might
    mount the <i>cpu</i> controller as follows:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup -o cpu none /sys/fs/cgroup/cpu
</pre>
<br>
<p class="Pp">It is possible to comount multiple controllers against the same
    hierarchy. For example, here the <i>cpu</i> and <i>cpuacct</i> controllers
    are comounted against a single hierarchy:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup -o cpu,cpuacct none /sys/fs/cgroup/cpu,cpuacct
</pre>
<br>
<p class="Pp">Comounting controllers has the effect that a process is in the
    same cgroup for all of the comounted controllers. Separately mounting
    controllers allows a process to be in cgroup <i>/foo1</i> for one controller
    while being in <i>/foo2/foo3</i> for another.</p>
<p class="Pp">It is possible to comount all v1 controllers against the same
    hierarchy:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup -o all cgroup /sys/fs/cgroup
</pre>
<br>
<p class="Pp">(One can achieve the same result by omitting <i>-o all</i>, since
    it is the default if no controllers are explicitly specified.)</p>
<p class="Pp">It is not possible to mount the same controller against multiple
    cgroup hierarchies. For example, it is not possible to mount both the
    <i>cpu</i> and <i>cpuacct</i> controllers against one hierarchy, and to
    mount the <i>cpu</i> controller alone against another hierarchy. It is
    possible to create multiple mount with exactly the same set of comounted
    controllers. However, in this case all that results is multiple mount points
    providing a view of the same hierarchy.</p>
<p class="Pp">Note that on many systems, the v1 controllers are automatically
    mounted under <i>/sys/fs/cgroup</i>; in particular, <b>systemd</b>(1)
    automatically creates such mounts.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Unmounting_v1_controllers"><a class="permalink" href="#Unmounting_v1_controllers">Unmounting
  v1 controllers</a></h2>
<p class="Pp">A mounted cgroup filesystem can be unmounted using the
    <b>umount</b>(8) command, as in the following example:</p>
<p class="Pp">
  <br>
</p>
<pre>umount /sys/fs/cgroup/pids
</pre>
<br>
<p class="Pp"><i>But note well</i>: a cgroup filesystem is unmounted only if it
    is not busy, that is, it has no child cgroups. If this is not the case, then
    the only effect of the <b>umount</b>(8) is to make the mount invisible.
    Thus, to ensure that the mount is really removed, one must first remove all
    child cgroups, which in turn can be done only after all member processes
    have been moved from those cgroups to the root cgroup.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_version_1_controllers"><a class="permalink" href="#Cgroups_version_1_controllers">Cgroups
  version 1 controllers</a></h2>
<p class="Pp">Each of the cgroups version 1 controllers is governed by a kernel
    configuration option (listed below). Additionally, the availability of the
    cgroups feature is governed by the <b>CONFIG_CGROUPS</b> kernel
    configuration option.</p>
<dl class="Bl-tag">
  <dt id="cpu"><a class="permalink" href="#cpu"><i>cpu</i> (since Linux 2.6.24;
    <i><b>CONFIG_CGROUP_SCHED</b></i>)</a></dt>
  <dd>Cgroups can be guaranteed a minimum number of "CPU shares" when
      a system is busy. This does not limit a cgroup's CPU usage if the CPUs are
      not busy. For further information, see
      <i>Documentation/scheduler/sched-design-CFS.rst</i> (or
      <i>Documentation/scheduler/sched-design-CFS.txt</i> in Linux 5.2 and
      earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>In Linux 3.2, this controller was extended to provide CPU
      "bandwidth" control. If the kernel is configured with
      <b>CONFIG_CFS_BANDWIDTH</b>, then within each scheduling period (defined
      via a file in the cgroup directory), it is possible to define an upper
      limit on the CPU time allocated to the processes in a cgroup. This upper
      limit applies even if there is no other competition for the CPU. Further
      information can be found in the kernel source file
      <i>Documentation/scheduler/sched-bwc.rst</i> (or
      <i>Documentation/scheduler/sched-bwc.txt</i> in Linux 5.2 and
    earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="cpuacct"><a class="permalink" href="#cpuacct"><i>cpuacct</i> (since
    Linux 2.6.24; <i><b>CONFIG_CGROUP_CPUACCT</b></i>)</a></dt>
  <dd>This provides accounting for CPU usage by groups of processes.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/cpuacct.rst</i> (or
      <i>Documentation/cgroup-v1/cpuacct.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="cpuset"><a class="permalink" href="#cpuset"><i>cpuset</i> (since Linux
    2.6.24; <i><b>CONFIG_CPUSETS</b></i>)</a></dt>
  <dd>This cgroup can be used to bind the processes in a cgroup to a specified
      set of CPUs and NUMA nodes.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/cpusets.rst</i> (or
      <i>Documentation/cgroup-v1/cpusets.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="memory"><a class="permalink" href="#memory"><i>memory</i> (since Linux
    2.6.25; <i><b>CONFIG_MEMCG</b></i>)</a></dt>
  <dd>The memory controller supports reporting and limiting of process memory,
      kernel memory, and swap used by cgroups.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/memory.rst</i> (or
      <i>Documentation/cgroup-v1/memory.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="devices"><a class="permalink" href="#devices"><i>devices</i> (since
    Linux 2.6.26; <i><b>CONFIG_CGROUP_DEVICE</b></i>)</a></dt>
  <dd>This supports controlling which processes may create (mknod) devices as
      well as open them for reading or writing. The policies may be specified as
      allow-lists and deny-lists. Hierarchy is enforced, so new rules must not
      violate existing rules for the target or ancestor cgroups.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/devices.rst</i> (or
      <i>Documentation/cgroup-v1/devices.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="freezer"><a class="permalink" href="#freezer"><i>freezer</i> (since
    Linux 2.6.28; <i><b>CONFIG_CGROUP_FREEZER</b></i>)</a></dt>
  <dd>The <i>freezer</i> cgroup can suspend and restore (resume) all processes
      in a cgroup. Freezing a cgroup <i>/A</i> also causes its children, for
      example, processes in <i>/A/B</i>, to be frozen.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/freezer-subsystem.rst</i> (or
      <i>Documentation/cgroup-v1/freezer-subsystem.txt</i> in Linux 5.2 and
      earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="net_cls"><a class="permalink" href="#net_cls"><i>net_cls</i> (since
    Linux 2.6.29; <i><b>CONFIG_CGROUP_NET_CLASSID</b></i>)</a></dt>
  <dd>This places a classid, specified for the cgroup, on network packets
      created by a cgroup. These classids can then be used in firewall rules, as
      well as used to shape traffic using <b>tc</b>(8). This applies only to
      packets leaving the cgroup, not to traffic arriving at the cgroup.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i> (or
      <i>Documentation/cgroup-v1/net_cls.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="blkio"><a class="permalink" href="#blkio"><i>blkio</i> (since Linux
    2.6.33; <i><b>CONFIG_BLK_CGROUP</b></i>)</a></dt>
  <dd>The <i>blkio</i> cgroup controls and limits access to specified block
      devices by applying IO control in the form of throttling and upper limits
      against leaf nodes and intermediate nodes in the storage hierarchy.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Two policies are available. The first is a proportional-weight time-based
      division of disk implemented with CFQ. This is in effect for leaf nodes
      using CFQ. The second is a throttling policy which specifies upper I/O
      rate limits on a device.</dd>
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/blkio-controller.rst</i> (or
      <i>Documentation/cgroup-v1/blkio-controller.txt</i> in Linux 5.2 and
      earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="perf_event"><a class="permalink" href="#perf_event"><i>perf_event</i>
    (since Linux 2.6.39; <i><b>CONFIG_CGROUP_PERF</b></i>)</a></dt>
  <dd>This controller allows <i>perf</i> monitoring of the set of processes
      grouped in a cgroup.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source files</dd>
</dl>
<dl class="Bl-tag">
  <dt id="net_prio"><a class="permalink" href="#net_prio"><i>net_prio</i> (since
    Linux 3.3; <i><b>CONFIG_CGROUP_NET_PRIO</b></i>)</a></dt>
  <dd>This allows priorities to be specified, per network interface, for
      cgroups.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/net_prio.rst</i> (or
      <i>Documentation/cgroup-v1/net_prio.txt</i> in Linux 5.2 and
    earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="hugetlb"><a class="permalink" href="#hugetlb"><i>hugetlb</i> (since
    Linux 3.5; <i><b>CONFIG_CGROUP_HUGETLB</b></i>)</a></dt>
  <dd>This supports limiting the use of huge pages by cgroups.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/hugetlb.rst</i> (or
      <i>Documentation/cgroup-v1/hugetlb.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="pids"><a class="permalink" href="#pids"><i>pids</i> (since Linux 4.3;
    <i><b>CONFIG_CGROUP_PIDS</b></i>)</a></dt>
  <dd>This controller permits limiting the number of process that may be created
      in a cgroup (and its descendants).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/pids.rst</i> (or
      <i>Documentation/cgroup-v1/pids.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
<dl class="Bl-tag">
  <dt id="rdma"><a class="permalink" href="#rdma"><i>rdma</i> (since Linux 4.11;
    <i><b>CONFIG_CGROUP_RDMA</b></i>)</a></dt>
  <dd>The RDMA controller permits limiting the use of RDMA/IB-specific resources
      per cgroup.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Further information can be found in the kernel source file
      <i>Documentation/admin-guide/cgroup-v1/rdma.rst</i> (or
      <i>Documentation/cgroup-v1/rdma.txt</i> in Linux 5.2 and earlier).</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_cgroups_and_moving_processes"><a class="permalink" href="#Creating_cgroups_and_moving_processes">Creating
  cgroups and moving processes</a></h2>
<p class="Pp">A cgroup filesystem initially contains a single root cgroup, '/',
    which all processes belong to. A new cgroup is created by creating a
    directory in the cgroup filesystem:</p>
<p class="Pp">
  <br>
</p>
<pre>mkdir /sys/fs/cgroup/cpu/cg1
</pre>
<br>
<p class="Pp">This creates a new empty cgroup.</p>
<p class="Pp">A process may be moved to this cgroup by writing its PID into the
    cgroup's <i>cgroup.procs</i> file:</p>
<p class="Pp">
  <br>
</p>
<pre>echo $$ &gt; /sys/fs/cgroup/cpu/cg1/cgroup.procs
</pre>
<br>
<p class="Pp">Only one PID at a time should be written to this file.</p>
<p class="Pp">Writing the value 0 to a <i>cgroup.procs</i> file causes the
    writing process to be moved to the corresponding cgroup.</p>
<p class="Pp">When writing a PID into the <i>cgroup.procs</i>, all threads in
    the process are moved into the new cgroup at once.</p>
<p class="Pp">Within a hierarchy, a process can be a member of exactly one
    cgroup. Writing a process's PID to a <i>cgroup.procs</i> file automatically
    removes it from the cgroup of which it was previously a member.</p>
<p class="Pp">The <i>cgroup.procs</i> file can be read to obtain a list of the
    processes that are members of a cgroup. The returned list of PIDs is not
    guaranteed to be in order. Nor is it guaranteed to be free of duplicates.
    (For example, a PID may be recycled while reading from the list.)</p>
<p class="Pp">In cgroups v1, an individual thread can be moved to another cgroup
    by writing its thread ID (i.e., the kernel thread ID returned by
    <b>clone</b>(2) and <b>gettid</b>(2)) to the <i>tasks</i> file in a cgroup
    directory. This file can be read to discover the set of threads that are
    members of the cgroup.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Removing_cgroups"><a class="permalink" href="#Removing_cgroups">Removing
  cgroups</a></h2>
<p class="Pp">To remove a cgroup, it must first have no child cgroups and
    contain no (nonzombie) processes. So long as that is the case, one can
    simply remove the corresponding directory pathname. Note that files in a
    cgroup directory cannot and need not be removed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v1_release_notification"><a class="permalink" href="#Cgroups_v1_release_notification">Cgroups
  v1 release notification</a></h2>
<p class="Pp">Two files can be used to determine whether the kernel provides
    notifications when a cgroup becomes empty. A cgroup is considered to be
    empty when it contains no child cgroups and no member processes.</p>
<p class="Pp">A special file in the root directory of each cgroup hierarchy,
    <i>release_agent</i>, can be used to register the pathname of a program that
    may be invoked when a cgroup in the hierarchy becomes empty. The pathname of
    the newly empty cgroup (relative to the cgroup mount point) is provided as
    the sole command-line argument when the <i>release_agent</i> program is
    invoked. The <i>release_agent</i> program might remove the cgroup directory,
    or perhaps repopulate it with a process.</p>
<p class="Pp">The default value of the <i>release_agent</i> file is empty,
    meaning that no release agent is invoked.</p>
<p class="Pp">The content of the <i>release_agent</i> file can also be specified
    via a mount option when the cgroup filesystem is mounted:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -o release_agent=pathname ...
</pre>
<br>
<p class="Pp">Whether or not the <i>release_agent</i> program is invoked when a
    particular cgroup becomes empty is determined by the value in the
    <i>notify_on_release</i> file in the corresponding cgroup directory. If this
    file contains the value 0, then the <i>release_agent</i> program is not
    invoked. If it contains the value 1, the <i>release_agent</i> program is
    invoked. The default value for this file in the root cgroup is 0. At the
    time when a new cgroup is created, the value in this file is inherited from
    the corresponding file in the parent cgroup.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroup_v1_named_hierarchies"><a class="permalink" href="#Cgroup_v1_named_hierarchies">Cgroup
  v1 named hierarchies</a></h2>
<p class="Pp">In cgroups v1, it is possible to mount a cgroup hierarchy that has
    no attached controllers:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup -o none,name=somename none /some/mount/point
</pre>
<br>
<p class="Pp">Multiple instances of such hierarchies can be mounted; each
    hierarchy must have a unique name. The only purpose of such hierarchies is
    to track processes. (See the discussion of release notification below.) An
    example of this is the <i>name=systemd</i> cgroup hierarchy that is used by
    <b>systemd</b>(1) to track services and user sessions.</p>
<p class="Pp">Since Linux 5.0, the <i>cgroup_no_v1</i> kernel boot option
    (described below) can be used to disable cgroup v1 named hierarchies, by
    specifying <i>cgroup_no_v1=named</i>.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CGROUPS_VERSION_2"><a class="permalink" href="#CGROUPS_VERSION_2">CGROUPS
  VERSION 2</a></h1>
<p class="Pp">In cgroups v2, all mounted controllers reside in a single unified
    hierarchy. While (different) controllers may be simultaneously mounted under
    the v1 and v2 hierarchies, it is not possible to mount the same controller
    simultaneously under both the v1 and the v2 hierarchies.</p>
<p class="Pp">The new behaviors in cgroups v2 are summarized here, and in some
    cases elaborated in the following subsections.</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>Cgroups v2 provides a unified hierarchy against which all controllers are
      mounted.</dd>
  <dt>•</dt>
  <dd>"Internal" processes are not permitted. With the exception of
      the root cgroup, processes may reside only in leaf nodes (cgroups that do
      not themselves contain child cgroups). The details are somewhat more
      subtle than this, and are described below.</dd>
  <dt>•</dt>
  <dd>Active cgroups must be specified via the files <i>cgroup.controllers</i>
      and <i>cgroup.subtree_control</i>.</dd>
  <dt>•</dt>
  <dd>The <i>tasks</i> file has been removed. In addition, the
      <i>cgroup.clone_children</i> file that is employed by the <i>cpuset</i>
      controller has been removed.</dd>
  <dt>•</dt>
  <dd>An improved mechanism for notification of empty cgroups is provided by the
      <i>cgroup.events</i> file.</dd>
</dl>
<p class="Pp">For more changes, see the
    <i>Documentation/admin-guide/cgroup-v2.rst</i> file in the kernel source (or
    <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and earlier).</p>
<p class="Pp">Some of the new behaviors listed above saw subsequent modification
    with the addition in Linux 4.14 of "thread mode" (described
    below).</p>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_unified_hierarchy"><a class="permalink" href="#Cgroups_v2_unified_hierarchy">Cgroups
  v2 unified hierarchy</a></h2>
<p class="Pp">In cgroups v1, the ability to mount different controllers against
    different hierarchies was intended to allow great flexibility for
    application design. In practice, though, the flexibility turned out to be
    less useful than expected, and in many cases added complexity. Therefore, in
    cgroups v2, all available controllers are mounted against a single
    hierarchy. The available controllers are automatically mounted, meaning that
    it is not necessary (or possible) to specify the controllers when mounting
    the cgroup v2 filesystem using a command such as the following:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup2 none /mnt/cgroup2
</pre>
<br>
<p class="Pp">A cgroup v2 controller is available only if it is not currently in
    use via a mount against a cgroup v1 hierarchy. Or, to put things another
    way, it is not possible to employ the same controller against both a v1
    hierarchy and the unified v2 hierarchy. This means that it may be necessary
    first to unmount a v1 controller (as described above) before that controller
    is available in v2. Since <b>systemd</b>(1) makes heavy use of some v1
    controllers by default, it can in some cases be simpler to boot the system
    with selected v1 controllers disabled. To do this, specify the
    <i>cgroup_no_v1=list</i> option on the kernel boot command line; <i>list</i>
    is a comma-separated list of the names of the controllers to disable, or the
    word <i>all</i> to disable all v1 controllers. (This situation is correctly
    handled by <b>systemd</b>(1), which falls back to operating without the
    specified controllers.)</p>
<p class="Pp">Note that on many modern systems, <b>systemd</b>(1) automatically
    mounts the <i>cgroup2</i> filesystem at <i>/sys/fs/cgroup/unified</i> during
    the boot process.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_mount_options"><a class="permalink" href="#Cgroups_v2_mount_options">Cgroups
  v2 mount options</a></h2>
<p class="Pp">The following options (<i>mount&nbsp;-o</i>) can be specified
    when mounting the group v2 filesystem:</p>
<dl class="Bl-tag">
  <dt id="nsdelegate"><a class="permalink" href="#nsdelegate"><i>nsdelegate</i>
    (since Linux 4.15)</a></dt>
  <dd>Treat cgroup namespaces as delegation boundaries. For details, see
    below.</dd>
  <dt id="memory_localevents"><a class="permalink" href="#memory_localevents"><i>memory_localevents</i>
    (since Linux 5.2)</a></dt>
  <dd>The <i>memory.events</i> should show statistics only for the cgroup
      itself, and not for any descendant cgroups. This was the behavior before
      Linux 5.2. Starting in Linux 5.2, the default behavior is to include
      statistics for descendant cgroups in <i>memory.events</i>, and this mount
      option can be used to revert to the legacy behavior. This option is system
      wide and can be set on mount or modified through remount only from the
      initial mount namespace; it is silently ignored in noninitial
    namespaces.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_controllers"><a class="permalink" href="#Cgroups_v2_controllers">Cgroups
  v2 controllers</a></h2>
<p class="Pp">The following controllers, documented in the kernel source file
    <i>Documentation/admin-guide/cgroup-v2.rst</i> (or
    <i>Documentation/cgroup-v2.txt</i> in Linux 4.17 and earlier), are supported
    in cgroups version 2:</p>
<dl class="Bl-tag">
  <dt id="cpu~2"><a class="permalink" href="#cpu~2"><i>cpu</i> (since Linux
    4.15)</a></dt>
  <dd>This is the successor to the version 1 <i>cpu</i> and <i>cpuacct</i>
      controllers.</dd>
  <dt id="cpuset~2"><a class="permalink" href="#cpuset~2"><i>cpuset</i> (since
    Linux 5.0)</a></dt>
  <dd>This is the successor of the version 1 <i>cpuset</i> controller.</dd>
  <dt id="freezer~2"><a class="permalink" href="#freezer~2"><i>freezer</i>
    (since Linux 5.2)</a></dt>
  <dd>This is the successor of the version 1 <i>freezer</i> controller.</dd>
  <dt id="hugetlb~2"><a class="permalink" href="#hugetlb~2"><i>hugetlb</i>
    (since Linux 5.6)</a></dt>
  <dd>This is the successor of the version 1 <i>hugetlb</i> controller.</dd>
  <dt id="io"><a class="permalink" href="#io"><i>io</i> (since Linux
    4.5)</a></dt>
  <dd>This is the successor of the version 1 <i>blkio</i> controller.</dd>
  <dt id="memory~2"><a class="permalink" href="#memory~2"><i>memory</i> (since
    Linux 4.5)</a></dt>
  <dd>This is the successor of the version 1 <i>memory</i> controller.</dd>
  <dt id="perf_event~2"><a class="permalink" href="#perf_event~2"><i>perf_event</i>
    (since Linux 4.11)</a></dt>
  <dd>This is the same as the version 1 <i>perf_event</i> controller.</dd>
  <dt id="pids~2"><a class="permalink" href="#pids~2"><i>pids</i> (since Linux
    4.5)</a></dt>
  <dd>This is the same as the version 1 <i>pids</i> controller.</dd>
  <dt id="rdma~2"><a class="permalink" href="#rdma~2"><i>rdma</i> (since Linux
    4.11)</a></dt>
  <dd>This is the same as the version 1 <i>rdma</i> controller.</dd>
</dl>
<p class="Pp">There is no direct equivalent of the <i>net_cls</i> and
    <i>net_prio</i> controllers from cgroups version 1. Instead, support has
    been added to <b>iptables</b>(8) to allow eBPF filters that hook on cgroup
    v2 pathnames to make decisions about network traffic on a per-cgroup
  basis.</p>
<p class="Pp">The v2 <i>devices</i> controller provides no interface files;
    instead, device control is gated by attaching an eBPF
    (<b>BPF_CGROUP_DEVICE</b>) program to a v2 cgroup.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_subtree_control"><a class="permalink" href="#Cgroups_v2_subtree_control">Cgroups
  v2 subtree control</a></h2>
<p class="Pp">Each cgroup in the v2 hierarchy contains the following two
  files:</p>
<dl class="Bl-tag">
  <dt id="cgroup.controllers"><a class="permalink" href="#cgroup.controllers"><i>cgroup.controllers</i></a></dt>
  <dd>This read-only file exposes a list of the controllers that are
      <i>available</i> in this cgroup. The contents of this file match the
      contents of the <i>cgroup.subtree_control</i> file in the parent
    cgroup.</dd>
  <dt id="cgroup.subtree_control"><a class="permalink" href="#cgroup.subtree_control"><i>cgroup.subtree_control</i></a></dt>
  <dd>This is a list of controllers that are <i>active</i> (<i>enabled</i>) in
      the cgroup. The set of controllers in this file is a subset of the set in
      the <i>cgroup.controllers</i> of this cgroup. The set of active
      controllers is modified by writing strings to this file containing
      space-delimited controller names, each preceded by '+' (to enable a
      controller) or '-' (to disable a controller), as in the following
    example:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>echo '+pids -memory' &gt; x/y/cgroup.subtree_control
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>An attempt to enable a controller that is not present in
      <i>cgroup.controllers</i> leads to an <b>ENOENT</b> error when writing to
      the <i>cgroup.subtree_control</i> file.</dd>
</dl>
<p class="Pp">Because the list of controllers in <i>cgroup.subtree_control</i>
    is a subset of those <i>cgroup.controllers</i>, a controller that has been
    disabled in one cgroup in the hierarchy can never be re-enabled in the
    subtree below that cgroup.</p>
<p class="Pp">A cgroup's <i>cgroup.subtree_control</i> file determines the set
    of controllers that are exercised in the <i>child</i> cgroups. When a
    controller (e.g., <i>pids</i>) is present in the
    <i>cgroup.subtree_control</i> file of a parent cgroup, then the
    corresponding controller-interface files (e.g., <i>pids.max</i>) are
    automatically created in the children of that cgroup and can be used to
    exert resource control in the child cgroups.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2__no_internal_processes__rule"><a class="permalink" href="#Cgroups_v2__no_internal_processes__rule">Cgroups
  v2 "no internal processes" rule</a></h2>
<p class="Pp">Cgroups v2 enforces a so-called "no internal processes"
    rule. Roughly speaking, this rule means that, with the exception of the root
    cgroup, processes may reside only in leaf nodes (cgroups that do not
    themselves contain child cgroups). This avoids the need to decide how to
    partition resources between processes which are members of cgroup A and
    processes in child cgroups of A.</p>
<p class="Pp">For instance, if cgroup <i>/cg1/cg2</i> exists, then a process may
    reside in <i>/cg1/cg2</i>, but not in <i>/cg1</i>. This is to avoid an
    ambiguity in cgroups v1 with respect to the delegation of resources between
    processes in <i>/cg1</i> and its child cgroups. The recommended approach in
    cgroups v2 is to create a subdirectory called <i>leaf</i> for any nonleaf
    cgroup which should contain processes, but no child cgroups. Thus, processes
    which previously would have gone into <i>/cg1</i> would now go into
    <i>/cg1/leaf</i>. This has the advantage of making explicit the relationship
    between processes in <i>/cg1/leaf</i> and <i>/cg1</i>'s other children.</p>
<p class="Pp">The "no internal processes" rule is in fact more subtle
    than stated above. More precisely, the rule is that a (nonroot) cgroup can't
    both (1) have member processes, and (2) distribute resources into child
    cgroups—that is, have a nonempty <i>cgroup.subtree_control</i> file.
    Thus, it <i>is</i> possible for a cgroup to have both member processes and
    child cgroups, but before controllers can be enabled for that cgroup, the
    member processes must be moved out of the cgroup (e.g., perhaps into the
    child cgroups).</p>
<p class="Pp">With the Linux 4.14 addition of "thread mode" (described
    below), the "no internal processes" rule has been relaxed in some
    cases.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_cgroup.events_file"><a class="permalink" href="#Cgroups_v2_cgroup.events_file">Cgroups
  v2 cgroup.events file</a></h2>
<p class="Pp">Each nonroot cgroup in the v2 hierarchy contains a read-only file,
    <i>cgroup.events</i>, whose contents are key-value pairs (delimited by
    newline characters, with the key and value separated by spaces) providing
    state information about the cgroup:</p>
<p class="Pp">
  <br>
</p>
<pre>$ <b>cat mygrp/cgroup.events</b>
populated 1
frozen 0
</pre>
<br>
<p class="Pp">The following keys may appear in this file:</p>
<dl class="Bl-tag">
  <dt id="populated"><a class="permalink" href="#populated"><i>populated</i></a></dt>
  <dd>The value of this key is either 1, if this cgroup or any of its
      descendants has member processes, or otherwise 0.</dd>
  <dt id="frozen"><a class="permalink" href="#frozen"><i>frozen</i> (since Linux
    5.2)</a></dt>
  <dd>The value of this key is 1 if this cgroup is currently frozen, or 0 if it
      is not.</dd>
</dl>
<p class="Pp">The <i>cgroup.events</i> file can be monitored, in order to
    receive notification when the value of one of its keys changes. Such
    monitoring can be done using <b>inotify</b>(7), which notifies changes as
    <b>IN_MODIFY</b> events, or <b>poll</b>(2), which notifies changes by
    returning the <b>POLLPRI</b> and <b>POLLERR</b> bits in the <i>revents</i>
    field.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroup_v2_release_notification"><a class="permalink" href="#Cgroup_v2_release_notification">Cgroup
  v2 release notification</a></h2>
<p class="Pp">Cgroups v2 provides a new mechanism for obtaining notification
    when a cgroup becomes empty. The cgroups v1 <i>release_agent</i> and
    <i>notify_on_release</i> files are removed, and replaced by the
    <i>populated</i> key in the <i>cgroup.events</i> file. This key either has
    the value 0, meaning that the cgroup (and its descendants) contain no
    (nonzombie) member processes, or 1, meaning that the cgroup (or one of its
    descendants) contains member processes.</p>
<p class="Pp">The cgroups v2 release-notification mechanism offers the following
    advantages over the cgroups v1 <i>release_agent</i> mechanism:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>It allows for cheaper notification, since a single process can monitor
      multiple <i>cgroup.events</i> files (using the techniques described
      earlier). By contrast, the cgroups v1 mechanism requires the expense of
      creating a process for each notification.</dd>
  <dt>•</dt>
  <dd>Notification for different cgroup subhierarchies can be delegated to
      different processes. By contrast, the cgroups v1 mechanism allows only one
      release agent for an entire hierarchy.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_cgroup.stat_file"><a class="permalink" href="#Cgroups_v2_cgroup.stat_file">Cgroups
  v2 cgroup.stat file</a></h2>
<p class="Pp">Each cgroup in the v2 hierarchy contains a read-only
    <i>cgroup.stat</i> file (first introduced in Linux 4.14) that consists of
    lines containing key-value pairs. The following keys currently appear in
    this file:</p>
<dl class="Bl-tag">
  <dt id="nr_descendants"><a class="permalink" href="#nr_descendants"><i>nr_descendants</i></a></dt>
  <dd>This is the total number of visible (i.e., living) descendant cgroups
      underneath this cgroup.</dd>
  <dt id="nr_dying_descendants"><a class="permalink" href="#nr_dying_descendants"><i>nr_dying_descendants</i></a></dt>
  <dd>This is the total number of dying descendant cgroups underneath this
      cgroup. A cgroup enters the dying state after being deleted. It remains in
      that state for an undefined period (which will depend on system load)
      while resources are freed before the cgroup is destroyed. Note that the
      presence of some cgroups in the dying state is normal, and is not
      indicative of any problem.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>A process can't be made a member of a dying cgroup, and a dying cgroup
      can't be brought back to life.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Limiting_the_number_of_descendant_cgroups"><a class="permalink" href="#Limiting_the_number_of_descendant_cgroups">Limiting
  the number of descendant cgroups</a></h2>
<p class="Pp">Each cgroup in the v2 hierarchy contains the following files,
    which can be used to view and set limits on the number of descendant cgroups
    under that cgroup:</p>
<dl class="Bl-tag">
  <dt id="cgroup.max.depth"><a class="permalink" href="#cgroup.max.depth"><i>cgroup.max.depth</i>
    (since Linux 4.14)</a></dt>
  <dd>This file defines a limit on the depth of nesting of descendant cgroups. A
      value of 0 in this file means that no descendant cgroups can be created.
      An attempt to create a descendant whose nesting level exceeds the limit
      fails (<i>mkdir</i>(2) fails with the error <b>EAGAIN</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Writing the string <i>"max"</i> to this file means that no limit
      is imposed. The default value in this file is <i>"max"
    .</i></dd>
</dl>
<dl class="Bl-tag">
  <dt id="cgroup.max.descendants"><a class="permalink" href="#cgroup.max.descendants"><i>cgroup.max.descendants</i>
    (since Linux 4.14)</a></dt>
  <dd>This file defines a limit on the number of live descendant cgroups that
      this cgroup may have. An attempt to create more descendants than allowed
      by the limit fails (<i>mkdir</i>(2) fails with the error
    <b>EAGAIN</b>).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Writing the string <i>"max"</i> to this file means that no limit
      is imposed. The default value in this file is <i>"max"</i>.</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CGROUPS_DELEGATION:_DELEGATING_A_HIERARCHY_TO_A_LESS_PRIVILEGED_USER"><a class="permalink" href="#CGROUPS_DELEGATION:_DELEGATING_A_HIERARCHY_TO_A_LESS_PRIVILEGED_USER">CGROUPS
  DELEGATION: DELEGATING A HIERARCHY TO A LESS PRIVILEGED USER</a></h1>
<p class="Pp">In the context of cgroups, delegation means passing management of
    some subtree of the cgroup hierarchy to a nonprivileged user. Cgroups v1
    provides support for delegation based on file permissions in the cgroup
    hierarchy but with less strict containment rules than v2 (as noted below).
    Cgroups v2 supports delegation with containment by explicit design. The
    focus of the discussion in this section is on delegation in cgroups v2, with
    some differences for cgroups v1 noted along the way.</p>
<p class="Pp">Some terminology is required in order to describe delegation. A
    <i>delegater</i> is a privileged user (i.e., root) who owns a parent cgroup.
    A <i>delegatee</i> is a nonprivileged user who will be granted the
    permissions needed to manage some subhierarchy under that parent cgroup,
    known as the <i>delegated subtree</i>.</p>
<p class="Pp">To perform delegation, the delegater makes certain directories and
    files writable by the delegatee, typically by changing the ownership of the
    objects to be the user ID of the delegatee. Assuming that we want to
    delegate the hierarchy rooted at (say) <i>/dlgt_grp</i> and that there are
    not yet any child cgroups under that cgroup, the ownership of the following
    is changed to the user ID of the delegatee:</p>
<dl class="Bl-tag">
  <dt><i>/dlgt_grp</i></dt>
  <dd>Changing the ownership of the root of the subtree means that any new
      cgroups created under the subtree (and the files they contain) will also
      be owned by the delegatee.</dd>
  <dt><i>/dlgt_grp/cgroup.procs</i></dt>
  <dd>Changing the ownership of this file means that the delegatee can move
      processes into the root of the delegated subtree.</dd>
  <dt><i>/dlgt_grp/cgroup.subtree_control</i> (cgroups v2 only)</dt>
  <dd>Changing the ownership of this file means that the delegatee can enable
      controllers (that are present in <i>/dlgt_grp/cgroup.controllers</i>) in
      order to further redistribute resources at lower levels in the subtree.
      (As an alternative to changing the ownership of this file, the delegater
      might instead add selected controllers to this file.)</dd>
  <dt><i>/dlgt_grp/cgroup.threads</i> (cgroups v2 only)</dt>
  <dd>Changing the ownership of this file is necessary if a threaded subtree is
      being delegated (see the description of "thread mode", below).
      This permits the delegatee to write thread IDs to the file. (The ownership
      of this file can also be changed when delegating a domain subtree, but
      currently this serves no purpose, since, as described below, it is not
      possible to move a thread between domain cgroups by writing its thread ID
      to the <i>cgroup.threads</i> file.)</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>In cgroups v1, the corresponding file that should instead be delegated is
      the <i>tasks</i> file.</dd>
</dl>
<p class="Pp">The delegater should <i>not</i> change the ownership of any of the
    controller interfaces files (e.g., <i>pids.max</i>, <i>memory.high</i>) in
    <i>dlgt_grp</i>. Those files are used from the next level above the
    delegated subtree in order to distribute resources into the subtree, and the
    delegatee should not have permission to change the resources that are
    distributed into the delegated subtree.</p>
<p class="Pp">See also the discussion of the <i>/sys/kernel/cgroup/delegate</i>
    file in NOTES for information about further delegatable files in cgroups
  v2.</p>
<p class="Pp">After the aforementioned steps have been performed, the delegatee
    can create child cgroups within the delegated subtree (the cgroup
    subdirectories and the files they contain will be owned by the delegatee)
    and move processes between cgroups in the subtree. If some controllers are
    present in <i>dlgt_grp/cgroup.subtree_control</i>, or the ownership of that
    file was passed to the delegatee, the delegatee can also control the further
    redistribution of the corresponding resources into the delegated
  subtree.</p>
<section class="Ss">
<h2 class="Ss" id="Cgroups_v2_delegation:_nsdelegate_and_cgroup_namespaces"><a class="permalink" href="#Cgroups_v2_delegation:_nsdelegate_and_cgroup_namespaces">Cgroups
  v2 delegation: nsdelegate and cgroup namespaces</a></h2>
<p class="Pp">Starting with Linux 4.13, there is a second way to perform cgroup
    delegation in the cgroups v2 hierarchy. This is done by mounting or
    remounting the cgroup v2 filesystem with the <i>nsdelegate</i> mount option.
    For example, if the cgroup v2 filesystem has already been mounted, we can
    remount it with the <i>nsdelegate</i> option as follows:</p>
<p class="Pp">
  <br>
</p>
<pre>mount -t cgroup2 -o remount,nsdelegate \
<br>
                 none /sys/fs/cgroup/unified
</pre>
<br>
<p class="Pp">The effect of this mount option is to cause cgroup namespaces to
    automatically become delegation boundaries. More specifically, the following
    restrictions apply for processes inside the cgroup namespace:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>Writes to controller interface files in the root directory of the
      namespace will fail with the error <b>EPERM</b>. Processes inside the
      cgroup namespace can still write to delegatable files in the root
      directory of the cgroup namespace such as <i>cgroup.procs</i> and
      <i>cgroup.subtree_control</i>, and can create subhierarchy underneath the
      root directory.</dd>
  <dt>•</dt>
  <dd>Attempts to migrate processes across the namespace boundary are denied
      (with the error <b>ENOENT</b>). Processes inside the cgroup namespace can
      still (subject to the containment rules described below) move processes
      between cgroups <i>within</i> the subhierarchy under the namespace
    root.</dd>
</dl>
<p class="Pp">The ability to define cgroup namespaces as delegation boundaries
    makes cgroup namespaces more useful. To understand why, suppose that we
    already have one cgroup hierarchy that has been delegated to a nonprivileged
    user, <i>cecilia</i>, using the older delegation technique described above.
    Suppose further that <i>cecilia</i> wanted to further delegate a
    subhierarchy under the existing delegated hierarchy. (For example, the
    delegated hierarchy might be associated with an unprivileged container run
    by <i>cecilia</i>.) Even if a cgroup namespace was employed, because both
    hierarchies are owned by the unprivileged user <i>cecilia</i>, the following
    illegitimate actions could be performed:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>A process in the inferior hierarchy could change the resource controller
      settings in the root directory of that hierarchy. (These resource
      controller settings are intended to allow control to be exercised from the
      <i>parent</i> cgroup; a process inside the child cgroup should not be
      allowed to modify them.)</dd>
  <dt>•</dt>
  <dd>A process inside the inferior hierarchy could move processes into and out
      of the inferior hierarchy if the cgroups in the superior hierarchy were
      somehow visible.</dd>
</dl>
<p class="Pp">Employing the <i>nsdelegate</i> mount option prevents both of
    these possibilities.</p>
<p class="Pp">The <i>nsdelegate</i> mount option only has an effect when
    performed in the initial mount namespace; in other mount namespaces, the
    option is silently ignored.</p>
<p class="Pp"><i>Note</i>: On some systems, <b>systemd</b>(1) automatically
    mounts the cgroup v2 filesystem. In order to experiment with the
    <i>nsdelegate</i> operation, it may be useful to boot the kernel with the
    following command-line options:</p>
<p class="Pp">
  <br>
</p>
<pre>cgroup_no_v1=all systemd.legacy_systemd_cgroup_controller
</pre>
<br>
<p class="Pp">These options cause the kernel to boot with the cgroups v1
    controllers disabled (meaning that the controllers are available in the v2
    hierarchy), and tells <b>systemd</b>(1) not to mount and use the cgroup v2
    hierarchy, so that the v2 hierarchy can be manually mounted with the desired
    options after boot-up.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Cgroup_delegation_containment_rules"><a class="permalink" href="#Cgroup_delegation_containment_rules">Cgroup
  delegation containment rules</a></h2>
<p class="Pp">Some delegation <i>containment rules</i> ensure that the delegatee
    can move processes between cgroups within the delegated subtree, but can't
    move processes from outside the delegated subtree into the subtree or vice
    versa. A nonprivileged process (i.e., the delegatee) can write the PID of a
    "target" process into a <i>cgroup.procs</i> file only if all of
    the following are true:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The writer has write permission on the <i>cgroup.procs</i> file in the
      destination cgroup.</dd>
  <dt>•</dt>
  <dd>The writer has write permission on the <i>cgroup.procs</i> file in the
      nearest common ancestor of the source and destination cgroups. Note that
      in some cases, the nearest common ancestor may be the source or
      destination cgroup itself. This requirement is not enforced for cgroups v1
      hierarchies, with the consequence that containment in v1 is less strict
      than in v2. (For example, in cgroups v1 the user that owns two distinct
      delegated subhierarchies can move a process between the hierarchies.)</dd>
  <dt>•</dt>
  <dd>If the cgroup v2 filesystem was mounted with the <i>nsdelegate</i> option,
      the writer must be able to see the source and destination cgroups from its
      cgroup namespace.</dd>
  <dt>•</dt>
  <dd>In cgroups v1: the effective UID of the writer (i.e., the delegatee)
      matches the real user ID or the saved set-user-ID of the target process.
      Before Linux 4.11, this requirement also applied in cgroups v2 (This was a
      historical requirement inherited from cgroups v1 that was later deemed
      unnecessary, since the other rules suffice for containment in cgroups
    v2.)</dd>
</dl>
<p class="Pp"><i>Note</i>: one consequence of these delegation containment rules
    is that the unprivileged delegatee can't place the first process into the
    delegated subtree; instead, the delegater must place the first process (a
    process owned by the delegatee) into the delegated subtree.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="CGROUPS_VERSION_2_THREAD_MODE"><a class="permalink" href="#CGROUPS_VERSION_2_THREAD_MODE">CGROUPS
  VERSION 2 THREAD MODE</a></h1>
<p class="Pp">Among the restrictions imposed by cgroups v2 that were not present
    in cgroups v1 are the following:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>No thread-granularity control</i>: all of the threads of a process must
      be in the same cgroup.</dd>
  <dt>•</dt>
  <dd><i>No internal processes</i>: a cgroup can't both have member processes
      and exercise controllers on child cgroups.</dd>
</dl>
<p class="Pp">Both of these restrictions were added because the lack of these
    restrictions had caused problems in cgroups v1. In particular, the cgroups
    v1 ability to allow thread-level granularity for cgroup membership made no
    sense for some controllers. (A notable example was the <i>memory</i>
    controller: since threads share an address space, it made no sense to split
    threads across different <i>memory</i> cgroups.)</p>
<p class="Pp">Notwithstanding the initial design decision in cgroups v2, there
    were use cases for certain controllers, notably the <i>cpu</i> controller,
    for which thread-level granularity of control was meaningful and useful. To
    accommodate such use cases, Linux 4.14 added <i>thread mode</i> for cgroups
    v2.</p>
<p class="Pp">Thread mode allows the following:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The creation of <i>threaded subtrees</i> in which the threads of a process
      may be spread across cgroups inside the tree. (A threaded subtree may
      contain multiple multithreaded processes.)</dd>
  <dt>•</dt>
  <dd>The concept of <i>threaded controllers</i>, which can distribute resources
      across the cgroups in a threaded subtree.</dd>
  <dt>•</dt>
  <dd>A relaxation of the "no internal processes rule", so that,
      within a threaded subtree, a cgroup can both contain member threads and
      exercise resource control over child cgroups.</dd>
</dl>
<p class="Pp">With the addition of thread mode, each nonroot cgroup now contains
    a new file, <i>cgroup.type</i>, that exposes, and in some circumstances can
    be used to change, the "type" of a cgroup. This file contains one
    of the following type values:</p>
<dl class="Bl-tag">
  <dt id="domain"><a class="permalink" href="#domain"><i>domain</i></a></dt>
  <dd>This is a normal v2 cgroup that provides process-granularity control. If a
      process is a member of this cgroup, then all threads of the process are
      (by definition) in the same cgroup. This is the default cgroup type, and
      provides the same behavior that was provided for cgroups in the initial
      cgroups v2 implementation.</dd>
  <dt id="threaded"><a class="permalink" href="#threaded"><i>threaded</i></a></dt>
  <dd>This cgroup is a member of a threaded subtree. Threads can be added to
      this cgroup, and controllers can be enabled for the cgroup.</dd>
  <dt><i>domain threaded</i></dt>
  <dd>This is a domain cgroup that serves as the root of a threaded subtree.
      This cgroup type is also known as "threaded root".</dd>
  <dt><i>domain invalid</i></dt>
  <dd>This is a cgroup inside a threaded subtree that is in an
      "invalid" state. Processes can't be added to the cgroup, and
      controllers can't be enabled for the cgroup. The only thing that can be
      done with this cgroup (other than deleting it) is to convert it to a
      <i>threaded</i> cgroup by writing the string <i>"threaded"</i>
      to the <i>cgroup.type</i> file.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The rationale for the existence of this "interim" type during
      the creation of a threaded subtree (rather than the kernel simply
      immediately converting all cgroups under the threaded root to the type
      <i>threaded</i>) is to allow for possible future extensions to the thread
      mode model</dd>
</dl>
<section class="Ss">
<h2 class="Ss" id="Threaded_versus_domain_controllers"><a class="permalink" href="#Threaded_versus_domain_controllers">Threaded
  versus domain controllers</a></h2>
<p class="Pp">With the addition of threads mode, cgroups v2 now distinguishes
    two types of resource controllers:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>Threaded</i> controllers: these controllers support thread-granularity
      for resource control and can be enabled inside threaded subtrees, with the
      result that the corresponding controller-interface files appear inside the
      cgroups in the threaded subtree. As at Linux 4.19, the following
      controllers are threaded: <i>cpu</i>, <i>perf_event</i>, and
    <i>pids</i>.</dd>
  <dt>•</dt>
  <dd><i>Domain</i> controllers: these controllers support only process
      granularity for resource control. From the perspective of a domain
      controller, all threads of a process are always in the same cgroup. Domain
      controllers can't be enabled inside a threaded subtree.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Creating_a_threaded_subtree"><a class="permalink" href="#Creating_a_threaded_subtree">Creating
  a threaded subtree</a></h2>
<p class="Pp">There are two pathways that lead to the creation of a threaded
    subtree. The first pathway proceeds as follows:</p>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>We write the string <i>"threaded"</i> to the <i>cgroup.type</i>
      file of a cgroup <i>y/z</i> that currently has the type <i>domain</i>.
      This has the following effects:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The type of the cgroup <i>y/z</i> becomes <i>threaded</i>.</dd>
  <dt>•</dt>
  <dd>The type of the parent cgroup, <i>y</i>, becomes <i>domain threaded</i>.
      The parent cgroup is the root of a threaded subtree (also known as the
      "threaded root").</dd>
  <dt>•</dt>
  <dd>All other cgroups under <i>y</i> that were not already of type
      <i>threaded</i> (because they were inside already existing threaded
      subtrees under the new threaded root) are converted to type <i>domain
      invalid</i>. Any subsequently created cgroups under <i>y</i> will also
      have the type <i>domain invalid</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(2)</dt>
  <dd>We write the string <i>"threaded"</i> to each of the <i>domain
      invalid</i> cgroups under <i>y</i>, in order to convert them to the type
      <i>threaded</i>. As a consequence of this step, all threads under the
      threaded root now have the type <i>threaded</i> and the threaded subtree
      is now fully usable. The requirement to write <i>"threaded"</i>
      to each of these cgroups is somewhat cumbersome, but allows for possible
      future extensions to the thread-mode model.</dd>
</dl>
<p class="Pp">The second way of creating a threaded subtree is as follows:</p>
<dl class="Bl-tag">
  <dt>(1)</dt>
  <dd>In an existing cgroup, <i>z</i>, that currently has the type
      <i>domain</i>, we (1.1) enable one or more threaded controllers and (1.2)
      make a process a member of <i>z</i>. (These two steps can be done in
      either order.) This has the following consequences:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The type of <i>z</i> becomes <i>domain threaded</i>.</dd>
  <dt>•</dt>
  <dd>All of the descendant cgroups of <i>x</i> that were not already of type
      <i>threaded</i> are converted to type <i>domain invalid</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>(2)</dt>
  <dd>As before, we make the threaded subtree usable by writing the string
      <i>"threaded"</i> to each of the <i>domain invalid</i> cgroups
      under <i>y</i>, in order to convert them to the type <i>threaded</i>.</dd>
</dl>
<p class="Pp">One of the consequences of the above pathways to creating a
    threaded subtree is that the threaded root cgroup can be a parent only to
    <i>threaded</i> (and <i>domain invalid</i>) cgroups. The threaded root
    cgroup can't be a parent of a <i>domain</i> cgroups, and a <i>threaded</i>
    cgroup can't have a sibling that is a <i>domain</i> cgroup.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Using_a_threaded_subtree"><a class="permalink" href="#Using_a_threaded_subtree">Using
  a threaded subtree</a></h2>
<p class="Pp">Within a threaded subtree, threaded controllers can be enabled in
    each subgroup whose type has been changed to <i>threaded</i>; upon doing so,
    the corresponding controller interface files appear in the children of that
    cgroup.</p>
<p class="Pp">A process can be moved into a threaded subtree by writing its PID
    to the <i>cgroup.procs</i> file in one of the cgroups inside the tree. This
    has the effect of making all of the threads in the process members of the
    corresponding cgroup and makes the process a member of the threaded subtree.
    The threads of the process can then be spread across the threaded subtree by
    writing their thread IDs (see <b>gettid</b>(2)) to the <i>cgroup.threads</i>
    files in different cgroups inside the subtree. The threads of a process must
    all reside in the same threaded subtree.</p>
<p class="Pp">As with writing to <i>cgroup.procs</i>, some containment rules
    apply when writing to the <i>cgroup.threads</i> file:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The writer must have write permission on the cgroup.threads file in the
      destination cgroup.</dd>
  <dt>•</dt>
  <dd>The writer must have write permission on the <i>cgroup.procs</i> file in
      the common ancestor of the source and destination cgroups. (In some cases,
      the common ancestor may be the source or destination cgroup itself.)</dd>
  <dt>•</dt>
  <dd>The source and destination cgroups must be in the same threaded subtree.
      (Outside a threaded subtree, an attempt to move a thread by writing its
      thread ID to the <i>cgroup.threads</i> file in a different <i>domain</i>
      cgroup fails with the error <b>EOPNOTSUPP</b>.)</dd>
</dl>
<p class="Pp">The <i>cgroup.threads</i> file is present in each cgroup
    (including <i>domain</i> cgroups) and can be read in order to discover the
    set of threads that is present in the cgroup. The set of thread IDs obtained
    when reading this file is not guaranteed to be ordered or free of
    duplicates.</p>
<p class="Pp">The <i>cgroup.procs</i> file in the threaded root shows the PIDs
    of all processes that are members of the threaded subtree. The
    <i>cgroup.procs</i> files in the other cgroups in the subtree are not
    readable.</p>
<p class="Pp">Domain controllers can't be enabled in a threaded subtree; no
    controller-interface files appear inside the cgroups underneath the threaded
    root. From the point of view of a domain controller, threaded subtrees are
    invisible: a multithreaded process inside a threaded subtree appears to a
    domain controller as a process that resides in the threaded root cgroup.</p>
<p class="Pp">Within a threaded subtree, the "no internal processes"
    rule does not apply: a cgroup can both contain member processes (or thread)
    and exercise controllers on child cgroups.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Rules_for_writing_to_cgroup.type_and_creating_threaded_subtrees"><a class="permalink" href="#Rules_for_writing_to_cgroup.type_and_creating_threaded_subtrees">Rules
  for writing to cgroup.type and creating threaded subtrees</a></h2>
<p class="Pp">A number of rules apply when writing to the <i>cgroup.type</i>
    file:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>Only the string <i>"threaded"</i> may be written. In other
      words, the only explicit transition that is possible is to convert a
      <i>domain</i> cgroup to type <i>threaded</i>.</dd>
  <dt>•</dt>
  <dd>The effect of writing <i>"threaded"</i> depends on the current
      value in <i>cgroup.type</i>, as follows:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>domain</i> or <i>domain threaded</i>: start the creation of a threaded
      subtree (whose root is the parent of this cgroup) via the first of the
      pathways described above;</dd>
  <dt>•</dt>
  <dd><i>domain&nbsp;invalid</i>: convert this cgroup (which is inside a
      threaded subtree) to a usable (i.e., <i>threaded</i>) state;</dd>
  <dt>•</dt>
  <dd><i>threaded</i>: no effect (a "no-op").</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>We can't write to a <i>cgroup.type</i> file if the parent's type is
      <i>domain invalid</i>. In other words, the cgroups of a threaded subtree
      must be converted to the <i>threaded</i> state in a top-down manner.</dd>
</dl>
<p class="Pp">There are also some constraints that must be satisfied in order to
    create a threaded subtree rooted at the cgroup <i>x</i>:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>There can be no member processes in the descendant cgroups of <i>x</i>.
      (The cgroup <i>x</i> can itself have member processes.)</dd>
  <dt>•</dt>
  <dd>No domain controllers may be enabled in <i>x</i>'s
      <i>cgroup.subtree_control</i> file.</dd>
</dl>
<p class="Pp">If any of the above constraints is violated, then an attempt to
    write <i>"threaded"</i> to a <i>cgroup.type</i> file fails with
    the error <b>ENOTSUP</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The__domain_threaded__cgroup_type"><a class="permalink" href="#The__domain_threaded__cgroup_type">The
  "domain threaded" cgroup type</a></h2>
<p class="Pp">According to the pathways described above, the type of a cgroup
    can change to <i>domain threaded</i> in either of the following cases:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The string <i>"threaded"</i> is written to a child cgroup.</dd>
  <dt>•</dt>
  <dd>A threaded controller is enabled inside the cgroup and a process is made a
      member of the cgroup.</dd>
</dl>
<p class="Pp">A <i>domain threaded</i> cgroup, <i>x</i>, can revert to the type
    <i>domain</i> if the above conditions no longer hold true—that is, if
    all <i>threaded</i> child cgroups of <i>x</i> are removed and either
    <i>x</i> no longer has threaded controllers enabled or no longer has member
    processes.</p>
<p class="Pp">When a <i>domain threaded</i> cgroup <i>x</i> reverts to the type
    <i>domain</i>:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>All <i>domain invalid</i> descendants of <i>x</i> that are not in
      lower-level threaded subtrees revert to the type <i>domain</i>.</dd>
  <dt>•</dt>
  <dd>The root cgroups in any lower-level threaded subtrees revert to the type
      <i>domain threaded</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Exceptions_for_the_root_cgroup"><a class="permalink" href="#Exceptions_for_the_root_cgroup">Exceptions
  for the root cgroup</a></h2>
<p class="Pp">The root cgroup of the v2 hierarchy is treated exceptionally: it
    can be the parent of both <i>domain</i> and <i>threaded</i> cgroups. If the
    string <i>"threaded"</i> is written to the <i>cgroup.type</i> file
    of one of the children of the root cgroup, then</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>The type of that cgroup becomes <i>threaded</i>.</dd>
  <dt>•</dt>
  <dd>The type of any descendants of that cgroup that are not part of
      lower-level threaded subtrees changes to <i>domain invalid</i>.</dd>
</dl>
<p class="Pp">Note that in this case, there is no cgroup whose type becomes
    <i>domain threaded</i>. (Notionally, the root cgroup can be considered as
    the threaded root for the cgroup whose type was changed to
  <i>threaded</i>.)</p>
<p class="Pp">The aim of this exceptional treatment for the root cgroup is to
    allow a threaded cgroup that employs the <i>cpu</i> controller to be placed
    as high as possible in the hierarchy, so as to minimize the (small) cost of
    traversing the cgroup hierarchy.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_cgroups_v2__cpu__controller_and_realtime_threads"><a class="permalink" href="#The_cgroups_v2__cpu__controller_and_realtime_threads">The
  cgroups v2 "cpu" controller and realtime threads</a></h2>
<p class="Pp">As at Linux 4.19, the cgroups v2 <i>cpu</i> controller does not
    support control of realtime threads (specifically threads scheduled under
    any of the policies <b>SCHED_FIFO</b>, <b>SCHED_RR</b>, described
    <b>SCHED_DEADLINE</b>; see <b>sched</b>(7)). Therefore, the <i>cpu</i>
    controller can be enabled in the root cgroup only if all realtime threads
    are in the root cgroup. (If there are realtime threads in nonroot cgroups,
    then a <b>write</b>(2) of the string <i>"+cpu"</i> to the
    <i>cgroup.subtree_control</i> file fails with the error <b>EINVAL</b>.)</p>
<p class="Pp">On some systems, <b>systemd</b>(1) places certain realtime threads
    in nonroot cgroups in the v2 hierarchy. On such systems, these threads must
    first be moved to the root cgroup before the <i>cpu</i> controller can be
    enabled.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">The following errors can occur for <b>mount</b>(2):</p>
<dl class="Bl-tag">
  <dt id="EBUSY"><a class="permalink" href="#EBUSY"><b>EBUSY</b></a></dt>
  <dd>An attempt to mount a cgroup version 1 filesystem specified neither the
      <i>name=</i> option (to mount a named hierarchy) nor a controller name (or
      <i>all</i>).</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">A child process created via <b>fork</b>(2) inherits its parent's
    cgroup memberships. A process's cgroup memberships are preserved across
    <b>execve</b>(2).</p>
<p class="Pp">The <b>clone3</b>(2) <b>CLONE_INTO_CGROUP</b> flag can be used to
    create a child process that begins its life in a different version 2 cgroup
    from the parent process.</p>
<section class="Ss">
<h2 class="Ss" id="/proc_files"><a class="permalink" href="#/proc_files">/proc
  files</a></h2>
<dl class="Bl-tag">
  <dt><i>/proc/cgroups</i> (since Linux 2.6.24)</dt>
  <dd>This file contains information about the controllers that are compiled
      into the kernel. An example of the contents of this file (reformatted for
      readability) is the following:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>#subsys_name    hierarchy      num_cgroups    enabled
cpuset          4              1              1
cpu             8              1              1
cpuacct         8              1              1
blkio           6              1              1
memory          3              1              1
devices         10             84             1
freezer         7              1              1
net_cls         9              1              1
perf_event      5              1              1
net_prio        9              1              1
hugetlb         0              1              0
pids            2              1              1
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The fields in this file are, from left to right:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>The name of the controller.</dd>
  <dt>[2]</dt>
  <dd>The unique ID of the cgroup hierarchy on which this controller is mounted.
      If multiple cgroups v1 controllers are bound to the same hierarchy, then
      each will show the same hierarchy ID in this field. The value in this
      field will be 0 if:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>the controller is not mounted on a cgroups v1 hierarchy;</dd>
  <dt>•</dt>
  <dd>the controller is bound to the cgroups v2 single unified hierarchy;
    or</dd>
  <dt>•</dt>
  <dd>the controller is disabled (see below).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt>[3]</dt>
  <dd>The number of control groups in this hierarchy using this controller.</dd>
  <dt>[4]</dt>
  <dd>This field contains the value 1 if this controller is enabled, or 0 if it
      has been disabled (via the <i>cgroup_disable</i> kernel command-line boot
      parameter).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt><i>/proc/[pid]/cgroup</i> (since Linux 2.6.24)</dt>
  <dd>This file describes control groups to which the process with the
      corresponding PID belongs. The displayed information differs for cgroups
      version 1 and version 2 hierarchies.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>For each cgroup hierarchy of which the process is a member, there is one
      entry containing three colon-separated fields:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>hierarchy-ID:controller-list:cgroup-path
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>For example:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>5:cpuacct,cpu,cpuset:/daemons
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The colon-separated fields are, from left to right:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>[1]</dt>
  <dd>For cgroups version 1 hierarchies, this field contains a unique hierarchy
      ID number that can be matched to a hierarchy ID in <i>/proc/cgroups</i>.
      For the cgroups version 2 hierarchy, this field contains the value 0.</dd>
  <dt>[2]</dt>
  <dd>For cgroups version 1 hierarchies, this field contains a comma-separated
      list of the controllers bound to the hierarchy. For the cgroups version 2
      hierarchy, this field is empty.</dd>
  <dt>[3]</dt>
  <dd>This field contains the pathname of the control group in the hierarchy to
      which the process belongs. This pathname is relative to the mount point of
      the hierarchy.</dd>
</dl>
</div>
</section>
<section class="Ss">
<h2 class="Ss" id="/sys/kernel/cgroup_files"><a class="permalink" href="#/sys/kernel/cgroup_files">/sys/kernel/cgroup
  files</a></h2>
<dl class="Bl-tag">
  <dt><i>/sys/kernel/cgroup/delegate</i> (since Linux 4.15)</dt>
  <dd>This file exports a list of the cgroups v2 files (one per line) that are
      delegatable (i.e., whose ownership should be changed to the user ID of the
      delegatee). In the future, the set of delegatable files may change or
      grow, and this file provides a way for the kernel to inform user-space
      applications of which files must be delegated. As at Linux 4.15, one sees
      the following when inspecting this file:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>$ <b>cat /sys/kernel/cgroup/delegate</b>
cgroup.procs
cgroup.subtree_control
cgroup.threads
    </pre>
    <br>
  </dd>
</dl>
<dl class="Bl-tag">
  <dt><i>/sys/kernel/cgroup/features</i> (since Linux 4.15)</dt>
  <dd>Over time, the set of cgroups v2 features that are provided by the kernel
      may change or grow, or some features may not be enabled by default. This
      file provides a way for user-space applications to discover what features
      the running kernel supports and has enabled. Features are listed one per
      line:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>$ <b>cat /sys/kernel/cgroup/features</b>
nsdelegate
memory_localevents
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>The entries that can appear in this file are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="memory_localevents~2"><a class="permalink" href="#memory_localevents~2"><i>memory_localevents</i>
    (since Linux 5.2)</a></dt>
  <dd>The kernel supports the <i>memory_localevents</i> mount option.</dd>
  <dt id="nsdelegate~2"><a class="permalink" href="#nsdelegate~2"><i>nsdelegate</i>
    (since Linux 4.15)</a></dt>
  <dd>The kernel supports the <i>nsdelegate</i> mount option.</dd>
  <dt id="memory_recursiveprot"><a class="permalink" href="#memory_recursiveprot"><i>memory_recursiveprot</i>
    (since Linux 5.7)</a></dt>
  <dd>The kernel supports the <i>memory_recursiveprot</i> mount option.</dd>
</dl>
</div>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>prlimit</b>(1), <b>systemd</b>(1), <b>systemd-cgls</b>(1),
    <b>systemd-cgtop</b>(1), <b>clone</b>(2), <b>ioprio_set</b>(2),
    <b>perf_event_open</b>(2), <b>setrlimit</b>(2), <b>cgroup_namespaces</b>(7),
    <b>cpuset</b>(7), <b>namespaces</b>(7), <b>sched</b>(7),
    <b>user_namespaces</b>(7)</p>
<p class="Pp">The kernel source file
    <i>Documentation/admin-guide/cgroup-v2.rst</i>.</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>