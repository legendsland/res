<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Copyright (C) 2013, Heinrich Schuchardt <xypron.glpk@gmx.de>
   and Copyright (C) 2014, Michael Kerrisk <mtk.manpages@gmail.com>
  
   SPDX-License-Identifier: Linux-man-pages-copyleft
 --><head>
<meta name="dc.identifier" content="res/a3aaaf14775f173feeca28eaa5a7bc8ac2888443">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>fanotify(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">fanotify(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">fanotify(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">fanotify - monitoring filesystem events</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The fanotify API provides notification and interception of
    filesystem events. Use cases include virus scanning and hierarchical storage
    management. In the original fanotify API, only a limited set of events was
    supported. In particular, there was no support for create, delete, and move
    events. The support for those events was added in Linux 5.1. (See
    <b>inotify</b>(7) for details of an API that did notify those events pre
    Linux 5.1.)</p>
<p class="Pp">Additional capabilities compared to the <b>inotify</b>(7) API
    include the ability to monitor all of the objects in a mounted filesystem,
    the ability to make access permission decisions, and the possibility to read
    or modify files before access by other applications.</p>
<p class="Pp">The following system calls are used with this API:
    <b>fanotify_init</b>(2), <b>fanotify_mark</b>(2), <b>read</b>(2),
    <b>write</b>(2), and <b>close</b>(2).</p>
<section class="Ss">
<h2 class="Ss" id="fanotify_init(),_fanotify_mark(),_and_notification_groups"><a class="permalink" href="#fanotify_init(),_fanotify_mark(),_and_notification_groups">fanotify_init(),
  fanotify_mark(), and notification groups</a></h2>
<p class="Pp">The <b>fanotify_init</b>(2) system call creates and initializes an
    fanotify notification group and returns a file descriptor referring to
  it.</p>
<p class="Pp">An fanotify notification group is a kernel-internal object that
    holds a list of files, directories, filesystems, and mounts for which events
    shall be created.</p>
<p class="Pp">For each entry in an fanotify notification group, two bit masks
    exist: the <i>mark</i> mask and the <i>ignore</i> mask. The mark mask
    defines file activities for which an event shall be created. The ignore mask
    defines activities for which no event shall be generated. Having these two
    types of masks permits a filesystem, mount, or directory to be marked for
    receiving events, while at the same time ignoring events for specific
    objects under a mount or directory.</p>
<p class="Pp">The <b>fanotify_mark</b>(2) system call adds a file, directory,
    filesystem, or mount to a notification group and specifies which events
    shall be reported (or ignored), or removes or modifies such an entry.</p>
<p class="Pp">A possible usage of the ignore mask is for a file cache. Events of
    interest for a file cache are modification of a file and closing of the
    same. Hence, the cached directory or mount is to be marked to receive these
    events. After receiving the first event informing that a file has been
    modified, the corresponding cache entry will be invalidated. No further
    modification events for this file are of interest until the file is closed.
    Hence, the modify event can be added to the ignore mask. Upon receiving the
    close event, the modify event can be removed from the ignore mask and the
    file cache entry can be updated.</p>
<p class="Pp">The entries in the fanotify notification groups refer to files and
    directories via their inode number and to mounts via their mount ID. If
    files or directories are renamed or moved within the same mount, the
    respective entries survive. If files or directories are deleted or moved to
    another mount or if filesystems or mounts are unmounted, the corresponding
    entries are deleted.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="The_event_queue"><a class="permalink" href="#The_event_queue">The
  event queue</a></h2>
<p class="Pp">As events occur on the filesystem objects monitored by a
    notification group, the fanotify system generates events that are collected
    in a queue. These events can then be read (using <b>read</b>(2) or similar)
    from the fanotify file descriptor returned by <b>fanotify_init</b>(2).</p>
<p class="Pp">Two types of events are generated: <i>notification</i> events and
    <i>permission</i> events. Notification events are merely informative and
    require no action to be taken by the receiving application with one
    exception: if a valid file descriptor is provided within a generic event,
    the file descriptor must be closed. Permission events are requests to the
    receiving application to decide whether permission for a file access shall
    be granted. For these events, the recipient must write a response which
    decides whether access is granted or not.</p>
<p class="Pp">An event is removed from the event queue of the fanotify group
    when it has been read. Permission events that have been read are kept in an
    internal list of the fanotify group until either a permission decision has
    been taken by writing to the fanotify file descriptor or the fanotify file
    descriptor is closed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Reading_fanotify_events"><a class="permalink" href="#Reading_fanotify_events">Reading
  fanotify events</a></h2>
<p class="Pp">Calling <b>read</b>(2) for the file descriptor returned by
    <b>fanotify_init</b>(2) blocks (if the flag <b>FAN_NONBLOCK</b> is not
    specified in the call to <b>fanotify_init</b>(2)) until either a file event
    occurs or the call is interrupted by a signal (see <b>signal</b>(7)).</p>
<p class="Pp">After a successful <b>read</b>(2), the read buffer contains one or
    more of the following structures:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_event_metadata {
<br>
    __u32 event_len;
<br>
    __u8 vers;
<br>
    __u8 reserved;
<br>
    __u16 metadata_len;
<br>
    __aligned_u64 mask;
<br>
    __s32 fd;
<br>
    __s32 pid;
};
</pre>
<br>
<p class="Pp">Information records are supplemental pieces of information that
    may be provided alongside the generic <i>fanotify_event_metadata</i>
    structure. The <i>flags</i> passed to <b>fanotify_init</b>(2) have influence
    over the type of information records that may be returned for an event. For
    example, if a notification group is initialized with <b>FAN_REPORT_FID</b>
    or <b>FAN_REPORT_DIR_FID</b>, then event listeners should also expect to
    receive a <i>fanotify_event_info_fid</i> structure alongside the
    <i>fanotify_event_metadata</i> structure, whereby file handles are used to
    identify filesystem objects rather than file descriptors. Information
    records may also be stacked, meaning that using the various
    <b>FAN_REPORT_*</b> flags in conjunction with one another is supported. In
    such cases, multiple information records can be returned for an event
    alongside the generic <i>fanotify_event_metadata</i> structure. For example,
    if a notification group is initialized with <b>FAN_REPORT_TARGET_FID</b> and
    <b>FAN_REPORT_PIDFD</b>, then an event listener should expect to receive up
    to two <i>fanotify_event_info_fid</i> information records and one
    <i>fanotify_event_info_pidfd</i> information record alongside the generic
    <i>fanotify_event_metadata</i> structure. Importantly, fanotify provides no
    guarantee around the ordering of information records when a notification
    group is initialized with a stacked based configuration. Each information
    record has a nested structure of type <i>fanotify_event_info_header</i>. It
    is imperative for event listeners to inspect the <i>info_type</i> field of
    this structure in order to determine the type of information record that had
    been received for a given event.</p>
<p class="Pp">In cases where an fanotify group identifies filesystem objects by
    file handles, event listeners should also expect to receive one or more of
    the below information record objects alongside the generic
    <i>fanotify_event_metadata</i> structure within the read buffer:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_event_info_fid {
<br>
    struct fanotify_event_info_header hdr;
<br>
    __kernel_fsid_t fsid;
<br>
    unsigned char file_handle[0];
};
</pre>
<br>
<p class="Pp">In cases where an fanotify group is initialized with
    <b>FAN_REPORT_PIDFD</b>, event listeners should expect to receive the below
    information record object alongside the generic
    <i>fanotify_event_metadata</i> structure within the read buffer:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_event_info_pidfd {
<br>
        struct fanotify_event_info_header hdr;
<br>
        __s32 pidfd;
};
</pre>
<br>
<p class="Pp">In case of a <b>FAN_FS_ERROR</b> event, an additional information
    record describing the error that occurred is returned alongside the generic
    <i>fanotify_event_metadata</i> structure within the read buffer. This
    structure is defined as follows:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_event_info_error {
<br>
    struct fanotify_event_info_header hdr;
<br>
    __s32 error;
<br>
    __u32 error_count;
};
</pre>
<br>
<p class="Pp">All information records contain a nested structure of type
    <i>fanotify_event_info_header</i>. This structure holds meta-information
    about the information record that may have been returned alongside the
    generic <i>fanotify_event_metadata</i> structure. This structure is defined
    as follows:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_event_info_header {
	__u8 info_type;
	__u8 pad;
	__u16 len;
};
</pre>
<br>
<p class="Pp">For performance reasons, it is recommended to use a large buffer
    size (for example, 4096 bytes), so that multiple events can be retrieved by
    a single <b>read</b>(2).</p>
<p class="Pp">The return value of <b>read</b>(2) is the number of bytes placed
    in the buffer, or -1 in case of an error (but see BUGS).</p>
<p class="Pp">The fields of the <i>fanotify_event_metadata</i> structure are as
    follows:</p>
<dl class="Bl-tag">
  <dt id="event_len"><a class="permalink" href="#event_len"><i>event_len</i></a></dt>
  <dd>This is the length of the data for the current event and the offset to the
      next event in the buffer. Unless the group identifies filesystem objects
      by file handles, the value of <i>event_len</i> is always
      <b>FAN_EVENT_METADATA_LEN</b>. For a group that identifies filesystem
      objects by file handles, <i>event_len</i> also includes the variable
      length file identifier records.</dd>
  <dt id="vers"><a class="permalink" href="#vers"><i>vers</i></a></dt>
  <dd>This field holds a version number for the structure. It must be compared
      to <b>FANOTIFY_METADATA_VERSION</b> to verify that the structures returned
      at run time match the structures defined at compile time. In case of a
      mismatch, the application should abandon trying to use the fanotify file
      descriptor.</dd>
  <dt id="reserved"><a class="permalink" href="#reserved"><i>reserved</i></a></dt>
  <dd>This field is not used.</dd>
  <dt id="metadata_len"><a class="permalink" href="#metadata_len"><i>metadata_len</i></a></dt>
  <dd>This is the length of the structure. The field was introduced to
      facilitate the implementation of optional headers per event type. No such
      optional headers exist in the current implementation.</dd>
  <dt id="mask"><a class="permalink" href="#mask"><i>mask</i></a></dt>
  <dd>This is a bit mask describing the event (see below).</dd>
  <dt id="fd"><a class="permalink" href="#fd"><i>fd</i></a></dt>
  <dd>This is an open file descriptor for the object being accessed, or
      <b>FAN_NOFD</b> if a queue overflow occurred. With an fanotify group that
      identifies filesystem objects by file handles, applications should expect
      this value to be set to <b>FAN_NOFD</b> for each event that is received.
      The file descriptor can be used to access the contents of the monitored
      file or directory. The reading application is responsible for closing this
      file descriptor.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When calling <b>fanotify_init</b>(2), the caller may specify (via the
      <i>event_f_flags</i> argument) various file status flags that are to be
      set on the open file description that corresponds to this file descriptor.
      In addition, the (kernel-internal) <b>FMODE_NONOTIFY</b> file status flag
      is set on the open file description. This flag suppresses fanotify event
      generation. Hence, when the receiver of the fanotify event accesses the
      notified file or directory using this file descriptor, no additional
      events will be created.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="pid"><a class="permalink" href="#pid"><i>pid</i></a></dt>
  <dd>If flag <b>FAN_REPORT_TID</b> was set in <b>fanotify_init</b>(2), this is
      the TID of the thread that caused the event. Otherwise, this the PID of
      the process that caused the event.</dd>
</dl>
<p class="Pp">A program listening to fanotify events can compare this PID to the
    PID returned by <b>getpid</b>(2), to determine whether the event is caused
    by the listener itself, or is due to a file access by another process.</p>
<p class="Pp">The bit mask in <i>mask</i> indicates which events have occurred
    for a single filesystem object. Multiple bits may be set in this mask, if
    more than one event occurred for the monitored filesystem object. In
    particular, consecutive events for the same filesystem object and
    originating from the same process may be merged into a single event, with
    the exception that two permission events are never merged into one queue
    entry.</p>
<p class="Pp">The bits that may appear in <i>mask</i> are as follows:</p>
<dl class="Bl-tag">
  <dt id="FAN_ACCESS"><a class="permalink" href="#FAN_ACCESS"><b>FAN_ACCESS</b></a></dt>
  <dd>A file or a directory (but see BUGS) was accessed (read).</dd>
  <dt id="FAN_OPEN"><a class="permalink" href="#FAN_OPEN"><b>FAN_OPEN</b></a></dt>
  <dd>A file or a directory was opened.</dd>
  <dt id="FAN_OPEN_EXEC"><a class="permalink" href="#FAN_OPEN_EXEC"><b>FAN_OPEN_EXEC</b></a></dt>
  <dd>A file was opened with the intent to be executed. See NOTES in
      <b>fanotify_mark</b>(2) for additional details.</dd>
  <dt id="FAN_ATTRIB"><a class="permalink" href="#FAN_ATTRIB"><b>FAN_ATTRIB</b></a></dt>
  <dd>A file or directory metadata was changed.</dd>
  <dt id="FAN_CREATE"><a class="permalink" href="#FAN_CREATE"><b>FAN_CREATE</b></a></dt>
  <dd>A child file or directory was created in a watched parent.</dd>
  <dt id="FAN_DELETE"><a class="permalink" href="#FAN_DELETE"><b>FAN_DELETE</b></a></dt>
  <dd>A child file or directory was deleted in a watched parent.</dd>
  <dt id="FAN_DELETE_SELF"><a class="permalink" href="#FAN_DELETE_SELF"><b>FAN_DELETE_SELF</b></a></dt>
  <dd>A watched file or directory was deleted.</dd>
  <dt id="FAN_FS_ERROR"><a class="permalink" href="#FAN_FS_ERROR"><b>FAN_FS_ERROR</b></a></dt>
  <dd>A filesystem error was detected.</dd>
  <dt id="FAN_RENAME"><a class="permalink" href="#FAN_RENAME"><b>FAN_RENAME</b></a></dt>
  <dd>A file or directory has been moved to or from a watched parent
    directory.</dd>
  <dt id="FAN_MOVED_FROM"><a class="permalink" href="#FAN_MOVED_FROM"><b>FAN_MOVED_FROM</b></a></dt>
  <dd>A file or directory has been moved from a watched parent directory.</dd>
  <dt id="FAN_MOVED_TO"><a class="permalink" href="#FAN_MOVED_TO"><b>FAN_MOVED_TO</b></a></dt>
  <dd>A file or directory has been moved to a watched parent directory.</dd>
  <dt id="FAN_MOVE_SELF"><a class="permalink" href="#FAN_MOVE_SELF"><b>FAN_MOVE_SELF</b></a></dt>
  <dd>A watched file or directory was moved.</dd>
  <dt id="FAN_MODIFY"><a class="permalink" href="#FAN_MODIFY"><b>FAN_MODIFY</b></a></dt>
  <dd>A file was modified.</dd>
  <dt id="FAN_CLOSE_WRITE"><a class="permalink" href="#FAN_CLOSE_WRITE"><b>FAN_CLOSE_WRITE</b></a></dt>
  <dd>A file that was opened for writing (<b>O_WRONLY</b> or <b>O_RDWR</b>) was
      closed.</dd>
  <dt id="FAN_CLOSE_NOWRITE"><a class="permalink" href="#FAN_CLOSE_NOWRITE"><b>FAN_CLOSE_NOWRITE</b></a></dt>
  <dd>A file or directory that was opened read-only (<b>O_RDONLY</b>) was
      closed.</dd>
  <dt id="FAN_Q_OVERFLOW"><a class="permalink" href="#FAN_Q_OVERFLOW"><b>FAN_Q_OVERFLOW</b></a></dt>
  <dd>The event queue exceeded the limit on number of events. This limit can be
      overridden by specifying the <b>FAN_UNLIMITED_QUEUE</b> flag when calling
      <b>fanotify_init</b>(2).</dd>
  <dt id="FAN_ACCESS_PERM"><a class="permalink" href="#FAN_ACCESS_PERM"><b>FAN_ACCESS_PERM</b></a></dt>
  <dd>An application wants to read a file or directory, for example using
      <b>read</b>(2) or <b>readdir</b>(2). The reader must write a response (as
      described below) that determines whether the permission to access the
      filesystem object shall be granted.</dd>
  <dt id="FAN_OPEN_PERM"><a class="permalink" href="#FAN_OPEN_PERM"><b>FAN_OPEN_PERM</b></a></dt>
  <dd>An application wants to open a file or directory. The reader must write a
      response that determines whether the permission to open the filesystem
      object shall be granted.</dd>
  <dt id="FAN_OPEN_EXEC_PERM"><a class="permalink" href="#FAN_OPEN_EXEC_PERM"><b>FAN_OPEN_EXEC_PERM</b></a></dt>
  <dd>An application wants to open a file for execution. The reader must write a
      response that determines whether the permission to open the filesystem
      object for execution shall be granted. See NOTES in
      <b>fanotify_mark</b>(2) for additional details.</dd>
</dl>
<p class="Pp">To check for any close event, the following bit mask may be
  used:</p>
<dl class="Bl-tag">
  <dt id="FAN_CLOSE"><a class="permalink" href="#FAN_CLOSE"><b>FAN_CLOSE</b></a></dt>
  <dd>A file was closed. This is a synonym for:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>FAN_CLOSE_WRITE | FAN_CLOSE_NOWRITE
    </pre>
    <br>
  </dd>
</dl>
<p class="Pp">To check for any move event, the following bit mask may be
  used:</p>
<dl class="Bl-tag">
  <dt id="FAN_MOVE"><a class="permalink" href="#FAN_MOVE"><b>FAN_MOVE</b></a></dt>
  <dd>A file or directory was moved. This is a synonym for:</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>FAN_MOVED_FROM | FAN_MOVED_TO
    </pre>
    <br>
  </dd>
</dl>
<p class="Pp">The following bits may appear in <i>mask</i> only in conjunction
    with other event type bits:</p>
<dl class="Bl-tag">
  <dt id="FAN_ONDIR"><a class="permalink" href="#FAN_ONDIR"><b>FAN_ONDIR</b></a></dt>
  <dd>The events described in the <i>mask</i> have occurred on a directory
      object. Reporting events on directories requires setting this flag in the
      mark mask. See <b>fanotify_mark</b>(2) for additional details. The
      <b>FAN_ONDIR</b> flag is reported in an event mask only if the fanotify
      group identifies filesystem objects by file handles.</dd>
</dl>
<p class="Pp">Information records that are supplied alongside the generic
    <i>fanotify_event_metadata</i> structure will always contain a nested
    structure of type <i>fanotify_event_info_header</i>. The fields of the
    <i>fanotify_event_info_header</i> are as follows:</p>
<dl class="Bl-tag">
  <dt id="info_type"><a class="permalink" href="#info_type"><i>info_type</i></a></dt>
  <dd>A unique integer value representing the type of information record object
      received for an event. The value of this field can be set to one of the
      following: <b>FAN_EVENT_INFO_TYPE_FID</b>,
      <b>FAN_EVENT_INFO_TYPE_DFID</b>, <b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, or
      <b>FAN_EVENT_INFO_TYPE_PIDFD</b>. The value set for this field is
      dependent on the flags that have been supplied to <b>fanotify_init</b>(2).
      Refer to the field details of each information record object type below to
      understand the different cases in which the <i>info_type</i> values can be
      set.</dd>
  <dt id="pad"><a class="permalink" href="#pad"><i>pad</i></a></dt>
  <dd>This field is currently not used by any information record object type and
      therefore is set to zero.</dd>
  <dt id="len"><a class="permalink" href="#len"><i>len</i></a></dt>
  <dd>The value of <i>len</i> is set to the size of the information record
      object, including the <i>fanotify_event_info_header</i>. The total size of
      all additional information records is not expected to be larger than
      (<i>event_len</i> - <i>metadata_len</i>).</dd>
</dl>
<p class="Pp">The fields of the <i>fanotify_event_info_fid</i> structure are as
    follows:</p>
<dl class="Bl-tag">
  <dt id="hdr"><a class="permalink" href="#hdr"><i>hdr</i></a></dt>
  <dd>This is a structure of type <i>fanotify_event_info_header</i>. For
      example, when an fanotify file descriptor is created using
      <b>FAN_REPORT_FID</b>, a single information record is expected to be
      attached to the event with <i>info_type</i> field value of
      <b>FAN_EVENT_INFO_TYPE_FID</b>. When an fanotify file descriptor is
      created using the combination of <b>FAN_REPORT_FID</b> and
      <b>FAN_REPORT_DIR_FID</b>, there may be two information records attached
      to the event: one with <i>info_type</i> field value of
      <b>FAN_EVENT_INFO_TYPE_DFID</b>, identifying a parent directory object,
      and one with <i>info_type</i> field value of
      <b>FAN_EVENT_INFO_TYPE_FID</b>, identifying a child object. Note that for
      the directory entry modification events <b>FAN_CREATE</b>,
      <b>FAN_DELETE</b>, <b>FAN_MOVE</b>, and <b>FAN_RENAME</b>, an information
      record identifying the created/deleted/moved child object is reported only
      if an fanotify group was initialized with the flag
      <b>FAN_REPORT_TARGET_FID</b>.</dd>
  <dt id="fsid"><a class="permalink" href="#fsid"><i>fsid</i></a></dt>
  <dd>This is a unique identifier of the filesystem containing the object
      associated with the event. It is a structure of type
      <i>__kernel_fsid_t</i> and contains the same value as <i>f_fsid</i> when
      calling <b>statfs</b>(2).</dd>
  <dt id="file_handle"><a class="permalink" href="#file_handle"><i>file_handle</i></a></dt>
  <dd>This is a variable length structure of type struct file_handle. It is an
      opaque handle that corresponds to a specified object on a filesystem as
      returned by <b>name_to_handle_at</b>(2). It can be used to uniquely
      identify a file on a filesystem and can be passed as an argument to
      <b>open_by_handle_at</b>(2). If the value of <i>info_type</i> field is
      <b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the file handle is followed by a
      null terminated string that identifies the created/deleted/moved directory
      entry name. For other events such as <b>FAN_OPEN</b>, <b>FAN_ATTRIB</b>,
      <b>FAN_DELETE_SELF</b>, and <b>FAN_MOVE_SELF</b>, if the value of
      <i>info_type</i> field is <b>FAN_EVENT_INFO_TYPE_FID</b>, the
      <i>file_handle</i> identifies the object correlated to the event. If the
      value of <i>info_type</i> field is <b>FAN_EVENT_INFO_TYPE_DFID</b>, the
      <i>file_handle</i> identifies the directory object correlated to the event
      or the parent directory of a non-directory object correlated to the event.
      If the value of <i>info_type</i> field is
      <b>FAN_EVENT_INFO_TYPE_DFID_NAME</b>, the <i>file_handle</i> identifies
      the same directory object that would be reported with
      <b>FAN_EVENT_INFO_TYPE_DFID</b> and the file handle is followed by a null
      terminated string that identifies the name of a directory entry in that
      directory, or '.' to identify the directory object itself.</dd>
</dl>
<p class="Pp">The fields of the <i>fanotify_event_info_pidfd</i> structure are
    as follows:</p>
<dl class="Bl-tag">
  <dt id="hdr~2"><a class="permalink" href="#hdr~2"><i>hdr</i></a></dt>
  <dd>This is a structure of type <i>fanotify_event_info_header</i>. When an
      fanotify group is initialized using <b>FAN_REPORT_PIDFD</b>, the
      <i>info_type</i> field value of the <i>fanotify_event_info_header</i> is
      set to <b>FAN_EVENT_INFO_TYPE_PIDFD</b>.</dd>
  <dt id="pidfd"><a class="permalink" href="#pidfd"><i>pidfd</i></a></dt>
  <dd>This is a process file descriptor that refers to the process responsible
      for generating the event. The returned process file descriptor is no
      different from one which could be obtained manually if
      <b>pidfd_open</b>(2) were to be called on
      <i>fanotify_event_metadata.pid</i>. In the instance that an error is
      encountered during pidfd creation, one of two possible error types
      represented by a negative integer value may be returned in this
      <i>pidfd</i> field. In cases where the process responsible for generating
      the event has terminated prior to the event listener being able to read
      events from the notification queue, <b>FAN_NOPIDFD</b> is returned. The
      pidfd creation for an event is only performed at the time the events are
      read from the notification queue. All other possible pidfd creation
      failures are represented by <b>FAN_EPIDFD</b>. Once the event listener has
      dealt with an event and the pidfd is no longer required, the pidfd should
      be closed via <b>close</b>(2).</dd>
</dl>
<p class="Pp">The fields of the <i>fanotify_event_info_error</i> structure are
    as follows:</p>
<dl class="Bl-tag">
  <dt id="hdr~3"><a class="permalink" href="#hdr~3"><i>hdr</i></a></dt>
  <dd>This is a structure of type <i>fanotify_event_info_header</i>. The
      <i>info_type</i> field is set to <b>FAN_EVENT_INFO_TYPE_ERROR</b>.</dd>
  <dt id="error"><a class="permalink" href="#error"><i>error</i></a></dt>
  <dd>Identifies the type of error that occurred.</dd>
  <dt id="error_count"><a class="permalink" href="#error_count"><i>error_count</i></a></dt>
  <dd>This is a counter of the number of errors suppressed since the last error
      was read.</dd>
</dl>
<p class="Pp">The following macros are provided to iterate over a buffer
    containing fanotify event metadata returned by a <b>read</b>(2) from an
    fanotify file descriptor:</p>
<dl class="Bl-tag">
  <dt id="FAN_EVENT_OK(meta,"><a class="permalink" href="#FAN_EVENT_OK(meta,"><b>FAN_EVENT_OK(meta,
    len)</b></a></dt>
  <dd>This macro checks the remaining length <i>len</i> of the buffer
      <i>meta</i> against the length of the metadata structure and the
      <i>event_len</i> field of the first metadata structure in the buffer.</dd>
  <dt id="FAN_EVENT_NEXT(meta,"><a class="permalink" href="#FAN_EVENT_NEXT(meta,"><b>FAN_EVENT_NEXT(meta,
    len)</b></a></dt>
  <dd>This macro uses the length indicated in the <i>event_len</i> field of the
      metadata structure pointed to by <i>meta</i> to calculate the address of
      the next metadata structure that follows <i>meta</i>. <i>len</i> is the
      number of bytes of metadata that currently remain in the buffer. The macro
      returns a pointer to the next metadata structure that follows <i>meta</i>,
      and reduces <i>len</i> by the number of bytes in the metadata structure
      that has been skipped over (i.e., it subtracts <i>meta-&gt;event_len</i>
      from <i>len</i>).</dd>
</dl>
<p class="Pp">In addition, there is:</p>
<dl class="Bl-tag">
  <dt id="FAN_EVENT_METADATA_LEN"><a class="permalink" href="#FAN_EVENT_METADATA_LEN"><b>FAN_EVENT_METADATA_LEN</b></a></dt>
  <dd>This macro returns the size (in bytes) of the structure
      <i>fanotify_event_metadata</i>. This is the minimum size (and currently
      the only size) of any event metadata.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Monitoring_an_fanotify_file_descriptor_for_events"><a class="permalink" href="#Monitoring_an_fanotify_file_descriptor_for_events">Monitoring
  an fanotify file descriptor for events</a></h2>
<p class="Pp">When an fanotify event occurs, the fanotify file descriptor
    indicates as readable when passed to <b>epoll</b>(7), <b>poll</b>(2), or
    <b>select</b>(2).</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Dealing_with_permission_events"><a class="permalink" href="#Dealing_with_permission_events">Dealing
  with permission events</a></h2>
<p class="Pp">For permission events, the application must <b>write</b>(2) a
    structure of the following form to the fanotify file descriptor:</p>
<p class="Pp">
  <br>
</p>
<pre>struct fanotify_response {
<br>
    __s32 fd;
<br>
    __u32 response;
};
</pre>
<br>
<p class="Pp">The fields of this structure are as follows:</p>
<dl class="Bl-tag">
  <dt id="fd~2"><a class="permalink" href="#fd~2"><i>fd</i></a></dt>
  <dd>This is the file descriptor from the structure
      <i>fanotify_event_metadata</i>.</dd>
  <dt id="response"><a class="permalink" href="#response"><i>response</i></a></dt>
  <dd>This field indicates whether or not the permission is to be granted. Its
      value must be either <b>FAN_ALLOW</b> to allow the file operation or
      <b>FAN_DENY</b> to deny the file operation.</dd>
</dl>
<p class="Pp">If access is denied, the requesting application call will receive
    an <b>EPERM</b> error. Additionally, if the notification group has been
    created with the <b>FAN_ENABLE_AUDIT</b> flag, then the <b>FAN_AUDIT</b>
    flag can be set in the <i>response</i> field. In that case, the audit
    subsystem will log information about the access decision to the audit
  logs.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Monitoring_filesystems_for_errors"><a class="permalink" href="#Monitoring_filesystems_for_errors">Monitoring
  filesystems for errors</a></h2>
<p class="Pp">A single <b>FAN_FS_ERROR</b> event is stored per filesystem at
    once. Extra error messages are suppressed and accounted for in the
    <i>error_count</i> field of the existing <b>FAN_FS_ERROR</b> event record,
    but details about the errors are lost.</p>
<p class="Pp">Errors reported by <b>FAN_FS_ERROR</b> are generic <i>errno</i>
    values, but not all kinds of error types are reported by all
  filesystems.</p>
<p class="Pp">Errors not directly related to a file (i.e. super block
    corruption) are reported with an invalid <i>file_handle</i>. For these
    errors, the <i>file_handle</i> will have the field <i>handle_type</i> set to
    <b>FILEID_INVALID</b>, and the handle buffer size set to <b>0</b>.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Closing_the_fanotify_file_descriptor"><a class="permalink" href="#Closing_the_fanotify_file_descriptor">Closing
  the fanotify file descriptor</a></h2>
<p class="Pp">When all file descriptors referring to the fanotify notification
    group are closed, the fanotify group is released and its resources are freed
    for reuse by the kernel. Upon <b>close</b>(2), outstanding permission events
    will be set to allowed.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="/proc_interfaces"><a class="permalink" href="#/proc_interfaces">/proc
  interfaces</a></h2>
<p class="Pp">The file <i>/proc/[pid]/fdinfo/[fd]</i> contains information about
    fanotify marks for file descriptor <i>fd</i> of process <i>pid</i>. See
    <b>proc</b>(5) for details.</p>
<p class="Pp">Since Linux 5.13, the following interfaces can be used to control
    the amount of kernel resources consumed by fanotify:</p>
<dl class="Bl-tag">
  <dt><i>/proc/sys/fs/fanotify/max_queued_events</i></dt>
  <dd>The value in this file is used when an application calls
      <b>fanotify_init</b>(2) to set an upper limit on the number of events that
      can be queued to the corresponding fanotify group. Events in excess of
      this limit are dropped, but an <b>FAN_Q_OVERFLOW</b> event is always
      generated. Prior to Linux kernel 5.13, the hardcoded limit was 16384
      events.</dd>
  <dt><i>/proc/sys/fs/fanotify/max_user_group</i></dt>
  <dd>This specifies an upper limit on the number of fanotify groups that can be
      created per real user ID. Prior to Linux kernel 5.13, the hardcoded limit
      was 128 groups per user.</dd>
  <dt><i>/proc/sys/fs/fanotify/max_user_marks</i></dt>
  <dd>This specifies an upper limit on the number of fanotify marks that can be
      created per real user ID. Prior to Linux kernel 5.13, the hardcoded limit
      was 8192 marks per group (not per user).</dd>
</dl>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<p class="Pp">In addition to the usual errors for <b>read</b>(2), the following
    errors can occur when reading from the fanotify file descriptor:</p>
<dl class="Bl-tag">
  <dt id="EINVAL"><a class="permalink" href="#EINVAL"><b>EINVAL</b></a></dt>
  <dd>The buffer is too small to hold the event.</dd>
  <dt id="EMFILE"><a class="permalink" href="#EMFILE"><b>EMFILE</b></a></dt>
  <dd>The per-process limit on the number of open files has been reached. See
      the description of <b>RLIMIT_NOFILE</b> in <b>getrlimit</b>(2).</dd>
  <dt id="ENFILE"><a class="permalink" href="#ENFILE"><b>ENFILE</b></a></dt>
  <dd>The system-wide limit on the total number of open files has been reached.
      See <i>/proc/sys/fs/file-max</i> in <b>proc</b>(5).</dd>
  <dt id="ETXTBSY"><a class="permalink" href="#ETXTBSY"><b>ETXTBSY</b></a></dt>
  <dd>This error is returned by <b>read</b>(2) if <b>O_RDWR</b> or
      <b>O_WRONLY</b> was specified in the <i>event_f_flags</i> argument when
      calling <b>fanotify_init</b>(2) and an event occurred for a monitored file
      that is currently being executed.</dd>
</dl>
<p class="Pp">In addition to the usual errors for <b>write</b>(2), the following
    errors can occur when writing to the fanotify file descriptor:</p>
<dl class="Bl-tag">
  <dt id="EINVAL~2"><a class="permalink" href="#EINVAL~2"><b>EINVAL</b></a></dt>
  <dd>Fanotify access permissions are not enabled in the kernel configuration or
      the value of <i>response</i> in the response structure is not valid.</dd>
  <dt id="ENOENT"><a class="permalink" href="#ENOENT"><b>ENOENT</b></a></dt>
  <dd>The file descriptor <i>fd</i> in the response structure is not valid. This
      may occur when a response for the permission event has already been
      written.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSIONS"><a class="permalink" href="#VERSIONS">VERSIONS</a></h1>
<p class="Pp">The fanotify API was introduced in Linux 2.6.36 and enabled in
    Linux 2.6.37. Fdinfo support was added in Linux 3.8.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="STANDARDS"><a class="permalink" href="#STANDARDS">STANDARDS</a></h1>
<p class="Pp">The fanotify API is Linux-specific.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="NOTES"><a class="permalink" href="#NOTES">NOTES</a></h1>
<p class="Pp">The fanotify API is available only if the kernel was built with
    the <b>CONFIG_FANOTIFY</b> configuration option enabled. In addition,
    fanotify permission handling is available only if the
    <b>CONFIG_FANOTIFY_ACCESS_PERMISSIONS</b> configuration option is
  enabled.</p>
<section class="Ss">
<h2 class="Ss" id="Limitations_and_caveats"><a class="permalink" href="#Limitations_and_caveats">Limitations
  and caveats</a></h2>
<p class="Pp">Fanotify reports only events that a user-space program triggers
    through the filesystem API. As a result, it does not catch remote events
    that occur on network filesystems.</p>
<p class="Pp">The fanotify API does not report file accesses and modifications
    that may occur because of <b>mmap</b>(2), <b>msync</b>(2), and
    <b>munmap</b>(2).</p>
<p class="Pp">Events for directories are created only if the directory itself is
    opened, read, and closed. Adding, removing, or changing children of a marked
    directory does not create events for the monitored directory itself.</p>
<p class="Pp">Fanotify monitoring of directories is not recursive: to monitor
    subdirectories under a directory, additional marks must be created. The
    <b>FAN_CREATE</b> event can be used for detecting when a subdirectory has
    been created under a marked directory. An additional mark must then be set
    on the newly created subdirectory. This approach is racy, because it can
    lose events that occurred inside the newly created subdirectory, before a
    mark is added on that subdirectory. Monitoring mounts offers the capability
    to monitor a whole directory tree in a race-free manner. Monitoring
    filesystems offers the capability to monitor changes made from any mount of
    a filesystem instance in a race-free manner.</p>
<p class="Pp">The event queue can overflow. In this case, events are lost.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Before Linux 3.19, <b>fallocate</b>(2) did not generate fanotify
    events. Since Linux 3.19, calls to <b>fallocate</b>(2) generate
    <b>FAN_MODIFY</b> events.</p>
<p class="Pp">As of Linux 3.17, the following bugs exist:</p>
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>On Linux, a filesystem object may be accessible through multiple paths,
      for example, a part of a filesystem may be remounted using the
      <i>--bind</i> option of <b>mount</b>(8). A listener that marked a mount
      will be notified only of events that were triggered for a filesystem
      object using the same mount. Any other event will pass unnoticed.</dd>
  <dt>•</dt>
  <dd>When an event is generated, no check is made to see whether the user ID of
      the receiving process has authorization to read or write the file before
      passing a file descriptor for that file. This poses a security risk, when
      the <b>CAP_SYS_ADMIN</b> capability is set for programs executed by
      unprivileged users.</dd>
  <dt>•</dt>
  <dd>If a call to <b>read</b>(2) processes multiple events from the fanotify
      queue and an error occurs, the return value will be the total length of
      the events successfully copied to the user-space buffer before the error
      occurred. The return value will not be -1, and <i>errno</i> will not be
      set. Thus, the reading application has no way to detect the error.</dd>
</dl>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">The two example programs below demonstrate the usage of the
    fanotify API.</p>
<section class="Ss">
<h2 class="Ss" id="Example_program:_fanotify_example.c"><a class="permalink" href="#Example_program:_fanotify_example.c">Example
  program: fanotify_example.c</a></h2>
<p class="Pp">The first program is an example of fanotify being used with its
    event object information passed in the form of a file descriptor. The
    program marks the mount passed as a command-line argument and waits for
    events of type <b>FAN_OPEN_PERM</b> and <b>FAN_CLOSE_WRITE</b>. When a
    permission event occurs, a <b>FAN_ALLOW</b> response is given.</p>
<p class="Pp">The following shell session shows an example of running this
    program. This session involved editing the file
    <i>/home/user/temp/notes</i>. Before the file was opened, a
    <b>FAN_OPEN_PERM</b> event occurred. After the file was closed, a
    <b>FAN_CLOSE_WRITE</b> event occurred. Execution of the program ends when
    the user presses the ENTER key.</p>
<p class="Pp">
  <br>
</p>
<pre># <b>./fanotify_example /home</b>
Press enter key to terminate.
Listening for events.
FAN_OPEN_PERM: File /home/user/temp/notes
FAN_CLOSE_WRITE: File /home/user/temp/notes
Listening for events stopped.
</pre>
<br>
</section>
<section class="Ss">
<h2 class="Ss" id="Program_source:_fanotify_example.c"><a class="permalink" href="#Program_source:_fanotify_example.c">Program
  source: fanotify_example.c</a></h2>
<p class="Pp"></p>
<pre>#define _GNU_SOURCE     /* Needed to get O_LARGEFILE definition */
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;poll.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/fanotify.h&gt;
#include &lt;unistd.h&gt;
/* Read all available fanotify events from the file descriptor 'fd'. */
static void
handle_events(int fd)
{
<br>
    const struct fanotify_event_metadata *metadata;
<br>
    struct fanotify_event_metadata buf[200];
<br>
    ssize_t len;
<br>
    char path[PATH_MAX];
<br>
    ssize_t path_len;
<br>
    char procfd_path[PATH_MAX];
<br>
    struct fanotify_response response;
<br>
    /* Loop while events can be read from fanotify file descriptor. */
<br>
    for (;;) {
<br>
        /* Read some events. */
<br>
        len = read(fd, buf, sizeof(buf));
<br>
        if (len == -1 &amp;&amp; errno != EAGAIN) {
<br>
            perror("read");
<br>
            exit(EXIT_FAILURE);
<br>
        }
<br>
        /* Check if end of available data reached. */
<br>
        if (len &lt;= 0)
<br>
            break;
<br>
        /* Point to the first event in the buffer. */
<br>
        metadata = buf;
<br>
        /* Loop over all events in the buffer. */
<br>
        while (FAN_EVENT_OK(metadata, len)) {
<br>
            /* Check that run-time and compile-time structures match. */
<br>
            if (metadata-&gt;vers != FANOTIFY_METADATA_VERSION) {
<br>
                fprintf(stderr,
<br>
                        "Mismatch of fanotify metadata version.\n");
<br>
                exit(EXIT_FAILURE);
<br>
            }
<br>
            /* metadata-&gt;fd contains either FAN_NOFD, indicating a
<br>
               queue overflow, or a file descriptor (a nonnegative
<br>
               integer). Here, we simply ignore queue overflow. */
<br>
            if (metadata-&gt;fd &gt;= 0) {
<br>
                /* Handle open permission event. */
<br>
                if (metadata-&gt;mask &amp; FAN_OPEN_PERM) {
<br>
                    printf("FAN_OPEN_PERM: ");
<br>
                    /* Allow file to be opened. */
<br>
                    response.fd = metadata-&gt;fd;
<br>
                    response.response = FAN_ALLOW;
<br>
                    write(fd, &amp;response, sizeof(response));
<br>
                }
<br>
                /* Handle closing of writable file event. */
<br>
                if (metadata-&gt;mask &amp; FAN_CLOSE_WRITE)
<br>
                    printf("FAN_CLOSE_WRITE: ");
<br>
                /* Retrieve and print pathname of the accessed file. */
<br>
                snprintf(procfd_path, sizeof(procfd_path),
<br>
                         "/proc/self/fd/%d", metadata-&gt;fd);
<br>
                path_len = readlink(procfd_path, path,
<br>
                                    sizeof(path) - 1);
<br>
                if (path_len == -1) {
<br>
                    perror("readlink");
<br>
                    exit(EXIT_FAILURE);
<br>
                }
<br>
                path[path_len] = '\0';
<br>
                printf("File %s\n", path);
<br>
                /* Close the file descriptor of the event. */
<br>
                close(metadata-&gt;fd);
<br>
            }
<br>
            /* Advance to next event. */
<br>
            metadata = FAN_EVENT_NEXT(metadata, len);
<br>
        }
<br>
    }
}
int
main(int argc, char *argv[])
{
<br>
    char buf;
<br>
    int fd, poll_num;
<br>
    nfds_t nfds;
<br>
    struct pollfd fds[2];
<br>
    /* Check mount point is supplied. */
<br>
    if (argc != 2) {
<br>
        fprintf(stderr, "Usage: %s MOUNT\n", argv[0]);
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    printf("Press enter key to terminate.\n");
<br>
    /* Create the file descriptor for accessing the fanotify API. */
<br>
    fd = fanotify_init(FAN_CLOEXEC | FAN_CLASS_CONTENT | FAN_NONBLOCK,
<br>
                       O_RDONLY | O_LARGEFILE);
<br>
    if (fd == -1) {
<br>
        perror("fanotify_init");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    /* Mark the mount for:
<br>
       - permission events before opening files
<br>
       - notification events after closing a write-enabled
<br>
         file descriptor. */
<br>
    if (fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_MOUNT,
<br>
                      FAN_OPEN_PERM | FAN_CLOSE_WRITE, AT_FDCWD,
<br>
                      argv[1]) == -1) {
<br>
        perror("fanotify_mark");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    /* Prepare for polling. */
<br>
    nfds = 2;
<br>
    fds[0].fd = STDIN_FILENO;       /* Console input */
<br>
    fds[0].events = POLLIN;
<br>
    fds[1].fd = fd;                 /* Fanotify input */
<br>
    fds[1].events = POLLIN;
<br>
    /* This is the loop to wait for incoming events. */
<br>
    printf("Listening for events.\n");
<br>
    while (1) {
<br>
        poll_num = poll(fds, nfds, -1);
<br>
        if (poll_num == -1) {
<br>
            if (errno == EINTR)     /* Interrupted by a signal */
<br>
                continue;           /* Restart poll() */
<br>
            perror("poll");         /* Unexpected error */
<br>
            exit(EXIT_FAILURE);
<br>
        }
<br>
        if (poll_num &gt; 0) {
<br>
            if (fds[0].revents &amp; POLLIN) {
<br>
                /* Console input is available: empty stdin and quit. */
<br>
                while (read(STDIN_FILENO, &amp;buf, 1) &gt; 0 &amp;&amp; buf != '\n')
<br>
                    continue;
<br>
                break;
<br>
            }
<br>
            if (fds[1].revents &amp; POLLIN) {
<br>
                /* Fanotify events are available. */
<br>
                handle_events(fd);
<br>
            }
<br>
        }
<br>
    }
<br>
    printf("Listening for events stopped.\n");
<br>
    exit(EXIT_SUCCESS);
}
</pre>
</section>
<section class="Ss">
<h2 class="Ss" id="Example_program:_fanotify_fid.c"><a class="permalink" href="#Example_program:_fanotify_fid.c">Example
  program: fanotify_fid.c</a></h2>
<p class="Pp">The second program is an example of fanotify being used with a
    group that identifies objects by file handles. The program marks the
    filesystem object that is passed as a command-line argument and waits until
    an event of type <b>FAN_CREATE</b> has occurred. The event mask indicates
    which type of filesystem object—either a file or a
    directory—was created. Once all events have been read from the buffer
    and processed accordingly, the program simply terminates.</p>
<p class="Pp">The following shell sessions show two different invocations of
    this program, with different actions performed on a watched object.</p>
<p class="Pp">The first session shows a mark being placed on <i>/home/user</i>.
    This is followed by the creation of a regular file,
    <i>/home/user/testfile.txt</i>. This results in a <b>FAN_CREATE</b> event
    being generated and reported against the file's parent watched directory
    object and with the created file name. Program execution ends once all
    events captured within the buffer have been processed.</p>
<p class="Pp">
  <br>
</p>
<pre># <b>./fanotify_fid /home/user</b>
Listening for events.
FAN_CREATE (file created):
<br>
        Directory /home/user has been modified.
<br>
        Entry 'testfile.txt' is not a subdirectory.
All events processed successfully. Program exiting.
$ <b>touch /home/user/testfile.txt</b>              # In another terminal
</pre>
<br>
<p class="Pp">The second session shows a mark being placed on <i>/home/user</i>.
    This is followed by the creation of a directory, <i>/home/user/testdir</i>.
    This specific action results in a <b>FAN_CREATE</b> event being generated
    and is reported with the <b>FAN_ONDIR</b> flag set and with the created
    directory name.</p>
<p class="Pp">
  <br>
</p>
<pre># <b>./fanotify_fid /home/user</b>
Listening for events.
FAN_CREATE | FAN_ONDIR (subdirectory created):
<br>
        Directory /home/user has been modified.
<br>
        Entry 'testdir' is a subdirectory.
All events processed successfully. Program exiting.
$ <b>mkdir -p /home/user/testdir</b>          # In another terminal
</pre>
<br>
</section>
<section class="Ss">
<h2 class="Ss" id="Program_source:_fanotify_fid.c"><a class="permalink" href="#Program_source:_fanotify_fid.c">Program
  source: fanotify_fid.c</a></h2>
<p class="Pp"></p>
<pre>#define _GNU_SOURCE
#include &lt;errno.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;limits.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;sys/fanotify.h&gt;
#include &lt;unistd.h&gt;
#define BUF_SIZE 256
int
main(int argc, char *argv[])
{
<br>
    int fd, ret, event_fd, mount_fd;
<br>
    ssize_t len, path_len;
<br>
    char path[PATH_MAX];
<br>
    char procfd_path[PATH_MAX];
<br>
    char events_buf[BUF_SIZE];
<br>
    struct file_handle *file_handle;
<br>
    struct fanotify_event_metadata *metadata;
<br>
    struct fanotify_event_info_fid *fid;
<br>
    const char *file_name;
<br>
    struct stat sb;
<br>
    if (argc != 2) {
<br>
        fprintf(stderr, "Invalid number of command line arguments.\n");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    mount_fd = open(argv[1], O_DIRECTORY | O_RDONLY);
<br>
    if (mount_fd == -1) {
<br>
        perror(argv[1]);
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    /* Create an fanotify file descriptor with FAN_REPORT_DFID_NAME as
<br>
       a flag so that program can receive fid events with directory
<br>
       entry name. */
<br>
    fd = fanotify_init(FAN_CLASS_NOTIF | FAN_REPORT_DFID_NAME, 0);
<br>
    if (fd == -1) {
<br>
        perror("fanotify_init");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    /* Place a mark on the filesystem object supplied in argv[1]. */
<br>
    ret = fanotify_mark(fd, FAN_MARK_ADD | FAN_MARK_ONLYDIR,
<br>
                        FAN_CREATE | FAN_ONDIR,
<br>
                        AT_FDCWD, argv[1]);
<br>
    if (ret == -1) {
<br>
        perror("fanotify_mark");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    printf("Listening for events.\n");
<br>
    /* Read events from the event queue into a buffer. */
<br>
    len = read(fd, events_buf, sizeof(events_buf));
<br>
    if (len == -1 &amp;&amp; errno != EAGAIN) {
<br>
        perror("read");
<br>
        exit(EXIT_FAILURE);
<br>
    }
<br>
    /* Process all events within the buffer. */
<br>
    for (metadata = (struct fanotify_event_metadata *) events_buf;
<br>
            FAN_EVENT_OK(metadata, len);
<br>
            metadata = FAN_EVENT_NEXT(metadata, len)) {
<br>
        fid = (struct fanotify_event_info_fid *) (metadata + 1);
<br>
        file_handle = (struct file_handle *) fid-&gt;handle;
<br>
        /* Ensure that the event info is of the correct type. */
<br>
        if (fid-&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_FID ||
<br>
            fid-&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID) {
<br>
            file_name = NULL;
<br>
        } else if (fid-&gt;hdr.info_type == FAN_EVENT_INFO_TYPE_DFID_NAME) {
<br>
            file_name = file_handle-&gt;f_handle +
<br>
                        file_handle-&gt;handle_bytes;
<br>
        } else {
<br>
            fprintf(stderr, "Received unexpected event info type.\n");
<br>
            exit(EXIT_FAILURE);
<br>
        }
<br>
        if (metadata-&gt;mask == FAN_CREATE)
<br>
            printf("FAN_CREATE (file created):\n");
<br>
        if (metadata-&gt;mask == (FAN_CREATE | FAN_ONDIR))
<br>
            printf("FAN_CREATE | FAN_ONDIR (subdirectory created):\n");
	/* metadata-&gt;fd is set to FAN_NOFD when the group identifies
	   objects by file handles.  To obtain a file descriptor for
	   the file object corresponding to an event you can use the
	   struct file_handle that's provided within the
	   fanotify_event_info_fid in conjunction with the
	   open_by_handle_at(2) system call.  A check for ESTALE is
	   done to accommodate for the situation where the file handle
	   for the object was deleted prior to this system call. */
<br>
        event_fd = open_by_handle_at(mount_fd, file_handle, O_RDONLY);
<br>
        if (event_fd == -1) {
<br>
            if (errno == ESTALE) {
<br>
                printf("File handle is no longer valid. "
<br>
                        "File has been deleted\n");
<br>
                continue;
<br>
            } else {
<br>
                perror("open_by_handle_at");
<br>
                exit(EXIT_FAILURE);
<br>
            }
<br>
        }
<br>
        snprintf(procfd_path, sizeof(procfd_path), "/proc/self/fd/%d",
<br>
                event_fd);
<br>
        /* Retrieve and print the path of the modified dentry. */
<br>
        path_len = readlink(procfd_path, path, sizeof(path) - 1);
<br>
        if (path_len == -1) {
<br>
            perror("readlink");
<br>
            exit(EXIT_FAILURE);
<br>
        }
<br>
        path[path_len] = '\0';
<br>
        printf("\tDirectory '%s' has been modified.\n", path);
<br>
        if (file_name) {
<br>
            ret = fstatat(event_fd, file_name, &amp;sb, 0);
<br>
            if (ret == -1) {
<br>
                if (errno != ENOENT) {
<br>
                    perror("fstatat");
<br>
                    exit(EXIT_FAILURE);
<br>
                }
<br>
                printf("\tEntry '%s' does not exist.\n", file_name);
<br>
            } else if ((sb.st_mode &amp; S_IFMT) == S_IFDIR) {
<br>
                printf("\tEntry '%s' is a subdirectory.\n", file_name);
<br>
            } else {
<br>
                printf("\tEntry '%s' is not a subdirectory.\n",
<br>
                        file_name);
<br>
            }
<br>
        }
<br>
        /* Close associated file descriptor for this event. */
<br>
        close(event_fd);
<br>
    }
<br>
    printf("All events processed successfully. Program exiting.\n");
<br>
    exit(EXIT_SUCCESS);
}
</pre>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>fanotify_init</b>(2), <b>fanotify_mark</b>(2),
    <b>inotify</b>(7)</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>