<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   Man page generated from reStructuredText.
 --><head>
<meta name="dc.identifier" content="res/8dc67c7c3ae9c0bb81a07a489b1b11876166bcf6">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>BPF-HELPERS(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">BPF-HELPERS(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">BPF-HELPERS(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">BPF-HELPERS - list of eBPF helper functions</p>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">The extended Berkeley Packet Filter (eBPF) subsystem consists in
    programs written in a pseudo-assembly language, then attached to one of the
    several kernel hooks and run in reaction of specific events. This framework
    differs from the older, "classic" BPF (or "cBPF") in
    several aspects, one of them being the ability to call special functions (or
    "helpers") from within a program. These functions are restricted
    to a white-list of helpers defined in the kernel.</p>
<p class="Pp">These helpers are used by eBPF programs to interact with the
    system, or with the context in which they work. For instance, they can be
    used to print debugging messages, to get the time since the system was
    booted, to interact with eBPF maps, or to manipulate network packets. Since
    there are several eBPF program types, and that they do not run in the same
    context, each program type can only call a subset of those helpers.</p>
<p class="Pp">Due to eBPF conventions, a helper can not have more than five
    arguments.</p>
<p class="Pp">Internally, eBPF programs call directly into the compiled helper
    functions without requiring any foreign-function interface. As a result,
    calling helpers introduces no overhead, thus offering excellent
  performance.</p>
<p class="Pp">This document is an attempt to list and document the helpers
    available to eBPF developers. They are sorted by chronological order (the
    oldest helpers in the kernel at the top).</p>
</section>
<section class="Sh">
<h1 class="Sh" id="HELPERS"><a class="permalink" href="#HELPERS">HELPERS</a></h1>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="void"><a class="permalink" href="#void"><b><b>void
    *bpf_map_lookup_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>key</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description"><a class="permalink" href="#Description"><b>Description</b></a></dt>
  <dd>Perform a lookup in <i>map</i> for an entry associated to <i>key</i>.</dd>
  <dt id="Return"><a class="permalink" href="#Return"><b>Return</b></a></dt>
  <dd>Map value associated to <i>key</i>, or <b>NULL</b> if no entry was
    found.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long"><a class="permalink" href="#long"><b><b>long
    bpf_map_update_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>key</i><b>, const void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~2"><a class="permalink" href="#Description~2"><b>Description</b></a></dt>
  <dd>Add or update the value of the entry associated to <i>key</i> in
      <i>map</i> with <i>value</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_NOEXIST"><a class="permalink" href="#BPF_NOEXIST"><b><b>BPF_NOEXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt id="BPF_EXIST"><a class="permalink" href="#BPF_EXIST"><b><b>BPF_EXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt id="BPF_ANY"><a class="permalink" href="#BPF_ANY"><b><b>BPF_ANY</b></b></a></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br>
<p class="Pp">Flag value <b>BPF_NOEXIST</b> cannot be used for maps of types
    <b>BPF_MAP_TYPE_ARRAY</b> or <b>BPF_MAP_TYPE_PERCPU_ARRAY</b> (all elements
    always exist), the helper would return an error.</p>
<dl class="Bl-tag">
  <dt id="Return~2"><a class="permalink" href="#Return~2"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~2"><a class="permalink" href="#long~2"><b><b>long
    bpf_map_delete_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>key</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~3"><a class="permalink" href="#Description~3"><b>Description</b></a></dt>
  <dd>Delete entry with <i>key</i> from <i>map</i>.</dd>
  <dt id="Return~3"><a class="permalink" href="#Return~3"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~3"><a class="permalink" href="#long~3"><b><b>long
    bpf_probe_read(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>, const void
    *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~4"><a class="permalink" href="#Description~4"><b>Description</b></a></dt>
  <dd>For tracing programs, safely attempt to read <i>size</i> bytes from kernel
      space address <i>unsafe_ptr</i> and store the data in <i>dst</i>.
    <p class="Pp">Generally, use <b>bpf_probe_read_user</b>() or
        <b>bpf_probe_read_kernel</b>() instead.</p>
  </dd>
  <dt id="Return~4"><a class="permalink" href="#Return~4"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64"><a class="permalink" href="#u64"><b><b>u64
    bpf_ktime_get_ns(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~5"><a class="permalink" href="#Description~5"><b>Description</b></a></dt>
  <dd>Return the time elapsed since system boot, in nanoseconds. Does not
      include time the system was suspended. See:
      <b>clock_gettime</b>(<b>CLOCK_MONOTONIC</b>)</dd>
  <dt id="Return~5"><a class="permalink" href="#Return~5"><b>Return</b></a></dt>
  <dd>Current <i>ktime</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~4"><a class="permalink" href="#long~4"><b><b>long
    bpf_trace_printk(const char *</b><i>fmt</i><b>, u32</b> <i>fmt_size</i><b>,
    ...)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~6"><a class="permalink" href="#Description~6"><b>Description</b></a></dt>
  <dd>This helper is a "printk()-like" facility for debugging. It
      prints a message defined by format <i>fmt</i> (of size <i>fmt_size</i>) to
      file <i>/sys/kernel/debug/tracing/trace</i> from DebugFS, if available. It
      can take up to three additional <b>u64</b> arguments (as an eBPF helpers,
      the total number of arguments is limited to five).
    <p class="Pp">Each time the helper is called, it appends a line to the
        trace. Lines are discarded while <i>/sys/kernel/debug/tracing/trace</i>
        is open, use <i>/sys/kernel/debug/tracing/trace_pipe</i> to avoid this.
        The format of the trace is customizable, and the exact output one will
        get depends on the options set in
        <i>/sys/kernel/debug/tracing/trace_options</i> (see also the
        <i>README</i> file under the same directory). However, it usually
        defaults to something like:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>telnet-470   [001] .N.. 419421.045894: 0x00000001: &lt;formatted msg&gt;
</pre>
</div>
<br>
</div>
<br>
<p class="Pp">In the above:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>telnet</b> is the name of the current task.</dd>
  <dt>•</dt>
  <dd><b>470</b> is the PID of the current task.</dd>
  <dt>•</dt>
  <dd><b>001</b> is the CPU number on which the task is running.</dd>
  <dt>•</dt>
  <dd>In <b>.N..</b>, each character refers to a set of options (whether irqs
      are enabled, scheduling options, whether hard/softirqs are running, level
      of preempt_disabled respectively). <b>N</b> means that
      <b>TIF_NEED_RESCHED</b> and <b>PREEMPT_NEED_RESCHED</b> are set.</dd>
  <dt>•</dt>
  <dd><b>419421.045894</b> is a timestamp.</dd>
  <dt>•</dt>
  <dd><b>0x00000001</b> is a fake value used by BPF for the instruction pointer
      register.</dd>
  <dt>•</dt>
  <dd><b>&lt;formatted msg&gt;</b> is the message formatted with
    <i>fmt</i>.</dd>
</dl>
</div>
<br>
</div>
<br>
</div>
<br>
<p class="Pp">The conversion specifiers supported by <i>fmt</i> are similar, but
    more limited than for printk(). They are <b>%d</b>, <b>%i</b>, <b>%u</b>,
    <b>%x</b>, <b>%ld</b>, <b>%li</b>, <b>%lu</b>, <b>%lx</b>, <b>%lld</b>,
    <b>%lli</b>, <b>%llu</b>, <b>%llx</b>, <b>%p</b>, <b>%s</b>. No modifier
    (size of field, padding with zeroes, etc.) is available, and the helper will
    return <b>-EINVAL</b> (but print nothing) if it encounters an unknown
    specifier.</p>
<p class="Pp">Also, note that <b>bpf_trace_printk</b>() is slow, and should only
    be used for debugging purposes. For this reason, a notice block (spanning
    several lines) is printed to kernel logs and states that the helper should
    not be used "for production use" the first time this helper is
    used (or more precisely, when <b>trace_printk</b>() buffers are allocated).
    For passing values to user space, perf events should be preferred.</p>
<dl class="Bl-tag">
  <dt id="Return~6"><a class="permalink" href="#Return~6"><b>Return</b></a></dt>
  <dd>The number of bytes written to the buffer, or a negative error in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32"><a class="permalink" href="#u32"><b><b>u32
    bpf_get_prandom_u32(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~7"><a class="permalink" href="#Description~7"><b>Description</b></a></dt>
  <dd>Get a pseudo-random number.
    <p class="Pp">From a security point of view, this helper uses its own
        pseudo-random internal state, and cannot be used to infer the seed of
        other random functions in the kernel. However, it is essential to note
        that the generator used by the helper is not cryptographically
      secure.</p>
  </dd>
  <dt id="Return~7"><a class="permalink" href="#Return~7"><b>Return</b></a></dt>
  <dd>A random 32-bit unsigned value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32~2"><a class="permalink" href="#u32~2"><b><b>u32
    bpf_get_smp_processor_id(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~8"><a class="permalink" href="#Description~8"><b>Description</b></a></dt>
  <dd>Get the SMP (symmetric multiprocessing) processor id. Note that all
      programs run with migration disabled, which means that the SMP processor
      id is stable during all the execution of the program.</dd>
  <dt id="Return~8"><a class="permalink" href="#Return~8"><b>Return</b></a></dt>
  <dd>The SMP id of the processor running the program.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~5"><a class="permalink" href="#long~5"><b><b>long
    bpf_skb_store_bytes(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, const void *</b><i>from</i><b>, u32</b> <i>len</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~9"><a class="permalink" href="#Description~9"><b>Description</b></a></dt>
  <dd>Store <i>len</i> bytes from address <i>from</i> into the packet associated
      to <i>skb</i>, at <i>offset</i>. <i>flags</i> are a combination of
      <b>BPF_F_RECOMPUTE_CSUM</b> (automatically recompute the checksum for the
      packet after storing the bytes) and <b>BPF_F_INVALIDATE_HASH</b> (set
      <i>skb</i><b>-&gt;hash</b>, <i>skb</i><b>-&gt;swhash</b> and
      <i>skb</i><b>-&gt;l4hash</b> to 0).
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~9"><a class="permalink" href="#Return~9"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~6"><a class="permalink" href="#long~6"><b><b>long
    bpf_l3_csum_replace(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b> <i>to</i><b>, u64</b>
    <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~10"><a class="permalink" href="#Description~10"><b>Description</b></a></dt>
  <dd>Recompute the layer 3 (e.g. IP) checksum for the packet associated to
      <i>skb</i>. Computation is incremental, so the helper must know the former
      value of the header field that was modified (<i>from</i>), the new value
      of this field (<i>to</i>), and the number of bytes (2 or 4) for this
      field, stored in <i>size</i>. Alternatively, it is possible to store the
      difference between the previous and the new values of the header field in
      <i>to</i>, by setting <i>from</i> and <i>size</i> to 0. For both methods,
      <i>offset</i> indicates the location of the IP checksum within the packet.
    <p class="Pp">This helper works in combination with <b>bpf_csum_diff</b>(),
        which does not update the checksum in-place, but offers more flexibility
        and can handle sizes larger than 2 or 4 for the checksum to update.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~10"><a class="permalink" href="#Return~10"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~7"><a class="permalink" href="#long~7"><b><b>long
    bpf_l4_csum_replace(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, u64</b> <i>from</i><b>, u64</b> <i>to</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~11"><a class="permalink" href="#Description~11"><b>Description</b></a></dt>
  <dd>Recompute the layer 4 (e.g. TCP, UDP or ICMP) checksum for the packet
      associated to <i>skb</i>. Computation is incremental, so the helper must
      know the former value of the header field that was modified (<i>from</i>),
      the new value of this field (<i>to</i>), and the number of bytes (2 or 4)
      for this field, stored on the lowest four bits of <i>flags</i>.
      Alternatively, it is possible to store the difference between the previous
      and the new values of the header field in <i>to</i>, by setting
      <i>from</i> and the four lowest bits of <i>flags</i> to 0. For both
      methods, <i>offset</i> indicates the location of the IP checksum within
      the packet. In addition to the size of the field, <i>flags</i> can be
      added (bitwise OR) actual flags. With <b>BPF_F_MARK_MANGLED_0</b>, a null
      checksum is left untouched (unless <b>BPF_F_MARK_ENFORCE</b> is added as
      well), and for updates resulting in a null checksum the value is set to
      <b>CSUM_MANGLED_0</b> instead. Flag <b>BPF_F_PSEUDO_HDR</b> indicates the
      checksum is to be computed against a pseudo-header.
    <p class="Pp">This helper works in combination with <b>bpf_csum_diff</b>(),
        which does not update the checksum in-place, but offers more flexibility
        and can handle sizes larger than 2 or 4 for the checksum to update.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~11"><a class="permalink" href="#Return~11"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~8"><a class="permalink" href="#long~8"><b><b>long
    bpf_tail_call(void *</b><i>ctx</i><b>, struct bpf_map
    *</b><i>prog_array_map</i><b>, u32</b> <i>index</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~12"><a class="permalink" href="#Description~12"><b>Description</b></a></dt>
  <dd>This special helper is used to trigger a "tail call", or in
      other words, to jump into another eBPF program. The same stack frame is
      used (but values on stack and in registers for the caller are not
      accessible to the callee). This mechanism allows for program chaining,
      either for raising the maximum number of available eBPF instructions, or
      to execute given programs in conditional blocks. For security reasons,
      there is an upper limit to the number of successive tail calls that can be
      performed.
    <p class="Pp">Upon call of this helper, the program attempts to jump into a
        program referenced at index <i>index</i> in <i>prog_array_map</i>, a
        special map of type <b>BPF_MAP_TYPE_PROG_ARRAY</b>, and passes
        <i>ctx</i>, a pointer to the context.</p>
    <p class="Pp">If the call succeeds, the kernel immediately runs the first
        instruction of the new program. This is not a function call, and it
        never returns to the previous program. If the call fails, then the
        helper has no effect, and the caller continues to run its subsequent
        instructions. A call can fail if the destination program for the jump
        does not exist (i.e. <i>index</i> is superior to the number of entries
        in <i>prog_array_map</i>), or if the maximum number of tail calls has
        been reached for this chain of programs. This limit is defined in the
        kernel by the macro <b>MAX_TAIL_CALL_CNT</b> (not accessible to user
        space), which is currently set to 33.</p>
  </dd>
  <dt id="Return~12"><a class="permalink" href="#Return~12"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~9"><a class="permalink" href="#long~9"><b><b>long
    bpf_clone_redirect(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>ifindex</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~13"><a class="permalink" href="#Description~13"><b>Description</b></a></dt>
  <dd>Clone and redirect the packet associated to <i>skb</i> to another net
      device of index <i>ifindex</i>. Both ingress and egress interfaces can be
      used for redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is
      used to make the distinction (ingress path is selected if the flag is
      present, egress path otherwise). This is the only flag supported for now.
    <p class="Pp">In comparison with <b>bpf_redirect</b>() helper,
        <b>bpf_clone_redirect</b>() has the associated cost of duplicating the
        packet buffer, but this can be executed out of the eBPF program.
        Conversely, <b>bpf_redirect</b>() is more efficient, but it is handled
        through an action code where the redirection happens only after the eBPF
        program has returned.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~13"><a class="permalink" href="#Return~13"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~2"><a class="permalink" href="#u64~2"><b><b>u64
    bpf_get_current_pid_tgid(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~14"><a class="permalink" href="#Description~14"><b>Description</b></a></dt>
  <dd>Get the current pid and tgid.</dd>
  <dt id="Return~14"><a class="permalink" href="#Return~14"><b>Return</b></a></dt>
  <dd>A 64-bit integer containing the current tgid and pid, and created as such:
      <i>current_task</i><b>-&gt;tgid &lt;&lt; 32 |</b>
      <i>current_task</i><b>-&gt;pid</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~3"><a class="permalink" href="#u64~3"><b><b>u64
    bpf_get_current_uid_gid(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~15"><a class="permalink" href="#Description~15"><b>Description</b></a></dt>
  <dd>Get the current uid and gid.</dd>
  <dt id="Return~15"><a class="permalink" href="#Return~15"><b>Return</b></a></dt>
  <dd>A 64-bit integer containing the current GID and UID, and created as such:
      <i>current_gid</i> <b>&lt;&lt; 32 |</b> <i>current_uid</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~10"><a class="permalink" href="#long~10"><b><b>long
    bpf_get_current_comm(void *</b><i>buf</i><b>, u32</b>
    <i>size_of_buf</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~16"><a class="permalink" href="#Description~16"><b>Description</b></a></dt>
  <dd>Copy the <b>comm</b> attribute of the current task into <i>buf</i> of
      <i>size_of_buf</i>. The <b>comm</b> attribute contains the name of the
      executable (excluding the path) for the current task. The
      <i>size_of_buf</i> must be strictly positive. On success, the helper makes
      sure that the <i>buf</i> is NUL-terminated. On failure, it is filled with
      zeroes.</dd>
  <dt id="Return~16"><a class="permalink" href="#Return~16"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32~3"><a class="permalink" href="#u32~3"><b><b>u32
    bpf_get_cgroup_classid(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~17"><a class="permalink" href="#Description~17"><b>Description</b></a></dt>
  <dd>Retrieve the classid for the current task, i.e. for the net_cls cgroup to
      which <i>skb</i> belongs.
    <p class="Pp">This helper can be used on TC egress path, but not on
      ingress.</p>
    <p class="Pp">The net_cls cgroup provides an interface to tag network
        packets based on a user-provided identifier for all traffic coming from
        the tasks belonging to the related cgroup. See also the related kernel
        documentation, available from the Linux sources in file
        <i>Documentation/admin-guide/cgroup-v1/net_cls.rst</i>.</p>
    <p class="Pp">The Linux kernel has two versions for cgroups: there are
        cgroups v1 and cgroups v2. Both are available to users, who can use a
        mixture of them, but note that the net_cls cgroup is for cgroup v1 only.
        This makes it incompatible with BPF programs run on cgroups, which is a
        cgroup-v2-only feature (a socket can only hold data for one version of
        cgroups at a time).</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_CGROUP_NET_CLASSID</b> configuration option set to
        "<b>y</b>" or to "<b>m</b>".</p>
  </dd>
  <dt id="Return~17"><a class="permalink" href="#Return~17"><b>Return</b></a></dt>
  <dd>The classid, or 0 for the default unconfigured classid.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~11"><a class="permalink" href="#long~11"><b><b>long
    bpf_skb_vlan_push(struct sk_buff *</b><i>skb</i><b>, __be16</b>
    <i>vlan_proto</i><b>, u16</b> <i>vlan_tci</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~18"><a class="permalink" href="#Description~18"><b>Description</b></a></dt>
  <dd>Push a <i>vlan_tci</i> (VLAN tag control information) of protocol
      <i>vlan_proto</i> to the packet associated to <i>skb</i>, then update the
      checksum. Note that if <i>vlan_proto</i> is different from
      <b>ETH_P_8021Q</b> and <b>ETH_P_8021AD</b>, it is considered to be
      <b>ETH_P_8021Q</b>.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~18"><a class="permalink" href="#Return~18"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~12"><a class="permalink" href="#long~12"><b><b>long
    bpf_skb_vlan_pop(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~19"><a class="permalink" href="#Description~19"><b>Description</b></a></dt>
  <dd>Pop a VLAN header from the packet associated to <i>skb</i>.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~19"><a class="permalink" href="#Return~19"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~13"><a class="permalink" href="#long~13"><b><b>long
    bpf_skb_get_tunnel_key(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_tunnel_key *</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~20"><a class="permalink" href="#Description~20"><b>Description</b></a></dt>
  <dd>Get tunnel metadata. This helper takes a pointer <i>key</i> to an empty
      <b>struct bpf_tunnel_key</b> of <b>size</b>, that will be filled with
      tunnel metadata for the packet associated to <i>skb</i>. The <i>flags</i>
      can be set to <b>BPF_F_TUNINFO_IPV6</b>, which indicates that the tunnel
      is based on IPv6 protocol instead of IPv4.
    <p class="Pp">The <b>struct bpf_tunnel_key</b> is an object that generalizes
        the principal parameters used by various tunneling protocols into a
        single struct. This way, it can be used to easily make a decision based
        on the contents of the encapsulation header, "summarized" in
        this struct. In particular, it holds the IP address of the remote end
        (IPv4 or IPv6, depending on the case) in
        <i>key</i><b>-&gt;remote_ipv4</b> or <i>key</i><b>-&gt;remote_ipv6</b>.
        Also, this struct exposes the <i>key</i><b>-&gt;tunnel_id</b>, which is
        generally mapped to a VNI (Virtual Network Identifier), making it
        programmable together with the <b>bpf_skb_set_tunnel_key</b>()
      helper.</p>
    <p class="Pp">Let's imagine that the following code is part of a program
        attached to the TC ingress interface, on one end of a GRE tunnel, and is
        supposed to filter out all messages coming from remote ends with IPv4
        address other than 10.0.0.1:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>int ret;
struct bpf_tunnel_key key = {};
ret = bpf_skb_get_tunnel_key(skb, &amp;key, sizeof(key), 0);
if (ret &lt; 0)
<br>
        return TC_ACT_SHOT;     // drop packet
if (key.remote_ipv4 != 0x0a000001)
<br>
        return TC_ACT_SHOT;     // drop packet
return TC_ACT_OK;               // accept packet
</pre>
</div>
<br>
</div>
<br>
<p class="Pp">This interface can also be used with all encapsulation devices
    that can operate in "collect metadata" mode: instead of having one
    network device per specific configuration, the "collect metadata"
    mode only requires a single device where the configuration can be extracted
    from this helper.</p>
<p class="Pp">This can be used together with various tunnels such as VXLan,
    Geneve, GRE or IP in IP (IPIP).</p>
<dl class="Bl-tag">
  <dt id="Return~20"><a class="permalink" href="#Return~20"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~14"><a class="permalink" href="#long~14"><b><b>long
    bpf_skb_set_tunnel_key(struct sk_buff *</b><i>skb</i><b>, struct
    bpf_tunnel_key *</b><i>key</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~21"><a class="permalink" href="#Description~21"><b>Description</b></a></dt>
  <dd>Populate tunnel metadata for packet associated to <i>skb.</i> The tunnel
      metadata is set to the contents of <i>key</i>, of <i>size</i>. The
      <i>flags</i> can be set to a combination of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_F_TUNINFO_IPV6"><a class="permalink" href="#BPF_F_TUNINFO_IPV6"><b><b>BPF_F_TUNINFO_IPV6</b></b></a></dt>
  <dd>Indicate that the tunnel is based on IPv6 protocol instead of IPv4.</dd>
  <dt id="BPF_F_ZERO_CSUM_TX"><a class="permalink" href="#BPF_F_ZERO_CSUM_TX"><b><b>BPF_F_ZERO_CSUM_TX</b></b></a></dt>
  <dd>For IPv4 packets, add a flag to tunnel metadata indicating that checksum
      computation should be skipped and checksum set to zeroes.</dd>
  <dt id="BPF_F_DONT_FRAGMENT"><a class="permalink" href="#BPF_F_DONT_FRAGMENT"><b><b>BPF_F_DONT_FRAGMENT</b></b></a></dt>
  <dd>Add a flag to tunnel metadata indicating that the packet should not be
      fragmented.</dd>
  <dt id="BPF_F_SEQ_NUMBER"><a class="permalink" href="#BPF_F_SEQ_NUMBER"><b><b>BPF_F_SEQ_NUMBER</b></b></a></dt>
  <dd>Add a flag to tunnel metadata indicating that a sequence number should be
      added to tunnel header before sending the packet. This flag was added for
      GRE encapsulation, but might be used with other protocols as well in the
      future.</dd>
</dl>
</div>
<br>
<p class="Pp">Here is a typical usage on the transmit path:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>struct bpf_tunnel_key key;
<br>
     populate key ...
bpf_skb_set_tunnel_key(skb, &amp;key, sizeof(key), 0);
bpf_clone_redirect(skb, vxlan_dev_ifindex, 0);
</pre>
</div>
<br>
</div>
<br>
<p class="Pp">See also the description of the <b>bpf_skb_get_tunnel_key</b>()
    helper for additional information.</p>
<dl class="Bl-tag">
  <dt id="Return~21"><a class="permalink" href="#Return~21"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~4"><a class="permalink" href="#u64~4"><b><b>u64
    bpf_perf_event_read(struct bpf_map *</b><i>map</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~22"><a class="permalink" href="#Description~22"><b>Description</b></a></dt>
  <dd>Read the value of a perf event counter. This helper relies on a <i>map</i>
      of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf event
      counter is selected when <i>map</i> is updated with perf event file
      descriptors. The <i>map</i> is an array whose size is the number of
      available CPUs, and each cell contains a value relative to one CPU. The
      value to retrieve is indicated by <i>flags</i>, that contains the index of
      the CPU to look up, masked with <b>BPF_F_INDEX_MASK</b>. Alternatively,
      <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to indicate that the
      value for the current CPU should be retrieved.
    <p class="Pp">Note that before Linux 4.13, only hardware perf event can be
        retrieved.</p>
    <p class="Pp">Also, be aware that the newer helper
        <b>bpf_perf_event_read_value</b>() is recommended over
        <b>bpf_perf_event_read</b>() in general. The latter has some ABI quirks
        where error and counter value are used as a return code (which is wrong
        to do since ranges may overlap). This issue is fixed with
        <b>bpf_perf_event_read_value</b>(), which at the same time provides more
        features over the <b>bpf_perf_event_read</b>() interface. Please refer
        to the description of <b>bpf_perf_event_read_value</b>() for
      details.</p>
  </dd>
  <dt id="Return~22"><a class="permalink" href="#Return~22"><b>Return</b></a></dt>
  <dd>The value of the perf event counter read from the map, or a negative error
      code in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~15"><a class="permalink" href="#long~15"><b><b>long
    bpf_redirect(u32</b> <i>ifindex</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~23"><a class="permalink" href="#Description~23"><b>Description</b></a></dt>
  <dd>Redirect the packet to another net device of index <i>ifindex</i>. This
      helper is somewhat similar to <b>bpf_clone_redirect</b>(), except that the
      packet is not cloned, which provides increased performance.
    <p class="Pp">Except for XDP, both ingress and egress interfaces can be used
        for redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is used
        to make the distinction (ingress path is selected if the flag is
        present, egress path otherwise). Currently, XDP only supports
        redirection to the egress interface, and accepts no flag at all.</p>
    <p class="Pp">The same effect can also be attained with the more generic
        <b>bpf_redirect_map</b>(), which uses a BPF map to store the redirect
        target instead of providing it directly to the helper.</p>
  </dd>
  <dt id="Return~23"><a class="permalink" href="#Return~23"><b>Return</b></a></dt>
  <dd>For XDP, the helper returns <b>XDP_REDIRECT</b> on success or
      <b>XDP_ABORTED</b> on error. For other program types, the values are
      <b>TC_ACT_REDIRECT</b> on success or <b>TC_ACT_SHOT</b> on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32~4"><a class="permalink" href="#u32~4"><b><b>u32
    bpf_get_route_realm(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~24"><a class="permalink" href="#Description~24"><b>Description</b></a></dt>
  <dd>Retrieve the realm or the route, that is to say the <b>tclassid</b> field
      of the destination for the <i>skb</i>. The identifier retrieved is a
      user-provided tag, similar to the one used with the net_cls cgroup (see
      description for <b>bpf_get_cgroup_classid</b>() helper), but here this tag
      is held by a route (a destination entry), not by a task.
    <p class="Pp">Retrieving this identifier works with the clsact TC egress
        hook (see also <b>tc-bpf(8)</b>), or alternatively on conventional
        classful egress qdiscs, but not on TC ingress path. In case of clsact TC
        egress hook, this has the advantage that, internally, the destination
        entry has not been dropped yet in the transmit path. Therefore, the
        destination entry does not need to be artificially held via
        <b>netif_keep_dst</b>() for a classful qdisc until the <i>skb</i> is
        freed.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_IP_ROUTE_CLASSID</b> configuration option.</p>
  </dd>
  <dt id="Return~24"><a class="permalink" href="#Return~24"><b>Return</b></a></dt>
  <dd>The realm of the route for the packet associated to <i>skb</i>, or 0 if
      none was found.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~16"><a class="permalink" href="#long~16"><b><b>long
    bpf_perf_event_output(void *</b><i>ctx</i><b>, struct bpf_map
    *</b><i>map</i><b>, u64</b> <i>flags</i><b>, void *</b><i>data</i><b>,
    u64</b> <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~25"><a class="permalink" href="#Description~25"><b>Description</b></a></dt>
  <dd>Write raw <i>data</i> blob into a special BPF perf event held by
      <i>map</i> of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event
      must have the following attributes: <b>PERF_SAMPLE_RAW</b> as
      <b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as <b>type</b>, and
      <b>PERF_COUNT_SW_BPF_OUTPUT</b> as <b>config</b>.
    <p class="Pp">The <i>flags</i> are used to indicate the index in <i>map</i>
        for which the value must be put, masked with <b>BPF_F_INDEX_MASK</b>.
        Alternatively, <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to
        indicate that the index of the current CPU core should be used.</p>
    <p class="Pp">The value to write, of <i>size</i>, is passed through eBPF
        stack and pointed by <i>data</i>.</p>
    <p class="Pp">The context of the program <i>ctx</i> needs also be passed to
        the helper.</p>
    <p class="Pp">On user space, a program willing to read the values needs to
        call <b>perf_event_open</b>() on the perf event (either for one or for
        all CPUs) and to store the file descriptor into the <i>map</i>. This
        must be done before the eBPF program can send data into it. An example
        is available in file <i>samples/bpf/trace_output_user.c</i> in the Linux
        kernel source tree (the eBPF program counterpart is in
        <i>samples/bpf/trace_output_kern.c</i>).</p>
    <p class="Pp"><b>bpf_perf_event_output</b>() achieves better performance
        than <b>bpf_trace_printk</b>() for sharing data with user space, and is
        much better suitable for streaming data from eBPF programs.</p>
    <p class="Pp">Note that this helper is not restricted to tracing use cases
        and can be used with programs attached to TC or XDP as well, where it
        allows for passing data to user space listeners. Data can be:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>Only custom structs,</dd>
  <dt>•</dt>
  <dd>Only the packet payload, or</dd>
  <dt>•</dt>
  <dd>A combination of both.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~25"><a class="permalink" href="#Return~25"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~17"><a class="permalink" href="#long~17"><b><b>long
    bpf_skb_load_bytes(const void *</b><i>skb</i><b>, u32</b> <i>offset</i><b>,
    void *</b><i>to</i><b>, u32</b> <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~26"><a class="permalink" href="#Description~26"><b>Description</b></a></dt>
  <dd>This helper was provided as an easy way to load data from a packet. It can
      be used to load <i>len</i> bytes from <i>offset</i> from the packet
      associated to <i>skb</i>, into the buffer pointed by <i>to</i>.
    <p class="Pp">Since Linux 4.7, usage of this helper has mostly been replaced
        by "direct packet access", enabling packet data to be
        manipulated with <i>skb</i><b>-&gt;data</b> and
        <i>skb</i><b>-&gt;data_end</b> pointing respectively to the first byte
        of packet data and to the byte after the last byte of packet data.
        However, it remains useful if one wishes to read large quantities of
        data at once from a packet into the eBPF stack.</p>
  </dd>
  <dt id="Return~26"><a class="permalink" href="#Return~26"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~18"><a class="permalink" href="#long~18"><b><b>long
    bpf_get_stackid(void *</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~27"><a class="permalink" href="#Description~27"><b>Description</b></a></dt>
  <dd>Walk a user or a kernel stack and return its id. To achieve this, the
      helper needs <i>ctx</i>, which is a pointer to the context on which the
      tracing program is executed, and a pointer to a <i>map</i> of type
      <b>BPF_MAP_TYPE_STACK_TRACE</b>.
    <p class="Pp">The last argument, <i>flags</i>, holds the number of stack
        frames to skip (from 0 to 255), masked with
        <b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to set a
        combination of the following flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_F_USER_STACK"><a class="permalink" href="#BPF_F_USER_STACK"><b><b>BPF_F_USER_STACK</b></b></a></dt>
  <dd>Collect a user space stack instead of a kernel stack.</dd>
  <dt id="BPF_F_FAST_STACK_CMP"><a class="permalink" href="#BPF_F_FAST_STACK_CMP"><b><b>BPF_F_FAST_STACK_CMP</b></b></a></dt>
  <dd>Compare stacks by hash only.</dd>
  <dt id="BPF_F_REUSE_STACKID"><a class="permalink" href="#BPF_F_REUSE_STACKID"><b><b>BPF_F_REUSE_STACKID</b></b></a></dt>
  <dd>If two different stacks hash into the same <i>stackid</i>, discard the old
      one.</dd>
</dl>
</div>
<br>
<p class="Pp">The stack id retrieved is a 32 bit long integer handle which can
    be further combined with other data (including other stack ids) and used as
    a key into maps. This can be useful for generating a variety of graphs (such
    as flame graphs or off-cpu graphs).</p>
<p class="Pp">For walking a stack, this helper is an improvement over
    <b>bpf_probe_read</b>(), which can be used with unrolled loops but is not
    efficient and consumes a lot of eBPF instructions. Instead,
    <b>bpf_get_stackid</b>() can collect up to <b>PERF_MAX_STACK_DEPTH</b> both
    kernel and user frames. Note that this limit can be controlled with the
    <b>sysctl</b> program, and that it should be manually increased in order to
    profile long user stacks (such as stacks for Java programs). To do so,
  use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~27"><a class="permalink" href="#Return~27"><b>Return</b></a></dt>
  <dd>The positive or null stack id on success, or a negative error in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="s64"><a class="permalink" href="#s64"><b><b>s64 bpf_csum_diff(__be32
    *</b><i>from</i><b>, u32</b> <i>from_size</i><b>, __be32 *</b><i>to</i><b>,
    u32</b> <i>to_size</i><b>, __wsum</b> <i>seed</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~28"><a class="permalink" href="#Description~28"><b>Description</b></a></dt>
  <dd>Compute a checksum difference, from the raw buffer pointed by <i>from</i>,
      of length <i>from_size</i> (that must be a multiple of 4), towards the raw
      buffer pointed by <i>to</i>, of size <i>to_size</i> (same remark). An
      optional <i>seed</i> can be added to the value (this can be cascaded, the
      seed may come from a previous call to the helper).
    <p class="Pp">This is flexible enough to be used in several ways:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>With <i>from_size</i> == 0, <i>to_size</i> &gt; 0 and <i>seed</i> set to
      checksum, it can be used when pushing new data.</dd>
  <dt>•</dt>
  <dd>With <i>from_size</i> &gt; 0, <i>to_size</i> == 0 and <i>seed</i> set to
      checksum, it can be used when removing data from a packet.</dd>
  <dt>•</dt>
  <dd>With <i>from_size</i> &gt; 0, <i>to_size</i> &gt; 0 and <i>seed</i> set to
      0, it can be used to compute a diff. Note that <i>from_size</i> and
      <i>to_size</i> do not need to be equal.</dd>
</dl>
</div>
<br>
<p class="Pp">This helper can be used in combination with
    <b>bpf_l3_csum_replace</b>() and <b>bpf_l4_csum_replace</b>(), to which one
    can feed in the difference computed with <b>bpf_csum_diff</b>().</p>
<dl class="Bl-tag">
  <dt id="Return~28"><a class="permalink" href="#Return~28"><b>Return</b></a></dt>
  <dd>The checksum result, or a negative error code in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~19"><a class="permalink" href="#long~19"><b><b>long
    bpf_skb_get_tunnel_opt(struct sk_buff *</b><i>skb</i><b>, void
    *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~29"><a class="permalink" href="#Description~29"><b>Description</b></a></dt>
  <dd>Retrieve tunnel options metadata for the packet associated to <i>skb</i>,
      and store the raw tunnel option data to the buffer <i>opt</i> of
      <i>size</i>.
    <p class="Pp">This helper can be used with encapsulation devices that can
        operate in "collect metadata" mode (please refer to the
        related note in the description of <b>bpf_skb_get_tunnel_key</b>() for
        more details). A particular example where this can be used is in
        combination with the Geneve encapsulation protocol, where it allows for
        pushing (with <b>bpf_skb_get_tunnel_opt</b>() helper) and retrieving
        arbitrary TLVs (Type-Length-Value headers) from the eBPF program. This
        allows for full customization of these headers.</p>
  </dd>
  <dt id="Return~29"><a class="permalink" href="#Return~29"><b>Return</b></a></dt>
  <dd>The size of the option data retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~20"><a class="permalink" href="#long~20"><b><b>long
    bpf_skb_set_tunnel_opt(struct sk_buff *</b><i>skb</i><b>, void
    *</b><i>opt</i><b>, u32</b> <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~30"><a class="permalink" href="#Description~30"><b>Description</b></a></dt>
  <dd>Set tunnel options metadata for the packet associated to <i>skb</i> to the
      option data contained in the raw buffer <i>opt</i> of <i>size</i>.
    <p class="Pp">See also the description of the
        <b>bpf_skb_get_tunnel_opt</b>() helper for additional information.</p>
  </dd>
  <dt id="Return~30"><a class="permalink" href="#Return~30"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~21"><a class="permalink" href="#long~21"><b><b>long
    bpf_skb_change_proto(struct sk_buff *</b><i>skb</i><b>, __be16</b>
    <i>proto</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~31"><a class="permalink" href="#Description~31"><b>Description</b></a></dt>
  <dd>Change the protocol of the <i>skb</i> to <i>proto</i>. Currently supported
      are transition from IPv4 to IPv6, and from IPv6 to IPv4. The helper takes
      care of the groundwork for the transition, including resizing the socket
      buffer. The eBPF program is expected to fill the new headers, if any, via
      <b>skb_store_bytes</b>() and to recompute the checksums with
      <b>bpf_l3_csum_replace</b>() and <b>bpf_l4_csum_replace</b>(). The main
      case for this helper is to perform NAT64 operations out of an eBPF
      program.
    <p class="Pp">Internally, the GSO type is marked as dodgy so that headers
        are checked and segments are recalculated by the GSO/GRO engine. The
        size for GSO target is adapted as well.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~31"><a class="permalink" href="#Return~31"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~22"><a class="permalink" href="#long~22"><b><b>long
    bpf_skb_change_type(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>type</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~32"><a class="permalink" href="#Description~32"><b>Description</b></a></dt>
  <dd>Change the packet type for the packet associated to <i>skb</i>. This comes
      down to setting <i>skb</i><b>-&gt;pkt_type</b> to <i>type</i>, except the
      eBPF program does not have a write access to
      <i>skb</i><b>-&gt;pkt_type</b> beside this helper. Using a helper here
      allows for graceful handling of errors.
    <p class="Pp">The major use case is to change incoming <i>skb*s to</i>
        <i>**PACKET_HOST*</i> in a programmatic way instead of having to
        recirculate via <b>redirect</b>(..., <b>BPF_F_INGRESS</b>), for
      example.</p>
    <p class="Pp">Note that <i>type</i> only allows certain values. At this
        time, they are:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="PACKET_HOST"><a class="permalink" href="#PACKET_HOST"><b><b>PACKET_HOST</b></b></a></dt>
  <dd>Packet is for us.</dd>
  <dt id="PACKET_BROADCAST"><a class="permalink" href="#PACKET_BROADCAST"><b><b>PACKET_BROADCAST</b></b></a></dt>
  <dd>Send packet to all.</dd>
  <dt id="PACKET_MULTICAST"><a class="permalink" href="#PACKET_MULTICAST"><b><b>PACKET_MULTICAST</b></b></a></dt>
  <dd>Send packet to group.</dd>
  <dt id="PACKET_OTHERHOST"><a class="permalink" href="#PACKET_OTHERHOST"><b><b>PACKET_OTHERHOST</b></b></a></dt>
  <dd>Send packet to someone else.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~32"><a class="permalink" href="#Return~32"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~23"><a class="permalink" href="#long~23"><b><b>long
    bpf_skb_under_cgroup(struct sk_buff *</b><i>skb</i><b>, struct bpf_map
    *</b><i>map</i><b>, u32</b> <i>index</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~33"><a class="permalink" href="#Description~33"><b>Description</b></a></dt>
  <dd>Check whether <i>skb</i> is a descendant of the cgroup2 held by <i>map</i>
      of type <b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</dd>
  <dt id="Return~33"><a class="permalink" href="#Return~33"><b>Return</b></a></dt>
  <dd>The return value depends on the result of the test, and can be:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>0, if the <i>skb</i> failed the cgroup2 descendant test.</dd>
  <dt>•</dt>
  <dd>1, if the <i>skb</i> succeeded the cgroup2 descendant test.</dd>
  <dt>•</dt>
  <dd>A negative error code, if an error occurred.</dd>
</dl>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32~5"><a class="permalink" href="#u32~5"><b><b>u32
    bpf_get_hash_recalc(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~34"><a class="permalink" href="#Description~34"><b>Description</b></a></dt>
  <dd>Retrieve the hash of the packet, <i>skb</i><b>-&gt;hash</b>. If it is not
      set, in particular if the hash was cleared due to mangling, recompute this
      hash. Later accesses to the hash can be done directly with
      <i>skb</i><b>-&gt;hash</b>.
    <p class="Pp">Calling <b>bpf_set_hash_invalid</b>(), changing a packet
        prototype with <b>bpf_skb_change_proto</b>(), or calling
        <b>bpf_skb_store_bytes</b>() with the <b>BPF_F_INVALIDATE_HASH</b> are
        actions susceptible to clear the hash and to trigger a new computation
        for the next call to <b>bpf_get_hash_recalc</b>().</p>
  </dd>
  <dt id="Return~34"><a class="permalink" href="#Return~34"><b>Return</b></a></dt>
  <dd>The 32-bit hash.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~5"><a class="permalink" href="#u64~5"><b><b>u64
    bpf_get_current_task(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~35"><a class="permalink" href="#Description~35"><b>Description</b></a></dt>
  <dd>Get the current task.</dd>
  <dt id="Return~35"><a class="permalink" href="#Return~35"><b>Return</b></a></dt>
  <dd>A pointer to the current task struct.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~24"><a class="permalink" href="#long~24"><b><b>long
    bpf_probe_write_user(void *</b><i>dst</i><b>, const void *</b><i>src</i><b>,
    u32</b> <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~36"><a class="permalink" href="#Description~36"><b>Description</b></a></dt>
  <dd>Attempt in a safe way to write <i>len</i> bytes from the buffer <i>src</i>
      to <i>dst</i> in memory. It only works for threads that are in user
      context, and <i>dst</i> must be a valid user space address.
    <p class="Pp">This helper should not be used to implement any kind of
        security mechanism because of TOC-TOU attacks, but rather to debug,
        divert, and manipulate execution of semi-cooperative processes.</p>
    <p class="Pp">Keep in mind that this feature is meant for experiments, and
        it has a risk of crashing the system and running programs. Therefore,
        when an eBPF program using this helper is attached, a warning including
        PID and process name is printed to kernel logs.</p>
  </dd>
  <dt id="Return~36"><a class="permalink" href="#Return~36"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~25"><a class="permalink" href="#long~25"><b><b>long
    bpf_current_task_under_cgroup(struct bpf_map *</b><i>map</i><b>, u32</b>
    <i>index</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~37"><a class="permalink" href="#Description~37"><b>Description</b></a></dt>
  <dd>Check whether the probe is being run is the context of a given subset of
      the cgroup2 hierarchy. The cgroup2 to test is held by <i>map</i> of type
      <b>BPF_MAP_TYPE_CGROUP_ARRAY</b>, at <i>index</i>.</dd>
  <dt id="Return~37"><a class="permalink" href="#Return~37"><b>Return</b></a></dt>
  <dd>The return value depends on the result of the test, and can be:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>1, if current task belongs to the cgroup2.</dd>
  <dt>•</dt>
  <dd>0, if current task does not belong to the cgroup2.</dd>
  <dt>•</dt>
  <dd>A negative error code, if an error occurred.</dd>
</dl>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~26"><a class="permalink" href="#long~26"><b><b>long
    bpf_skb_change_tail(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~38"><a class="permalink" href="#Description~38"><b>Description</b></a></dt>
  <dd>Resize (trim or grow) the packet associated to <i>skb</i> to the new
      <i>len</i>. The <i>flags</i> are reserved for future usage, and must be
      left at zero.
    <p class="Pp">The basic idea is that the helper performs the needed work to
        change the size of the packet, then the eBPF program rewrites the rest
        via helpers like <b>bpf_skb_store_bytes</b>(),
        <b>bpf_l3_csum_replace</b>(), <b>bpf_l3_csum_replace</b>() and others.
        This helper is a slow path utility intended for replies with control
        messages. And because it is targeted for slow path, the helper itself
        can afford to be slow: it implicitly linearizes, unclones and drops
        offloads from the <i>skb</i>.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~38"><a class="permalink" href="#Return~38"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~27"><a class="permalink" href="#long~27"><b><b>long
    bpf_skb_pull_data(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~39"><a class="permalink" href="#Description~39"><b>Description</b></a></dt>
  <dd>Pull in non-linear data in case the <i>skb</i> is non-linear and not all
      of <i>len</i> are part of the linear section. Make <i>len</i> bytes from
      <i>skb</i> readable and writable. If a zero value is passed for
      <i>len</i>, then all bytes in the linear part of <i>skb</i> will be made
      readable and writable.
    <p class="Pp">This helper is only needed for reading and writing with direct
        packet access.</p>
    <p class="Pp">For direct packet access, testing that offsets to access are
        within packet boundaries (test on <i>skb</i><b>-&gt;data_end</b>) is
        susceptible to fail if offsets are invalid, or if the requested data is
        in non-linear parts of the <i>skb</i>. On failure the program can just
        bail out, or in the case of a non-linear buffer, use a helper to make
        the data available. The <b>bpf_skb_load_bytes</b>() helper is a first
        solution to access the data. Another one consists in using
        <b>bpf_skb_pull_data</b> to pull in once the non-linear parts, then
        retesting and eventually access the data.</p>
    <p class="Pp">At the same time, this also makes sure the <i>skb</i> is
        uncloned, which is a necessary condition for direct write. As this needs
        to be an invariant for the write part only, the verifier detects writes
        and adds a prologue that is calling <b>bpf_skb_pull_data()</b> to
        effectively unclone the <i>skb</i> from the very beginning in case it is
        indeed cloned.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~39"><a class="permalink" href="#Return~39"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="s64~2"><a class="permalink" href="#s64~2"><b><b>s64
    bpf_csum_update(struct sk_buff *</b><i>skb</i><b>, __wsum</b>
    <i>csum</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~40"><a class="permalink" href="#Description~40"><b>Description</b></a></dt>
  <dd>Add the checksum <i>csum</i> into <i>skb</i><b>-&gt;csum</b> in case the
      driver has supplied a checksum for the entire packet into that field.
      Return an error otherwise. This helper is intended to be used in
      combination with <b>bpf_csum_diff</b>(), in particular when the checksum
      needs to be updated after data has been written into the packet through
      direct packet access.</dd>
  <dt id="Return~40"><a class="permalink" href="#Return~40"><b>Return</b></a></dt>
  <dd>The checksum on success, or a negative error code in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~2"><a class="permalink" href="#void~2"><b><b>void
    bpf_set_hash_invalid(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~41"><a class="permalink" href="#Description~41"><b>Description</b></a></dt>
  <dd>Invalidate the current <i>skb</i><b>-&gt;hash</b>. It can be used after
      mangling on headers through direct packet access, in order to indicate
      that the hash is outdated and to trigger a recalculation the next time the
      kernel tries to access this hash or when the <b>bpf_get_hash_recalc</b>()
      helper is called.</dd>
  <dt id="Return~41"><a class="permalink" href="#Return~41"><b>Return</b></a></dt>
  <dd>void.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~28"><a class="permalink" href="#long~28"><b><b>long
    bpf_get_numa_node_id(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~42"><a class="permalink" href="#Description~42"><b>Description</b></a></dt>
  <dd>Return the id of the current NUMA node. The primary use case for this
      helper is the selection of sockets for the local NUMA node, when the
      program is attached to sockets using the <b>SO_ATTACH_REUSEPORT_EBPF</b>
      option (see also <b>socket(7)</b>), but the helper is also available to
      other eBPF program types, similarly to
    <b>bpf_get_smp_processor_id</b>().</dd>
  <dt id="Return~42"><a class="permalink" href="#Return~42"><b>Return</b></a></dt>
  <dd>The id of current NUMA node.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~29"><a class="permalink" href="#long~29"><b><b>long
    bpf_skb_change_head(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>len</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~43"><a class="permalink" href="#Description~43"><b>Description</b></a></dt>
  <dd>Grows headroom of packet associated to <i>skb</i> and adjusts the offset
      of the MAC header accordingly, adding <i>len</i> bytes of space. It
      automatically extends and reallocates memory as required.
    <p class="Pp">This helper can be used on a layer 3 <i>skb</i> to push a MAC
        header for redirection into a layer 2 device.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~43"><a class="permalink" href="#Return~43"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~30"><a class="permalink" href="#long~30"><b><b>long
    bpf_xdp_adjust_head(struct xdp_buff *</b><i>xdp_md</i><b>, int</b>
    <i>delta</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~44"><a class="permalink" href="#Description~44"><b>Description</b></a></dt>
  <dd>Adjust (move) <i>xdp_md</i><b>-&gt;data</b> by <i>delta</i> bytes. Note
      that it is possible to use a negative value for <i>delta</i>. This helper
      can be used to prepare the packet for pushing or popping headers.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~44"><a class="permalink" href="#Return~44"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~31"><a class="permalink" href="#long~31"><b><b>long
    bpf_probe_read_str(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>, const
    void *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~45"><a class="permalink" href="#Description~45"><b>Description</b></a></dt>
  <dd>Copy a NUL terminated string from an unsafe kernel address
      <i>unsafe_ptr</i> to <i>dst</i>. See <b>bpf_probe_read_kernel_str</b>()
      for more details.
    <p class="Pp">Generally, use <b>bpf_probe_read_user_str</b>() or
        <b>bpf_probe_read_kernel_str</b>() instead.</p>
  </dd>
  <dt id="Return~45"><a class="permalink" href="#Return~45"><b>Return</b></a></dt>
  <dd>On success, the strictly positive length of the string, including the
      trailing NUL character. On error, a negative value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~6"><a class="permalink" href="#u64~6"><b><b>u64
    bpf_get_socket_cookie(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~46"><a class="permalink" href="#Description~46"><b>Description</b></a></dt>
  <dd>If the <b>struct sk_buff</b> pointed by <i>skb</i> has a known socket,
      retrieve the cookie (generated by the kernel) of this socket. If no cookie
      has been set yet, generate a new cookie. Once generated, the socket cookie
      remains stable for the life of the socket. This helper can be useful for
      monitoring per socket networking traffic statistics as it provides a
      global socket identifier that can be assumed unique.</dd>
  <dt id="Return~46"><a class="permalink" href="#Return~46"><b>Return</b></a></dt>
  <dd>A 8-byte long unique number on success, or 0 if the socket field is
      missing inside <i>skb</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~7"><a class="permalink" href="#u64~7"><b><b>u64
    bpf_get_socket_cookie(struct bpf_sock_addr
    *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~47"><a class="permalink" href="#Description~47"><b>Description</b></a></dt>
  <dd>Equivalent to bpf_get_socket_cookie() helper that accepts <i>skb</i>, but
      gets socket from <b>struct bpf_sock_addr</b> context.</dd>
  <dt id="Return~47"><a class="permalink" href="#Return~47"><b>Return</b></a></dt>
  <dd>A 8-byte long unique number.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~8"><a class="permalink" href="#u64~8"><b><b>u64
    bpf_get_socket_cookie(struct bpf_sock_ops
    *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~48"><a class="permalink" href="#Description~48"><b>Description</b></a></dt>
  <dd>Equivalent to <b>bpf_get_socket_cookie</b>() helper that accepts
      <i>skb</i>, but gets socket from <b>struct bpf_sock_ops</b> context.</dd>
  <dt id="Return~48"><a class="permalink" href="#Return~48"><b>Return</b></a></dt>
  <dd>A 8-byte long unique number.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~9"><a class="permalink" href="#u64~9"><b><b>u64
    bpf_get_socket_cookie(struct sock *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~49"><a class="permalink" href="#Description~49"><b>Description</b></a></dt>
  <dd>Equivalent to <b>bpf_get_socket_cookie</b>() helper that accepts
      <i>sk</i>, but gets socket from a BTF <b>struct sock</b>. This helper also
      works for sleepable programs.</dd>
  <dt id="Return~49"><a class="permalink" href="#Return~49"><b>Return</b></a></dt>
  <dd>A 8-byte long unique number or 0 if <i>sk</i> is NULL.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u32~6"><a class="permalink" href="#u32~6"><b><b>u32
    bpf_get_socket_uid(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~50"><a class="permalink" href="#Description~50"><b>Description</b></a></dt>
  <dd>Get the owner UID of the socked associated to <i>skb</i>.</dd>
  <dt id="Return~50"><a class="permalink" href="#Return~50"><b>Return</b></a></dt>
  <dd>The owner UID of the socket associated to <i>skb</i>. If the socket is
      <b>NULL</b>, or if it is not a full socket (i.e. if it is a time-wait or a
      request socket instead), <b>overflowuid</b> value is returned (note that
      <b>overflowuid</b> might also be the actual UID value for the
    socket).</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~32"><a class="permalink" href="#long~32"><b><b>long
    bpf_set_hash(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>hash</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~51"><a class="permalink" href="#Description~51"><b>Description</b></a></dt>
  <dd>Set the full hash for <i>skb</i> (set the field
      <i>skb</i><b>-&gt;hash</b>) to value <i>hash</i>.</dd>
  <dt id="Return~51"><a class="permalink" href="#Return~51"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~33"><a class="permalink" href="#long~33"><b><b>long
    bpf_setsockopt(void *</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>,
    int</b> <i>optname</i><b>, void *</b><i>optval</i><b>, int</b>
    <i>optlen</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~52"><a class="permalink" href="#Description~52"><b>Description</b></a></dt>
  <dd>Emulate a call to <b>setsockopt()</b> on the socket associated to
      <i>bpf_socket</i>, which must be a full socket. The <i>level</i> at which
      the option resides and the name <i>optname</i> of the option must be
      specified, see <b>setsockopt(2)</b> for more information. The option value
      of length <i>optlen</i> is pointed by <i>optval</i>.
    <p class="Pp"><i>bpf_socket</i> should be one of the following:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>struct bpf_sock_ops</b> for <b>BPF_PROG_TYPE_SOCK_OPS</b>.</dd>
  <dt>•</dt>
  <dd><b>struct bpf_sock_addr</b> for <b>BPF_CGROUP_INET4_CONNECT</b> and
      <b>BPF_CGROUP_INET6_CONNECT</b>.</dd>
</dl>
</div>
<br>
<p class="Pp">This helper actually implements a subset of <b>setsockopt()</b>.
    It supports the following <i>level</i>s:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>SOL_SOCKET</b>, which supports the following <i>optname</i>s:
      <b>SO_RCVBUF</b>, <b>SO_SNDBUF</b>, <b>SO_MAX_PACING_RATE</b>,
      <b>SO_PRIORITY</b>, <b>SO_RCVLOWAT</b>, <b>SO_MARK</b>,
      <b>SO_BINDTODEVICE</b>, <b>SO_KEEPALIVE</b>.</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_TCP</b>, which supports the following <i>optname</i>s:
      <b>TCP_CONGESTION</b>, <b>TCP_BPF_IW</b>, <b>TCP_BPF_SNDCWND_CLAMP</b>,
      <b>TCP_SAVE_SYN</b>, <b>TCP_KEEPIDLE</b>, <b>TCP_KEEPINTVL</b>,
      <b>TCP_KEEPCNT</b>, <b>TCP_SYNCNT</b>, <b>TCP_USER_TIMEOUT</b>,
      <b>TCP_NOTSENT_LOWAT</b>.</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_IP</b>, which supports <i>optname</i> <b>IP_TOS</b>.</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_IPV6</b>, which supports <i>optname</i>
    <b>IPV6_TCLASS</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~52"><a class="permalink" href="#Return~52"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~34"><a class="permalink" href="#long~34"><b><b>long
    bpf_skb_adjust_room(struct sk_buff *</b><i>skb</i><b>, s32</b>
    <i>len_diff</i><b>, u32</b> <i>mode</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~53"><a class="permalink" href="#Description~53"><b>Description</b></a></dt>
  <dd>Grow or shrink the room for data in the packet associated to <i>skb</i> by
      <i>len_diff</i>, and according to the selected <i>mode</i>.
    <p class="Pp">By default, the helper will reset any offloaded checksum
        indicator of the skb to CHECKSUM_NONE. This can be avoided by the
        following flag:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b>: Do not reset offloaded checksum data
      of the skb to CHECKSUM_NONE.</dd>
</dl>
</div>
<br>
<p class="Pp">There are two supported modes at this time:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_ADJ_ROOM_MAC</b>: Adjust room at the mac layer (room space is added
      or removed between the layer 2 and layer 3 headers).</dd>
  <dt>•</dt>
  <dd><b>BPF_ADJ_ROOM_NET</b>: Adjust room at the network layer (room space is
      added or removed between the layer 3 and layer 4 headers).</dd>
</dl>
</div>
<br>
<p class="Pp">The following flags are supported at this time:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_FIXED_GSO</b>: Do not adjust gso_size. Adjusting mss in
      this way is not allowed for datagrams.</dd>
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV4</b>, <b>BPF_F_ADJ_ROOM_ENCAP_L3_IPV6</b>:
      Any new space is reserved to hold a tunnel header. Configure skb offsets
      and other fields accordingly.</dd>
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_ENCAP_L4_GRE</b>, <b>BPF_F_ADJ_ROOM_ENCAP_L4_UDP</b>:
      Use with ENCAP_L3 flags to further specify the tunnel type.</dd>
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_ENCAP_L2</b>(<i>len</i>): Use with ENCAP_L3/L4 flags to
      further specify the tunnel type; <i>len</i> is the length of the inner MAC
      header.</dd>
  <dt>•</dt>
  <dd><b>BPF_F_ADJ_ROOM_ENCAP_L2_ETH</b>: Use with BPF_F_ADJ_ROOM_ENCAP_L2 flag
      to further specify the L2 type as Ethernet.</dd>
</dl>
</div>
<br>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt id="Return~53"><a class="permalink" href="#Return~53"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~35"><a class="permalink" href="#long~35"><b><b>long
    bpf_redirect_map(struct bpf_map *</b><i>map</i><b>, u32</b> <i>key</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~54"><a class="permalink" href="#Description~54"><b>Description</b></a></dt>
  <dd>Redirect the packet to the endpoint referenced by <i>map</i> at index
      <i>key</i>. Depending on its type, this <i>map</i> can contain references
      to net devices (for forwarding packets through other ports), or to CPUs
      (for redirecting XDP frames to another CPU; but this is only implemented
      for native XDP (with driver support) as of this writing).
    <p class="Pp">The lower two bits of <i>flags</i> are used as the return code
        if the map lookup fails. This is so that the return value can be one of
        the XDP program return codes up to <b>XDP_TX</b>, as chosen by the
        caller. The higher bits of <i>flags</i> can be set to BPF_F_BROADCAST or
        BPF_F_EXCLUDE_INGRESS as defined below.</p>
    <p class="Pp">With BPF_F_BROADCAST the packet will be broadcasted to all the
        interfaces in the map, with BPF_F_EXCLUDE_INGRESS the ingress interface
        will be excluded when do broadcasting.</p>
    <p class="Pp">See also <b>bpf_redirect</b>(), which only supports
        redirecting to an ifindex, but doesn't require a map to do so.</p>
  </dd>
  <dt id="Return~54"><a class="permalink" href="#Return~54"><b>Return</b></a></dt>
  <dd><b>XDP_REDIRECT</b> on success, or the value of the two lower bits of the
      <i>flags</i> argument on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~36"><a class="permalink" href="#long~36"><b><b>long
    bpf_sk_redirect_map(struct sk_buff *</b><i>skb</i><b>, struct bpf_map
    *</b><i>map</i><b>, u32</b> <i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~55"><a class="permalink" href="#Description~55"><b>Description</b></a></dt>
  <dd>Redirect the packet to the socket referenced by <i>map</i> (of type
      <b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both ingress and egress
      interfaces can be used for redirection. The <b>BPF_F_INGRESS</b> value in
      <i>flags</i> is used to make the distinction (ingress path is selected if
      the flag is present, egress path otherwise). This is the only flag
      supported for now.</dd>
  <dt id="Return~55"><a class="permalink" href="#Return~55"><b>Return</b></a></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~37"><a class="permalink" href="#long~37"><b><b>long
    bpf_sock_map_update(struct bpf_sock_ops *</b><i>skops</i><b>, struct bpf_map
    *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~56"><a class="permalink" href="#Description~56"><b>Description</b></a></dt>
  <dd>Add an entry to, or update a <i>map</i> referencing sockets. The
      <i>skops</i> is used as a new value for the entry associated to
      <i>key</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_NOEXIST~2"><a class="permalink" href="#BPF_NOEXIST~2"><b><b>BPF_NOEXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt id="BPF_EXIST~2"><a class="permalink" href="#BPF_EXIST~2"><b><b>BPF_EXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt id="BPF_ANY~2"><a class="permalink" href="#BPF_ANY~2"><b><b>BPF_ANY</b></b></a></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br>
<p class="Pp">If the <i>map</i> has eBPF programs (parser and verdict), those
    will be inherited by the socket being added. If the socket is already
    attached to eBPF programs, this results in an error.</p>
<dl class="Bl-tag">
  <dt id="Return~56"><a class="permalink" href="#Return~56"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~38"><a class="permalink" href="#long~38"><b><b>long
    bpf_xdp_adjust_meta(struct xdp_buff *</b><i>xdp_md</i><b>, int</b>
    <i>delta</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~57"><a class="permalink" href="#Description~57"><b>Description</b></a></dt>
  <dd>Adjust the address pointed by <i>xdp_md</i><b>-&gt;data_meta</b> by
      <i>delta</i> (which can be positive or negative). Note that this operation
      modifies the address stored in <i>xdp_md</i><b>-&gt;data</b>, so the
      latter must be loaded only after the helper has been called.
    <p class="Pp">The use of <i>xdp_md</i><b>-&gt;data_meta</b> is optional and
        programs are not required to use it. The rationale is that when the
        packet is processed with XDP (e.g. as DoS filter), it is possible to
        push further meta data along with it before passing to the stack, and to
        give the guarantee that an ingress eBPF program attached as a TC
        classifier on the same device can pick this up for further
        post-processing. Since TC works with socket buffers, it remains possible
        to set from XDP the <b>mark</b> or <b>priority</b> pointers, or other
        pointers for the socket buffer. Having this scratch space generic and
        programmable allows for more flexibility as the user is free to store
        whatever meta data they need.</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~57"><a class="permalink" href="#Return~57"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~39"><a class="permalink" href="#long~39"><b><b>long
    bpf_perf_event_read_value(struct bpf_map *</b><i>map</i><b>, u64</b>
    <i>flags</i><b>, struct bpf_perf_event_value *</b><i>buf</i><b>, u32</b>
    <i>buf_size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~58"><a class="permalink" href="#Description~58"><b>Description</b></a></dt>
  <dd>Read the value of a perf event counter, and store it into <i>buf</i> of
      size <i>buf_size</i>. This helper relies on a <i>map</i> of type
      <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. The nature of the perf event counter
      is selected when <i>map</i> is updated with perf event file descriptors.
      The <i>map</i> is an array whose size is the number of available CPUs, and
      each cell contains a value relative to one CPU. The value to retrieve is
      indicated by <i>flags</i>, that contains the index of the CPU to look up,
      masked with <b>BPF_F_INDEX_MASK</b>. Alternatively, <i>flags</i> can be
      set to <b>BPF_F_CURRENT_CPU</b> to indicate that the value for the current
      CPU should be retrieved.
    <p class="Pp">This helper behaves in a way close to
        <b>bpf_perf_event_read</b>() helper, save that instead of just returning
        the value observed, it fills the <i>buf</i> structure. This allows for
        additional data to be retrieved: in particular, the enabled and running
        times (in <i>buf</i><b>-&gt;enabled</b> and
        <i>buf</i><b>-&gt;running</b>, respectively) are copied. In general,
        <b>bpf_perf_event_read_value</b>() is recommended over
        <b>bpf_perf_event_read</b>(), which has some ABI issues and provides
        fewer functionalities.</p>
    <p class="Pp">These values are interesting, because hardware PMU
        (Performance Monitoring Unit) counters are limited resources. When there
        are more PMU based perf events opened than available counters, kernel
        will multiplex these events so each event gets certain percentage (but
        not all) of the PMU time. In case that multiplexing happens, the number
        of samples or counter value will not reflect the case compared to when
        no multiplexing occurs. This makes comparison between different runs
        difficult. Typically, the counter value should be normalized before
        comparing to other experiments. The usual normalization is done as
        follows.</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>normalized_counter = counter * t_enabled / t_running
</pre>
</div>
<br>
</div>
<br>
<p class="Pp">Where t_enabled is the time enabled for event and t_running is the
    time running for event since last normalization. The enabled and running
    times are accumulated since the perf event open. To achieve scaling factor
    between two invocations of an eBPF program, users can use CPU id as the key
    (which is typical for perf array usage model) to remember the previous value
    and do the calculation inside the eBPF program.</p>
<dl class="Bl-tag">
  <dt id="Return~58"><a class="permalink" href="#Return~58"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~40"><a class="permalink" href="#long~40"><b><b>long
    bpf_perf_prog_read_value(struct bpf_perf_event_data *</b><i>ctx</i><b>,
    struct bpf_perf_event_value *</b><i>buf</i><b>, u32</b>
    <i>buf_size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~59"><a class="permalink" href="#Description~59"><b>Description</b></a></dt>
  <dd>For en eBPF program attached to a perf event, retrieve the value of the
      event counter associated to <i>ctx</i> and store it in the structure
      pointed by <i>buf</i> and of size <i>buf_size</i>. Enabled and running
      times are also stored in the structure (see description of helper
      <b>bpf_perf_event_read_value</b>() for more details).</dd>
  <dt id="Return~59"><a class="permalink" href="#Return~59"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~41"><a class="permalink" href="#long~41"><b><b>long
    bpf_getsockopt(void *</b><i>bpf_socket</i><b>, int</b> <i>level</i><b>,
    int</b> <i>optname</i><b>, void *</b><i>optval</i><b>, int</b>
    <i>optlen</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~60"><a class="permalink" href="#Description~60"><b>Description</b></a></dt>
  <dd>Emulate a call to <b>getsockopt()</b> on the socket associated to
      <i>bpf_socket</i>, which must be a full socket. The <i>level</i> at which
      the option resides and the name <i>optname</i> of the option must be
      specified, see <b>getsockopt(2)</b> for more information. The retrieved
      value is stored in the structure pointed by <i>opval</i> and of length
      <i>optlen</i>.
    <p class="Pp"><i>bpf_socket</i> should be one of the following:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>struct bpf_sock_ops</b> for <b>BPF_PROG_TYPE_SOCK_OPS</b>.</dd>
  <dt>•</dt>
  <dd><b>struct bpf_sock_addr</b> for <b>BPF_CGROUP_INET4_CONNECT</b> and
      <b>BPF_CGROUP_INET6_CONNECT</b>.</dd>
</dl>
</div>
<br>
<p class="Pp">This helper actually implements a subset of <b>getsockopt()</b>.
    It supports the following <i>level</i>s:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>IPPROTO_TCP</b>, which supports <i>optname</i>
    <b>TCP_CONGESTION</b>.</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_IP</b>, which supports <i>optname</i> <b>IP_TOS</b>.</dd>
  <dt>•</dt>
  <dd><b>IPPROTO_IPV6</b>, which supports <i>optname</i>
    <b>IPV6_TCLASS</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~60"><a class="permalink" href="#Return~60"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~42"><a class="permalink" href="#long~42"><b><b>long
    bpf_override_return(struct pt_regs *</b><i>regs</i><b>, u64</b>
    <i>rc</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~61"><a class="permalink" href="#Description~61"><b>Description</b></a></dt>
  <dd>Used for error injection, this helper uses kprobes to override the return
      value of the probed function, and to set it to <i>rc</i>. The first
      argument is the context <i>regs</i> on which the kprobe works.
    <p class="Pp">This helper works by setting the PC (program counter) to an
        override function which is run in place of the original probed function.
        This means the probed function is not run at all. The replacement
        function just returns with the required value.</p>
    <p class="Pp">This helper has security implications, and thus is subject to
        restrictions. It is only available if the kernel was compiled with the
        <b>CONFIG_BPF_KPROBE_OVERRIDE</b> configuration option, and in this case
        it only works on functions tagged with <b>ALLOW_ERROR_INJECTION</b> in
        the kernel code.</p>
    <p class="Pp">Also, the helper is only available for the architectures
        having the CONFIG_FUNCTION_ERROR_INJECTION option. As of this writing,
        x86 architecture is the only one to support this feature.</p>
  </dd>
  <dt id="Return~61"><a class="permalink" href="#Return~61"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~43"><a class="permalink" href="#long~43"><b><b>long
    bpf_sock_ops_cb_flags_set(struct bpf_sock_ops *</b><i>bpf_sock</i><b>,
    int</b> <i>argval</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~62"><a class="permalink" href="#Description~62"><b>Description</b></a></dt>
  <dd>Attempt to set the value of the <b>bpf_sock_ops_cb_flags</b> field for the
      full TCP socket associated to <i>bpf_sock_ops</i> to <i>argval</i>.
    <p class="Pp">The primary use of this field is to determine if there should
        be calls to eBPF programs of type <b>BPF_PROG_TYPE_SOCK_OPS</b> at
        various points in the TCP code. A program of the same type can change
        its value, per connection and as necessary, when the connection is
        established. This field is directly accessible for reading, but this
        helper must be used for updates in order to return an error if an eBPF
        program tries to set a callback that is not supported in the current
        kernel.</p>
    <p class="Pp"><i>argval</i> is a flag array which can combine these
      flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_SOCK_OPS_RTO_CB_FLAG</b> (retransmission time out)</dd>
  <dt>•</dt>
  <dd><b>BPF_SOCK_OPS_RETRANS_CB_FLAG</b> (retransmission)</dd>
  <dt>•</dt>
  <dd><b>BPF_SOCK_OPS_STATE_CB_FLAG</b> (TCP state change)</dd>
  <dt>•</dt>
  <dd><b>BPF_SOCK_OPS_RTT_CB_FLAG</b> (every RTT)</dd>
</dl>
</div>
<br>
<p class="Pp">Therefore, this function can be used to clear a callback flag by
    setting the appropriate bit to zero. e.g. to disable the RTO callback:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="bpf_sock_ops_cb_flags_set(bpf_sock,"><a class="permalink" href="#bpf_sock_ops_cb_flags_set(bpf_sock,"><b><b>bpf_sock_ops_cb_flags_set(bpf_sock,</b></b></a></dt>
  <dd><b>bpf_sock-&gt;bpf_sock_ops_cb_flags &amp;
    ~BPF_SOCK_OPS_RTO_CB_FLAG)</b></dd>
</dl>
</div>
<br>
<p class="Pp">Here are some examples of where one could call such eBPF
  program:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>When RTO fires.</dd>
  <dt>•</dt>
  <dd>When a packet is retransmitted.</dd>
  <dt>•</dt>
  <dd>When the connection terminates.</dd>
  <dt>•</dt>
  <dd>When a packet is sent.</dd>
  <dt>•</dt>
  <dd>When a packet is received.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~62"><a class="permalink" href="#Return~62"><b>Return</b></a></dt>
  <dd>Code <b>-EINVAL</b> if the socket is not a full TCP socket; otherwise, a
      positive number containing the bits that could not be set is returned
      (which comes down to 0 if all bits were set as required).</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~44"><a class="permalink" href="#long~44"><b><b>long
    bpf_msg_redirect_map(struct sk_msg_buff *</b><i>msg</i><b>, struct bpf_map
    *</b><i>map</i><b>, u32</b> <i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~63"><a class="permalink" href="#Description~63"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing policies at the socket level.
      If the message <i>msg</i> is allowed to pass (i.e. if the verdict eBPF
      program returns <b>SK_PASS</b>), redirect it to the socket referenced by
      <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKMAP</b>) at index <i>key</i>. Both
      ingress and egress interfaces can be used for redirection. The
      <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to make the distinction
      (ingress path is selected if the flag is present, egress path otherwise).
      This is the only flag supported for now.</dd>
  <dt id="Return~63"><a class="permalink" href="#Return~63"><b>Return</b></a></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~45"><a class="permalink" href="#long~45"><b><b>long
    bpf_msg_apply_bytes(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>bytes</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~64"><a class="permalink" href="#Description~64"><b>Description</b></a></dt>
  <dd>For socket policies, apply the verdict of the eBPF program to the next
      <i>bytes</i> (number of bytes) of message <i>msg</i>.
    <p class="Pp">For example, this helper can be used in the following
      cases:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>A single <b>sendmsg</b>() or <b>sendfile</b>() system call contains
      multiple logical messages that the eBPF program is supposed to read and
      for which it should apply a verdict.</dd>
  <dt>•</dt>
  <dd>An eBPF program only cares to read the first <i>bytes</i> of a <i>msg</i>.
      If the message has a large payload, then setting up and calling the eBPF
      program repeatedly for all bytes, even though the verdict is already
      known, would create unnecessary overhead.</dd>
</dl>
</div>
<br>
<p class="Pp">When called from within an eBPF program, the helper sets a counter
    internal to the BPF infrastructure, that is used to apply the last verdict
    to the next <i>bytes</i>. If <i>bytes</i> is smaller than the current data
    being processed from a <b>sendmsg</b>() or <b>sendfile</b>() system call,
    the first <i>bytes</i> will be sent and the eBPF program will be re-run with
    the pointer for start of data pointing to byte number <i>bytes</i> <b>+
    1</b>. If <i>bytes</i> is larger than the current data being processed, then
    the eBPF verdict will be applied to multiple <b>sendmsg</b>() or
    <b>sendfile</b>() calls until <i>bytes</i> are consumed.</p>
<p class="Pp">Note that if a socket closes with the internal counter holding a
    non-zero value, this is not a problem because data is not being buffered for
    <i>bytes</i> and is sent as it is received.</p>
<dl class="Bl-tag">
  <dt id="Return~64"><a class="permalink" href="#Return~64"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~46"><a class="permalink" href="#long~46"><b><b>long
    bpf_msg_cork_bytes(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>bytes</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~65"><a class="permalink" href="#Description~65"><b>Description</b></a></dt>
  <dd>For socket policies, prevent the execution of the verdict eBPF program for
      message <i>msg</i> until <i>bytes</i> (byte number) have been accumulated.
    <p class="Pp">This can be used when one needs a specific number of bytes
        before a verdict can be assigned, even if the data spans multiple
        <b>sendmsg</b>() or <b>sendfile</b>() calls. The extreme case would be a
        user calling <b>sendmsg</b>() repeatedly with 1-byte long message
        segments. Obviously, this is bad for performance, but it is still valid.
        If the eBPF program needs <i>bytes</i> bytes to validate a header, this
        helper can be used to prevent the eBPF program to be called again until
        <i>bytes</i> have been accumulated.</p>
  </dd>
  <dt id="Return~65"><a class="permalink" href="#Return~65"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~47"><a class="permalink" href="#long~47"><b><b>long
    bpf_msg_pull_data(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>end</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~66"><a class="permalink" href="#Description~66"><b>Description</b></a></dt>
  <dd>For socket policies, pull in non-linear data from user space for
      <i>msg</i> and set pointers <i>msg</i><b>-&gt;data</b> and
      <i>msg</i><b>-&gt;data_end</b> to <i>start</i> and <i>end</i> bytes
      offsets into <i>msg</i>, respectively.
    <p class="Pp">If a program of type <b>BPF_PROG_TYPE_SK_MSG</b> is run on a
        <i>msg</i> it can only parse data that the (<b>data</b>,
        <b>data_end</b>) pointers have already consumed. For <b>sendmsg</b>()
        hooks this is likely the first scatterlist element. But for calls
        relying on the <b>sendpage</b> handler (e.g. <b>sendfile</b>()) this
        will be the range (<b>0</b>, <b>0</b>) because the data is shared with
        user space and by default the objective is to avoid allowing user space
        to modify data while (or after) eBPF verdict is being decided. This
        helper can be used to pull in data and to set the start and end pointer
        to given values. Data will be copied if necessary (i.e. if data was not
        linear and if start and end pointers do not point to the same
      chunk).</p>
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
  </dd>
  <dt id="Return~66"><a class="permalink" href="#Return~66"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~48"><a class="permalink" href="#long~48"><b><b>long
    bpf_bind(struct bpf_sock_addr *</b><i>ctx</i><b>, struct sockaddr
    *</b><i>addr</i><b>, int</b> <i>addr_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~67"><a class="permalink" href="#Description~67"><b>Description</b></a></dt>
  <dd>Bind the socket associated to <i>ctx</i> to the address pointed by
      <i>addr</i>, of length <i>addr_len</i>. This allows for making outgoing
      connection from the desired IP address, which can be useful for example
      when all processes inside a cgroup should use one single IP address on a
      host that has multiple IP configured.
    <p class="Pp">This helper works for IPv4 and IPv6, TCP and UDP sockets. The
        domain (<i>addr</i><b>-&gt;sa_family</b>) must be <b>AF_INET</b> (or
        <b>AF_INET6</b>). It's advised to pass zero port (<b>sin_port</b> or
        <b>sin6_port</b>) which triggers IP_BIND_ADDRESS_NO_PORT-like behavior
        and lets the kernel efficiently pick up an unused port as long as
        4-tuple is unique. Passing non-zero port might lead to degraded
        performance.</p>
  </dd>
  <dt id="Return~67"><a class="permalink" href="#Return~67"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~49"><a class="permalink" href="#long~49"><b><b>long
    bpf_xdp_adjust_tail(struct xdp_buff *</b><i>xdp_md</i><b>, int</b>
    <i>delta</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~68"><a class="permalink" href="#Description~68"><b>Description</b></a></dt>
  <dd>Adjust (move) <i>xdp_md</i><b>-&gt;data_end</b> by <i>delta</i> bytes. It
      is possible to both shrink and grow the packet tail. Shrink done via
      <i>delta</i> being a negative integer.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~68"><a class="permalink" href="#Return~68"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~50"><a class="permalink" href="#long~50"><b><b>long
    bpf_skb_get_xfrm_state(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>index</i><b>, struct bpf_xfrm_state *</b><i>xfrm_state</i><b>, u32</b>
    <i>size</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~69"><a class="permalink" href="#Description~69"><b>Description</b></a></dt>
  <dd>Retrieve the XFRM state (IP transform framework, see also
      <b>ip-xfrm(8)</b>) at <i>index</i> in XFRM "security path" for
      <i>skb</i>.
    <p class="Pp">The retrieved value is stored in the <b>struct
        bpf_xfrm_state</b> pointed by <i>xfrm_state</i> and of length
        <i>size</i>.</p>
    <p class="Pp">All values for <i>flags</i> are reserved for future usage, and
        must be left at zero.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_XFRM</b> configuration option.</p>
  </dd>
  <dt id="Return~69"><a class="permalink" href="#Return~69"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~51"><a class="permalink" href="#long~51"><b><b>long
    bpf_get_stack(void *</b><i>ctx</i><b>, void *</b><i>buf</i><b>, u32</b>
    <i>size</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~70"><a class="permalink" href="#Description~70"><b>Description</b></a></dt>
  <dd>Return a user or a kernel stack in bpf program provided buffer. To achieve
      this, the helper needs <i>ctx</i>, which is a pointer to the context on
      which the tracing program is executed. To store the stacktrace, the bpf
      program provides <i>buf</i> with a nonnegative <i>size</i>.
    <p class="Pp">The last argument, <i>flags</i>, holds the number of stack
        frames to skip (from 0 to 255), masked with
        <b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to set the
        following flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_F_USER_STACK~2"><a class="permalink" href="#BPF_F_USER_STACK~2"><b><b>BPF_F_USER_STACK</b></b></a></dt>
  <dd>Collect a user space stack instead of a kernel stack.</dd>
  <dt id="BPF_F_USER_BUILD_ID"><a class="permalink" href="#BPF_F_USER_BUILD_ID"><b><b>BPF_F_USER_BUILD_ID</b></b></a></dt>
  <dd>Collect (build_id, file_offset) instead of ips for user stack, only valid
      if <b>BPF_F_USER_STACK</b> is also specified.
    <p class="Pp"><i>file_offset</i> is an offset relative to the beginning of
        the executable or shared object file backing the vma which the <i>ip</i>
        falls in. It is <i>not</i> an offset relative to that object's base
        address. Accordingly, it must be adjusted by adding (sh_addr -
        sh_offset), where sh_{addr,offset} correspond to the executable section
        containing <i>file_offset</i> in the object, for comparisons to symbols'
        st_value to be valid.</p>
  </dd>
</dl>
</div>
<br>
<p class="Pp"><b>bpf_get_stack</b>() can collect up to
    <b>PERF_MAX_STACK_DEPTH</b> both kernel and user frames, subject to
    sufficient large buffer size. Note that this limit can be controlled with
    the <b>sysctl</b> program, and that it should be manually increased in order
    to profile long user stacks (such as stacks for Java programs). To do so,
    use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~70"><a class="permalink" href="#Return~70"><b>Return</b></a></dt>
  <dd>The non-negative copied <i>buf</i> length equal to or less than
      <i>size</i> on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~52"><a class="permalink" href="#long~52"><b><b>long
    bpf_skb_load_bytes_relative(const void *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, void *</b><i>to</i><b>, u32</b> <i>len</i><b>, u32</b>
    <i>start_header</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~71"><a class="permalink" href="#Description~71"><b>Description</b></a></dt>
  <dd>This helper is similar to <b>bpf_skb_load_bytes</b>() in that it provides
      an easy way to load <i>len</i> bytes from <i>offset</i> from the packet
      associated to <i>skb</i>, into the buffer pointed by <i>to</i>. The
      difference to <b>bpf_skb_load_bytes</b>() is that a fifth argument
      <i>start_header</i> exists in order to select a base offset to start from.
      <i>start_header</i> can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_HDR_START_MAC"><a class="permalink" href="#BPF_HDR_START_MAC"><b><b>BPF_HDR_START_MAC</b></b></a></dt>
  <dd>Base offset to load data from is <i>skb</i>'s mac header.</dd>
  <dt id="BPF_HDR_START_NET"><a class="permalink" href="#BPF_HDR_START_NET"><b><b>BPF_HDR_START_NET</b></b></a></dt>
  <dd>Base offset to load data from is <i>skb</i>'s network header.</dd>
</dl>
</div>
<br>
<p class="Pp">In general, "direct packet access" is the preferred
    method to access packet data, however, this helper is in particular useful
    in socket filters where <i>skb</i><b>-&gt;data</b> does not always point to
    the start of the mac header and where "direct packet access" is
    not available.</p>
<dl class="Bl-tag">
  <dt id="Return~71"><a class="permalink" href="#Return~71"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~53"><a class="permalink" href="#long~53"><b><b>long
    bpf_fib_lookup(void *</b><i>ctx</i><b>, struct bpf_fib_lookup
    *</b><i>params</i><b>, int</b> <i>plen</i><b>, u32</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~72"><a class="permalink" href="#Description~72"><b>Description</b></a></dt>
  <dd>Do FIB lookup in kernel tables using parameters in <i>params</i>. If
      lookup is successful and result shows packet is to be forwarded, the
      neighbor tables are searched for the nexthop. If successful (ie., FIB
      lookup shows forwarding and nexthop is resolved), the nexthop address is
      returned in ipv4_dst or ipv6_dst based on family, smac is set to mac
      address of egress device, dmac is set to nexthop mac address, rt_metric is
      set to metric from route (IPv4/IPv6 only), and ifindex is set to the
      device index of the nexthop from the FIB lookup.
    <p class="Pp"><i>plen</i> argument is the size of the passed in struct.
        <i>flags</i> argument can be a combination of one or more of the
        following values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_FIB_LOOKUP_DIRECT"><a class="permalink" href="#BPF_FIB_LOOKUP_DIRECT"><b><b>BPF_FIB_LOOKUP_DIRECT</b></b></a></dt>
  <dd>Do a direct table lookup vs full lookup using FIB rules.</dd>
  <dt id="BPF_FIB_LOOKUP_OUTPUT"><a class="permalink" href="#BPF_FIB_LOOKUP_OUTPUT"><b><b>BPF_FIB_LOOKUP_OUTPUT</b></b></a></dt>
  <dd>Perform lookup from an egress perspective (default is ingress).</dd>
</dl>
</div>
<br>
<p class="Pp"><i>ctx</i> is either <b>struct xdp_md</b> for XDP programs or
    <b>struct sk_buff</b> tc cls_act programs.</p>
<dl class="Bl-tag">
  <dt id="Return~72"><a class="permalink" href="#Return~72"><b>Return</b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>&lt; 0 if any input argument is invalid</dd>
  <dt>•</dt>
  <dd>0 on success (packet is forwarded, nexthop neighbor exists)</dd>
  <dt>•</dt>
  <dd>&gt; 0 one of <b>BPF_FIB_LKUP_RET_</b> codes explaining why the packet is
      not forwarded or needs assist from full stack</dd>
</dl>
</div>
<br>
<p class="Pp">If lookup fails with BPF_FIB_LKUP_RET_FRAG_NEEDED, then the MTU
    was exceeded and output params-&gt;mtu_result contains the MTU.</p>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~54"><a class="permalink" href="#long~54"><b><b>long
    bpf_sock_hash_update(struct bpf_sock_ops *</b><i>skops</i><b>, struct
    bpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~73"><a class="permalink" href="#Description~73"><b>Description</b></a></dt>
  <dd>Add an entry to, or update a sockhash <i>map</i> referencing sockets. The
      <i>skops</i> is used as a new value for the entry associated to
      <i>key</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_NOEXIST~3"><a class="permalink" href="#BPF_NOEXIST~3"><b><b>BPF_NOEXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must not exist in the map.</dd>
  <dt id="BPF_EXIST~3"><a class="permalink" href="#BPF_EXIST~3"><b><b>BPF_EXIST</b></b></a></dt>
  <dd>The entry for <i>key</i> must already exist in the map.</dd>
  <dt id="BPF_ANY~3"><a class="permalink" href="#BPF_ANY~3"><b><b>BPF_ANY</b></b></a></dt>
  <dd>No condition on the existence of the entry for <i>key</i>.</dd>
</dl>
</div>
<br>
<p class="Pp">If the <i>map</i> has eBPF programs (parser and verdict), those
    will be inherited by the socket being added. If the socket is already
    attached to eBPF programs, this results in an error.</p>
<dl class="Bl-tag">
  <dt id="Return~73"><a class="permalink" href="#Return~73"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~55"><a class="permalink" href="#long~55"><b><b>long
    bpf_msg_redirect_hash(struct sk_msg_buff *</b><i>msg</i><b>, struct bpf_map
    *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~74"><a class="permalink" href="#Description~74"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing policies at the socket level.
      If the message <i>msg</i> is allowed to pass (i.e. if the verdict eBPF
      program returns <b>SK_PASS</b>), redirect it to the socket referenced by
      <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKHASH</b>) using hash <i>key</i>.
      Both ingress and egress interfaces can be used for redirection. The
      <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to make the distinction
      (ingress path is selected if the flag is present, egress path otherwise).
      This is the only flag supported for now.</dd>
  <dt id="Return~74"><a class="permalink" href="#Return~74"><b>Return</b></a></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~56"><a class="permalink" href="#long~56"><b><b>long
    bpf_sk_redirect_hash(struct sk_buff *</b><i>skb</i><b>, struct bpf_map
    *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~75"><a class="permalink" href="#Description~75"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing policies at the skb socket
      level. If the sk_buff <i>skb</i> is allowed to pass (i.e. if the verdict
      eBPF program returns <b>SK_PASS</b>), redirect it to the socket referenced
      by <i>map</i> (of type <b>BPF_MAP_TYPE_SOCKHASH</b>) using hash
      <i>key</i>. Both ingress and egress interfaces can be used for
      redirection. The <b>BPF_F_INGRESS</b> value in <i>flags</i> is used to
      make the distinction (ingress path is selected if the flag is present,
      egress otherwise). This is the only flag supported for now.</dd>
  <dt id="Return~75"><a class="permalink" href="#Return~75"><b>Return</b></a></dt>
  <dd><b>SK_PASS</b> on success, or <b>SK_DROP</b> on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~57"><a class="permalink" href="#long~57"><b><b>long
    bpf_lwt_push_encap(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>type</i><b>, void *</b><i>hdr</i><b>, u32</b>
    <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~76"><a class="permalink" href="#Description~76"><b>Description</b></a></dt>
  <dd>Encapsulate the packet associated to <i>skb</i> within a Layer 3 protocol
      header. This header is provided in the buffer at address <i>hdr</i>, with
      <i>len</i> its size in bytes. <i>type</i> indicates the protocol of the
      header and can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_LWT_ENCAP_SEG6"><a class="permalink" href="#BPF_LWT_ENCAP_SEG6"><b><b>BPF_LWT_ENCAP_SEG6</b></b></a></dt>
  <dd>IPv6 encapsulation with Segment Routing Header (<b>struct
      ipv6_sr_hdr</b>). <i>hdr</i> only contains the SRH, the IPv6 header is
      computed by the kernel.</dd>
  <dt id="BPF_LWT_ENCAP_SEG6_INLINE"><a class="permalink" href="#BPF_LWT_ENCAP_SEG6_INLINE"><b><b>BPF_LWT_ENCAP_SEG6_INLINE</b></b></a></dt>
  <dd>Only works if <i>skb</i> contains an IPv6 packet. Insert a Segment Routing
      Header (<b>struct ipv6_sr_hdr</b>) inside the IPv6 header.</dd>
  <dt id="BPF_LWT_ENCAP_IP"><a class="permalink" href="#BPF_LWT_ENCAP_IP"><b><b>BPF_LWT_ENCAP_IP</b></b></a></dt>
  <dd>IP encapsulation (GRE/GUE/IPIP/etc). The outer header must be IPv4 or
      IPv6, followed by zero or more additional headers, up to
      <b>LWT_BPF_MAX_HEADROOM</b> total bytes in all prepended headers. Please
      note that if <b>skb_is_gso</b>(<i>skb</i>) is true, no more than two
      headers can be prepended, and the inner header, if present, should be
      either GRE or UDP/GUE.</dd>
</dl>
</div>
<br>
<p class="Pp"><b>BPF_LWT_ENCAP_SEG6</b>* types can be called by BPF programs of
    type <b>BPF_PROG_TYPE_LWT_IN</b>; <b>BPF_LWT_ENCAP_IP</b> type can be called
    by bpf programs of types <b>BPF_PROG_TYPE_LWT_IN</b> and
    <b>BPF_PROG_TYPE_LWT_XMIT</b>.</p>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt id="Return~76"><a class="permalink" href="#Return~76"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~58"><a class="permalink" href="#long~58"><b><b>long
    bpf_lwt_seg6_store_bytes(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, const void *</b><i>from</i><b>, u32</b>
    <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~77"><a class="permalink" href="#Description~77"><b>Description</b></a></dt>
  <dd>Store <i>len</i> bytes from address <i>from</i> into the packet associated
      to <i>skb</i>, at <i>offset</i>. Only the flags, tag and TLVs inside the
      outermost IPv6 Segment Routing Header can be modified through this helper.
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~77"><a class="permalink" href="#Return~77"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~59"><a class="permalink" href="#long~59"><b><b>long
    bpf_lwt_seg6_adjust_srh(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>offset</i><b>, s32</b> <i>delta</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~78"><a class="permalink" href="#Description~78"><b>Description</b></a></dt>
  <dd>Adjust the size allocated to TLVs in the outermost IPv6 Segment Routing
      Header contained in the packet associated to <i>skb</i>, at position
      <i>offset</i> by <i>delta</i> bytes. Only offsets after the segments are
      accepted. <i>delta</i> can be as well positive (growing) as negative
      (shrinking).
    <p class="Pp">A call to this helper is susceptible to change the underlying
        packet buffer. Therefore, at load time, all checks on pointers
        previously done by the verifier are invalidated and must be performed
        again, if the helper is used in combination with direct packet
      access.</p>
  </dd>
  <dt id="Return~78"><a class="permalink" href="#Return~78"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~60"><a class="permalink" href="#long~60"><b><b>long
    bpf_lwt_seg6_action(struct sk_buff *</b><i>skb</i><b>, u32</b>
    <i>action</i><b>, void *</b><i>param</i><b>, u32</b>
    <i>param_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~79"><a class="permalink" href="#Description~79"><b>Description</b></a></dt>
  <dd>Apply an IPv6 Segment Routing action of type <i>action</i> to the packet
      associated to <i>skb</i>. Each action takes a parameter contained at
      address <i>param</i>, and of length <i>param_len</i> bytes. <i>action</i>
      can be one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="SEG6_LOCAL_ACTION_END_X"><a class="permalink" href="#SEG6_LOCAL_ACTION_END_X"><b><b>SEG6_LOCAL_ACTION_END_X</b></b></a></dt>
  <dd>End.X action: Endpoint with Layer-3 cross-connect. Type of <i>param</i>:
      <b>struct in6_addr</b>.</dd>
  <dt id="SEG6_LOCAL_ACTION_END_T"><a class="permalink" href="#SEG6_LOCAL_ACTION_END_T"><b><b>SEG6_LOCAL_ACTION_END_T</b></b></a></dt>
  <dd>End.T action: Endpoint with specific IPv6 table lookup. Type of
      <i>param</i>: <b>int</b>.</dd>
  <dt id="SEG6_LOCAL_ACTION_END_B6"><a class="permalink" href="#SEG6_LOCAL_ACTION_END_B6"><b><b>SEG6_LOCAL_ACTION_END_B6</b></b></a></dt>
  <dd>End.B6 action: Endpoint bound to an SRv6 policy. Type of <i>param</i>:
      <b>struct ipv6_sr_hdr</b>.</dd>
  <dt id="SEG6_LOCAL_ACTION_END_B6_ENCAP"><a class="permalink" href="#SEG6_LOCAL_ACTION_END_B6_ENCAP"><b><b>SEG6_LOCAL_ACTION_END_B6_ENCAP</b></b></a></dt>
  <dd>End.B6.Encap action: Endpoint bound to an SRv6 encapsulation policy. Type
      of <i>param</i>: <b>struct ipv6_sr_hdr</b>.</dd>
</dl>
</div>
<br>
<p class="Pp">A call to this helper is susceptible to change the underlying
    packet buffer. Therefore, at load time, all checks on pointers previously
    done by the verifier are invalidated and must be performed again, if the
    helper is used in combination with direct packet access.</p>
<dl class="Bl-tag">
  <dt id="Return~79"><a class="permalink" href="#Return~79"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~61"><a class="permalink" href="#long~61"><b><b>long
    bpf_rc_repeat(void *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~80"><a class="permalink" href="#Description~80"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded repeat key message. This delays the generation of a
      key up event for previously generated key down event.
    <p class="Pp">Some IR protocols like NEC have a special IR message for
        repeating last button, for when a button is held down.</p>
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        "<b>y</b>".</p>
  </dd>
  <dt id="Return~80"><a class="permalink" href="#Return~80"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~62"><a class="permalink" href="#long~62"><b><b>long
    bpf_rc_keydown(void *</b><i>ctx</i><b>, u32</b> <i>protocol</i><b>, u64</b>
    <i>scancode</i><b>, u32</b> <i>toggle</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~81"><a class="permalink" href="#Description~81"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded key press with <i>scancode</i>, <i>toggle</i> value
      in the given <i>protocol</i>. The scancode will be translated to a keycode
      using the rc keymap, and reported as an input key down event. After a
      period a key up event is generated. This period can be extended by calling
      either <b>bpf_rc_keydown</b>() again with the same values, or calling
      <b>bpf_rc_repeat</b>().
    <p class="Pp">Some protocols include a toggle bit, in case the button was
        released and pressed again between consecutive scancodes.</p>
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">The <i>protocol</i> is the decoded protocol number (see
        <b>enum rc_proto</b> for some predefined values).</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        "<b>y</b>".</p>
  </dd>
  <dt id="Return~81"><a class="permalink" href="#Return~81"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~10"><a class="permalink" href="#u64~10"><b><b>u64
    bpf_skb_cgroup_id(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~82"><a class="permalink" href="#Description~82"><b>Description</b></a></dt>
  <dd>Return the cgroup v2 id of the socket associated with the <i>skb</i>. This
      is roughly similar to the <b>bpf_get_cgroup_classid</b>() helper for
      cgroup v1 by providing a tag resp. identifier that can be matched on or
      used for map lookups e.g. to implement policy. The cgroup v2 id of a given
      path in the hierarchy is exposed in user space through the f_handle API in
      order to get to the same 64-bit id.
    <p class="Pp">This helper can be used on TC egress path, but not on ingress,
        and is available only if the kernel was compiled with the
        <b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.</p>
  </dd>
  <dt id="Return~82"><a class="permalink" href="#Return~82"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~11"><a class="permalink" href="#u64~11"><b><b>u64
    bpf_get_current_cgroup_id(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~83"><a class="permalink" href="#Description~83"><b>Description</b></a></dt>
  <dd>Get the current cgroup id based on the cgroup within which the current
      task is running.</dd>
  <dt id="Return~83"><a class="permalink" href="#Return~83"><b>Return</b></a></dt>
  <dd>A 64-bit integer containing the current cgroup id based on the cgroup
      within which the current task is running.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~3"><a class="permalink" href="#void~3"><b><b>void
    *bpf_get_local_storage(void *</b><i>map</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~84"><a class="permalink" href="#Description~84"><b>Description</b></a></dt>
  <dd>Get the pointer to the local storage area. The type and the size of the
      local storage is defined by the <i>map</i> argument. The <i>flags</i>
      meaning is specific for each map type, and has to be 0 for cgroup local
      storage.
    <p class="Pp">Depending on the BPF program type, a local storage area can be
        shared between multiple instances of the BPF program, running
        simultaneously.</p>
    <p class="Pp">A user should care about the synchronization by himself. For
        example, by using the <b>BPF_ATOMIC</b> instructions to alter the shared
        data.</p>
  </dd>
  <dt id="Return~84"><a class="permalink" href="#Return~84"><b>Return</b></a></dt>
  <dd>A pointer to the local storage area.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~63"><a class="permalink" href="#long~63"><b><b>long
    bpf_sk_select_reuseport(struct sk_reuseport_md *</b><i>reuse</i><b>, struct
    bpf_map *</b><i>map</i><b>, void *</b><i>key</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~85"><a class="permalink" href="#Description~85"><b>Description</b></a></dt>
  <dd>Select a <b>SO_REUSEPORT</b> socket from a
      <b>BPF_MAP_TYPE_REUSEPORT_SOCKARRAY</b> <i>map</i>. It checks the selected
      socket is matching the incoming request in the socket buffer.</dd>
  <dt id="Return~85"><a class="permalink" href="#Return~85"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~12"><a class="permalink" href="#u64~12"><b><b>u64
    bpf_skb_ancestor_cgroup_id(struct sk_buff *</b><i>skb</i><b>, int</b>
    <i>ancestor_level</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~86"><a class="permalink" href="#Description~86"><b>Description</b></a></dt>
  <dd>Return id of cgroup v2 that is ancestor of cgroup associated with the
      <i>skb</i> at the <i>ancestor_level</i>. The root cgroup is at
      <i>ancestor_level</i> zero and each step down the hierarchy increments the
      level. If <i>ancestor_level</i> == level of cgroup associated with
      <i>skb</i>, then return value will be same as that of
      <b>bpf_skb_cgroup_id</b>().
    <p class="Pp">The helper is useful to implement policies based on cgroups
        that are upper in hierarchy than immediate cgroup associated with
        <i>skb</i>.</p>
    <p class="Pp">The format of returned id and helper limitations are same as
        in <b>bpf_skb_cgroup_id</b>().</p>
  </dd>
  <dt id="Return~86"><a class="permalink" href="#Return~86"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct"><a class="permalink" href="#struct"><b><b>struct bpf_sock
    *bpf_sk_lookup_tcp(void *</b><i>ctx</i><b>, struct bpf_sock_tuple
    *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b> <i>netns</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~87"><a class="permalink" href="#Description~87"><b>Description</b></a></dt>
  <dd>Look for TCP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">The <i>ctx</i> should point to the context of the program,
        such as the skb or socket (depending on the hook in use). This is used
        to determine the base network namespace for the lookup.</p>
    <p class="Pp"><i>tuple_size</i> must be one of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="sizeof"><a class="permalink" href="#sizeof"><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv4</b>)</b></a></dt>
  <dd>Look for an IPv4 socket.</dd>
  <dt id="sizeof~2"><a class="permalink" href="#sizeof~2"><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv6</b>)</b></a></dt>
  <dd>Look for an IPv6 socket.</dd>
</dl>
</div>
<br>
<p class="Pp">If the <i>netns</i> is a negative signed 32-bit integer, then the
    socket lookup table in the netns associated with the <i>ctx</i> will be
    used. For the TC hooks, this is the netns of the device in the skb. For
    socket hooks, this is the netns of the socket. If <i>netns</i> is any other
    signed 32-bit value greater than or equal to zero then it specifies the ID
    of the netns relative to the netns associated with the <i>ctx</i>.
    <i>netns</i> values beyond the range of 32-bit integers are reserved for
    future use.</p>
<p class="Pp">All values for <i>flags</i> are reserved for future usage, and
    must be left at zero.</p>
<p class="Pp">This helper is available only if the kernel was compiled with
    <b>CONFIG_NET</b> configuration option.</p>
<dl class="Bl-tag">
  <dt id="Return~87"><a class="permalink" href="#Return~87"><b>Return</b></a></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~2"><a class="permalink" href="#struct~2"><b><b>struct bpf_sock
    *bpf_sk_lookup_udp(void *</b><i>ctx</i><b>, struct bpf_sock_tuple
    *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b> <i>netns</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~88"><a class="permalink" href="#Description~88"><b>Description</b></a></dt>
  <dd>Look for UDP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">The <i>ctx</i> should point to the context of the program,
        such as the skb or socket (depending on the hook in use). This is used
        to determine the base network namespace for the lookup.</p>
    <p class="Pp"><i>tuple_size</i> must be one of:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="sizeof~3"><a class="permalink" href="#sizeof~3"><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv4</b>)</b></a></dt>
  <dd>Look for an IPv4 socket.</dd>
  <dt id="sizeof~4"><a class="permalink" href="#sizeof~4"><b><b>sizeof</b>(<i>tuple</i><b>-&gt;ipv6</b>)</b></a></dt>
  <dd>Look for an IPv6 socket.</dd>
</dl>
</div>
<br>
<p class="Pp">If the <i>netns</i> is a negative signed 32-bit integer, then the
    socket lookup table in the netns associated with the <i>ctx</i> will be
    used. For the TC hooks, this is the netns of the device in the skb. For
    socket hooks, this is the netns of the socket. If <i>netns</i> is any other
    signed 32-bit value greater than or equal to zero then it specifies the ID
    of the netns relative to the netns associated with the <i>ctx</i>.
    <i>netns</i> values beyond the range of 32-bit integers are reserved for
    future use.</p>
<p class="Pp">All values for <i>flags</i> are reserved for future usage, and
    must be left at zero.</p>
<p class="Pp">This helper is available only if the kernel was compiled with
    <b>CONFIG_NET</b> configuration option.</p>
<dl class="Bl-tag">
  <dt id="Return~88"><a class="permalink" href="#Return~88"><b>Return</b></a></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~64"><a class="permalink" href="#long~64"><b><b>long
    bpf_sk_release(void *</b><i>sock</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~89"><a class="permalink" href="#Description~89"><b>Description</b></a></dt>
  <dd>Release the reference held by <i>sock</i>. <i>sock</i> must be a
      non-<b>NULL</b> pointer that was returned from
    <b>bpf_sk_lookup_xxx</b>().</dd>
  <dt id="Return~89"><a class="permalink" href="#Return~89"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~65"><a class="permalink" href="#long~65"><b><b>long
    bpf_map_push_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>value</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~90"><a class="permalink" href="#Description~90"><b>Description</b></a></dt>
  <dd>Push an element <i>value</i> in <i>map</i>. <i>flags</i> is one of:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_EXIST~4"><a class="permalink" href="#BPF_EXIST~4"><b><b>BPF_EXIST</b></b></a></dt>
  <dd>If the queue/stack is full, the oldest element is removed to make room for
      this.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~90"><a class="permalink" href="#Return~90"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~66"><a class="permalink" href="#long~66"><b><b>long
    bpf_map_pop_elem(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>value</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~91"><a class="permalink" href="#Description~91"><b>Description</b></a></dt>
  <dd>Pop an element from <i>map</i>.</dd>
  <dt id="Return~91"><a class="permalink" href="#Return~91"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~67"><a class="permalink" href="#long~67"><b><b>long
    bpf_map_peek_elem(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>value</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~92"><a class="permalink" href="#Description~92"><b>Description</b></a></dt>
  <dd>Get an element from <i>map</i> without removing it.</dd>
  <dt id="Return~92"><a class="permalink" href="#Return~92"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~68"><a class="permalink" href="#long~68"><b><b>long
    bpf_msg_push_data(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~93"><a class="permalink" href="#Description~93"><b>Description</b></a></dt>
  <dd>For socket policies, insert <i>len</i> bytes into <i>msg</i> at offset
      <i>start</i>.
    <p class="Pp">If a program of type <b>BPF_PROG_TYPE_SK_MSG</b> is run on a
        <i>msg</i> it may want to insert metadata or options into the
        <i>msg</i>. This can later be read and used by any of the lower layer
        BPF hooks.</p>
    <p class="Pp">This helper may fail if under memory pressure (a malloc fails)
        in these cases BPF programs will get an appropriate error and BPF
        programs will need to handle them.</p>
  </dd>
  <dt id="Return~93"><a class="permalink" href="#Return~93"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~69"><a class="permalink" href="#long~69"><b><b>long
    bpf_msg_pop_data(struct sk_msg_buff *</b><i>msg</i><b>, u32</b>
    <i>start</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~94"><a class="permalink" href="#Description~94"><b>Description</b></a></dt>
  <dd>Will remove <i>len</i> bytes from a <i>msg</i> starting at byte
      <i>start</i>. This may result in <b>ENOMEM</b> errors under certain
      situations if an allocation and copy are required due to a full ring
      buffer. However, the helper will try to avoid doing the allocation if
      possible. Other errors can occur if input parameters are invalid either
      due to <i>start</i> byte not being valid part of <i>msg</i> payload and/or
      <i>pop</i> value being to large.</dd>
  <dt id="Return~94"><a class="permalink" href="#Return~94"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~70"><a class="permalink" href="#long~70"><b><b>long
    bpf_rc_pointer_rel(void *</b><i>ctx</i><b>, s32</b> <i>rel_x</i><b>, s32</b>
    <i>rel_y</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~95"><a class="permalink" href="#Description~95"><b>Description</b></a></dt>
  <dd>This helper is used in programs implementing IR decoding, to report a
      successfully decoded pointer movement.
    <p class="Pp">The <i>ctx</i> should point to the lirc sample as passed into
        the program.</p>
    <p class="Pp">This helper is only available is the kernel was compiled with
        the <b>CONFIG_BPF_LIRC_MODE2</b> configuration option set to
        "<b>y</b>".</p>
  </dd>
  <dt id="Return~95"><a class="permalink" href="#Return~95"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~71"><a class="permalink" href="#long~71"><b><b>long
    bpf_spin_lock(struct bpf_spin_lock *</b><i>lock</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~96"><a class="permalink" href="#Description~96"><b>Description</b></a></dt>
  <dd>Acquire a spinlock represented by the pointer <i>lock</i>, which is stored
      as part of a value of a map. Taking the lock allows to safely update the
      rest of the fields in that value. The spinlock can (and must) later be
      released with a call to <b>bpf_spin_unlock</b>(<i>lock</i>).
    <p class="Pp">Spinlocks in BPF programs come with a number of restrictions
        and constraints:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>bpf_spin_lock</b> objects are only allowed inside maps of types
      <b>BPF_MAP_TYPE_HASH</b> and <b>BPF_MAP_TYPE_ARRAY</b> (this list could be
      extended in the future).</dd>
  <dt>•</dt>
  <dd>BTF description of the map is mandatory.</dd>
  <dt>•</dt>
  <dd>The BPF program can take ONE lock at a time, since taking two or more
      could cause dead locks.</dd>
  <dt>•</dt>
  <dd>Only one <b>struct bpf_spin_lock</b> is allowed per map element.</dd>
  <dt>•</dt>
  <dd>When the lock is taken, calls (either BPF to BPF or helpers) are not
      allowed.</dd>
  <dt>•</dt>
  <dd>The <b>BPF_LD_ABS</b> and <b>BPF_LD_IND</b> instructions are not allowed
      inside a spinlock-ed region.</dd>
  <dt>•</dt>
  <dd>The BPF program MUST call <b>bpf_spin_unlock</b>() to release the lock, on
      all execution paths, before it returns.</dd>
  <dt>•</dt>
  <dd>The BPF program can access <b>struct bpf_spin_lock</b> only via the
      <b>bpf_spin_lock</b>() and <b>bpf_spin_unlock</b>() helpers. Loading or
      storing data into the <b>struct</b> <b>bpf_spin_lock</b>
      <i>lock</i><b>;</b> field of a map is not allowed.</dd>
  <dt>•</dt>
  <dd>To use the <b>bpf_spin_lock</b>() helper, the BTF description of the map
      value must be a struct and have <b>struct</b> <b>bpf_spin_lock</b>
      <i>anyname</i><b>;</b> field at the top level. Nested lock inside another
      struct is not allowed.</dd>
  <dt>•</dt>
  <dd>The <b>struct bpf_spin_lock</b> <i>lock</i> field in a map value must be
      aligned on a multiple of 4 bytes in that value.</dd>
  <dt>•</dt>
  <dd>Syscall with command <b>BPF_MAP_LOOKUP_ELEM</b> does not copy the
      <b>bpf_spin_lock</b> field to user space.</dd>
  <dt>•</dt>
  <dd>Syscall with command <b>BPF_MAP_UPDATE_ELEM</b>, or update from a BPF
      program, do not update the <b>bpf_spin_lock</b> field.</dd>
  <dt>•</dt>
  <dd><b>bpf_spin_lock</b> cannot be on the stack or inside a networking packet
      (it can only be inside of a map values).</dd>
  <dt>•</dt>
  <dd><b>bpf_spin_lock</b> is available to root only.</dd>
  <dt>•</dt>
  <dd>Tracing programs and socket filter programs cannot use
      <b>bpf_spin_lock</b>() due to insufficient preemption checks (but this may
      change in the future).</dd>
  <dt>•</dt>
  <dd><b>bpf_spin_lock</b> is not allowed in inner maps of map-in-map.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~96"><a class="permalink" href="#Return~96"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~72"><a class="permalink" href="#long~72"><b><b>long
    bpf_spin_unlock(struct bpf_spin_lock *</b><i>lock</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~97"><a class="permalink" href="#Description~97"><b>Description</b></a></dt>
  <dd>Release the <i>lock</i> previously locked by a call to
      <b>bpf_spin_lock</b>(<i>lock</i>).</dd>
  <dt id="Return~97"><a class="permalink" href="#Return~97"><b>Return</b></a></dt>
  <dd>0</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~3"><a class="permalink" href="#struct~3"><b><b>struct bpf_sock
    *bpf_sk_fullsock(struct bpf_sock *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~98"><a class="permalink" href="#Description~98"><b>Description</b></a></dt>
  <dd>This helper gets a <b>struct bpf_sock</b> pointer such that all the fields
      in this <b>bpf_sock</b> can be accessed.</dd>
  <dt id="Return~98"><a class="permalink" href="#Return~98"><b>Return</b></a></dt>
  <dd>A <b>struct bpf_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~4"><a class="permalink" href="#struct~4"><b><b>struct
    bpf_tcp_sock *bpf_tcp_sock(struct bpf_sock
    *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~99"><a class="permalink" href="#Description~99"><b>Description</b></a></dt>
  <dd>This helper gets a <b>struct bpf_tcp_sock</b> pointer from a <b>struct
      bpf_sock</b> pointer.</dd>
  <dt id="Return~99"><a class="permalink" href="#Return~99"><b>Return</b></a></dt>
  <dd>A <b>struct bpf_tcp_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~73"><a class="permalink" href="#long~73"><b><b>long
    bpf_skb_ecn_set_ce(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~100"><a class="permalink" href="#Description~100"><b>Description</b></a></dt>
  <dd>Set ECN (Explicit Congestion Notification) field of IP header to <b>CE</b>
      (Congestion Encountered) if current value is <b>ECT</b> (ECN Capable
      Transport). Otherwise, do nothing. Works with IPv6 and IPv4.</dd>
  <dt id="Return~100"><a class="permalink" href="#Return~100"><b>Return</b></a></dt>
  <dd>1 if the <b>CE</b> flag is set (either by the current helper call or
      because it was already present), 0 if it is not set.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~5"><a class="permalink" href="#struct~5"><b><b>struct bpf_sock
    *bpf_get_listener_sock(struct bpf_sock *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~101"><a class="permalink" href="#Description~101"><b>Description</b></a></dt>
  <dd>Return a <b>struct bpf_sock</b> pointer in <b>TCP_LISTEN</b> state.
      <b>bpf_sk_release</b>() is unnecessary and not allowed.</dd>
  <dt id="Return~101"><a class="permalink" href="#Return~101"><b>Return</b></a></dt>
  <dd>A <b>struct bpf_sock</b> pointer on success, or <b>NULL</b> in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~6"><a class="permalink" href="#struct~6"><b><b>struct bpf_sock
    *bpf_skc_lookup_tcp(void *</b><i>ctx</i><b>, struct bpf_sock_tuple
    *</b><i>tuple</i><b>, u32</b> <i>tuple_size</i><b>, u64</b> <i>netns</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~102"><a class="permalink" href="#Description~102"><b>Description</b></a></dt>
  <dd>Look for TCP socket matching <i>tuple</i>, optionally in a child network
      namespace <i>netns</i>. The return value must be checked, and if
      non-<b>NULL</b>, released via <b>bpf_sk_release</b>().
    <p class="Pp">This function is identical to <b>bpf_sk_lookup_tcp</b>(),
        except that it also returns timewait or request sockets. Use
        <b>bpf_sk_fullsock</b>() or <b>bpf_tcp_sock</b>() to access the full
        structure.</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        <b>CONFIG_NET</b> configuration option.</p>
  </dd>
  <dt id="Return~102"><a class="permalink" href="#Return~102"><b>Return</b></a></dt>
  <dd>Pointer to <b>struct bpf_sock</b>, or <b>NULL</b> in case of failure. For
      sockets with reuseport option, the <b>struct bpf_sock</b> result is from
      <i>reuse</i><b>-&gt;socks</b>[] using the hash of the tuple.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~74"><a class="permalink" href="#long~74"><b><b>long
    bpf_tcp_check_syncookie(void *</b><i>sk</i><b>, void *</b><i>iph</i><b>,
    u32</b> <i>iph_len</i><b>, struct tcphdr *</b><i>th</i><b>, u32</b>
    <i>th_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~103"><a class="permalink" href="#Description~103"><b>Description</b></a></dt>
  <dd>Check whether <i>iph</i> and <i>th</i> contain a valid SYN cookie ACK for
      the listening socket in <i>sk</i>.
    <p class="Pp"><i>iph</i> points to the start of the IPv4 or IPv6 header,
        while <i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>) or
        <b>sizeof</b>(<b>struct ipv6hdr</b>).</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains the length of the TCP header (at least
        <b>sizeof</b>(<b>struct tcphdr</b>)).</p>
  </dd>
  <dt id="Return~103"><a class="permalink" href="#Return~103"><b>Return</b></a></dt>
  <dd>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie ACK, or a negative
      error otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~75"><a class="permalink" href="#long~75"><b><b>long
    bpf_sysctl_get_name(struct bpf_sysctl *</b><i>ctx</i><b>, char
    *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~104"><a class="permalink" href="#Description~104"><b>Description</b></a></dt>
  <dd>Get name of sysctl in /proc/sys/ and copy it into provided by program
      buffer <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
    <p class="Pp">If <i>flags</i> is zero, full name (e.g.
        "net/ipv4/tcp_mem") is copied. Use
        <b>BPF_F_SYSCTL_BASE_NAME</b> flag to copy base name only (e.g.
        "tcp_mem").</p>
  </dd>
  <dt id="Return~104"><a class="permalink" href="#Return~104"><b>Return</b></a></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~76"><a class="permalink" href="#long~76"><b><b>long
    bpf_sysctl_get_current_value(struct bpf_sysctl *</b><i>ctx</i><b>, char
    *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~105"><a class="permalink" href="#Description~105"><b>Description</b></a></dt>
  <dd>Get current value of sysctl as it is presented in /proc/sys (incl.
      newline, etc), and copy it as a string into provided by program buffer
      <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">The whole value is copied, no matter what file position user
        space issued e.g. sys_read at.</p>
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
  </dd>
  <dt id="Return~105"><a class="permalink" href="#Return~105"><b>Return</b></a></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
    <p class="Pp"><b>-EINVAL</b> if current value was unavailable, e.g. because
        sysctl is uninitialized and read returns -EIO for it.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~77"><a class="permalink" href="#long~77"><b><b>long
    bpf_sysctl_get_new_value(struct bpf_sysctl *</b><i>ctx</i><b>, char
    *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~106"><a class="permalink" href="#Description~106"><b>Description</b></a></dt>
  <dd>Get new value being written by user space to sysctl (before the actual
      write happens) and copy it as a string into provided by program buffer
      <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp">User space may write new value at file position &gt; 0.</p>
    <p class="Pp">The buffer is always NUL terminated, unless it's
      zero-sized.</p>
  </dd>
  <dt id="Return~106"><a class="permalink" href="#Return~106"><b>Return</b></a></dt>
  <dd>Number of character copied (not including the trailing NUL).
    <p class="Pp"><b>-E2BIG</b> if the buffer wasn't big enough (<i>buf</i> will
        contain truncated name in this case).</p>
    <p class="Pp"><b>-EINVAL</b> if sysctl is being read.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~78"><a class="permalink" href="#long~78"><b><b>long
    bpf_sysctl_set_new_value(struct bpf_sysctl *</b><i>ctx</i><b>, const char
    *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~107"><a class="permalink" href="#Description~107"><b>Description</b></a></dt>
  <dd>Override new value being written by user space to sysctl with value
      provided by program in buffer <i>buf</i> of size <i>buf_len</i>.
    <p class="Pp"><i>buf</i> should contain a string in same form as provided by
        user space on sysctl write.</p>
    <p class="Pp">User space may write new value at file position &gt; 0. To
        override the whole sysctl value file position should be set to zero.</p>
  </dd>
  <dt id="Return~107"><a class="permalink" href="#Return~107"><b>Return</b></a></dt>
  <dd>0 on success.
    <p class="Pp"><b>-E2BIG</b> if the <i>buf_len</i> is too big.</p>
    <p class="Pp"><b>-EINVAL</b> if sysctl is being read.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~79"><a class="permalink" href="#long~79"><b><b>long
    bpf_strtol(const char *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>,
    u64</b> <i>flags</i><b>, long *</b><i>res</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~108"><a class="permalink" href="#Description~108"><b>Description</b></a></dt>
  <dd>Convert the initial part of the string from buffer <i>buf</i> of size
      <i>buf_len</i> to a long integer according to the given base and save the
      result in <i>res</i>.
    <p class="Pp">The string may begin with an arbitrary amount of white space
        (as determined by <b>isspace</b>(3)) followed by a single optional
        '<b>-</b>' sign.</p>
    <p class="Pp">Five least significant bits of <i>flags</i> encode base, other
        bits are currently unused.</p>
    <p class="Pp">Base must be either 8, 10, 16 or 0 to detect it automatically
        similar to user space <b>strtol</b>(3).</p>
  </dd>
  <dt id="Return~108"><a class="permalink" href="#Return~108"><b>Return</b></a></dt>
  <dd>Number of characters consumed on success. Must be positive but no more
      than <i>buf_len</i>.
    <p class="Pp"><b>-EINVAL</b> if no valid digits were found or unsupported
        base was provided.</p>
    <p class="Pp"><b>-ERANGE</b> if resulting value was out of range.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~80"><a class="permalink" href="#long~80"><b><b>long
    bpf_strtoul(const char *</b><i>buf</i><b>, size_t</b> <i>buf_len</i><b>,
    u64</b> <i>flags</i><b>, unsigned long *</b><i>res</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~109"><a class="permalink" href="#Description~109"><b>Description</b></a></dt>
  <dd>Convert the initial part of the string from buffer <i>buf</i> of size
      <i>buf_len</i> to an unsigned long integer according to the given base and
      save the result in <i>res</i>.
    <p class="Pp">The string may begin with an arbitrary amount of white space
        (as determined by <b>isspace</b>(3)).</p>
    <p class="Pp">Five least significant bits of <i>flags</i> encode base, other
        bits are currently unused.</p>
    <p class="Pp">Base must be either 8, 10, 16 or 0 to detect it automatically
        similar to user space <b>strtoul</b>(3).</p>
  </dd>
  <dt id="Return~109"><a class="permalink" href="#Return~109"><b>Return</b></a></dt>
  <dd>Number of characters consumed on success. Must be positive but no more
      than <i>buf_len</i>.
    <p class="Pp"><b>-EINVAL</b> if no valid digits were found or unsupported
        base was provided.</p>
    <p class="Pp"><b>-ERANGE</b> if resulting value was out of range.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~4"><a class="permalink" href="#void~4"><b><b>void
    *bpf_sk_storage_get(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>sk</i><b>, void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~110"><a class="permalink" href="#Description~110"><b>Description</b></a></dt>
  <dd>Get a bpf-local-storage from a <i>sk</i>.
    <p class="Pp">Logically, it could be thought of getting the value from a
        <i>map</i> with <i>sk</i> as the <b>key</b>. From this perspective, the
        usage is not much different from <b>bpf_map_lookup_elem</b>(<i>map</i>,
        <b>&amp;</b><i>sk</i>) except this helper enforces the key must be a
        full socket and the map must be a <b>BPF_MAP_TYPE_SK_STORAGE</b>
      also.</p>
    <p class="Pp">Underneath, the value is stored locally at <i>sk</i> instead
        of the <i>map</i>. The <i>map</i> is used as the bpf-local-storage
        "type". The bpf-local-storage "type" (i.e. the
        <i>map</i>) is searched against all bpf-local-storages residing at
        <i>sk</i>.</p>
    <p class="Pp"><i>sk</i> is a kernel <b>struct sock</b> pointer for LSM
        program. <i>sk</i> is a <b>struct bpf_sock</b> pointer for other program
        types.</p>
    <p class="Pp">An optional <i>flags</i> (<b>BPF_SK_STORAGE_GET_F_CREATE</b>)
        can be used such that a new bpf-local-storage will be created if one
        does not exist. <i>value</i> can be used together with
        <b>BPF_SK_STORAGE_GET_F_CREATE</b> to specify the initial value of a
        bpf-local-storage. If <i>value</i> is <b>NULL</b>, the new
        bpf-local-storage will be zero initialized.</p>
  </dd>
  <dt id="Return~110"><a class="permalink" href="#Return~110"><b>Return</b></a></dt>
  <dd>A bpf-local-storage pointer is returned on success.
    <p class="Pp"><b>NULL</b> if not found or there was an error in adding a new
        bpf-local-storage.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~81"><a class="permalink" href="#long~81"><b><b>long
    bpf_sk_storage_delete(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~111"><a class="permalink" href="#Description~111"><b>Description</b></a></dt>
  <dd>Delete a bpf-local-storage from a <i>sk</i>.</dd>
  <dt id="Return~111"><a class="permalink" href="#Return~111"><b>Return</b></a></dt>
  <dd>0 on success.
    <p class="Pp"><b>-ENOENT</b> if the bpf-local-storage cannot be found.
        <b>-EINVAL</b> if sk is not a fullsock (e.g. a request_sock).</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~82"><a class="permalink" href="#long~82"><b><b>long
    bpf_send_signal(u32</b> <i>sig</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~112"><a class="permalink" href="#Description~112"><b>Description</b></a></dt>
  <dd>Send signal <i>sig</i> to the process of the current task. The signal may
      be delivered to any of this process's threads.</dd>
  <dt id="Return~112"><a class="permalink" href="#Return~112"><b>Return</b></a></dt>
  <dd>0 on success or successfully queued.
    <p class="Pp"><b>-EBUSY</b> if work queue under nmi is full.</p>
    <p class="Pp"><b>-EINVAL</b> if <i>sig</i> is invalid.</p>
    <p class="Pp"><b>-EPERM</b> if no permission to send the <i>sig</i>.</p>
    <p class="Pp"><b>-EAGAIN</b> if bpf program can try again.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="s64~3"><a class="permalink" href="#s64~3"><b><b>s64
    bpf_tcp_gen_syncookie(void *</b><i>sk</i><b>, void *</b><i>iph</i><b>,
    u32</b> <i>iph_len</i><b>, struct tcphdr *</b><i>th</i><b>, u32</b>
    <i>th_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~113"><a class="permalink" href="#Description~113"><b>Description</b></a></dt>
  <dd>Try to issue a SYN cookie for the packet with corresponding IP/TCP
      headers, <i>iph</i> and <i>th</i>, on the listening socket in <i>sk</i>.
    <p class="Pp"><i>iph</i> points to the start of the IPv4 or IPv6 header,
        while <i>iph_len</i> contains <b>sizeof</b>(<b>struct iphdr</b>) or
        <b>sizeof</b>(<b>struct ipv6hdr</b>).</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains the length of the TCP header with options (at
        least <b>sizeof</b>(<b>struct tcphdr</b>)).</p>
  </dd>
  <dt id="Return~113"><a class="permalink" href="#Return~113"><b>Return</b></a></dt>
  <dd>On success, lower 32 bits hold the generated SYN cookie in followed by 16
      bits which hold the MSS value for that cookie, and the top 16 bits are
      unused.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EINVAL</b> SYN cookie cannot be issued due to error</p>
    <p class="Pp"><b>-ENOENT</b> SYN cookie should not be issued (no SYN
      flood)</p>
    <p class="Pp"><b>-EOPNOTSUPP</b> kernel configuration does not enable SYN
        cookies</p>
    <p class="Pp"><b>-EPROTONOSUPPORT</b> IP packet version is not 4 or 6</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~83"><a class="permalink" href="#long~83"><b><b>long
    bpf_skb_output(void *</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,
    u64</b> <i>flags</i><b>, void *</b><i>data</i><b>, u64</b>
    <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~114"><a class="permalink" href="#Description~114"><b>Description</b></a></dt>
  <dd>Write raw <i>data</i> blob into a special BPF perf event held by
      <i>map</i> of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event
      must have the following attributes: <b>PERF_SAMPLE_RAW</b> as
      <b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as <b>type</b>, and
      <b>PERF_COUNT_SW_BPF_OUTPUT</b> as <b>config</b>.
    <p class="Pp">The <i>flags</i> are used to indicate the index in <i>map</i>
        for which the value must be put, masked with <b>BPF_F_INDEX_MASK</b>.
        Alternatively, <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to
        indicate that the index of the current CPU core should be used.</p>
    <p class="Pp">The value to write, of <i>size</i>, is passed through eBPF
        stack and pointed by <i>data</i>.</p>
    <p class="Pp"><i>ctx</i> is a pointer to in-kernel struct sk_buff.</p>
    <p class="Pp">This helper is similar to <b>bpf_perf_event_output</b>() but
        restricted to raw_tracepoint bpf programs.</p>
  </dd>
  <dt id="Return~114"><a class="permalink" href="#Return~114"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~84"><a class="permalink" href="#long~84"><b><b>long
    bpf_probe_read_user(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>, const
    void *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~115"><a class="permalink" href="#Description~115"><b>Description</b></a></dt>
  <dd>Safely attempt to read <i>size</i> bytes from user space address
      <i>unsafe_ptr</i> and store the data in <i>dst</i>.</dd>
  <dt id="Return~115"><a class="permalink" href="#Return~115"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~85"><a class="permalink" href="#long~85"><b><b>long
    bpf_probe_read_kernel(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>, const
    void *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~116"><a class="permalink" href="#Description~116"><b>Description</b></a></dt>
  <dd>Safely attempt to read <i>size</i> bytes from kernel space address
      <i>unsafe_ptr</i> and store the data in <i>dst</i>.</dd>
  <dt id="Return~116"><a class="permalink" href="#Return~116"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~86"><a class="permalink" href="#long~86"><b><b>long
    bpf_probe_read_user_str(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>,
    const void *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~117"><a class="permalink" href="#Description~117"><b>Description</b></a></dt>
  <dd>Copy a NUL terminated string from an unsafe user address <i>unsafe_ptr</i>
      to <i>dst</i>. The <i>size</i> should include the terminating NUL byte. In
      case the string length is smaller than <i>size</i>, the target is not
      padded with further NUL bytes. If the string length is larger than
      <i>size</i>, just <i>size</i>-1 bytes are copied and the last byte is set
      to NUL.
    <p class="Pp">On success, returns the number of bytes that were written,
        including the terminal NUL. This makes this helper useful in tracing
        programs for reading strings, and more importantly to get its length at
        runtime. See the following snippet:</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>SEC("kprobe/sys_open")
void bpf_sys_open(struct pt_regs *ctx)
{
<br>
        char buf[PATHLEN]; // PATHLEN is defined to 256
<br>
        int res = bpf_probe_read_user_str(buf, sizeof(buf),
<br>
                                          ctx-&gt;di);
<br>
        // Consume buf, for example push it to
<br>
        // userspace via bpf_perf_event_output(); we
<br>
        // can use res (the string length) as event
<br>
        // size, after checking its boundaries.
}
</pre>
</div>
<br>
</div>
<br>
<p class="Pp">In comparison, using <b>bpf_probe_read_user</b>() helper here
    instead to read the string would require to estimate the length at compile
    time, and would often result in copying more memory than necessary.</p>
<p class="Pp">Another useful use case is when parsing individual process
    arguments or individual environment variables navigating
    <i>current</i><b>-&gt;mm-&gt;arg_start</b> and
    <i>current</i><b>-&gt;mm-&gt;env_start</b>: using this helper and the return
    value, one can quickly iterate at the right offset of the memory area.</p>
<dl class="Bl-tag">
  <dt id="Return~117"><a class="permalink" href="#Return~117"><b>Return</b></a></dt>
  <dd>On success, the strictly positive length of the output string, including
      the trailing NUL character. On error, a negative value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~87"><a class="permalink" href="#long~87"><b><b>long
    bpf_probe_read_kernel_str(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>,
    const void *</b><i>unsafe_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~118"><a class="permalink" href="#Description~118"><b>Description</b></a></dt>
  <dd>Copy a NUL terminated string from an unsafe kernel address
      <i>unsafe_ptr</i> to <i>dst</i>. Same semantics as with
      <b>bpf_probe_read_user_str</b>() apply.</dd>
  <dt id="Return~118"><a class="permalink" href="#Return~118"><b>Return</b></a></dt>
  <dd>On success, the strictly positive length of the string, including the
      trailing NUL character. On error, a negative value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~88"><a class="permalink" href="#long~88"><b><b>long
    bpf_tcp_send_ack(void *</b><i>tp</i><b>, u32</b>
    <i>rcv_nxt</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~119"><a class="permalink" href="#Description~119"><b>Description</b></a></dt>
  <dd>Send out a tcp-ack. <i>tp</i> is the in-kernel struct <b>tcp_sock</b>.
      <i>rcv_nxt</i> is the ack_seq to be sent out.</dd>
  <dt id="Return~119"><a class="permalink" href="#Return~119"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~89"><a class="permalink" href="#long~89"><b><b>long
    bpf_send_signal_thread(u32</b> <i>sig</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~120"><a class="permalink" href="#Description~120"><b>Description</b></a></dt>
  <dd>Send signal <i>sig</i> to the thread corresponding to the current
    task.</dd>
  <dt id="Return~120"><a class="permalink" href="#Return~120"><b>Return</b></a></dt>
  <dd>0 on success or successfully queued.
    <p class="Pp"><b>-EBUSY</b> if work queue under nmi is full.</p>
    <p class="Pp"><b>-EINVAL</b> if <i>sig</i> is invalid.</p>
    <p class="Pp"><b>-EPERM</b> if no permission to send the <i>sig</i>.</p>
    <p class="Pp"><b>-EAGAIN</b> if bpf program can try again.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~13"><a class="permalink" href="#u64~13"><b><b>u64
    bpf_jiffies64(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~121"><a class="permalink" href="#Description~121"><b>Description</b></a></dt>
  <dd>Obtain the 64bit jiffies</dd>
  <dt id="Return~121"><a class="permalink" href="#Return~121"><b>Return</b></a></dt>
  <dd>The 64 bit jiffies</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~90"><a class="permalink" href="#long~90"><b><b>long
    bpf_read_branch_records(struct bpf_perf_event_data *</b><i>ctx</i><b>, void
    *</b><i>buf</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~122"><a class="permalink" href="#Description~122"><b>Description</b></a></dt>
  <dd>For an eBPF program attached to a perf event, retrieve the branch records
      (<b>struct perf_branch_entry</b>) associated to <i>ctx</i> and store it in
      the buffer pointed by <i>buf</i> up to size <i>size</i> bytes.</dd>
  <dt id="Return~122"><a class="permalink" href="#Return~122"><b>Return</b></a></dt>
  <dd>On success, number of bytes written to <i>buf</i>. On error, a negative
      value.
    <p class="Pp">The <i>flags</i> can be set to
        <b>BPF_F_GET_BRANCH_RECORDS_SIZE</b> to instead return the number of
        bytes required to store all the branch entries. If this flag is set,
        <i>buf</i> may be NULL.</p>
    <p class="Pp"><b>-EINVAL</b> if arguments invalid or <b>size</b> not a
        multiple of <b>sizeof</b>(<b>struct perf_branch_entry</b>).</p>
    <p class="Pp"><b>-ENOENT</b> if architecture does not support branch
        records.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~91"><a class="permalink" href="#long~91"><b><b>long
    bpf_get_ns_current_pid_tgid(u64</b> <i>dev</i><b>, u64</b> <i>ino</i><b>,
    struct bpf_pidns_info *</b><i>nsdata</i><b>, u32</b>
    <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~123"><a class="permalink" href="#Description~123"><b>Description</b></a></dt>
  <dd>Returns 0 on success, values for <i>pid</i> and <i>tgid</i> as seen from
      the current <i>namespace</i> will be returned in <i>nsdata</i>.</dd>
  <dt id="Return~123"><a class="permalink" href="#Return~123"><b>Return</b></a></dt>
  <dd>0 on success, or one of the following in case of failure:
    <p class="Pp"><b>-EINVAL</b> if dev and inum supplied don't match dev_t and
        inode number with nsfs of current task, or if dev conversion to dev_t
        lost high bits.</p>
    <p class="Pp"><b>-ENOENT</b> if pidns does not exists for the current
      task.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~92"><a class="permalink" href="#long~92"><b><b>long
    bpf_xdp_output(void *</b><i>ctx</i><b>, struct bpf_map *</b><i>map</i><b>,
    u64</b> <i>flags</i><b>, void *</b><i>data</i><b>, u64</b>
    <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~124"><a class="permalink" href="#Description~124"><b>Description</b></a></dt>
  <dd>Write raw <i>data</i> blob into a special BPF perf event held by
      <i>map</i> of type <b>BPF_MAP_TYPE_PERF_EVENT_ARRAY</b>. This perf event
      must have the following attributes: <b>PERF_SAMPLE_RAW</b> as
      <b>sample_type</b>, <b>PERF_TYPE_SOFTWARE</b> as <b>type</b>, and
      <b>PERF_COUNT_SW_BPF_OUTPUT</b> as <b>config</b>.
    <p class="Pp">The <i>flags</i> are used to indicate the index in <i>map</i>
        for which the value must be put, masked with <b>BPF_F_INDEX_MASK</b>.
        Alternatively, <i>flags</i> can be set to <b>BPF_F_CURRENT_CPU</b> to
        indicate that the index of the current CPU core should be used.</p>
    <p class="Pp">The value to write, of <i>size</i>, is passed through eBPF
        stack and pointed by <i>data</i>.</p>
    <p class="Pp"><i>ctx</i> is a pointer to in-kernel struct xdp_buff.</p>
    <p class="Pp">This helper is similar to <b>bpf_perf_eventoutput</b>() but
        restricted to raw_tracepoint bpf programs.</p>
  </dd>
  <dt id="Return~124"><a class="permalink" href="#Return~124"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~14"><a class="permalink" href="#u64~14"><b><b>u64
    bpf_get_netns_cookie(void *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~125"><a class="permalink" href="#Description~125"><b>Description</b></a></dt>
  <dd>Retrieve the cookie (generated by the kernel) of the network namespace the
      input <i>ctx</i> is associated with. The network namespace cookie remains
      stable for its lifetime and provides a global identifier that can be
      assumed unique. If <i>ctx</i> is NULL, then the helper returns the cookie
      for the initial network namespace. The cookie itself is very similar to
      that of <b>bpf_get_socket_cookie</b>() helper, but for network namespaces
      instead of sockets.</dd>
  <dt id="Return~125"><a class="permalink" href="#Return~125"><b>Return</b></a></dt>
  <dd>A 8-byte long opaque number.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~15"><a class="permalink" href="#u64~15"><b><b>u64
    bpf_get_current_ancestor_cgroup_id(int</b>
    <i>ancestor_level</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~126"><a class="permalink" href="#Description~126"><b>Description</b></a></dt>
  <dd>Return id of cgroup v2 that is ancestor of the cgroup associated with the
      current task at the <i>ancestor_level</i>. The root cgroup is at
      <i>ancestor_level</i> zero and each step down the hierarchy increments the
      level. If <i>ancestor_level</i> == level of cgroup associated with the
      current task, then return value will be the same as that of
      <b>bpf_get_current_cgroup_id</b>().
    <p class="Pp">The helper is useful to implement policies based on cgroups
        that are upper in hierarchy than immediate cgroup associated with the
        current task.</p>
    <p class="Pp">The format of returned id and helper limitations are same as
        in <b>bpf_get_current_cgroup_id</b>().</p>
  </dd>
  <dt id="Return~126"><a class="permalink" href="#Return~126"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~93"><a class="permalink" href="#long~93"><b><b>long
    bpf_sk_assign(struct sk_buff *</b><i>skb</i><b>, void *</b><i>sk</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~127"><a class="permalink" href="#Description~127"><b>Description</b></a></dt>
  <dd>Helper is overloaded depending on BPF program type. This description
      applies to <b>BPF_PROG_TYPE_SCHED_CLS</b> and
      <b>BPF_PROG_TYPE_SCHED_ACT</b> programs.
    <p class="Pp">Assign the <i>sk</i> to the <i>skb</i>. When combined with
        appropriate routing configuration to receive the packet towards the
        socket, will cause <i>skb</i> to be delivered to the specified socket.
        Subsequent redirection of <i>skb</i> via <b>bpf_redirect</b>(),
        <b>bpf_clone_redirect</b>() or other methods outside of BPF may
        interfere with successful delivery to the socket.</p>
    <p class="Pp">This operation is only valid from TC ingress path.</p>
    <p class="Pp">The <i>flags</i> argument must be zero.</p>
  </dd>
  <dt id="Return~127"><a class="permalink" href="#Return~127"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure:
    <p class="Pp"><b>-EINVAL</b> if specified <i>flags</i> are not
      supported.</p>
    <p class="Pp"><b>-ENOENT</b> if the socket is unavailable for
      assignment.</p>
    <p class="Pp"><b>-ENETUNREACH</b> if the socket is unreachable (wrong
        netns).</p>
    <p class="Pp"><b>-EOPNOTSUPP</b> if the operation is not supported, for
        example a call from outside of TC ingress.</p>
    <p class="Pp"><b>-ESOCKTNOSUPPORT</b> if the socket type is not supported
        (reuseport).</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~94"><a class="permalink" href="#long~94"><b><b>long
    bpf_sk_assign(struct bpf_sk_lookup *</b><i>ctx</i><b>, struct bpf_sock
    *</b><i>sk</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~128"><a class="permalink" href="#Description~128"><b>Description</b></a></dt>
  <dd>Helper is overloaded depending on BPF program type. This description
      applies to <b>BPF_PROG_TYPE_SK_LOOKUP</b> programs.
    <p class="Pp">Select the <i>sk</i> as a result of a socket lookup.</p>
    <p class="Pp">For the operation to succeed passed socket must be compatible
        with the packet description provided by the <i>ctx</i> object.</p>
    <p class="Pp">L4 protocol (<b>IPPROTO_TCP</b> or <b>IPPROTO_UDP</b>) must be
        an exact match. While IP family (<b>AF_INET</b> or <b>AF_INET6</b>) must
        be compatible, that is IPv6 sockets that are not v6-only can be selected
        for IPv4 packets.</p>
    <p class="Pp">Only TCP listeners and UDP unconnected sockets can be
        selected. <i>sk</i> can also be NULL to reset any previous
      selection.</p>
    <p class="Pp"><i>flags</i> argument can combination of following values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_SK_LOOKUP_F_REPLACE</b> to override the previous socket selection,
      potentially done by a BPF program that ran before us.</dd>
  <dt>•</dt>
  <dd><b>BPF_SK_LOOKUP_F_NO_REUSEPORT</b> to skip load-balancing within
      reuseport group for the socket being selected.</dd>
</dl>
</div>
<br>
<p class="Pp">On success <i>ctx-&gt;sk</i> will point to the selected
  socket.</p>
<dl class="Bl-tag">
  <dt id="Return~128"><a class="permalink" href="#Return~128"><b>Return</b></a></dt>
  <dd>0 on success, or a negative errno in case of failure.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>-EAFNOSUPPORT</b> if socket family (<i>sk-&gt;family</i>) is not
      compatible with packet family (<i>ctx-&gt;family</i>).</dd>
  <dt>•</dt>
  <dd><b>-EEXIST</b> if socket has been already selected, potentially by another
      program, and <b>BPF_SK_LOOKUP_F_REPLACE</b> flag was not specified.</dd>
  <dt>•</dt>
  <dd><b>-EINVAL</b> if unsupported flags were specified.</dd>
  <dt>•</dt>
  <dd><b>-EPROTOTYPE</b> if socket L4 protocol (<i>sk-&gt;protocol</i>) doesn't
      match packet protocol (<i>ctx-&gt;protocol</i>).</dd>
  <dt>•</dt>
  <dd><b>-ESOCKTNOSUPPORT</b> if socket is not in allowed state (TCP listening
      or UDP unconnected).</dd>
</dl>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~16"><a class="permalink" href="#u64~16"><b><b>u64
    bpf_ktime_get_boot_ns(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~129"><a class="permalink" href="#Description~129"><b>Description</b></a></dt>
  <dd>Return the time elapsed since system boot, in nanoseconds. Does include
      the time the system was suspended. See:
      <b>clock_gettime</b>(<b>CLOCK_BOOTTIME</b>)</dd>
  <dt id="Return~129"><a class="permalink" href="#Return~129"><b>Return</b></a></dt>
  <dd>Current <i>ktime</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~95"><a class="permalink" href="#long~95"><b><b>long
    bpf_seq_printf(struct seq_file *</b><i>m</i><b>, const char
    *</b><i>fmt</i><b>, u32</b> <i>fmt_size</i><b>, const void
    *</b><i>data</i><b>, u32</b> <i>data_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~130"><a class="permalink" href="#Description~130"><b>Description</b></a></dt>
  <dd><b>bpf_seq_printf</b>() uses seq_file <b>seq_printf</b>() to print out the
      format string. The <i>m</i> represents the seq_file. The <i>fmt</i> and
      <i>fmt_size</i> are for the format string itself. The <i>data</i> and
      <i>data_len</i> are format string arguments. The <i>data</i> are a
      <b>u64</b> array and corresponding format string values are stored in the
      array. For strings and pointers where pointees are accessed, only the
      pointer values are stored in the <i>data</i> array. The <i>data_len</i> is
      the size of <i>data</i> in bytes - must be a multiple of 8.
    <p class="Pp">Formats <b>%s</b>, <b>%p{i,I}{4,6}</b> requires to read kernel
        memory. Reading kernel memory may fail due to either invalid address or
        valid address but requiring a major memory fault. If reading kernel
        memory fails, the string for <b>%s</b> will be an empty string, and the
        ip address for <b>%p{i,I}{4,6}</b> will be 0. Not returning error to bpf
        program is consistent with what <b>bpf_trace_printk</b>() does for
      now.</p>
  </dd>
  <dt id="Return~130"><a class="permalink" href="#Return~130"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure:
    <p class="Pp"><b>-EBUSY</b> if per-CPU memory copy buffer is busy, can try
        again by returning 1 from bpf program.</p>
    <p class="Pp"><b>-EINVAL</b> if arguments are invalid, or if <i>fmt</i> is
        invalid/unsupported.</p>
    <p class="Pp"><b>-E2BIG</b> if <i>fmt</i> contains too many format
        specifiers.</p>
    <p class="Pp"><b>-EOVERFLOW</b> if an overflow happened: The same object
        will be tried again.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~96"><a class="permalink" href="#long~96"><b><b>long
    bpf_seq_write(struct seq_file *</b><i>m</i><b>, const void
    *</b><i>data</i><b>, u32</b> <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~131"><a class="permalink" href="#Description~131"><b>Description</b></a></dt>
  <dd><b>bpf_seq_write</b>() uses seq_file <b>seq_write</b>() to write the data.
      The <i>m</i> represents the seq_file. The <i>data</i> and <i>len</i>
      represent the data to write in bytes.</dd>
  <dt id="Return~131"><a class="permalink" href="#Return~131"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure:
    <p class="Pp"><b>-EOVERFLOW</b> if an overflow happened: The same object
        will be tried again.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~17"><a class="permalink" href="#u64~17"><b><b>u64
    bpf_sk_cgroup_id(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~132"><a class="permalink" href="#Description~132"><b>Description</b></a></dt>
  <dd>Return the cgroup v2 id of the socket <i>sk</i>.
    <p class="Pp"><i>sk</i> must be a non-<b>NULL</b> pointer to a socket, e.g.
        one returned from <b>bpf_sk_lookup_xxx</b>(), <b>bpf_sk_fullsock</b>(),
        etc. The format of returned id is same as in
      <b>bpf_skb_cgroup_id</b>().</p>
    <p class="Pp">This helper is available only if the kernel was compiled with
        the <b>CONFIG_SOCK_CGROUP_DATA</b> configuration option.</p>
  </dd>
  <dt id="Return~132"><a class="permalink" href="#Return~132"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~18"><a class="permalink" href="#u64~18"><b><b>u64
    bpf_sk_ancestor_cgroup_id(void *</b><i>sk</i><b>, int</b>
    <i>ancestor_level</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~133"><a class="permalink" href="#Description~133"><b>Description</b></a></dt>
  <dd>Return id of cgroup v2 that is ancestor of cgroup associated with the
      <i>sk</i> at the <i>ancestor_level</i>. The root cgroup is at
      <i>ancestor_level</i> zero and each step down the hierarchy increments the
      level. If <i>ancestor_level</i> == level of cgroup associated with
      <i>sk</i>, then return value will be same as that of
      <b>bpf_sk_cgroup_id</b>().
    <p class="Pp">The helper is useful to implement policies based on cgroups
        that are upper in hierarchy than immediate cgroup associated with
        <i>sk</i>.</p>
    <p class="Pp">The format of returned id and helper limitations are same as
        in <b>bpf_sk_cgroup_id</b>().</p>
  </dd>
  <dt id="Return~133"><a class="permalink" href="#Return~133"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~97"><a class="permalink" href="#long~97"><b><b>long
    bpf_ringbuf_output(void *</b><i>ringbuf</i><b>, void *</b><i>data</i><b>,
    u64</b> <i>size</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~134"><a class="permalink" href="#Description~134"><b>Description</b></a></dt>
  <dd>Copy <i>size</i> bytes from <i>data</i> into a ring buffer <i>ringbuf</i>.
      If <b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no notification
      of new data availability is sent. If <b>BPF_RB_FORCE_WAKEUP</b> is
      specified in <i>flags</i>, notification of new data availability is sent
      unconditionally. If <b>0</b> is specified in <i>flags</i>, an adaptive
      notification of new data availability is sent.
    <p class="Pp">An adaptive notification is a notification sent whenever the
        user-space process has caught up and consumed all available payloads. In
        case the user-space process is still processing a previous payload, then
        no notification is needed as it will process the newly added payload
        automatically.</p>
  </dd>
  <dt id="Return~134"><a class="permalink" href="#Return~134"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~5"><a class="permalink" href="#void~5"><b><b>void
    *bpf_ringbuf_reserve(void *</b><i>ringbuf</i><b>, u64</b> <i>size</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~135"><a class="permalink" href="#Description~135"><b>Description</b></a></dt>
  <dd>Reserve <i>size</i> bytes of payload in a ring buffer <i>ringbuf</i>.
      <i>flags</i> must be 0.</dd>
  <dt id="Return~135"><a class="permalink" href="#Return~135"><b>Return</b></a></dt>
  <dd>Valid pointer with <i>size</i> bytes of memory available; NULL,
    otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~6"><a class="permalink" href="#void~6"><b><b>void
    bpf_ringbuf_submit(void *</b><i>data</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~136"><a class="permalink" href="#Description~136"><b>Description</b></a></dt>
  <dd>Submit reserved ring buffer sample, pointed to by <i>data</i>. If
      <b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no notification of
      new data availability is sent. If <b>BPF_RB_FORCE_WAKEUP</b> is specified
      in <i>flags</i>, notification of new data availability is sent
      unconditionally. If <b>0</b> is specified in <i>flags</i>, an adaptive
      notification of new data availability is sent.
    <p class="Pp">See 'bpf_ringbuf_output()' for the definition of adaptive
        notification.</p>
  </dd>
  <dt id="Return~136"><a class="permalink" href="#Return~136"><b>Return</b></a></dt>
  <dd>Nothing. Always succeeds.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~7"><a class="permalink" href="#void~7"><b><b>void
    bpf_ringbuf_discard(void *</b><i>data</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~137"><a class="permalink" href="#Description~137"><b>Description</b></a></dt>
  <dd>Discard reserved ring buffer sample, pointed to by <i>data</i>. If
      <b>BPF_RB_NO_WAKEUP</b> is specified in <i>flags</i>, no notification of
      new data availability is sent. If <b>BPF_RB_FORCE_WAKEUP</b> is specified
      in <i>flags</i>, notification of new data availability is sent
      unconditionally. If <b>0</b> is specified in <i>flags</i>, an adaptive
      notification of new data availability is sent.
    <p class="Pp">See 'bpf_ringbuf_output()' for the definition of adaptive
        notification.</p>
  </dd>
  <dt id="Return~137"><a class="permalink" href="#Return~137"><b>Return</b></a></dt>
  <dd>Nothing. Always succeeds.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~19"><a class="permalink" href="#u64~19"><b><b>u64
    bpf_ringbuf_query(void *</b><i>ringbuf</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~138"><a class="permalink" href="#Description~138"><b>Description</b></a></dt>
  <dd>Query various characteristics of provided ring buffer. What exactly is
      queries is determined by <i>flags</i>:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_RB_AVAIL_DATA</b>: Amount of data not yet consumed.</dd>
  <dt>•</dt>
  <dd><b>BPF_RB_RING_SIZE</b>: The size of ring buffer.</dd>
  <dt>•</dt>
  <dd><b>BPF_RB_CONS_POS</b>: Consumer position (can wrap around).</dd>
  <dt>•</dt>
  <dd><b>BPF_RB_PROD_POS</b>: Producer(s) position (can wrap around).</dd>
</dl>
</div>
<br>
<p class="Pp">Data returned is just a momentary snapshot of actual values and
    could be inaccurate, so this facility should be used to power heuristics and
    for reporting, not to make 100% correct calculation.</p>
<dl class="Bl-tag">
  <dt id="Return~138"><a class="permalink" href="#Return~138"><b>Return</b></a></dt>
  <dd>Requested value, or 0, if <i>flags</i> are not recognized.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~98"><a class="permalink" href="#long~98"><b><b>long
    bpf_csum_level(struct sk_buff *</b><i>skb</i><b>, u64</b>
    <i>level</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~139"><a class="permalink" href="#Description~139"><b>Description</b></a></dt>
  <dd>Change the skbs checksum level by one layer up or down, or reset it
      entirely to none in order to have the stack perform checksum validation.
      The level is applicable to the following protocols: TCP, UDP, GRE, SCTP,
      FCOE. For example, a decap of | ETH | IP | UDP | GUE | IP | TCP | into |
      ETH | IP | TCP | through <b>bpf_skb_adjust_room</b>() helper with passing
      in <b>BPF_F_ADJ_ROOM_NO_CSUM_RESET</b> flag would require one call to
      <b>bpf_csum_level</b>() with <b>BPF_CSUM_LEVEL_DEC</b> since the UDP
      header is removed. Similarly, an encap of the latter into the former could
      be accompanied by a helper call to <b>bpf_csum_level</b>() with
      <b>BPF_CSUM_LEVEL_INC</b> if the skb is still intended to be processed in
      higher layers of the stack instead of just egressing at tc.
    <p class="Pp">There are three supported level settings at this time:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_CSUM_LEVEL_INC</b>: Increases skb-&gt;csum_level for skbs with
      CHECKSUM_UNNECESSARY.</dd>
  <dt>•</dt>
  <dd><b>BPF_CSUM_LEVEL_DEC</b>: Decreases skb-&gt;csum_level for skbs with
      CHECKSUM_UNNECESSARY.</dd>
  <dt>•</dt>
  <dd><b>BPF_CSUM_LEVEL_RESET</b>: Resets skb-&gt;csum_level to 0 and sets
      CHECKSUM_NONE to force checksum validation by the stack.</dd>
  <dt>•</dt>
  <dd><b>BPF_CSUM_LEVEL_QUERY</b>: No-op, returns the current
      skb-&gt;csum_level.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~139"><a class="permalink" href="#Return~139"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure. In the case of
      <b>BPF_CSUM_LEVEL_QUERY</b>, the current skb-&gt;csum_level is returned or
      the error code -EACCES in case the skb is not subject to
      CHECKSUM_UNNECESSARY.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~7"><a class="permalink" href="#struct~7"><b><b>struct tcp6_sock
    *bpf_skc_to_tcp6_sock(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~140"><a class="permalink" href="#Description~140"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>tcp6_sock</i> pointer.</dd>
  <dt id="Return~140"><a class="permalink" href="#Return~140"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~8"><a class="permalink" href="#struct~8"><b><b>struct tcp_sock
    *bpf_skc_to_tcp_sock(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~141"><a class="permalink" href="#Description~141"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>tcp_sock</i> pointer.</dd>
  <dt id="Return~141"><a class="permalink" href="#Return~141"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~9"><a class="permalink" href="#struct~9"><b><b>struct
    tcp_timewait_sock *bpf_skc_to_tcp_timewait_sock(void
    *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~142"><a class="permalink" href="#Description~142"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>tcp_timewait_sock</i>
      pointer.</dd>
  <dt id="Return~142"><a class="permalink" href="#Return~142"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~10"><a class="permalink" href="#struct~10"><b><b>struct
    tcp_request_sock *bpf_skc_to_tcp_request_sock(void
    *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~143"><a class="permalink" href="#Description~143"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>tcp_request_sock</i>
    pointer.</dd>
  <dt id="Return~143"><a class="permalink" href="#Return~143"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~11"><a class="permalink" href="#struct~11"><b><b>struct
    udp6_sock *bpf_skc_to_udp6_sock(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~144"><a class="permalink" href="#Description~144"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>udp6_sock</i> pointer.</dd>
  <dt id="Return~144"><a class="permalink" href="#Return~144"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~99"><a class="permalink" href="#long~99"><b><b>long
    bpf_get_task_stack(struct task_struct *</b><i>task</i><b>, void
    *</b><i>buf</i><b>, u32</b> <i>size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~145"><a class="permalink" href="#Description~145"><b>Description</b></a></dt>
  <dd>Return a user or a kernel stack in bpf program provided buffer. To achieve
      this, the helper needs <i>task</i>, which is a valid pointer to <b>struct
      task_struct</b>. To store the stacktrace, the bpf program provides
      <i>buf</i> with a nonnegative <i>size</i>.
    <p class="Pp">The last argument, <i>flags</i>, holds the number of stack
        frames to skip (from 0 to 255), masked with
        <b>BPF_F_SKIP_FIELD_MASK</b>. The next bits can be used to set the
        following flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_F_USER_STACK~3"><a class="permalink" href="#BPF_F_USER_STACK~3"><b><b>BPF_F_USER_STACK</b></b></a></dt>
  <dd>Collect a user space stack instead of a kernel stack.</dd>
  <dt id="BPF_F_USER_BUILD_ID~2"><a class="permalink" href="#BPF_F_USER_BUILD_ID~2"><b><b>BPF_F_USER_BUILD_ID</b></b></a></dt>
  <dd>Collect buildid+offset instead of ips for user stack, only valid if
      <b>BPF_F_USER_STACK</b> is also specified.</dd>
</dl>
</div>
<br>
<p class="Pp"><b>bpf_get_task_stack</b>() can collect up to
    <b>PERF_MAX_STACK_DEPTH</b> both kernel and user frames, subject to
    sufficient large buffer size. Note that this limit can be controlled with
    the <b>sysctl</b> program, and that it should be manually increased in order
    to profile long user stacks (such as stacks for Java programs). To do so,
    use:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre># sysctl kernel.perf_event_max_stack=&lt;new value&gt;
</pre>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~145"><a class="permalink" href="#Return~145"><b>Return</b></a></dt>
  <dd>The non-negative copied <i>buf</i> length equal to or less than
      <i>size</i> on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~100"><a class="permalink" href="#long~100"><b><b>long
    bpf_load_hdr_opt(struct bpf_sock_ops *</b><i>skops</i><b>, void
    *</b><i>searchby_res</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~146"><a class="permalink" href="#Description~146"><b>Description</b></a></dt>
  <dd>Load header option. Support reading a particular TCP header option for bpf
      program (<b>BPF_PROG_TYPE_SOCK_OPS</b>).
    <p class="Pp">If <i>flags</i> is 0, it will search the option from the
        <i>skops</i><b>-&gt;skb_data</b>. The comment in <b>struct
        bpf_sock_ops</b> has details on what skb_data contains under different
        <i>skops</i><b>-&gt;op</b>.</p>
    <p class="Pp">The first byte of the <i>searchby_res</i> specifies the kind
        that it wants to search.</p>
    <p class="Pp">If the searching kind is an experimental kind (i.e. 253 or 254
        according to RFC6994). It also needs to specify the "magic"
        which is either 2 bytes or 4 bytes. It then also needs to specify the
        size of the magic by using the 2nd byte which is "kind-length"
        of a TCP header option and the "kind-length" also includes the
        first 2 bytes "kind" and "kind-length" itself as a
        normal TCP header option also does.</p>
    <p class="Pp">For example, to search experimental kind 254 with 2 byte magic
        0xeB9F, the searchby_res should be [ 254, 4, 0xeB, 0x9F, 0, 0, .... 0
      ].</p>
    <p class="Pp">To search for the standard window scale option (3), the
        <i>searchby_res</i> should be [ 3, 0, 0, .... 0 ]. Note, kind-length
        must be 0 for regular option.</p>
    <p class="Pp">Searching for No-Op (0) and End-of-Option-List (1) are not
        supported.</p>
    <p class="Pp"><i>len</i> must be at least 2 bytes which is the minimal size
        of a header option.</p>
    <p class="Pp">Supported flags:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_LOAD_HDR_OPT_TCP_SYN</b> to search from the saved_syn packet or the
      just-received syn packet.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~146"><a class="permalink" href="#Return~146"><b>Return</b></a></dt>
  <dd>&gt; 0 when found, the header option is copied to <i>searchby_res</i>. The
      return value is the total length copied. On failure, a negative error code
      is returned:
    <p class="Pp"><b>-EINVAL</b> if a parameter is invalid.</p>
    <p class="Pp"><b>-ENOMSG</b> if the option is not found.</p>
    <p class="Pp"><b>-ENOENT</b> if no syn packet is available when
        <b>BPF_LOAD_HDR_OPT_TCP_SYN</b> is used.</p>
    <p class="Pp"><b>-ENOSPC</b> if there is not enough space. Only <i>len</i>
        number of bytes are copied.</p>
    <p class="Pp"><b>-EFAULT</b> on failure to parse the header options in the
        packet.</p>
    <p class="Pp"><b>-EPERM</b> if the helper cannot be used under the current
        <i>skops</i><b>-&gt;op</b>.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~101"><a class="permalink" href="#long~101"><b><b>long
    bpf_store_hdr_opt(struct bpf_sock_ops *</b><i>skops</i><b>, const void
    *</b><i>from</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~147"><a class="permalink" href="#Description~147"><b>Description</b></a></dt>
  <dd>Store header option. The data will be copied from buffer <i>from</i> with
      length <i>len</i> to the TCP header.
    <p class="Pp">The buffer <i>from</i> should have the whole option that
        includes the kind, kind-length, and the actual option data. The
        <i>len</i> must be at least kind-length long. The kind-length does not
        have to be 4 byte aligned. The kernel will take care of the padding and
        setting the 4 bytes aligned value to th-&gt;doff.</p>
    <p class="Pp">This helper will check for duplicated option by searching the
        same option in the outgoing skb.</p>
    <p class="Pp">This helper can only be called during
        <b>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</b>.</p>
  </dd>
  <dt id="Return~147"><a class="permalink" href="#Return~147"><b>Return</b></a></dt>
  <dd>0 on success, or negative error in case of failure:
    <p class="Pp"><b>-EINVAL</b> If param is invalid.</p>
    <p class="Pp"><b>-ENOSPC</b> if there is not enough space in the header.
        Nothing has been written</p>
    <p class="Pp"><b>-EEXIST</b> if the option already exists.</p>
    <p class="Pp"><b>-EFAULT</b> on failure to parse the existing header
        options.</p>
    <p class="Pp"><b>-EPERM</b> if the helper cannot be used under the current
        <i>skops</i><b>-&gt;op</b>.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~102"><a class="permalink" href="#long~102"><b><b>long
    bpf_reserve_hdr_opt(struct bpf_sock_ops *</b><i>skops</i><b>, u32</b>
    <i>len</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~148"><a class="permalink" href="#Description~148"><b>Description</b></a></dt>
  <dd>Reserve <i>len</i> bytes for the bpf header option. The space will be used
      by <b>bpf_store_hdr_opt</b>() later in
      <b>BPF_SOCK_OPS_WRITE_HDR_OPT_CB</b>.
    <p class="Pp">If <b>bpf_reserve_hdr_opt</b>() is called multiple times, the
        total number of bytes will be reserved.</p>
    <p class="Pp">This helper can only be called during
        <b>BPF_SOCK_OPS_HDR_OPT_LEN_CB</b>.</p>
  </dd>
  <dt id="Return~148"><a class="permalink" href="#Return~148"><b>Return</b></a></dt>
  <dd>0 on success, or negative error in case of failure:
    <p class="Pp"><b>-EINVAL</b> if a parameter is invalid.</p>
    <p class="Pp"><b>-ENOSPC</b> if there is not enough space in the header.</p>
    <p class="Pp"><b>-EPERM</b> if the helper cannot be used under the current
        <i>skops</i><b>-&gt;op</b>.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~8"><a class="permalink" href="#void~8"><b><b>void
    *bpf_inode_storage_get(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>inode</i><b>, void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~149"><a class="permalink" href="#Description~149"><b>Description</b></a></dt>
  <dd>Get a bpf_local_storage from an <i>inode</i>.
    <p class="Pp">Logically, it could be thought of as getting the value from a
        <i>map</i> with <i>inode</i> as the <b>key</b>. From this perspective,
        the usage is not much different from
        <b>bpf_map_lookup_elem</b>(<i>map</i>, <b>&amp;</b><i>inode</i>) except
        this helper enforces the key must be an inode and the map must also be a
        <b>BPF_MAP_TYPE_INODE_STORAGE</b>.</p>
    <p class="Pp">Underneath, the value is stored locally at <i>inode</i>
        instead of the <i>map</i>. The <i>map</i> is used as the
        bpf-local-storage "type". The bpf-local-storage
        "type" (i.e. the <i>map</i>) is searched against all
        bpf_local_storage residing at <i>inode</i>.</p>
    <p class="Pp">An optional <i>flags</i>
        (<b>BPF_LOCAL_STORAGE_GET_F_CREATE</b>) can be used such that a new
        bpf_local_storage will be created if one does not exist. <i>value</i>
        can be used together with <b>BPF_LOCAL_STORAGE_GET_F_CREATE</b> to
        specify the initial value of a bpf_local_storage. If <i>value</i> is
        <b>NULL</b>, the new bpf_local_storage will be zero initialized.</p>
  </dd>
  <dt id="Return~149"><a class="permalink" href="#Return~149"><b>Return</b></a></dt>
  <dd>A bpf_local_storage pointer is returned on success.
    <p class="Pp"><b>NULL</b> if not found or there was an error in adding a new
        bpf_local_storage.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="int"><a class="permalink" href="#int"><b><b>int
    bpf_inode_storage_delete(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>inode</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~150"><a class="permalink" href="#Description~150"><b>Description</b></a></dt>
  <dd>Delete a bpf_local_storage from an <i>inode</i>.</dd>
  <dt id="Return~150"><a class="permalink" href="#Return~150"><b>Return</b></a></dt>
  <dd>0 on success.
    <p class="Pp"><b>-ENOENT</b> if the bpf_local_storage cannot be found.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~103"><a class="permalink" href="#long~103"><b><b>long
    bpf_d_path(struct path *</b><i>path</i><b>, char *</b><i>buf</i><b>, u32</b>
    <i>sz</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~151"><a class="permalink" href="#Description~151"><b>Description</b></a></dt>
  <dd>Return full path for given <b>struct path</b> object, which needs to be
      the kernel BTF <i>path</i> object. The path is returned in the provided
      buffer <i>buf</i> of size <i>sz</i> and is zero terminated.</dd>
  <dt id="Return~151"><a class="permalink" href="#Return~151"><b>Return</b></a></dt>
  <dd>On success, the strictly positive length of the string, including the
      trailing NUL character. On error, a negative value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~104"><a class="permalink" href="#long~104"><b><b>long
    bpf_copy_from_user(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>, const
    void *</b><i>user_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~152"><a class="permalink" href="#Description~152"><b>Description</b></a></dt>
  <dd>Read <i>size</i> bytes from user space address <i>user_ptr</i> and store
      the data in <i>dst</i>. This is a wrapper of <b>copy_from_user</b>().</dd>
  <dt id="Return~152"><a class="permalink" href="#Return~152"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~105"><a class="permalink" href="#long~105"><b><b>long
    bpf_snprintf_btf(char *</b><i>str</i><b>, u32</b> <i>str_size</i><b>, struct
    btf_ptr *</b><i>ptr</i><b>, u32</b> <i>btf_ptr_size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~153"><a class="permalink" href="#Description~153"><b>Description</b></a></dt>
  <dd>Use BTF to store a string representation of <i>ptr</i>-&gt;ptr in
      <i>str</i>, using <i>ptr</i>-&gt;type_id. This value should specify the
      type that <i>ptr</i>-&gt;ptr points to. LLVM __builtin_btf_type_id(type,
      1) can be used to look up vmlinux BTF type ids. Traversing the data
      structure using BTF, the type information and values are stored in the
      first <i>str_size</i> - 1 bytes of <i>str</i>. Safe copy of the pointer
      data is carried out to avoid kernel crashes during operation. Smaller
      types can use string space on the stack; larger programs can use map data
      to store the string representation.
    <p class="Pp">The string can be subsequently shared with userspace via
        bpf_perf_event_output() or ring buffer interfaces. bpf_trace_printk() is
        to be avoided as it places too small a limit on string size to be
        useful.</p>
    <p class="Pp"><i>flags</i> is a combination of</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BTF_F_COMPACT"><a class="permalink" href="#BTF_F_COMPACT"><b><b>BTF_F_COMPACT</b></b></a></dt>
  <dd>no formatting around type information</dd>
  <dt id="BTF_F_NONAME"><a class="permalink" href="#BTF_F_NONAME"><b><b>BTF_F_NONAME</b></b></a></dt>
  <dd>no struct/union member names/types</dd>
  <dt id="BTF_F_PTR_RAW"><a class="permalink" href="#BTF_F_PTR_RAW"><b><b>BTF_F_PTR_RAW</b></b></a></dt>
  <dd>show raw (unobfuscated) pointer values; equivalent to printk specifier
      %px.</dd>
  <dt id="BTF_F_ZERO"><a class="permalink" href="#BTF_F_ZERO"><b><b>BTF_F_ZERO</b></b></a></dt>
  <dd>show zero-valued struct/union members; they are not displayed by
    default</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~153"><a class="permalink" href="#Return~153"><b>Return</b></a></dt>
  <dd>The number of bytes that were written (or would have been written if
      output had to be truncated due to string size), or a negative error in
      cases of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~106"><a class="permalink" href="#long~106"><b><b>long
    bpf_seq_printf_btf(struct seq_file *</b><i>m</i><b>, struct btf_ptr
    *</b><i>ptr</i><b>, u32</b> <i>ptr_size</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~154"><a class="permalink" href="#Description~154"><b>Description</b></a></dt>
  <dd>Use BTF to write to seq_write a string representation of
      <i>ptr</i>-&gt;ptr, using <i>ptr</i>-&gt;type_id as per
      bpf_snprintf_btf(). <i>flags</i> are identical to those used for
      bpf_snprintf_btf.</dd>
  <dt id="Return~154"><a class="permalink" href="#Return~154"><b>Return</b></a></dt>
  <dd>0 on success or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~20"><a class="permalink" href="#u64~20"><b><b>u64
    bpf_skb_cgroup_classid(struct sk_buff *</b><i>skb</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~155"><a class="permalink" href="#Description~155"><b>Description</b></a></dt>
  <dd>See <b>bpf_get_cgroup_classid</b>() for the main description. This helper
      differs from <b>bpf_get_cgroup_classid</b>() in that the cgroup v1 net_cls
      class is retrieved only from the <i>skb</i>'s associated socket instead of
      the current process.</dd>
  <dt id="Return~155"><a class="permalink" href="#Return~155"><b>Return</b></a></dt>
  <dd>The id is returned or 0 in case the id could not be retrieved.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~107"><a class="permalink" href="#long~107"><b><b>long
    bpf_redirect_neigh(u32</b> <i>ifindex</i><b>, struct bpf_redir_neigh
    *</b><i>params</i><b>, int</b> <i>plen</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~156"><a class="permalink" href="#Description~156"><b>Description</b></a></dt>
  <dd>Redirect the packet to another net device of index <i>ifindex</i> and fill
      in L2 addresses from neighboring subsystem. This helper is somewhat
      similar to <b>bpf_redirect</b>(), except that it populates L2 addresses as
      well, meaning, internally, the helper relies on the neighbor lookup for
      the L2 address of the nexthop.
    <p class="Pp">The helper will perform a FIB lookup based on the skb's
        networking header to get the address of the next hop, unless this is
        supplied by the caller in the <i>params</i> argument. The <i>plen</i>
        argument indicates the len of <i>params</i> and should be set to 0 if
        <i>params</i> is NULL.</p>
    <p class="Pp">The <i>flags</i> argument is reserved and must be 0. The
        helper is currently only supported for tc BPF program types, and enabled
        for IPv4 and IPv6 protocols.</p>
  </dd>
  <dt id="Return~156"><a class="permalink" href="#Return~156"><b>Return</b></a></dt>
  <dd>The helper returns <b>TC_ACT_REDIRECT</b> on success or <b>TC_ACT_SHOT</b>
      on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~9"><a class="permalink" href="#void~9"><b><b>void
    *bpf_per_cpu_ptr(const void *</b><i>percpu_ptr</i><b>, u32</b>
    <i>cpu</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~157"><a class="permalink" href="#Description~157"><b>Description</b></a></dt>
  <dd>Take a pointer to a percpu ksym, <i>percpu_ptr</i>, and return a pointer
      to the percpu kernel variable on <i>cpu</i>. A ksym is an extern variable
      decorated with '__ksym'. For ksym, there is a global var (either static or
      global) defined of the same name in the kernel. The ksym is percpu if the
      global var is percpu. The returned pointer points to the global percpu var
      on <i>cpu</i>.
    <p class="Pp">bpf_per_cpu_ptr() has the same semantic as per_cpu_ptr() in
        the kernel, except that bpf_per_cpu_ptr() may return NULL. This happens
        if <i>cpu</i> is larger than nr_cpu_ids. The caller of bpf_per_cpu_ptr()
        must check the returned value.</p>
  </dd>
  <dt id="Return~157"><a class="permalink" href="#Return~157"><b>Return</b></a></dt>
  <dd>A pointer pointing to the kernel percpu variable on <i>cpu</i>, or NULL,
      if <i>cpu</i> is invalid.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~10"><a class="permalink" href="#void~10"><b><b>void
    *bpf_this_cpu_ptr(const void *</b><i>percpu_ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~158"><a class="permalink" href="#Description~158"><b>Description</b></a></dt>
  <dd>Take a pointer to a percpu ksym, <i>percpu_ptr</i>, and return a pointer
      to the percpu kernel variable on this cpu. See the description of 'ksym'
      in <b>bpf_per_cpu_ptr</b>().
    <p class="Pp">bpf_this_cpu_ptr() has the same semantic as this_cpu_ptr() in
        the kernel. Different from <b>bpf_per_cpu_ptr</b>(), it would never
        return NULL.</p>
  </dd>
  <dt id="Return~158"><a class="permalink" href="#Return~158"><b>Return</b></a></dt>
  <dd>A pointer pointing to the kernel percpu variable on this cpu.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~108"><a class="permalink" href="#long~108"><b><b>long
    bpf_redirect_peer(u32</b> <i>ifindex</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~159"><a class="permalink" href="#Description~159"><b>Description</b></a></dt>
  <dd>Redirect the packet to another net device of index <i>ifindex</i>. This
      helper is somewhat similar to <b>bpf_redirect</b>(), except that the
      redirection happens to the <i>ifindex</i>' peer device and the netns
      switch takes place from ingress to ingress without going through the CPU's
      backlog queue.
    <p class="Pp">The <i>flags</i> argument is reserved and must be 0. The
        helper is currently only supported for tc BPF program types at the
        ingress hook and for veth device types. The peer device must reside in a
        different network namespace.</p>
  </dd>
  <dt id="Return~159"><a class="permalink" href="#Return~159"><b>Return</b></a></dt>
  <dd>The helper returns <b>TC_ACT_REDIRECT</b> on success or <b>TC_ACT_SHOT</b>
      on error.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~11"><a class="permalink" href="#void~11"><b><b>void
    *bpf_task_storage_get(struct bpf_map *</b><i>map</i><b>, struct task_struct
    *</b><i>task</i><b>, void *</b><i>value</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~160"><a class="permalink" href="#Description~160"><b>Description</b></a></dt>
  <dd>Get a bpf_local_storage from the <i>task</i>.
    <p class="Pp">Logically, it could be thought of as getting the value from a
        <i>map</i> with <i>task</i> as the <b>key</b>. From this perspective,
        the usage is not much different from
        <b>bpf_map_lookup_elem</b>(<i>map</i>, <b>&amp;</b><i>task</i>) except
        this helper enforces the key must be a task_struct and the map must also
        be a <b>BPF_MAP_TYPE_TASK_STORAGE</b>.</p>
    <p class="Pp">Underneath, the value is stored locally at <i>task</i> instead
        of the <i>map</i>. The <i>map</i> is used as the bpf-local-storage
        "type". The bpf-local-storage "type" (i.e. the
        <i>map</i>) is searched against all bpf_local_storage residing at
        <i>task</i>.</p>
    <p class="Pp">An optional <i>flags</i>
        (<b>BPF_LOCAL_STORAGE_GET_F_CREATE</b>) can be used such that a new
        bpf_local_storage will be created if one does not exist. <i>value</i>
        can be used together with <b>BPF_LOCAL_STORAGE_GET_F_CREATE</b> to
        specify the initial value of a bpf_local_storage. If <i>value</i> is
        <b>NULL</b>, the new bpf_local_storage will be zero initialized.</p>
  </dd>
  <dt id="Return~160"><a class="permalink" href="#Return~160"><b>Return</b></a></dt>
  <dd>A bpf_local_storage pointer is returned on success.
    <p class="Pp"><b>NULL</b> if not found or there was an error in adding a new
        bpf_local_storage.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~109"><a class="permalink" href="#long~109"><b><b>long
    bpf_task_storage_delete(struct bpf_map *</b><i>map</i><b>, struct
    task_struct *</b><i>task</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~161"><a class="permalink" href="#Description~161"><b>Description</b></a></dt>
  <dd>Delete a bpf_local_storage from a <i>task</i>.</dd>
  <dt id="Return~161"><a class="permalink" href="#Return~161"><b>Return</b></a></dt>
  <dd>0 on success.
    <p class="Pp"><b>-ENOENT</b> if the bpf_local_storage cannot be found.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~12"><a class="permalink" href="#struct~12"><b><b>struct
    task_struct *bpf_get_current_task_btf(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~162"><a class="permalink" href="#Description~162"><b>Description</b></a></dt>
  <dd>Return a BTF pointer to the "current" task. This pointer can
      also be used in helpers that accept an <i>ARG_PTR_TO_BTF_ID</i> of type
      <i>task_struct</i>.</dd>
  <dt id="Return~162"><a class="permalink" href="#Return~162"><b>Return</b></a></dt>
  <dd>Pointer to the current task.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~110"><a class="permalink" href="#long~110"><b><b>long
    bpf_bprm_opts_set(struct linux_binprm *</b><i>bprm</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~163"><a class="permalink" href="#Description~163"><b>Description</b></a></dt>
  <dd>Set or clear certain options on <i>bprm</i>:
    <p class="Pp"><b>BPF_F_BPRM_SECUREEXEC</b> Set the secureexec bit which sets
        the <b>AT_SECURE</b> auxv for glibc. The bit is cleared if the flag is
        not specified.</p>
  </dd>
  <dt id="Return~163"><a class="permalink" href="#Return~163"><b>Return</b></a></dt>
  <dd><b>-EINVAL</b> if invalid <i>flags</i> are passed, zero otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~21"><a class="permalink" href="#u64~21"><b><b>u64
    bpf_ktime_get_coarse_ns(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~164"><a class="permalink" href="#Description~164"><b>Description</b></a></dt>
  <dd>Return a coarse-grained version of the time elapsed since system boot, in
      nanoseconds. Does not include time the system was suspended.
    <p class="Pp">See: <b>clock_gettime</b>(<b>CLOCK_MONOTONIC_COARSE</b>)</p>
  </dd>
  <dt id="Return~164"><a class="permalink" href="#Return~164"><b>Return</b></a></dt>
  <dd>Current <i>ktime</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~111"><a class="permalink" href="#long~111"><b><b>long
    bpf_ima_inode_hash(struct inode *</b><i>inode</i><b>, void
    *</b><i>dst</i><b>, u32</b> <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~165"><a class="permalink" href="#Description~165"><b>Description</b></a></dt>
  <dd>Returns the stored IMA hash of the <i>inode</i> (if it's available). If
      the hash is larger than <i>size</i>, then only <i>size</i> bytes will be
      copied to <i>dst</i></dd>
  <dt id="Return~165"><a class="permalink" href="#Return~165"><b>Return</b></a></dt>
  <dd>The <b>hash_algo</b> is returned on success, <b>-EOPNOTSUP</b> if IMA is
      disabled or <b>-EINVAL</b> if invalid arguments are passed.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~13"><a class="permalink" href="#struct~13"><b><b>struct socket
    *bpf_sock_from_file(struct file *</b><i>file</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~166"><a class="permalink" href="#Description~166"><b>Description</b></a></dt>
  <dd>If the given file represents a socket, returns the associated socket.</dd>
  <dt id="Return~166"><a class="permalink" href="#Return~166"><b>Return</b></a></dt>
  <dd>A pointer to a struct socket on success or NULL if the file is not a
      socket.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~112"><a class="permalink" href="#long~112"><b><b>long
    bpf_check_mtu(void *</b><i>ctx</i><b>, u32</b> <i>ifindex</i><b>, u32
    *</b><i>mtu_len</i><b>, s32</b> <i>len_diff</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~167"><a class="permalink" href="#Description~167"><b>Description</b></a></dt>
  <dd>Check packet size against exceeding MTU of net device (based on
      <i>ifindex</i>). This helper will likely be used in combination with
      helpers that adjust/change the packet size.
    <p class="Pp">The argument <i>len_diff</i> can be used for querying with a
        planned size change. This allows to check MTU prior to changing packet
        ctx. Providing a <i>len_diff</i> adjustment that is larger than the
        actual packet size (resulting in negative packet size) will in principle
        not exceed the MTU, which is why it is not considered a failure. Other
        BPF helpers are needed for performing the planned size change; therefore
        the responsibility for catching a negative packet size belongs in those
        helpers.</p>
    <p class="Pp">Specifying <i>ifindex</i> zero means the MTU check is
        performed against the current net device. This is practical if this
        isn't used prior to redirect.</p>
    <p class="Pp">On input <i>mtu_len</i> must be a valid pointer, else verifier
        will reject BPF program. If the value <i>mtu_len</i> is initialized to
        zero then the ctx packet size is use. When value <i>mtu_len</i> is
        provided as input this specify the L3 length that the MTU check is done
        against. Remember XDP and TC length operate at L2, but this value is L3
        as this correlate to MTU and IP-header tot_len values which are L3
        (similar behavior as bpf_fib_lookup).</p>
    <p class="Pp">The Linux kernel route table can configure MTUs on a more
        specific per route level, which is not provided by this helper. For
        route level MTU checks use the <b>bpf_fib_lookup</b>() helper.</p>
    <p class="Pp"><i>ctx</i> is either <b>struct xdp_md</b> for XDP programs or
        <b>struct sk_buff</b> for tc cls_act programs.</p>
    <p class="Pp">The <i>flags</i> argument can be a combination of one or more
        of the following values:</p>
  </dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="BPF_MTU_CHK_SEGS"><a class="permalink" href="#BPF_MTU_CHK_SEGS"><b><b>BPF_MTU_CHK_SEGS</b></b></a></dt>
  <dd>This flag will only works for <i>ctx</i> <b>struct sk_buff</b>. If packet
      context contains extra packet segment buffers (often knows as GSO skb),
      then MTU check is harder to check at this point, because in transmit path
      it is possible for the skb packet to get re-segmented (depending on net
      device features). This could still be a MTU violation, so this flag
      enables performing MTU check against segments, with a different violation
      return code to tell it apart. Check cannot use len_diff.</dd>
</dl>
</div>
<br>
<p class="Pp">On return <i>mtu_len</i> pointer contains the MTU value of the net
    device. Remember the net device configured MTU is the L3 size, which is
    returned here and XDP and TC length operate at L2. Helper take this into
    account for you, but remember when using MTU value in your BPF-code.</p>
<dl class="Bl-tag">
  <dt id="Return~167"><a class="permalink" href="#Return~167"><b>Return</b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>0 on success, and populate MTU value in <i>mtu_len</i> pointer.</dd>
  <dt>•</dt>
  <dd>&lt; 0 if any input argument is invalid (<i>mtu_len</i> not updated)</dd>
</dl>
</div>
<br>
<p class="Pp">MTU violations return positive values, but also populate MTU value
    in <i>mtu_len</i> pointer, as this can be needed for implementing PMTU
    handing:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><b>BPF_MTU_CHK_RET_FRAG_NEEDED</b></dd>
  <dt>•</dt>
  <dd><b>BPF_MTU_CHK_RET_SEGS_TOOBIG</b></dd>
</dl>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~113"><a class="permalink" href="#long~113"><b><b>long
    bpf_for_each_map_elem(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>callback_fn</i><b>, void *</b><i>callback_ctx</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~168"><a class="permalink" href="#Description~168"><b>Description</b></a></dt>
  <dd>For each element in <b>map</b>, call <b>callback_fn</b> function with
      <b>map</b>, <b>callback_ctx</b> and other map-specific parameters. The
      <b>callback_fn</b> should be a static function and the <b>callback_ctx</b>
      should be a pointer to the stack. The <b>flags</b> is used to control
      certain aspects of the helper. Currently, the <b>flags</b> must be 0.
    <p class="Pp">The following are a list of supported map types and their
        respective expected callback signatures:</p>
    <p class="Pp">BPF_MAP_TYPE_HASH, BPF_MAP_TYPE_PERCPU_HASH,
        BPF_MAP_TYPE_LRU_HASH, BPF_MAP_TYPE_LRU_PERCPU_HASH, BPF_MAP_TYPE_ARRAY,
        BPF_MAP_TYPE_PERCPU_ARRAY</p>
    <p class="Pp">long (*callback_fn)(struct bpf_map *map, const void *key, void
        *value, void *ctx);</p>
    <p class="Pp">For per_cpu maps, the map_value is the value on the cpu where
        the bpf_prog is running.</p>
    <p class="Pp">If <b>callback_fn</b> return 0, the helper will continue to
        the next element. If return value is 1, the helper will skip the rest of
        elements and return. Other return values are not used now.</p>
  </dd>
  <dt id="Return~168"><a class="permalink" href="#Return~168"><b>Return</b></a></dt>
  <dd>The number of traversed map elements for success, <b>-EINVAL</b> for
      invalid <b>flags</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~114"><a class="permalink" href="#long~114"><b><b>long
    bpf_snprintf(char *</b><i>str</i><b>, u32</b> <i>str_size</i><b>, const char
    *</b><i>fmt</i><b>, u64 *</b><i>data</i><b>, u32</b>
    <i>data_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~169"><a class="permalink" href="#Description~169"><b>Description</b></a></dt>
  <dd>Outputs a string into the <b>str</b> buffer of size <b>str_size</b> based
      on a format string stored in a read-only map pointed by <b>fmt</b>.
    <p class="Pp">Each format specifier in <b>fmt</b> corresponds to one u64
        element in the <b>data</b> array. For strings and pointers where
        pointees are accessed, only the pointer values are stored in the
        <i>data</i> array. The <i>data_len</i> is the size of <i>data</i> in
        bytes - must be a multiple of 8.</p>
    <p class="Pp">Formats <b>%s</b> and <b>%p{i,I}{4,6}</b> require to read
        kernel memory. Reading kernel memory may fail due to either invalid
        address or valid address but requiring a major memory fault. If reading
        kernel memory fails, the string for <b>%s</b> will be an empty string,
        and the ip address for <b>%p{i,I}{4,6}</b> will be 0. Not returning
        error to bpf program is consistent with what <b>bpf_trace_printk</b>()
        does for now.</p>
  </dd>
  <dt id="Return~169"><a class="permalink" href="#Return~169"><b>Return</b></a></dt>
  <dd>The strictly positive length of the formatted string, including the
      trailing zero character. If the return value is greater than
      <b>str_size</b>, <b>str</b> contains a truncated string, guaranteed to be
      zero-terminated except when <b>str_size</b> is 0.
    <p class="Pp">Or <b>-EBUSY</b> if the per-CPU memory copy buffer is
      busy.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~115"><a class="permalink" href="#long~115"><b><b>long
    bpf_sys_bpf(u32</b> <i>cmd</i><b>, void *</b><i>attr</i><b>, u32</b>
    <i>attr_size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~170"><a class="permalink" href="#Description~170"><b>Description</b></a></dt>
  <dd>Execute bpf syscall with given arguments.</dd>
  <dt id="Return~170"><a class="permalink" href="#Return~170"><b>Return</b></a></dt>
  <dd>A syscall result.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~116"><a class="permalink" href="#long~116"><b><b>long
    bpf_btf_find_by_name_kind(char *</b><i>name</i><b>, int</b>
    <i>name_sz</i><b>, u32</b> <i>kind</i><b>, int</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~171"><a class="permalink" href="#Description~171"><b>Description</b></a></dt>
  <dd>Find BTF type with given name and kind in vmlinux BTF or in module's
    BTFs.</dd>
  <dt id="Return~171"><a class="permalink" href="#Return~171"><b>Return</b></a></dt>
  <dd>Returns btf_id and btf_obj_fd in lower and upper 32 bits.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~117"><a class="permalink" href="#long~117"><b><b>long
    bpf_sys_close(u32</b> <i>fd</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~172"><a class="permalink" href="#Description~172"><b>Description</b></a></dt>
  <dd>Execute close syscall for given FD.</dd>
  <dt id="Return~172"><a class="permalink" href="#Return~172"><b>Return</b></a></dt>
  <dd>A syscall result.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~118"><a class="permalink" href="#long~118"><b><b>long
    bpf_timer_init(struct bpf_timer *</b><i>timer</i><b>, struct bpf_map
    *</b><i>map</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~173"><a class="permalink" href="#Description~173"><b>Description</b></a></dt>
  <dd>Initialize the timer. First 4 bits of <i>flags</i> specify clockid. Only
      CLOCK_MONOTONIC, CLOCK_REALTIME, CLOCK_BOOTTIME are allowed. All other
      bits of <i>flags</i> are reserved. The verifier will reject the program if
      <i>timer</i> is not from the same <i>map</i>.</dd>
  <dt id="Return~173"><a class="permalink" href="#Return~173"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EBUSY</b> if <i>timer</i> is already initialized.
      <b>-EINVAL</b> if invalid <i>flags</i> are passed. <b>-EPERM</b> if
      <i>timer</i> is in a map that doesn't have any user references. The user
      space should either hold a file descriptor to a map with timers or pin
      such map in bpffs. When map is unpinned or file descriptor is closed all
      timers in the map will be cancelled and freed.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~119"><a class="permalink" href="#long~119"><b><b>long
    bpf_timer_set_callback(struct bpf_timer *</b><i>timer</i><b>, void
    *</b><i>callback_fn</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~174"><a class="permalink" href="#Description~174"><b>Description</b></a></dt>
  <dd>Configure the timer to call <i>callback_fn</i> static function.</dd>
  <dt id="Return~174"><a class="permalink" href="#Return~174"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EINVAL</b> if <i>timer</i> was not initialized with
      bpf_timer_init() earlier. <b>-EPERM</b> if <i>timer</i> is in a map that
      doesn't have any user references. The user space should either hold a file
      descriptor to a map with timers or pin such map in bpffs. When map is
      unpinned or file descriptor is closed all timers in the map will be
      cancelled and freed.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~120"><a class="permalink" href="#long~120"><b><b>long
    bpf_timer_start(struct bpf_timer *</b><i>timer</i><b>, u64</b>
    <i>nsecs</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~175"><a class="permalink" href="#Description~175"><b>Description</b></a></dt>
  <dd>Set timer expiration N nanoseconds from the current time. The configured
      callback will be invoked in soft irq context on some cpu and will not
      repeat unless another bpf_timer_start() is made. In such case the next
      invocation can migrate to a different cpu. Since struct bpf_timer is a
      field inside map element the map owns the timer. The
      bpf_timer_set_callback() will increment refcnt of BPF program to make sure
      that callback_fn code stays valid. When user space reference to a map
      reaches zero all timers in a map are cancelled and corresponding program's
      refcnts are decremented. This is done to make sure that Ctrl-C of a user
      process doesn't leave any timers running. If map is pinned in bpffs the
      callback_fn can re-arm itself indefinitely. bpf_map_update/delete_elem()
      helpers and user space sys_bpf commands cancel and free the timer in the
      given map element. The map can contain timers that invoke callback_fn-s
      from different programs. The same callback_fn can serve different timers
      from different maps if key/value layout matches across maps. Every
      bpf_timer_set_callback() can have different callback_fn.</dd>
  <dt id="Return~175"><a class="permalink" href="#Return~175"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EINVAL</b> if <i>timer</i> was not initialized with
      bpf_timer_init() earlier or invalid <i>flags</i> are passed.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~121"><a class="permalink" href="#long~121"><b><b>long
    bpf_timer_cancel(struct bpf_timer *</b><i>timer</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~176"><a class="permalink" href="#Description~176"><b>Description</b></a></dt>
  <dd>Cancel the timer and wait for callback_fn to finish if it was
    running.</dd>
  <dt id="Return~176"><a class="permalink" href="#Return~176"><b>Return</b></a></dt>
  <dd>0 if the timer was not active. 1 if the timer was active. <b>-EINVAL</b>
      if <i>timer</i> was not initialized with bpf_timer_init() earlier.
      <b>-EDEADLK</b> if callback_fn tried to call bpf_timer_cancel() on its own
      timer which would have led to a deadlock otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~22"><a class="permalink" href="#u64~22"><b><b>u64
    bpf_get_func_ip(void *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~177"><a class="permalink" href="#Description~177"><b>Description</b></a></dt>
  <dd>Get address of the traced function (for tracing and kprobe programs).</dd>
  <dt id="Return~177"><a class="permalink" href="#Return~177"><b>Return</b></a></dt>
  <dd>Address of the traced function. 0 for kprobes placed within the function
      (not at the entry).</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~23"><a class="permalink" href="#u64~23"><b><b>u64
    bpf_get_attach_cookie(void *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~178"><a class="permalink" href="#Description~178"><b>Description</b></a></dt>
  <dd>Get bpf_cookie value provided (optionally) during the program attachment.
      It might be different for each individual attachment, even if BPF program
      itself is the same. Expects BPF program context <i>ctx</i> as a first
      argument.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Supported"><a class="permalink" href="#Supported"><b>Supported for the
    following program types:</b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd>kprobe/uprobe;</dd>
  <dt>•</dt>
  <dd>tracepoint;</dd>
  <dt>•</dt>
  <dd>perf_event.</dd>
</dl>
</div>
<br>
</div>
<br>
<dl class="Bl-tag">
  <dt id="Return~178"><a class="permalink" href="#Return~178"><b>Return</b></a></dt>
  <dd>Value specified by user at BPF link creation/attachment time or 0, if it
      was not specified.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~122"><a class="permalink" href="#long~122"><b><b>long
    bpf_task_pt_regs(struct task_struct *</b><i>task</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~179"><a class="permalink" href="#Description~179"><b>Description</b></a></dt>
  <dd>Get the struct pt_regs associated with <b>task</b>.</dd>
  <dt id="Return~179"><a class="permalink" href="#Return~179"><b>Return</b></a></dt>
  <dd>A pointer to struct pt_regs.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~123"><a class="permalink" href="#long~123"><b><b>long
    bpf_get_branch_snapshot(void *</b><i>entries</i><b>, u32</b> <i>size</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~180"><a class="permalink" href="#Description~180"><b>Description</b></a></dt>
  <dd>Get branch trace from hardware engines like Intel LBR. The hardware engine
      is stopped shortly after the helper is called. Therefore, the user need to
      filter branch entries based on the actual use case. To capture branch
      trace before the trigger point of the BPF program, the helper should be
      called at the beginning of the BPF program.
    <p class="Pp">The data is stored as struct perf_branch_entry into output
        buffer <i>entries</i>. <i>size</i> is the size of <i>entries</i> in
        bytes. <i>flags</i> is reserved for now and must be zero.</p>
  </dd>
  <dt id="Return~180"><a class="permalink" href="#Return~180"><b>Return</b></a></dt>
  <dd>On success, number of bytes written to <i>buf</i>. On error, a negative
      value.
    <p class="Pp"><b>-EINVAL</b> if <i>flags</i> is not zero.</p>
    <p class="Pp"><b>-ENOENT</b> if architecture does not support branch
        records.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~124"><a class="permalink" href="#long~124"><b><b>long
    bpf_trace_vprintk(const char *</b><i>fmt</i><b>, u32</b> <i>fmt_size</i><b>,
    const void *</b><i>data</i><b>, u32</b> <i>data_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~181"><a class="permalink" href="#Description~181"><b>Description</b></a></dt>
  <dd>Behaves like <b>bpf_trace_printk</b>() helper, but takes an array of u64
      to format and can handle more format args as a result.
    <p class="Pp">Arguments are to be used as in <b>bpf_seq_printf</b>()
      helper.</p>
  </dd>
  <dt id="Return~181"><a class="permalink" href="#Return~181"><b>Return</b></a></dt>
  <dd>The number of bytes written to the buffer, or a negative error in case of
      failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~14"><a class="permalink" href="#struct~14"><b><b>struct
    unix_sock *bpf_skc_to_unix_sock(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~182"><a class="permalink" href="#Description~182"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>unix_sock</i> pointer.</dd>
  <dt id="Return~182"><a class="permalink" href="#Return~182"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~125"><a class="permalink" href="#long~125"><b><b>long
    bpf_kallsyms_lookup_name(const char *</b><i>name</i><b>, int</b>
    <i>name_sz</i><b>, int</b> <i>flags</i><b>, u64
    *</b><i>res</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~183"><a class="permalink" href="#Description~183"><b>Description</b></a></dt>
  <dd>Get the address of a kernel symbol, returned in <i>res</i>. <i>res</i> is
      set to 0 if the symbol is not found.</dd>
  <dt id="Return~183"><a class="permalink" href="#Return~183"><b>Return</b></a></dt>
  <dd>On success, zero. On error, a negative value.
    <p class="Pp"><b>-EINVAL</b> if <i>flags</i> is not zero.</p>
    <p class="Pp"><b>-EINVAL</b> if string <i>name</i> is not the same size as
        <i>name_sz</i>.</p>
    <p class="Pp"><b>-ENOENT</b> if symbol is not found.</p>
    <p class="Pp"><b>-EPERM</b> if caller does not have permission to obtain
        kernel address.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~126"><a class="permalink" href="#long~126"><b><b>long
    bpf_find_vma(struct task_struct *</b><i>task</i><b>, u64</b> <i>addr</i><b>,
    void *</b><i>callback_fn</i><b>, void *</b><i>callback_ctx</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~184"><a class="permalink" href="#Description~184"><b>Description</b></a></dt>
  <dd>Find vma of <i>task</i> that contains <i>addr</i>, call <i>callback_fn</i>
      function with <i>task</i>, <i>vma</i>, and <i>callback_ctx</i>. The
      <i>callback_fn</i> should be a static function and the <i>callback_ctx</i>
      should be a pointer to the stack. The <i>flags</i> is used to control
      certain aspects of the helper. Currently, the <i>flags</i> must be 0.
    <p class="Pp">The expected callback signature is</p>
    <p class="Pp">long (*callback_fn)(struct task_struct *task, struct
        vm_area_struct *vma, void *callback_ctx);</p>
  </dd>
  <dt id="Return~184"><a class="permalink" href="#Return~184"><b>Return</b></a></dt>
  <dd>0 on success. <b>-ENOENT</b> if <i>task-&gt;mm</i> is NULL, or no vma
      contains <i>addr</i>. <b>-EBUSY</b> if failed to try lock mmap_lock.
      <b>-EINVAL</b> for invalid <b>flags</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~127"><a class="permalink" href="#long~127"><b><b>long
    bpf_loop(u32</b> <i>nr_loops</i><b>, void *</b><i>callback_fn</i><b>, void
    *</b><i>callback_ctx</i><b>, u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~185"><a class="permalink" href="#Description~185"><b>Description</b></a></dt>
  <dd>For <b>nr_loops</b>, call <b>callback_fn</b> function with
      <b>callback_ctx</b> as the context parameter. The <b>callback_fn</b>
      should be a static function and the <b>callback_ctx</b> should be a
      pointer to the stack. The <b>flags</b> is used to control certain aspects
      of the helper. Currently, the <b>flags</b> must be 0. Currently, nr_loops
      is limited to 1 &lt;&lt; 23 (~8 million) loops.
    <p class="Pp">long (*callback_fn)(u32 index, void *ctx);</p>
    <p class="Pp">where <b>index</b> is the current index in the loop. The index
        is zero-indexed.</p>
    <p class="Pp">If <b>callback_fn</b> returns 0, the helper will continue to
        the next loop. If return value is 1, the helper will skip the rest of
        the loops and return. Other return values are not used now, and will be
        rejected by the verifier.</p>
  </dd>
  <dt id="Return~185"><a class="permalink" href="#Return~185"><b>Return</b></a></dt>
  <dd>The number of loops performed, <b>-EINVAL</b> for invalid <b>flags</b>,
      <b>-E2BIG</b> if <b>nr_loops</b> exceeds the maximum number of loops.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~128"><a class="permalink" href="#long~128"><b><b>long
    bpf_strncmp(const char *</b><i>s1</i><b>, u32</b> <i>s1_sz</i><b>, const
    char *</b><i>s2</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~186"><a class="permalink" href="#Description~186"><b>Description</b></a></dt>
  <dd>Do strncmp() between <b>s1</b> and <b>s2</b>. <b>s1</b> doesn't need to be
      null-terminated and <b>s1_sz</b> is the maximum storage size of <b>s1</b>.
      <b>s2</b> must be a read-only string.</dd>
  <dt id="Return~186"><a class="permalink" href="#Return~186"><b>Return</b></a></dt>
  <dd>An integer less than, equal to, or greater than zero if the first
      <b>s1_sz</b> bytes of <b>s1</b> is found to be less than, to match, or be
      greater than <b>s2</b>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~129"><a class="permalink" href="#long~129"><b><b>long
    bpf_get_func_arg(void *</b><i>ctx</i><b>, u32</b> <i>n</i><b>, u64
    *</b><i>value</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~187"><a class="permalink" href="#Description~187"><b>Description</b></a></dt>
  <dd>Get <b>n</b>-th argument register (zero based) of the traced function (for
      tracing programs) returned in <b>value</b>.</dd>
  <dt id="Return~187"><a class="permalink" href="#Return~187"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EINVAL</b> if n &gt;= argument register count of traced
      function.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~130"><a class="permalink" href="#long~130"><b><b>long
    bpf_get_func_ret(void *</b><i>ctx</i><b>, u64
    *</b><i>value</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~188"><a class="permalink" href="#Description~188"><b>Description</b></a></dt>
  <dd>Get return value of the traced function (for tracing programs) in
      <b>value</b>.</dd>
  <dt id="Return~188"><a class="permalink" href="#Return~188"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EOPNOTSUPP</b> for tracing programs other than
      BPF_TRACE_FEXIT or BPF_MODIFY_RETURN.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~131"><a class="permalink" href="#long~131"><b><b>long
    bpf_get_func_arg_cnt(void *</b><i>ctx</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~189"><a class="permalink" href="#Description~189"><b>Description</b></a></dt>
  <dd>Get number of registers of the traced function (for tracing programs)
      where function arguments are stored in these registers.</dd>
  <dt id="Return~189"><a class="permalink" href="#Return~189"><b>Return</b></a></dt>
  <dd>The number of argument registers of the traced function.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="int~2"><a class="permalink" href="#int~2"><b><b>int
    bpf_get_retval(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~190"><a class="permalink" href="#Description~190"><b>Description</b></a></dt>
  <dd>Get the BPF program's return value that will be returned to the upper
      layers.
    <p class="Pp">This helper is currently supported by cgroup programs and only
        by the hooks where BPF program's return value is returned to the
        userspace via errno.</p>
  </dd>
  <dt id="Return~190"><a class="permalink" href="#Return~190"><b>Return</b></a></dt>
  <dd>The BPF program's return value.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="int~3"><a class="permalink" href="#int~3"><b><b>int
    bpf_set_retval(int</b> <i>retval</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~191"><a class="permalink" href="#Description~191"><b>Description</b></a></dt>
  <dd>Set the BPF program's return value that will be returned to the upper
      layers.
    <p class="Pp">This helper is currently supported by cgroup programs and only
        by the hooks where BPF program's return value is returned to the
        userspace via errno.</p>
    <p class="Pp">Note that there is the following corner case where the program
        exports an error via bpf_set_retval but signals success via 'return
      1':</p>
  </dd>
</dl>
<div class="Bd-indent">
<div class="Bd-indent">bpf_set_retval(-EPERM); return 1;</div>
<br>
</div>
<br>
<p class="Pp">In this case, the BPF program's return value will use helper's
    -EPERM. This still holds true for cgroup/bind{4,6} which supports extra
    'return 3' success case.</p>
<dl class="Bl-tag">
  <dt id="Return~191"><a class="permalink" href="#Return~191"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~24"><a class="permalink" href="#u64~24"><b><b>u64
    bpf_xdp_get_buff_len(struct xdp_buff *</b><i>xdp_md</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~192"><a class="permalink" href="#Description~192"><b>Description</b></a></dt>
  <dd>Get the total size of a given xdp buff (linear and paged area)</dd>
  <dt id="Return~192"><a class="permalink" href="#Return~192"><b>Return</b></a></dt>
  <dd>The total size of a given xdp buffer.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~132"><a class="permalink" href="#long~132"><b><b>long
    bpf_xdp_load_bytes(struct xdp_buff *</b><i>xdp_md</i><b>, u32</b>
    <i>offset</i><b>, void *</b><i>buf</i><b>, u32</b>
    <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~193"><a class="permalink" href="#Description~193"><b>Description</b></a></dt>
  <dd>This helper is provided as an easy way to load data from a xdp buffer. It
      can be used to load <i>len</i> bytes from <i>offset</i> from the frame
      associated to <i>xdp_md</i>, into the buffer pointed by <i>buf</i>.</dd>
  <dt id="Return~193"><a class="permalink" href="#Return~193"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~133"><a class="permalink" href="#long~133"><b><b>long
    bpf_xdp_store_bytes(struct xdp_buff *</b><i>xdp_md</i><b>, u32</b>
    <i>offset</i><b>, void *</b><i>buf</i><b>, u32</b>
    <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~194"><a class="permalink" href="#Description~194"><b>Description</b></a></dt>
  <dd>Store <i>len</i> bytes from buffer <i>buf</i> into the frame associated to
      <i>xdp_md</i>, at <i>offset</i>.</dd>
  <dt id="Return~194"><a class="permalink" href="#Return~194"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~134"><a class="permalink" href="#long~134"><b><b>long
    bpf_copy_from_user_task(void *</b><i>dst</i><b>, u32</b> <i>size</i><b>,
    const void *</b><i>user_ptr</i><b>, struct task_struct *</b><i>tsk</i><b>,
    u64</b> <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~195"><a class="permalink" href="#Description~195"><b>Description</b></a></dt>
  <dd>Read <i>size</i> bytes from user space address <i>user_ptr</i> in
      <i>tsk</i>'s address space, and stores the data in <i>dst</i>.
      <i>flags</i> is not used yet and is provided for future extensibility.
      This helper can only be used by sleepable programs.</dd>
  <dt id="Return~195"><a class="permalink" href="#Return~195"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure. On error <i>dst</i>
      buffer is zeroed out.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~135"><a class="permalink" href="#long~135"><b><b>long
    bpf_skb_set_tstamp(struct sk_buff *</b><i>skb</i><b>, u64</b>
    <i>tstamp</i><b>, u32</b> <i>tstamp_type</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~196"><a class="permalink" href="#Description~196"><b>Description</b></a></dt>
  <dd>Change the __sk_buff-&gt;tstamp_type to <i>tstamp_type</i> and set
      <i>tstamp</i> to the __sk_buff-&gt;tstamp together.
    <p class="Pp">If there is no need to change the __sk_buff-&gt;tstamp_type,
        the tstamp value can be directly written to __sk_buff-&gt;tstamp
        instead.</p>
    <p class="Pp">BPF_SKB_TSTAMP_DELIVERY_MONO is the only tstamp that will be
        kept during bpf_redirect_*(). A non zero <i>tstamp</i> must be used with
        the BPF_SKB_TSTAMP_DELIVERY_MONO <i>tstamp_type</i>.</p>
    <p class="Pp">A BPF_SKB_TSTAMP_UNSPEC <i>tstamp_type</i> can only be used
        with a zero <i>tstamp</i>.</p>
    <p class="Pp">Only IPv4 and IPv6 skb-&gt;protocol are supported.</p>
    <p class="Pp">This function is most useful when it needs to set a mono
        delivery time to __sk_buff-&gt;tstamp and then bpf_redirect_*() to the
        egress of an iface. For example, changing the (rcv) timestamp in
        __sk_buff-&gt;tstamp at ingress to a mono delivery time and then
        bpf_redirect_*() to <i>sch_fq@phy-dev</i>.</p>
  </dd>
  <dt id="Return~196"><a class="permalink" href="#Return~196"><b>Return</b></a></dt>
  <dd>0 on success. <b>-EINVAL</b> for invalid input <b>-EOPNOTSUPP</b> for
      unsupported protocol</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~136"><a class="permalink" href="#long~136"><b><b>long
    bpf_ima_file_hash(struct file *</b><i>file</i><b>, void *</b><i>dst</i><b>,
    u32</b> <i>size</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~197"><a class="permalink" href="#Description~197"><b>Description</b></a></dt>
  <dd>Returns a calculated IMA hash of the <i>file</i>. If the hash is larger
      than <i>size</i>, then only <i>size</i> bytes will be copied to
    <i>dst</i></dd>
  <dt id="Return~197"><a class="permalink" href="#Return~197"><b>Return</b></a></dt>
  <dd>The <b>hash_algo</b> is returned on success, <b>-EOPNOTSUP</b> if the hash
      calculation failed or <b>-EINVAL</b> if invalid arguments are passed.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~12"><a class="permalink" href="#void~12"><b><b>void
    *bpf_kptr_xchg(void *</b><i>map_value</i><b>, void
    *</b><i>ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~198"><a class="permalink" href="#Description~198"><b>Description</b></a></dt>
  <dd>Exchange kptr at pointer <i>map_value</i> with <i>ptr</i>, and return the
      old value. <i>ptr</i> can be NULL, otherwise it must be a referenced
      pointer which will be released when this helper is called.</dd>
  <dt id="Return~198"><a class="permalink" href="#Return~198"><b>Return</b></a></dt>
  <dd>The old value of kptr (which can be NULL). The returned pointer if not
      NULL, is a reference which must be released using its corresponding
      release function, or moved into a BPF map before program exit.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~13"><a class="permalink" href="#void~13"><b><b>void
    *bpf_map_lookup_percpu_elem(struct bpf_map *</b><i>map</i><b>, const void
    *</b><i>key</i><b>, u32</b> <i>cpu</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~199"><a class="permalink" href="#Description~199"><b>Description</b></a></dt>
  <dd>Perform a lookup in <i>percpu map</i> for an entry associated to
      <i>key</i> on <i>cpu</i>.</dd>
  <dt id="Return~199"><a class="permalink" href="#Return~199"><b>Return</b></a></dt>
  <dd>Map value associated to <i>key</i> on <i>cpu</i>, or <b>NULL</b> if no
      entry was found or <i>cpu</i> is invalid.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="struct~15"><a class="permalink" href="#struct~15"><b><b>struct
    mptcp_sock *bpf_skc_to_mptcp_sock(void *</b><i>sk</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~200"><a class="permalink" href="#Description~200"><b>Description</b></a></dt>
  <dd>Dynamically cast a <i>sk</i> pointer to a <i>mptcp_sock</i> pointer.</dd>
  <dt id="Return~200"><a class="permalink" href="#Return~200"><b>Return</b></a></dt>
  <dd><i>sk</i> if casting is valid, or <b>NULL</b> otherwise.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~137"><a class="permalink" href="#long~137"><b><b>long
    bpf_dynptr_from_mem(void *</b><i>data</i><b>, u32</b> <i>size</i><b>,
    u64</b> <i>flags</i><b>, struct bpf_dynptr
    *</b><i>ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~201"><a class="permalink" href="#Description~201"><b>Description</b></a></dt>
  <dd>Get a dynptr to local memory <i>data</i>.
    <p class="Pp"><i>data</i> must be a ptr to a map value. The maximum
        <i>size</i> supported is DYNPTR_MAX_SIZE. <i>flags</i> is currently
        unused.</p>
  </dd>
  <dt id="Return~201"><a class="permalink" href="#Return~201"><b>Return</b></a></dt>
  <dd>0 on success, -E2BIG if the size exceeds DYNPTR_MAX_SIZE, -EINVAL if flags
      is not 0.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~138"><a class="permalink" href="#long~138"><b><b>long
    bpf_ringbuf_reserve_dynptr(void *</b><i>ringbuf</i><b>, u32</b>
    <i>size</i><b>, u64</b> <i>flags</i><b>, struct bpf_dynptr
    *</b><i>ptr</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~202"><a class="permalink" href="#Description~202"><b>Description</b></a></dt>
  <dd>Reserve <i>size</i> bytes of payload in a ring buffer <i>ringbuf</i>
      through the dynptr interface. <i>flags</i> must be 0.
    <p class="Pp">Please note that a corresponding bpf_ringbuf_submit_dynptr or
        bpf_ringbuf_discard_dynptr must be called on <i>ptr</i>, even if the
        reservation fails. This is enforced by the verifier.</p>
  </dd>
  <dt id="Return~202"><a class="permalink" href="#Return~202"><b>Return</b></a></dt>
  <dd>0 on success, or a negative error in case of failure.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~14"><a class="permalink" href="#void~14"><b><b>void
    bpf_ringbuf_submit_dynptr(struct bpf_dynptr *</b><i>ptr</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~203"><a class="permalink" href="#Description~203"><b>Description</b></a></dt>
  <dd>Submit reserved ring buffer sample, pointed to by <i>data</i>, through the
      dynptr interface. This is a no-op if the dynptr is invalid/null.
    <p class="Pp">For more information on <i>flags</i>, please see
        'bpf_ringbuf_submit'.</p>
  </dd>
  <dt id="Return~203"><a class="permalink" href="#Return~203"><b>Return</b></a></dt>
  <dd>Nothing. Always succeeds.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~15"><a class="permalink" href="#void~15"><b><b>void
    bpf_ringbuf_discard_dynptr(struct bpf_dynptr *</b><i>ptr</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~204"><a class="permalink" href="#Description~204"><b>Description</b></a></dt>
  <dd>Discard reserved ring buffer sample through the dynptr interface. This is
      a no-op if the dynptr is invalid/null.
    <p class="Pp">For more information on <i>flags</i>, please see
        'bpf_ringbuf_discard'.</p>
  </dd>
  <dt id="Return~204"><a class="permalink" href="#Return~204"><b>Return</b></a></dt>
  <dd>Nothing. Always succeeds.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~139"><a class="permalink" href="#long~139"><b><b>long
    bpf_dynptr_read(void *</b><i>dst</i><b>, u32</b> <i>len</i><b>, struct
    bpf_dynptr *</b><i>src</i><b>, u32</b> <i>offset</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~205"><a class="permalink" href="#Description~205"><b>Description</b></a></dt>
  <dd>Read <i>len</i> bytes from <i>src</i> into <i>dst</i>, starting from
      <i>offset</i> into <i>src</i>. <i>flags</i> is currently unused.</dd>
  <dt id="Return~205"><a class="permalink" href="#Return~205"><b>Return</b></a></dt>
  <dd>0 on success, -E2BIG if <i>offset</i> + <i>len</i> exceeds the length of
      <i>src</i>'s data, -EINVAL if <i>src</i> is an invalid dynptr or if
      <i>flags</i> is not 0.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~140"><a class="permalink" href="#long~140"><b><b>long
    bpf_dynptr_write(struct bpf_dynptr *</b><i>dst</i><b>, u32</b>
    <i>offset</i><b>, void *</b><i>src</i><b>, u32</b> <i>len</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~206"><a class="permalink" href="#Description~206"><b>Description</b></a></dt>
  <dd>Write <i>len</i> bytes from <i>src</i> into <i>dst</i>, starting from
      <i>offset</i> into <i>dst</i>. <i>flags</i> is currently unused.</dd>
  <dt id="Return~206"><a class="permalink" href="#Return~206"><b>Return</b></a></dt>
  <dd>0 on success, -E2BIG if <i>offset</i> + <i>len</i> exceeds the length of
      <i>dst</i>'s data, -EINVAL if <i>dst</i> is an invalid dynptr or if
      <i>dst</i> is a read-only dynptr or if <i>flags</i> is not 0.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="void~16"><a class="permalink" href="#void~16"><b><b>void
    *bpf_dynptr_data(struct bpf_dynptr *</b><i>ptr</i><b>, u32</b>
    <i>offset</i><b>, u32</b> <i>len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~207"><a class="permalink" href="#Description~207"><b>Description</b></a></dt>
  <dd>Get a pointer to the underlying dynptr data.
    <p class="Pp"><i>len</i> must be a statically known value. The returned data
        slice is invalidated whenever the dynptr is invalidated.</p>
  </dd>
  <dt id="Return~207"><a class="permalink" href="#Return~207"><b>Return</b></a></dt>
  <dd>Pointer to the underlying dynptr data, NULL if the dynptr is read-only, if
      the dynptr is invalid, or if the offset and length is out of bounds.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="s64~4"><a class="permalink" href="#s64~4"><b><b>s64
    bpf_tcp_raw_gen_syncookie_ipv4(struct iphdr *</b><i>iph</i><b>, struct
    tcphdr *</b><i>th</i><b>, u32</b> <i>th_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~208"><a class="permalink" href="#Description~208"><b>Description</b></a></dt>
  <dd>Try to issue a SYN cookie for the packet with corresponding IPv4/TCP
      headers, <i>iph</i> and <i>th</i>, without depending on a listening
      socket.
    <p class="Pp"><i>iph</i> points to the IPv4 header.</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains the length of the TCP header (at least
        <b>sizeof</b>(<b>struct tcphdr</b>)).</p>
  </dd>
  <dt id="Return~208"><a class="permalink" href="#Return~208"><b>Return</b></a></dt>
  <dd>On success, lower 32 bits hold the generated SYN cookie in followed by 16
      bits which hold the MSS value for that cookie, and the top 16 bits are
      unused.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EINVAL</b> if <i>th_len</i> is invalid.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="s64~5"><a class="permalink" href="#s64~5"><b><b>s64
    bpf_tcp_raw_gen_syncookie_ipv6(struct ipv6hdr *</b><i>iph</i><b>, struct
    tcphdr *</b><i>th</i><b>, u32</b> <i>th_len</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~209"><a class="permalink" href="#Description~209"><b>Description</b></a></dt>
  <dd>Try to issue a SYN cookie for the packet with corresponding IPv6/TCP
      headers, <i>iph</i> and <i>th</i>, without depending on a listening
      socket.
    <p class="Pp"><i>iph</i> points to the IPv6 header.</p>
    <p class="Pp"><i>th</i> points to the start of the TCP header, while
        <i>th_len</i> contains the length of the TCP header (at least
        <b>sizeof</b>(<b>struct tcphdr</b>)).</p>
  </dd>
  <dt id="Return~209"><a class="permalink" href="#Return~209"><b>Return</b></a></dt>
  <dd>On success, lower 32 bits hold the generated SYN cookie in followed by 16
      bits which hold the MSS value for that cookie, and the top 16 bits are
      unused.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EINVAL</b> if <i>th_len</i> is invalid.</p>
    <p class="Pp"><b>-EPROTONOSUPPORT</b> if CONFIG_IPV6 is not builtin.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~141"><a class="permalink" href="#long~141"><b><b>long
    bpf_tcp_raw_check_syncookie_ipv4(struct iphdr *</b><i>iph</i><b>, struct
    tcphdr *</b><i>th</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~210"><a class="permalink" href="#Description~210"><b>Description</b></a></dt>
  <dd>Check whether <i>iph</i> and <i>th</i> contain a valid SYN cookie ACK
      without depending on a listening socket.
    <p class="Pp"><i>iph</i> points to the IPv4 header.</p>
    <p class="Pp"><i>th</i> points to the TCP header.</p>
  </dd>
  <dt id="Return~210"><a class="permalink" href="#Return~210"><b>Return</b></a></dt>
  <dd>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie ACK.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EACCES</b> if the SYN cookie is not valid.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~142"><a class="permalink" href="#long~142"><b><b>long
    bpf_tcp_raw_check_syncookie_ipv6(struct ipv6hdr *</b><i>iph</i><b>, struct
    tcphdr *</b><i>th</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~211"><a class="permalink" href="#Description~211"><b>Description</b></a></dt>
  <dd>Check whether <i>iph</i> and <i>th</i> contain a valid SYN cookie ACK
      without depending on a listening socket.
    <p class="Pp"><i>iph</i> points to the IPv6 header.</p>
    <p class="Pp"><i>th</i> points to the TCP header.</p>
  </dd>
  <dt id="Return~211"><a class="permalink" href="#Return~211"><b>Return</b></a></dt>
  <dd>0 if <i>iph</i> and <i>th</i> are a valid SYN cookie ACK.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EACCES</b> if the SYN cookie is not valid.</p>
    <p class="Pp"><b>-EPROTONOSUPPORT</b> if CONFIG_IPV6 is not builtin.</p>
  </dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="u64~25"><a class="permalink" href="#u64~25"><b><b>u64
    bpf_ktime_get_tai_ns(void)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~212"><a class="permalink" href="#Description~212"><b>Description</b></a></dt>
  <dd>A nonsettable system-wide clock derived from wall-clock time but ignoring
      leap seconds. This clock does not experience discontinuities and backwards
      jumps caused by NTP inserting leap seconds as CLOCK_REALTIME does.
    <p class="Pp">See: <b>clock_gettime</b>(<b>CLOCK_TAI</b>)</p>
  </dd>
  <dt id="Return~212"><a class="permalink" href="#Return~212"><b>Return</b></a></dt>
  <dd>Current <i>ktime</i>.</dd>
</dl>
</div>
<br>
<dl class="Bl-tag">
  <dt id="long~143"><a class="permalink" href="#long~143"><b><b>long
    bpf_user_ringbuf_drain(struct bpf_map *</b><i>map</i><b>, void
    *</b><i>callback_fn</i><b>, void *</b><i>ctx</i><b>, u64</b>
    <i>flags</i><b>)</b></b></a></dt>
  <dd></dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="Description~213"><a class="permalink" href="#Description~213"><b>Description</b></a></dt>
  <dd>Drain samples from the specified user ring buffer, and invoke the provided
      callback for each such sample:
    <p class="Pp">long (*callback_fn)(struct bpf_dynptr *dynptr, void *ctx);</p>
    <p class="Pp">If <b>callback_fn</b> returns 0, the helper will continue to
        try and drain the next sample, up to a maximum of
        BPF_MAX_USER_RINGBUF_SAMPLES samples. If the return value is 1, the
        helper will skip the rest of the samples and return. Other return values
        are not used now, and will be rejected by the verifier.</p>
  </dd>
  <dt id="Return~213"><a class="permalink" href="#Return~213"><b>Return</b></a></dt>
  <dd>The number of drained samples if no error was encountered while draining
      samples, or 0 if no samples were present in the ring buffer. If a
      user-space producer was epoll-waiting on this map, and at least one sample
      was drained, they will receive an event notification notifying them of
      available space in the ring buffer. If the BPF_RB_NO_WAKEUP flag is passed
      to this function, no wakeup notification will be sent. If the
      BPF_RB_FORCE_WAKEUP flag is passed, a wakeup notification will be sent
      even if no sample was drained.
    <p class="Pp">On failure, the returned value is one of the following:</p>
    <p class="Pp"><b>-EBUSY</b> if the ring buffer is contended, and another
        calling context was concurrently draining the ring buffer.</p>
    <p class="Pp"><b>-EINVAL</b> if user-space is not properly tracking the ring
        buffer due to the producer position not being aligned to 8 bytes, a
        sample not being aligned to 8 bytes, or the producer position not
        matching the advertised length of a sample.</p>
    <p class="Pp"><b>-E2BIG</b> if user-space has tried to publish a sample
        which is larger than the size of the ring buffer, or which cannot fit
        within a struct bpf_dynptr.</p>
  </dd>
</dl>
</div>
<br>
</div>
<br>
</section>
<section class="Sh">
<h1 class="Sh" id="EXAMPLES"><a class="permalink" href="#EXAMPLES">EXAMPLES</a></h1>
<p class="Pp">Example usage for most of the eBPF helpers listed in this manual
    page are available within the Linux kernel sources, at the following
    locations:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>samples/bpf/</i></dd>
  <dt>•</dt>
  <dd><i>tools/testing/selftests/bpf/</i></dd>
</dl>
</div>
<br>
</section>
<section class="Sh">
<h1 class="Sh" id="LICENSE"><a class="permalink" href="#LICENSE">LICENSE</a></h1>
<p class="Pp">eBPF programs can have an associated license, passed along with
    the bytecode instructions to the kernel when the programs are loaded. The
    format for that string is identical to the one in use for kernel modules
    (Dual licenses, such as "Dual BSD/GPL", may be used). Some helper
    functions are only accessible to programs that are compatible with the GNU
    Privacy License (GPL).</p>
<p class="Pp">In order to use such helpers, the eBPF program must be loaded with
    the correct license string passed (via <b>attr</b>) to the <b>bpf</b>()
    system call, and this generally translates into the C source code of the
    program containing a line similar to the following:</p>
<div class="Bd-indent">
<div class="Bd-indent">
<p class="Pp"></p>
<pre>char ____license[] __attribute__((section("license"), used)) = "GPL";
</pre>
</div>
<br>
</div>
<br>
</section>
<section class="Sh">
<h1 class="Sh" id="IMPLEMENTATION"><a class="permalink" href="#IMPLEMENTATION">IMPLEMENTATION</a></h1>
<p class="Pp">This manual page is an effort to document the existing eBPF helper
    functions. But as of this writing, the BPF sub-system is under heavy
    development. New eBPF program or map types are added, along with new helper
    functions. Some helpers are occasionally made available for additional
    program types. So in spite of the efforts of the community, this page might
    not be up-to-date. If you want to check by yourself what helper functions
    exist in your kernel, or what types of programs they can support, here are
    some files among the kernel tree that you may be interested in:</p>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt>•</dt>
  <dd><i>include/uapi/linux/bpf.h</i> is the main BPF header. It contains the
      full list of all helper functions, as well as many other BPF definitions
      including most of the flags, structs or constants used by the
    helpers.</dd>
  <dt>•</dt>
  <dd><i>net/core/filter.c</i> contains the definition of most network-related
      helper functions, and the list of program types from which they can be
      used.</dd>
  <dt>•</dt>
  <dd><i>kernel/trace/bpf_trace.c</i> is the equivalent for most tracing
      program-related helpers.</dd>
  <dt>•</dt>
  <dd><i>kernel/bpf/verifier.c</i> contains the functions used to check that
      valid types of eBPF maps are used with a given helper function.</dd>
  <dt>•</dt>
  <dd><i>kernel/bpf/</i> directory contains other files in which additional
      helpers are defined (for cgroups, sockmaps, etc.).</dd>
  <dt>•</dt>
  <dd>The bpftool utility can be used to probe the availability of helper
      functions on the system (as well as supported program and map types, and a
      number of other parameters). To do so, run <b>bpftool feature probe</b>
      (see <b>bpftool-feature</b>(8) for details). Add the <b>unprivileged</b>
      keyword to list features available to unprivileged users.</dd>
</dl>
</div>
<br>
<p class="Pp">Compatibility between helper functions and program types can
    generally be found in the files where helper functions are defined. Look for
    the <b>struct</b> <b>bpf_func_proto</b> objects and for functions returning
    them: these functions contain a list of helpers that a given program type
    can call. Note that the <b>default:</b> label of the <b>switch ... case</b>
    used to filter helpers can call other functions, themselves allowing access
    to additional helpers. The requirement for GPL license is also in those
    <b>struct bpf_func_proto</b>.</p>
<p class="Pp">Compatibility between helper functions and map types can be found
    in the <b>check_map_func_compatibility</b>() function in file
    <i>kernel/bpf/verifier.c</i>.</p>
<p class="Pp">Helper functions that invalidate the checks on <b>data</b> and
    <b>data_end</b> pointers for network processing are listed in function
    <b>bpf_helper_changes_pkt_data</b>() in file <i>net/core/filter.c</i>.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>bpf</b>(2), <b>bpftool</b>(8), <b>cgroups</b>(7), <b>ip</b>(8),
    <b>perf_event_open</b>(2), <b>sendmsg</b>(2), <b>socket</b>(7),
    <b>tc-bpf</b>(8)</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">2022-09-26</td>
    <td class="foot-os">Linux v6.1</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>