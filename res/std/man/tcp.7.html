<!DOCTYPE html><html><!-- This is an automatically generated file.  Do not edit.
   This man page is Copyright (C) 1999 Andi Kleen <ak@muc.de>.
   and Copyright (C) 2008 Michael Kerrisk <mtk.manpages@gmail.com>
   Note also that many pieces are drawn from the kernel source file
   Documentation/networking/ip-sysctl.txt.
  
   %%%LICENSE_START(VERBATIM_ONE_PARA)
   Permission is granted to distribute possibly modified copies
   of this page provided the header is included verbatim,
   and in case of nontrivial modification author and date
   of the modification is added to the header.
   %%%LICENSE_END
  
   2.4 Updates by Nivedita Singhvi 4/20/02 <nivedita@us.ibm.com>.
   Modified, 2004-11-11, Michael Kerrisk and Andries Brouwer
  	Updated details of interaction of TCP_CORK and TCP_NODELAY.
  
   2008-11-21, mtk, many, many updates.
       The descriptions of /proc files and socket options should now
       be more or less up to date and complete as at Linux 2.6.27
       (other than the remaining FIXMEs in the page source below).
  
   FIXME The following need to be documented
  	TCP_MD5SIG (2.6.20)
  	    commit cfb6eeb4c860592edd123fdea908d23c6ad1c7dc
  	    Author was yoshfuji@linux-ipv6.org
  	    Needs CONFIG_TCP_MD5SIG
   From net/inet/Kconfig:
   bool "TCP: MD5 Signature Option support (RFC2385) (EXPERIMENTAL)"
   RFC2385 specifies a method of giving MD5 protection to TCP sessions.
   Its main (only?) use is to protect BGP sessions between core routers
   on the Internet.
  
   There is a TCP_MD5SIG option documented in FreeBSD's tcp(4),
   but probably many details are different on Linux
  	    http://thread.gmane.org/gmane.linux.network/47490
  	    http://www.daemon-systems.org/man/tcp.4.html
  	    http://article.gmane.org/gmane.os.netbsd.devel.network/3767/match=tcp_md5sig+freebsd
  
  	TCP_COOKIE_TRANSACTIONS (2.6.33)
  	    commit 519855c508b9a17878c0977a3cdefc09b59b30df
  	    Author: William Allen Simpson <william.allen.simpson@gmail.com>
  	    commit e56fb50f2b7958b931c8a2fc0966061b3f3c8f3a
  	    Author: William Allen Simpson <william.allen.simpson@gmail.com>
  
  	    REMOVED in Linux 3.10
   		commit 1a2c6181c4a1922021b4d7df373bba612c3e5f04
  		Author: Christoph Paasch <christoph.paasch@uclouvain.be>
  
  	TCP_THIN_LINEAR_TIMEOUTS (2.6.34)
  	    commit 36e31b0af58728071e8023cf8e20c5166b700717
  	    Author: Andreas Petlund <apetlund@simula.no>
  
  	TCP_THIN_DUPACK (2.6.34)
  	    commit 7e38017557bc0b87434d184f8804cadb102bb903
  	    Author: Andreas Petlund <apetlund@simula.no>
  
  	TCP_REPAIR (3.5)
  	    commit ee9952831cfd0bbe834f4a26489d7dce74582e37
  	    Author: Pavel Emelyanov <xemul@parallels.com>
  	    See also
  		http://criu.org/TCP_connection
  		https://lwn.net/Articles/495304/
  
  	TCP_REPAIR_QUEUE (3.5)
  	    commit ee9952831cfd0bbe834f4a26489d7dce74582e37
  	    Author: Pavel Emelyanov <xemul@parallels.com>
  
  	TCP_QUEUE_SEQ (3.5)
  	    commit ee9952831cfd0bbe834f4a26489d7dce74582e37
  	    Author: Pavel Emelyanov <xemul@parallels.com>
  
  	TCP_REPAIR_OPTIONS (3.5)
  	    commit b139ba4e90dccbf4cd4efb112af96a5c9e0b098c
  	    Author: Pavel Emelyanov <xemul@parallels.com>
  
       TCP_FASTOPEN (3.6)
           (Fast Open server side implementation completed in Linux 3.7)
  	    http://lwn.net/Articles/508865/
  
       TCP_TIMESTAMP (3.9)
          commit 93be6ce0e91b6a94783e012b1857a347a5e6e9f2
          Author: Andrey Vagin <avagin@openvz.org>
  
       TCP_NOTSENT_LOWAT (3.12)
          commit c9bee3b7fdecb0c1d070c7b54113b3bdfb9a3d36
          Author: Eric Dumazet <edumazet@google.com>
  
  	TCP_CC_INFO (4.1)
  	   commit 6e9250f59ef9efb932c84850cd221f22c2a03c4a
  	   Author: Eric Dumazet <edumazet@google.com>
  
  	TCP_SAVE_SYN, TCP_SAVED_SYN (4.2)
  	    commit cd8ae85299d54155702a56811b2e035e63064d3d
  	    Author: Eric Dumazet <edumazet@google.com>
   --><head>
<meta name="dc.identifier" content="res/cbeaef1cfdfc10a55f98220600f02aab846ef0c6">

  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    table.head, table.foot { width: 100%; }
    td.head-rtitle, td.foot-os { text-align: right; }
    td.head-vol { text-align: center; }
    .Nd, .Bf, .Op { display: inline; }
    .Pa, .Ad { font-style: italic; }
    .Ms { font-weight: bold; }
    .Bl-diag > dt { font-weight: bold; }
    code.Nm, .Fl, .Cm, .Ic, code.In, .Fd, .Fn, .Cd { font-weight: bold;
      font-family: inherit; }
  </style>
  <title>tcp(7)</title>
<link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>
<body>
<div id="book-container">
<table class="head">
  <tbody><tr>
    <td class="head-ltitle">tcp(7)</td>
    <td class="head-vol">Miscellaneous Information Manual</td>
    <td class="head-rtitle">tcp(7)</td>
  </tr>
</tbody></table>
<div class="manual-text">
<section class="Sh">
<h1 class="Sh" id="NAME"><a class="permalink" href="#NAME">NAME</a></h1>
<p class="Pp">tcp - TCP protocol</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SYNOPSIS"><a class="permalink" href="#SYNOPSIS">SYNOPSIS</a></h1>
<pre><b>#include &lt;sys/socket.h&gt;</b>
<b>#include &lt;netinet/in.h&gt;</b>
<b>#include &lt;netinet/tcp.h&gt;</b></pre>
<pre><i>tcp_socket</i><b> = socket(AF_INET, SOCK_STREAM, 0);</b></pre>
</section>
<section class="Sh">
<h1 class="Sh" id="DESCRIPTION"><a class="permalink" href="#DESCRIPTION">DESCRIPTION</a></h1>
<p class="Pp">This is an implementation of the TCP protocol defined in
    RFC&nbsp;793, RFC&nbsp;1122 and RFC&nbsp;2001 with the NewReno and
    SACK extensions. It provides a reliable, stream-oriented, full-duplex
    connection between two sockets on top of <b>ip</b>(7), for both v4 and v6
    versions. TCP guarantees that the data arrives in order and retransmits lost
    packets. It generates and checks a per-packet checksum to catch transmission
    errors. TCP does not preserve record boundaries.</p>
<p class="Pp">A newly created TCP socket has no remote or local address and is
    not fully specified. To create an outgoing TCP connection use
    <b>connect</b>(2) to establish a connection to another TCP socket. To
    receive new incoming connections, first <b>bind</b>(2) the socket to a local
    address and port and then call <b>listen</b>(2) to put the socket into the
    listening state. After that a new socket for each incoming connection can be
    accepted using <b>accept</b>(2). A socket which has had <b>accept</b>(2) or
    <b>connect</b>(2) successfully called on it is fully specified and may
    transmit data. Data cannot be transmitted on listening or not yet connected
    sockets.</p>
<p class="Pp">Linux supports RFC&nbsp;1323 TCP high performance extensions.
    These include Protection Against Wrapped Sequence Numbers (PAWS), Window
    Scaling and Timestamps. Window scaling allows the use of large (&gt;
    64&nbsp;kB) TCP windows in order to support links with high latency or
    bandwidth. To make use of them, the send and receive buffer sizes must be
    increased. They can be set globally with the
    <i>/proc/sys/net/ipv4/tcp_wmem</i> and <i>/proc/sys/net/ipv4/tcp_rmem</i>
    files, or on individual sockets by using the <b>SO_SNDBUF</b> and
    <b>SO_RCVBUF</b> socket options with the <b>setsockopt</b>(2) call.</p>
<p class="Pp">The maximum sizes for socket buffers declared via the
    <b>SO_SNDBUF</b> and <b>SO_RCVBUF</b> mechanisms are limited by the values
    in the <i>/proc/sys/net/core/rmem_max</i> and
    <i>/proc/sys/net/core/wmem_max</i> files. Note that TCP actually allocates
    twice the size of the buffer requested in the <b>setsockopt</b>(2) call, and
    so a succeeding <b>getsockopt</b>(2) call will not return the same size of
    buffer as requested in the <b>setsockopt</b>(2) call. TCP uses the extra
    space for administrative purposes and internal kernel structures, and the
    <i>/proc</i> file values reflect the larger sizes compared to the actual TCP
    windows. On individual connections, the socket buffer size must be set prior
    to the <b>listen</b>(2) or <b>connect</b>(2) calls in order to have it take
    effect. See <b>socket</b>(7) for more information.</p>
<p class="Pp">TCP supports urgent data. Urgent data is used to signal the
    receiver that some important message is part of the data stream and that it
    should be processed as soon as possible. To send urgent data specify the
    <b>MSG_OOB</b> option to <b>send</b>(2). When urgent data is received, the
    kernel sends a <b>SIGURG</b> signal to the process or process group that has
    been set as the socket "owner" using the <b>SIOCSPGRP</b> or
    <b>FIOSETOWN</b> ioctls (or the POSIX.1-specified <b>fcntl</b>(2)
    <b>F_SETOWN</b> operation). When the <b>SO_OOBINLINE</b> socket option is
    enabled, urgent data is put into the normal data stream (a program can test
    for its location using the <b>SIOCATMARK</b> ioctl described below),
    otherwise it can be received only when the <b>MSG_OOB</b> flag is set for
    <b>recv</b>(2) or <b>recvmsg</b>(2).</p>
<p class="Pp">When out-of-band data is present, <b>select</b>(2) indicates the
    file descriptor as having an exceptional condition and <i>poll (2)</i>
    indicates a <b>POLLPRI</b> event.</p>
<p class="Pp">Linux 2.4 introduced a number of changes for improved throughput
    and scaling, as well as enhanced functionality. Some of these features
    include support for zero-copy <b>sendfile</b>(2), Explicit Congestion
    Notification, new management of TIME_WAIT sockets, keep-alive socket options
    and support for Duplicate SACK extensions.</p>
<section class="Ss">
<h2 class="Ss" id="Address_formats"><a class="permalink" href="#Address_formats">Address
  formats</a></h2>
<p class="Pp">TCP is built on top of IP (see <b>ip</b>(7)). The address formats
    defined by <b>ip</b>(7) apply to TCP. TCP supports point-to-point
    communication only; broadcasting and multicasting are not supported.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="/proc_interfaces"><a class="permalink" href="#/proc_interfaces">/proc
  interfaces</a></h2>
<p class="Pp">System-wide TCP parameter settings can be accessed by files in the
    directory <i>/proc/sys/net/ipv4/</i>. In addition, most IP <i>/proc</i>
    interfaces also apply to TCP; see <b>ip</b>(7). Variables described as
    <i>Boolean</i> take an integer value, with a nonzero value
    ("true") meaning that the corresponding option is enabled, and a
    zero value ("false") meaning that the option is disabled.</p>
<dl class="Bl-tag">
  <dt id="tcp_abc"><a class="permalink" href="#tcp_abc"><i>tcp_abc</i> (Integer;
    default: 0; Linux 2.6.15 to Linux 3.8)</a></dt>
  <dd>Control the Appropriate Byte Count (ABC), defined in RFC 3465. ABC is a
      way of increasing the congestion window (<i>cwnd</i>) more slowly in
      response to partial acknowledgements. Possible values are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>increase <i>cwnd</i> once per acknowledgement (no ABC)</dd>
  <dt><b>1</b></dt>
  <dd>increase <i>cwnd</i> once per acknowledgement of full sized segment</dd>
  <dt><b>2</b></dt>
  <dd>allow increase <i>cwnd</i> by two if acknowledgement is of two segments to
      compensate for delayed acknowledgements.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_abort_on_overflow"><a class="permalink" href="#tcp_abort_on_overflow"><i>tcp_abort_on_overflow</i>
    (Boolean; default: disabled; since Linux 2.4)</a></dt>
  <dd>Enable resetting connections if the listening service is too slow and
      unable to keep up and accept them. It means that if overflow occurred due
      to a burst, the connection will recover. Enable this option <i>only</i> if
      you are really sure that the listening daemon cannot be tuned to accept
      connections faster. Enabling this option can harm the clients of your
      server.</dd>
  <dt id="tcp_adv_win_scale"><a class="permalink" href="#tcp_adv_win_scale"><i>tcp_adv_win_scale</i>
    (integer; default: 2; since Linux 2.4)</a></dt>
  <dd>Count buffering overhead as <i>bytes/2^tcp_adv_win_scale</i>, if
      <i>tcp_adv_win_scale</i> is greater than 0; or
      <i>bytes-bytes/2^(-tcp_adv_win_scale)</i>, if <i>tcp_adv_win_scale</i> is
      less than or equal to zero.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>The socket receive buffer space is shared between the application and
      kernel. TCP maintains part of the buffer as the TCP window, this is the
      size of the receive window advertised to the other end. The rest of the
      space is used as the "application" buffer, used to isolate the
      network from scheduling and application latencies. The
      <i>tcp_adv_win_scale</i> default value of 2 implies that the space used
      for the application buffer is one fourth that of the total.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_allowed_congestion_control"><a class="permalink" href="#tcp_allowed_congestion_control"><i>tcp_allowed_congestion_control</i>
    (String; default: see text; since Linux 2.4.20)</a></dt>
  <dd>Show/set the congestion control algorithm choices available to
      unprivileged processes (see the description of the <b>TCP_CONGESTION</b>
      socket option). The items in the list are separated by white space and
      terminated by a newline character. The list is a subset of those listed in
      <i>tcp_available_congestion_control</i>. The default value for this list
      is "reno" plus the default setting of
      <i>tcp_congestion_control</i>.</dd>
  <dt id="tcp_autocorking"><a class="permalink" href="#tcp_autocorking"><i>tcp_autocorking</i>
    (Boolean; default: enabled; since Linux 3.14)</a></dt>
  <dd>If this option is enabled, the kernel tries to coalesce small writes (from
      consecutive <b>write</b>(2) and <b>sendmsg</b>(2) calls) as much as
      possible, in order to decrease the total number of sent packets.
      Coalescing is done if at least one prior packet for the flow is waiting in
      Qdisc queues or device transmit queue. Applications can still use the
      <b>TCP_CORK</b> socket option to obtain optimal behavior when they know
      how/when to uncork their sockets.</dd>
  <dt id="tcp_available_congestion_control"><a class="permalink" href="#tcp_available_congestion_control"><i>tcp_available_congestion_control</i>
    (String; read-only; since Linux 2.4.20)</a></dt>
  <dd>Show a list of the congestion-control algorithms that are registered. The
      items in the list are separated by white space and terminated by a newline
      character. This list is a limiting set for the list in
      <i>tcp_allowed_congestion_control</i>. More congestion-control algorithms
      may be available as modules, but not loaded.</dd>
  <dt id="tcp_app_win"><a class="permalink" href="#tcp_app_win"><i>tcp_app_win</i>
    (integer; default: 31; since Linux 2.4)</a></dt>
  <dd>This variable defines how many bytes of the TCP window are reserved for
      buffering overhead.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>A maximum of (<i>window/2^tcp_app_win</i>, mss) bytes in the window are
      reserved for the application buffer. A value of 0 implies that no amount
      is reserved.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_base_mss"><a class="permalink" href="#tcp_base_mss"><i>tcp_base_mss</i>
    (Integer; default: 512; since Linux 2.6.17)</a></dt>
  <dd>The initial value of <i>search_low</i> to be used by the packetization
      layer Path MTU discovery (MTU probing). If MTU probing is enabled, this is
      the initial MSS used by the connection.</dd>
  <dt id="tcp_bic"><a class="permalink" href="#tcp_bic"><i>tcp_bic</i> (Boolean;
    default: disabled; Linux 2.4.27/2.6.6 to Linux 2.6.13)</a></dt>
  <dd>Enable BIC TCP congestion control algorithm. BIC-TCP is a sender-side-only
      change that ensures a linear RTT fairness under large windows while
      offering both scalability and bounded TCP-friendliness. The protocol
      combines two schemes called additive increase and binary search increase.
      When the congestion window is large, additive increase with a large
      increment ensures linear RTT fairness as well as good scalability. Under
      small congestion windows, binary search increase provides TCP
      friendliness.</dd>
  <dt id="tcp_bic_low_window"><a class="permalink" href="#tcp_bic_low_window"><i>tcp_bic_low_window</i>
    (integer; default: 14; Linux 2.4.27/2.6.6 to Linux 2.6.13)</a></dt>
  <dd>Set the threshold window (in packets) where BIC TCP starts to adjust the
      congestion window. Below this threshold BIC TCP behaves the same as the
      default TCP Reno.</dd>
  <dt id="tcp_bic_fast_convergence"><a class="permalink" href="#tcp_bic_fast_convergence"><i>tcp_bic_fast_convergence</i>
    (Boolean; default: enabled; Linux 2.4.27/2.6.6 to Linux 2.6.13)</a></dt>
  <dd>Force BIC TCP to more quickly respond to changes in congestion window.
      Allows two flows sharing the same connection to converge more
    rapidly.</dd>
  <dt id="tcp_congestion_control"><a class="permalink" href="#tcp_congestion_control"><i>tcp_congestion_control</i>
    (String; default: see text; since Linux 2.4.13)</a></dt>
  <dd>Set the default congestion-control algorithm to be used for new
      connections. The algorithm "reno" is always available, but
      additional choices may be available depending on kernel configuration. The
      default value for this file is set as part of kernel configuration.</dd>
  <dt id="tcp_dma_copybreak"><a class="permalink" href="#tcp_dma_copybreak"><i>tcp_dma_copybreak</i>
    (integer; default: 4096; since Linux 2.6.24)</a></dt>
  <dd>Lower limit, in bytes, of the size of socket reads that will be offloaded
      to a DMA copy engine, if one is present in the system and the kernel was
      configured with the <b>CONFIG_NET_DMA</b> option.</dd>
  <dt id="tcp_dsack"><a class="permalink" href="#tcp_dsack"><i>tcp_dsack</i>
    (Boolean; default: enabled; since Linux 2.4)</a></dt>
  <dd>Enable RFC&nbsp;2883 TCP Duplicate SACK support.</dd>
  <dt id="tcp_fastopen"><a class="permalink" href="#tcp_fastopen"><i>tcp_fastopen</i>
    (Bitmask; default: 0x1; since Linux 3.7)</a></dt>
  <dd>Enables RFC&nbsp;7413 Fast Open support. The flag is used as a bitmap
      with the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0x1</b></dt>
  <dd>Enables client side Fast Open support</dd>
  <dt><b>0x2</b></dt>
  <dd>Enables server side Fast Open support</dd>
  <dt><b>0x4</b></dt>
  <dd>Allows client side to transmit data in SYN without Fast Open option</dd>
  <dt><b>0x200</b></dt>
  <dd>Allows server side to accept SYN data without Fast Open option</dd>
  <dt><b>0x400</b></dt>
  <dd>Enables Fast Open on all listeners without <b>TCP_FASTOPEN</b> socket
      option</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_fastopen_key"><a class="permalink" href="#tcp_fastopen_key"><i>tcp_fastopen_key</i>
    (since Linux 3.7)</a></dt>
  <dd>Set server side RFC&nbsp;7413 Fast Open key to generate Fast Open cookie
      when server side Fast Open support is enabled.</dd>
  <dt id="tcp_ecn"><a class="permalink" href="#tcp_ecn"><i>tcp_ecn</i> (Integer;
    default: see below; since Linux 2.4)</a></dt>
  <dd>Enable RFC&nbsp;3168 Explicit Congestion Notification.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This file can have one of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Disable ECN. Neither initiate nor accept ECN. This was the default up to
      and including Linux 2.6.30.</dd>
  <dt><b>1</b></dt>
  <dd>Enable ECN when requested by incoming connections and also request ECN on
      outgoing connection attempts.</dd>
  <dt><b>2</b></dt>
  <dd>Enable ECN when requested by incoming connections, but do not request ECN
      on outgoing connections. This value is supported, and is the default,
      since Linux 2.6.31.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>When enabled, connectivity to some destinations could be affected due to
      older, misbehaving middle boxes along the path, causing connections to be
      dropped. However, to facilitate and encourage deployment with option 1,
      and to work around such buggy equipment, the <b>tcp_ecn_fallback</b>
      option has been introduced.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_ecn_fallback"><a class="permalink" href="#tcp_ecn_fallback"><i>tcp_ecn_fallback</i>
    (Boolean; default: enabled; since Linux 4.1)</a></dt>
  <dd>Enable RFC&nbsp;3168, Section 6.1.1.1. fallback. When enabled, outgoing
      ECN-setup SYNs that time out within the normal SYN retransmission timeout
      will be resent with CWR and ECE cleared.</dd>
  <dt id="tcp_fack"><a class="permalink" href="#tcp_fack"><i>tcp_fack</i>
    (Boolean; default: enabled; since Linux 2.2)</a></dt>
  <dd>Enable TCP Forward Acknowledgement support.</dd>
  <dt id="tcp_fin_timeout"><a class="permalink" href="#tcp_fin_timeout"><i>tcp_fin_timeout</i>
    (integer; default: 60; since Linux 2.2)</a></dt>
  <dd>This specifies how many seconds to wait for a final FIN packet before the
      socket is forcibly closed. This is strictly a violation of the TCP
      specification, but required to prevent denial-of-service attacks. In Linux
      2.2, the default value was 180.</dd>
  <dt id="tcp_frto"><a class="permalink" href="#tcp_frto"><i>tcp_frto</i>
    (integer; default: see below; since Linux 2.4.21/2.6)</a></dt>
  <dd>Enable F-RTO, an enhanced recovery algorithm for TCP retransmission
      timeouts (RTOs). It is particularly beneficial in wireless environments
      where packet loss is typically due to random radio interference rather
      than intermediate router congestion. See RFC 4138 for more details.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>This file can have one of the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Disabled. This was the default up to and including Linux 2.6.23.</dd>
  <dt><b>1</b></dt>
  <dd>The basic version F-RTO algorithm is enabled.</dd>
  <dt><b>2</b></dt>
  <dd>Enable SACK-enhanced F-RTO if flow uses SACK. The basic version can be
      used also when SACK is in use though in that case scenario(s) exists where
      F-RTO interacts badly with the packet counting of the SACK-enabled TCP
      flow. This value is the default since Linux 2.6.24.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Before Linux 2.6.22, this parameter was a Boolean value, supporting just
      values 0 and 1 above.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_frto_response"><a class="permalink" href="#tcp_frto_response"><i>tcp_frto_response</i>
    (integer; default: 0; since Linux 2.6.22)</a></dt>
  <dd>When F-RTO has detected that a TCP retransmission timeout was spurious
      (i.e., the timeout would have been avoided had TCP set a longer
      retransmission timeout), TCP has several options concerning what to do
      next. Possible values are:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Rate halving based; a smooth and conservative response, results in halved
      congestion window (<i>cwnd</i>) and slow-start threshold (<i>ssthresh</i>)
      after one RTT.</dd>
  <dt><b>1</b></dt>
  <dd>Very conservative response; not recommended because even though being
      valid, it interacts poorly with the rest of Linux TCP; halves <i>cwnd</i>
      and <i>ssthresh</i> immediately.</dd>
  <dt><b>2</b></dt>
  <dd>Aggressive response; undoes congestion-control measures that are now known
      to be unnecessary (ignoring the possibility of a lost retransmission that
      would require TCP to be more cautious); <i>cwnd</i> and <i>ssthresh</i>
      are restored to the values prior to timeout.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_keepalive_intvl"><a class="permalink" href="#tcp_keepalive_intvl"><i>tcp_keepalive_intvl</i>
    (integer; default: 75; since Linux 2.4)</a></dt>
  <dd>The number of seconds between TCP keep-alive probes.</dd>
  <dt id="tcp_keepalive_probes"><a class="permalink" href="#tcp_keepalive_probes"><i>tcp_keepalive_probes</i>
    (integer; default: 9; since Linux 2.2)</a></dt>
  <dd>The maximum number of TCP keep-alive probes to send before giving up and
      killing the connection if no response is obtained from the other end.</dd>
  <dt id="tcp_keepalive_time"><a class="permalink" href="#tcp_keepalive_time"><i>tcp_keepalive_time</i>
    (integer; default: 7200; since Linux 2.2)</a></dt>
  <dd>The number of seconds a connection needs to be idle before TCP begins
      sending out keep-alive probes. Keep-alives are sent only when the
      <b>SO_KEEPALIVE</b> socket option is enabled. The default value is 7200
      seconds (2 hours). An idle connection is terminated after approximately an
      additional 11 minutes (9 probes an interval of 75 seconds apart) when
      keep-alive is enabled.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Note that underlying connection tracking mechanisms and application
      timeouts may be much shorter.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_low_latency"><a class="permalink" href="#tcp_low_latency"><i>tcp_low_latency</i>
    (Boolean; default: disabled; since Linux 2.4.21/2.6; obsolete since Linux
    4.14)</a></dt>
  <dd>If enabled, the TCP stack makes decisions that prefer lower latency as
      opposed to higher throughput. It this option is disabled, then higher
      throughput is preferred. An example of an application where this default
      should be changed would be a Beowulf compute cluster. Since Linux 4.14,
      this file still exists, but its value is ignored.</dd>
  <dt id="tcp_max_orphans"><a class="permalink" href="#tcp_max_orphans"><i>tcp_max_orphans</i>
    (integer; default: see below; since Linux 2.4)</a></dt>
  <dd>The maximum number of orphaned (not attached to any user file handle) TCP
      sockets allowed in the system. When this number is exceeded, the orphaned
      connection is reset and a warning is printed. This limit exists only to
      prevent simple denial-of-service attacks. Lowering this limit is not
      recommended. Network conditions might require you to increase the number
      of orphans allowed, but note that each orphan can eat up to ~64&nbsp;kB
      of unswappable memory. The default initial value is set equal to the
      kernel parameter NR_FILE. This initial default is adjusted depending on
      the memory in the system.</dd>
  <dt id="tcp_max_syn_backlog"><a class="permalink" href="#tcp_max_syn_backlog"><i>tcp_max_syn_backlog</i>
    (integer; default: see below; since Linux 2.2)</a></dt>
  <dd>The maximum number of queued connection requests which have still not
      received an acknowledgement from the connecting client. If this number is
      exceeded, the kernel will begin dropping requests. The default value of
      256 is increased to 1024 when the memory present in the system is adequate
      or greater (&gt;= 128&nbsp;MB), and reduced to 128 for those systems
      with very low memory (&lt;= 32&nbsp;MB).</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Before Linux 2.6.20, it was recommended that if this needed to be
      increased above 1024, the size of the SYNACK hash table
      (<b>TCP_SYNQ_HSIZE</b>) in <i>include/net/tcp.h</i> should be modified to
      keep</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>TCP_SYNQ_HSIZE * 16 &lt;= tcp_max_syn_backlog
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>and the kernel should be recompiled. In Linux 2.6.20, the fixed sized
      <b>TCP_SYNQ_HSIZE</b> was removed in favor of dynamic sizing.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="tcp_max_tw_buckets"><a class="permalink" href="#tcp_max_tw_buckets"><i>tcp_max_tw_buckets</i>
    (integer; default: see below; since Linux 2.4)</a></dt>
  <dd>The maximum number of sockets in TIME_WAIT state allowed in the system.
      This limit exists only to prevent simple denial-of-service attacks. The
      default value of NR_FILE*2 is adjusted depending on the memory in the
      system. If this number is exceeded, the socket is closed and a warning is
      printed.</dd>
  <dt id="tcp_moderate_rcvbuf"><a class="permalink" href="#tcp_moderate_rcvbuf"><i>tcp_moderate_rcvbuf</i>
    (Boolean; default: enabled; since Linux 2.4.17/2.6.7)</a></dt>
  <dd>If enabled, TCP performs receive buffer auto-tuning, attempting to
      automatically size the buffer (no greater than <i>tcp_rmem[2]</i>) to
      match the size required by the path for full throughput.</dd>
  <dt id="tcp_mem"><a class="permalink" href="#tcp_mem"><i>tcp_mem</i> (since
    Linux 2.4)</a></dt>
  <dd>This is a vector of 3 integers: [low, pressure, high]. These bounds,
      measured in units of the system page size, are used by TCP to track its
      memory usage. The defaults are calculated at boot time from the amount of
      available memory. (TCP can only use <i>low memory</i> for this, which is
      limited to around 900 megabytes on 32-bit systems. 64-bit systems do not
      suffer this limitation.)</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="low"><a class="permalink" href="#low"><i>low</i></a></dt>
  <dd>TCP doesn't regulate its memory allocation when the number of pages it has
      allocated globally is below this number.</dd>
  <dt id="pressure"><a class="permalink" href="#pressure"><i>pressure</i></a></dt>
  <dd>When the amount of memory allocated by TCP exceeds this number of pages,
      TCP moderates its memory consumption. This memory pressure state is exited
      once the number of pages allocated falls below the <i>low</i> mark.</dd>
  <dt id="high"><a class="permalink" href="#high"><i>high</i></a></dt>
  <dd>The maximum number of pages, globally, that TCP will allocate. This value
      overrides any other limits imposed by the kernel.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_mtu_probing"><a class="permalink" href="#tcp_mtu_probing"><i>tcp_mtu_probing</i>
    (integer; default: 0; since Linux 2.6.17)</a></dt>
  <dd>This parameter controls TCP Packetization-Layer Path MTU Discovery. The
      following values may be assigned to the file:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Disabled</dd>
  <dt><b>1</b></dt>
  <dd>Disabled by default, enabled when an ICMP black hole detected</dd>
  <dt><b>2</b></dt>
  <dd>Always enabled, use initial MSS of <i>tcp_base_mss</i>.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_no_metrics_save"><a class="permalink" href="#tcp_no_metrics_save"><i>tcp_no_metrics_save</i>
    (Boolean; default: disabled; since Linux 2.6.6)</a></dt>
  <dd>By default, TCP saves various connection metrics in the route cache when
      the connection closes, so that connections established in the near future
      can use these to set initial conditions. Usually, this increases overall
      performance, but it may sometimes cause performance degradation. If
      <i>tcp_no_metrics_save</i> is enabled, TCP will not cache metrics on
      closing connections.</dd>
  <dt id="tcp_orphan_retries"><a class="permalink" href="#tcp_orphan_retries"><i>tcp_orphan_retries</i>
    (integer; default: 8; since Linux 2.4)</a></dt>
  <dd>The maximum number of attempts made to probe the other end of a connection
      which has been closed by our end.</dd>
  <dt id="tcp_reordering"><a class="permalink" href="#tcp_reordering"><i>tcp_reordering</i>
    (integer; default: 3; since Linux 2.4)</a></dt>
  <dd>The maximum a packet can be reordered in a TCP packet stream without TCP
      assuming packet loss and going into slow start. It is not advisable to
      change this number. This is a packet reordering detection metric designed
      to minimize unnecessary back off and retransmits provoked by reordering of
      packets on a connection.</dd>
  <dt id="tcp_retrans_collapse"><a class="permalink" href="#tcp_retrans_collapse"><i>tcp_retrans_collapse</i>
    (Boolean; default: enabled; since Linux 2.2)</a></dt>
  <dd>Try to send full-sized packets during retransmit.</dd>
  <dt id="tcp_retries1"><a class="permalink" href="#tcp_retries1"><i>tcp_retries1</i>
    (integer; default: 3; since Linux 2.2)</a></dt>
  <dd>The number of times TCP will attempt to retransmit a packet on an
      established connection normally, without the extra effort of getting the
      network layers involved. Once we exceed this number of retransmits, we
      first have the network layer update the route if possible before each new
      retransmit. The default is the RFC specified minimum of 3.</dd>
  <dt id="tcp_retries2"><a class="permalink" href="#tcp_retries2"><i>tcp_retries2</i>
    (integer; default: 15; since Linux 2.2)</a></dt>
  <dd>The maximum number of times a TCP packet is retransmitted in established
      state before giving up. The default value is 15, which corresponds to a
      duration of approximately between 13 to 30 minutes, depending on the
      retransmission timeout. The RFC&nbsp;1122 specified minimum limit of 100
      seconds is typically deemed too short.</dd>
  <dt id="tcp_rfc1337"><a class="permalink" href="#tcp_rfc1337"><i>tcp_rfc1337</i>
    (Boolean; default: disabled; since Linux 2.2)</a></dt>
  <dd>Enable TCP behavior conformant with RFC&nbsp;1337. When disabled, if a
      RST is received in TIME_WAIT state, we close the socket immediately
      without waiting for the end of the TIME_WAIT period.</dd>
  <dt id="tcp_rmem"><a class="permalink" href="#tcp_rmem"><i>tcp_rmem</i> (since
    Linux 2.4)</a></dt>
  <dd>This is a vector of 3 integers: [min, default, max]. These parameters are
      used by TCP to regulate receive buffer sizes. TCP dynamically adjusts the
      size of the receive buffer from the defaults listed below, in the range of
      these values, depending on memory available in the system.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="min"><a class="permalink" href="#min"><i>min</i></a></dt>
  <dd>minimum size of the receive buffer used by each TCP socket. The default
      value is the system page size. (On Linux 2.4, the default value is
      4&nbsp;kB, lowered to <b>PAGE_SIZE</b> bytes in low-memory systems.)
      This value is used to ensure that in memory pressure mode, allocations
      below this size will still succeed. This is not used to bound the size of
      the receive buffer declared using <b>SO_RCVBUF</b> on a socket.</dd>
  <dt id="default"><a class="permalink" href="#default"><i>default</i></a></dt>
  <dd>the default size of the receive buffer for a TCP socket. This value
      overwrites the initial default buffer size from the generic global
      <i>net.core.rmem_default</i> defined for all protocols. The default value
      is 87380 bytes. (On Linux 2.4, this will be lowered to 43689 in low-memory
      systems.) If larger receive buffer sizes are desired, this value should be
      increased (to affect all sockets). To employ large TCP windows, the
      <i>net.ipv4.tcp_window_scaling</i> must be enabled (default).</dd>
  <dt id="max"><a class="permalink" href="#max"><i>max</i></a></dt>
  <dd>the maximum size of the receive buffer used by each TCP socket. This value
      does not override the global <i>net.core.rmem_max</i>. This is not used to
      limit the size of the receive buffer declared using <b>SO_RCVBUF</b> on a
      socket. The default value is calculated using the formula</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>max(87380, min(4&nbsp;MB, <i>tcp_mem</i>[1]*PAGE_SIZE/128))
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>(On Linux 2.4, the default is 87380*2 bytes, lowered to 87380 in
      low-memory systems).</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_sack"><a class="permalink" href="#tcp_sack"><i>tcp_sack</i>
    (Boolean; default: enabled; since Linux 2.2)</a></dt>
  <dd>Enable RFC&nbsp;2018 TCP Selective Acknowledgements.</dd>
  <dt id="tcp_slow_start_after_idle"><a class="permalink" href="#tcp_slow_start_after_idle"><i>tcp_slow_start_after_idle</i>
    (Boolean; default: enabled; since Linux 2.6.18)</a></dt>
  <dd>If enabled, provide RFC 2861 behavior and time out the congestion window
      after an idle period. An idle period is defined as the current RTO
      (retransmission timeout). If disabled, the congestion window will not be
      timed out after an idle period.</dd>
  <dt id="tcp_stdurg"><a class="permalink" href="#tcp_stdurg"><i>tcp_stdurg</i>
    (Boolean; default: disabled; since Linux 2.2)</a></dt>
  <dd>If this option is enabled, then use the RFC&nbsp;1122 interpretation of
      the TCP urgent-pointer field. According to this interpretation, the urgent
      pointer points to the last byte of urgent data. If this option is
      disabled, then use the BSD-compatible interpretation of the urgent
      pointer: the urgent pointer points to the first byte after the urgent
      data. Enabling this option may lead to interoperability problems.</dd>
  <dt id="tcp_syn_retries"><a class="permalink" href="#tcp_syn_retries"><i>tcp_syn_retries</i>
    (integer; default: 6; since Linux 2.2)</a></dt>
  <dd>The maximum number of times initial SYNs for an active TCP connection
      attempt will be retransmitted. This value should not be higher than 255.
      The default value is 6, which corresponds to retrying for up to
      approximately 127 seconds. Before Linux 3.7, the default value was 5,
      which (in conjunction with calculation based on other kernel parameters)
      corresponded to approximately 180 seconds.</dd>
  <dt id="tcp_synack_retries"><a class="permalink" href="#tcp_synack_retries"><i>tcp_synack_retries</i>
    (integer; default: 5; since Linux 2.2)</a></dt>
  <dd>The maximum number of times a SYN/ACK segment for a passive TCP connection
      will be retransmitted. This number should not be higher than 255.</dd>
  <dt id="tcp_syncookies"><a class="permalink" href="#tcp_syncookies"><i>tcp_syncookies</i>
    (integer; default: 1; since Linux 2.2)</a></dt>
  <dd>Enable TCP syncookies. The kernel must be compiled with
      <b>CONFIG_SYN_COOKIES</b>. The syncookies feature attempts to protect a
      socket from a SYN flood attack. This should be used as a last resort, if
      at all. This is a violation of the TCP protocol, and conflicts with other
      areas of TCP such as TCP extensions. It can cause problems for clients and
      relays. It is not recommended as a tuning mechanism for heavily loaded
      servers to help with overloaded or misconfigured conditions. For
      recommended alternatives see <i>tcp_max_syn_backlog</i>,
      <i>tcp_synack_retries</i>, and <i>tcp_abort_on_overflow</i>. Set to one of
      the following values:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Disable TCP syncookies.</dd>
  <dt><b>1</b></dt>
  <dd>Send out syncookies when the syn backlog queue of a socket overflows.</dd>
  <dt><b>2</b></dt>
  <dd>(since Linux 3.12) Send out syncookies unconditionally. This can be useful
      for network testing.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_timestamps"><a class="permalink" href="#tcp_timestamps"><i>tcp_timestamps</i>
    (integer; default: 1; since Linux 2.2)</a></dt>
  <dd>Set to one of the following values to enable or disable RFC&nbsp;1323
      TCP timestamps:</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt><b>0</b></dt>
  <dd>Disable timestamps.</dd>
  <dt><b>1</b></dt>
  <dd>Enable timestamps as defined in RFC1323 and use random offset for each
      connection rather than only using the current time.</dd>
  <dt><b>2</b></dt>
  <dd>As for the value 1, but without random offsets. Setting
      <i>tcp_timestamps</i> to this value is meaningful since Linux 4.10.</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_tso_win_divisor"><a class="permalink" href="#tcp_tso_win_divisor"><i>tcp_tso_win_divisor</i>
    (integer; default: 3; since Linux 2.6.9)</a></dt>
  <dd>This parameter controls what percentage of the congestion window can be
      consumed by a single TCP Segmentation Offload (TSO) frame. The setting of
      this parameter is a tradeoff between burstiness and building larger TSO
      frames.</dd>
  <dt id="tcp_tw_recycle"><a class="permalink" href="#tcp_tw_recycle"><i>tcp_tw_recycle</i>
    (Boolean; default: disabled; Linux 2.4 to Linux 4.11)</a></dt>
  <dd>Enable fast recycling of TIME_WAIT sockets. Enabling this option is not
      recommended as the remote IP may not use monotonically increasing
      timestamps (devices behind NAT, devices with per-connection timestamp
      offsets). See RFC 1323 (PAWS) and RFC 6191.</dd>
  <dt id="tcp_tw_reuse"><a class="permalink" href="#tcp_tw_reuse"><i>tcp_tw_reuse</i>
    (Boolean; default: disabled; since Linux 2.4.19/2.6)</a></dt>
  <dd>Allow to reuse TIME_WAIT sockets for new connections when it is safe from
      protocol viewpoint. It should not be changed without advice/request of
      technical experts.</dd>
  <dt id="tcp_vegas_cong_avoid"><a class="permalink" href="#tcp_vegas_cong_avoid"><i>tcp_vegas_cong_avoid</i>
    (Boolean; default: disabled; Linux 2.2 to Linux 2.6.13)</a></dt>
  <dd>Enable TCP Vegas congestion avoidance algorithm. TCP Vegas is a
      sender-side-only change to TCP that anticipates the onset of congestion by
      estimating the bandwidth. TCP Vegas adjusts the sending rate by modifying
      the congestion window. TCP Vegas should provide less packet loss, but it
      is not as aggressive as TCP Reno.</dd>
  <dt id="tcp_westwood"><a class="permalink" href="#tcp_westwood"><i>tcp_westwood</i>
    (Boolean; default: disabled; Linux 2.4.26/2.6.3 to Linux 2.6.13)</a></dt>
  <dd>Enable TCP Westwood+ congestion control algorithm. TCP Westwood+ is a
      sender-side-only modification of the TCP Reno protocol stack that
      optimizes the performance of TCP congestion control. It is based on
      end-to-end bandwidth estimation to set congestion window and slow start
      threshold after a congestion episode. Using this estimation, TCP Westwood+
      adaptively sets a slow start threshold and a congestion window which takes
      into account the bandwidth used at the time congestion is experienced. TCP
      Westwood+ significantly increases fairness with respect to TCP Reno in
      wired networks and throughput over wireless links.</dd>
  <dt id="tcp_window_scaling"><a class="permalink" href="#tcp_window_scaling"><i>tcp_window_scaling</i>
    (Boolean; default: enabled; since Linux 2.2)</a></dt>
  <dd>Enable RFC&nbsp;1323 TCP window scaling. This feature allows the use of
      a large window (&gt; 64&nbsp;kB) on a TCP connection, should the other
      end support it. Normally, the 16 bit window length field in the TCP header
      limits the window size to less than 64&nbsp;kB. If larger windows are
      desired, applications can increase the size of their socket buffers and
      the window scaling option will be employed. If <i>tcp_window_scaling</i>
      is disabled, TCP will not negotiate the use of window scaling with the
      other end during connection setup.</dd>
  <dt id="tcp_wmem"><a class="permalink" href="#tcp_wmem"><i>tcp_wmem</i> (since
    Linux 2.4)</a></dt>
  <dd>This is a vector of 3 integers: [min, default, max]. These parameters are
      used by TCP to regulate send buffer sizes. TCP dynamically adjusts the
      size of the send buffer from the default values listed below, in the range
      of these values, depending on memory available.</dd>
</dl>
<div class="Bd-indent">
<dl class="Bl-tag">
  <dt id="min~2"><a class="permalink" href="#min~2"><i>min</i></a></dt>
  <dd>Minimum size of the send buffer used by each TCP socket. The default value
      is the system page size. (On Linux 2.4, the default value is 4&nbsp;kB.)
      This value is used to ensure that in memory pressure mode, allocations
      below this size will still succeed. This is not used to bound the size of
      the send buffer declared using <b>SO_SNDBUF</b> on a socket.</dd>
  <dt id="default~2"><a class="permalink" href="#default~2"><i>default</i></a></dt>
  <dd>The default size of the send buffer for a TCP socket. This value
      overwrites the initial default buffer size from the generic global
      <i>/proc/sys/net/core/wmem_default</i> defined for all protocols. The
      default value is 16&nbsp;kB. If larger send buffer sizes are desired,
      this value should be increased (to affect all sockets). To employ large
      TCP windows, the <i>/proc/sys/net/ipv4/tcp_window_scaling</i> must be set
      to a nonzero value (default).</dd>
  <dt id="max~2"><a class="permalink" href="#max~2"><i>max</i></a></dt>
  <dd>The maximum size of the send buffer used by each TCP socket. This value
      does not override the value in <i>/proc/sys/net/core/wmem_max</i>. This is
      not used to limit the size of the send buffer declared using
      <b>SO_SNDBUF</b> on a socket. The default value is calculated using the
      formula</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>
    <br>
    <pre>max(65536, min(4&nbsp;MB, <i>tcp_mem</i>[1]*PAGE_SIZE/128))
    </pre>
    <br>
  </dd>
  <dt></dt>
  <dd>(On Linux 2.4, the default value is 128&nbsp;kB, lowered 64&nbsp;kB
      depending on low-memory systems.)</dd>
</dl>
</div>
<dl class="Bl-tag">
  <dt id="tcp_workaround_signed_windows"><a class="permalink" href="#tcp_workaround_signed_windows"><i>tcp_workaround_signed_windows</i>
    (Boolean; default: disabled; since Linux 2.6.26)</a></dt>
  <dd>If enabled, assume that no receipt of a window-scaling option means that
      the remote TCP is broken and treats the window as a signed quantity. If
      disabled, assume that the remote TCP is not broken even if we do not
      receive a window scaling option from it.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Socket_options"><a class="permalink" href="#Socket_options">Socket
  options</a></h2>
<p class="Pp">To set or get a TCP socket option, call <b>getsockopt</b>(2) to
    read or <b>setsockopt</b>(2) to write the option with the option level
    argument set to <b>IPPROTO_TCP</b>. Unless otherwise noted, <i>optval</i> is
    a pointer to an <i>int</i>. In addition, most <b>IPPROTO_IP</b> socket
    options are valid on TCP sockets. For more information see <b>ip</b>(7).</p>
<p class="Pp">Following is a list of TCP-specific socket options. For details of
    some other socket options that are also applicable for TCP sockets, see
    <b>socket</b>(7).</p>
<dl class="Bl-tag">
  <dt id="TCP_CONGESTION"><a class="permalink" href="#TCP_CONGESTION"><b>TCP_CONGESTION</b>
    (since Linux 2.6.13)</a></dt>
  <dd>The argument for this option is a string. This option allows the caller to
      set the TCP congestion control algorithm to be used, on a per-socket
      basis. Unprivileged processes are restricted to choosing one of the
      algorithms in <i>tcp_allowed_congestion_control</i> (described above).
      Privileged processes (<b>CAP_NET_ADMIN</b>) can choose from any of the
      available congestion-control algorithms (see the description of
      <i>tcp_available_congestion_control</i> above).</dd>
  <dt id="TCP_CORK"><a class="permalink" href="#TCP_CORK"><b>TCP_CORK</b> (since
    Linux 2.2)</a></dt>
  <dd>If set, don't send out partial frames. All queued partial frames are sent
      when the option is cleared again. This is useful for prepending headers
      before calling <b>sendfile</b>(2), or for throughput optimization. As
      currently implemented, there is a 200 millisecond ceiling on the time for
      which output is corked by <b>TCP_CORK</b>. If this ceiling is reached,
      then queued data is automatically transmitted. This option can be combined
      with <b>TCP_NODELAY</b> only since Linux 2.5.71. This option should not be
      used in code intended to be portable.</dd>
  <dt id="TCP_DEFER_ACCEPT"><a class="permalink" href="#TCP_DEFER_ACCEPT"><b>TCP_DEFER_ACCEPT</b>
    (since Linux 2.4)</a></dt>
  <dd>Allow a listener to be awakened only when data arrives on the socket.
      Takes an integer value (seconds), this can bound the maximum number of
      attempts TCP will make to complete the connection. This option should not
      be used in code intended to be portable.</dd>
  <dt id="TCP_INFO"><a class="permalink" href="#TCP_INFO"><b>TCP_INFO</b> (since
    Linux 2.4)</a></dt>
  <dd>Used to collect information about this socket. The kernel returns a
      <i>struct tcp_info</i> as defined in the file
      <i>/usr/include/linux/tcp.h</i>. This option should not be used in code
      intended to be portable.</dd>
  <dt id="TCP_KEEPCNT"><a class="permalink" href="#TCP_KEEPCNT"><b>TCP_KEEPCNT</b>
    (since Linux 2.4)</a></dt>
  <dd>The maximum number of keepalive probes TCP should send before dropping the
      connection. This option should not be used in code intended to be
      portable.</dd>
  <dt id="TCP_KEEPIDLE"><a class="permalink" href="#TCP_KEEPIDLE"><b>TCP_KEEPIDLE</b>
    (since Linux 2.4)</a></dt>
  <dd>The time (in seconds) the connection needs to remain idle before TCP
      starts sending keepalive probes, if the socket option <b>SO_KEEPALIVE</b>
      has been set on this socket. This option should not be used in code
      intended to be portable.</dd>
  <dt id="TCP_KEEPINTVL"><a class="permalink" href="#TCP_KEEPINTVL"><b>TCP_KEEPINTVL</b>
    (since Linux 2.4)</a></dt>
  <dd>The time (in seconds) between individual keepalive probes. This option
      should not be used in code intended to be portable.</dd>
  <dt id="TCP_LINGER2"><a class="permalink" href="#TCP_LINGER2"><b>TCP_LINGER2</b>
    (since Linux 2.4)</a></dt>
  <dd>The lifetime of orphaned FIN_WAIT2 state sockets. This option can be used
      to override the system-wide setting in the file
      <i>/proc/sys/net/ipv4/tcp_fin_timeout</i> for this socket. This is not to
      be confused with the <b>socket</b>(7) level option <b>SO_LINGER</b>. This
      option should not be used in code intended to be portable.</dd>
  <dt id="TCP_MAXSEG"><a class="permalink" href="#TCP_MAXSEG"><b>TCP_MAXSEG</b></a></dt>
  <dd>The maximum segment size for outgoing TCP packets. In Linux 2.2 and
      earlier, and in Linux 2.6.28 and later, if this option is set before
      connection establishment, it also changes the MSS value announced to the
      other end in the initial packet. Values greater than the (eventual)
      interface MTU have no effect. TCP will also impose its minimum and maximum
      bounds over the value provided.</dd>
  <dt id="TCP_NODELAY"><a class="permalink" href="#TCP_NODELAY"><b>TCP_NODELAY</b></a></dt>
  <dd>If set, disable the Nagle algorithm. This means that segments are always
      sent as soon as possible, even if there is only a small amount of data.
      When not set, data is buffered until there is a sufficient amount to send
      out, thereby avoiding the frequent sending of small packets, which results
      in poor utilization of the network. This option is overridden by
      <b>TCP_CORK</b>; however, setting this option forces an explicit flush of
      pending output, even if <b>TCP_CORK</b> is currently set.</dd>
  <dt id="TCP_QUICKACK"><a class="permalink" href="#TCP_QUICKACK"><b>TCP_QUICKACK</b>
    (since Linux 2.4.4)</a></dt>
  <dd>Enable quickack mode if set or disable quickack mode if cleared. In
      quickack mode, acks are sent immediately, rather than delayed if needed in
      accordance to normal TCP operation. This flag is not permanent, it only
      enables a switch to or from quickack mode. Subsequent operation of the TCP
      protocol will once again enter/leave quickack mode depending on internal
      protocol processing and factors such as delayed ack timeouts occurring and
      data transfer. This option should not be used in code intended to be
      portable.</dd>
  <dt id="TCP_SYNCNT"><a class="permalink" href="#TCP_SYNCNT"><b>TCP_SYNCNT</b>
    (since Linux 2.4)</a></dt>
  <dd>Set the number of SYN retransmits that TCP should send before aborting the
      attempt to connect. It cannot exceed 255. This option should not be used
      in code intended to be portable.</dd>
  <dt id="TCP_USER_TIMEOUT"><a class="permalink" href="#TCP_USER_TIMEOUT"><b>TCP_USER_TIMEOUT</b>
    (since Linux 2.6.37)</a></dt>
  <dd>This option takes an <i>unsigned int</i> as an argument. When the value is
      greater than 0, it specifies the maximum amount of time in milliseconds
      that transmitted data may remain unacknowledged, or buffered data may
      remain untransmitted (due to zero window size) before TCP will forcibly
      close the corresponding connection and return <b>ETIMEDOUT</b> to the
      application. If the option value is specified as 0, TCP will use the
      system default.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>Increasing user timeouts allows a TCP connection to survive extended
      periods without end-to-end connectivity. Decreasing user timeouts allows
      applications to "fail fast", if so desired. Otherwise, failure
      may take up to 20 minutes with the current system defaults in a normal WAN
      environment.</dd>
  <dt></dt>
  <dd>This option can be set during any state of a TCP connection, but is
      effective only during the synchronized states of a connection
      (ESTABLISHED, FIN-WAIT-1, FIN-WAIT-2, CLOSE-WAIT, CLOSING, and LAST-ACK).
      Moreover, when used with the TCP keepalive (<b>SO_KEEPALIVE</b>) option,
      <b>TCP_USER_TIMEOUT</b> will override keepalive to determine when to close
      a connection due to keepalive failure.</dd>
  <dt></dt>
  <dd>The option has no effect on when TCP retransmits a packet, nor when a
      keepalive probe is sent.</dd>
  <dt></dt>
  <dd>This option, like many others, will be inherited by the socket returned by
      <b>accept</b>(2), if it was set on the listening socket.</dd>
  <dt></dt>
  <dd>Further details on the user timeout feature can be found in RFC&nbsp;793
      and RFC&nbsp;5482 ("TCP User Timeout Option").</dd>
</dl>
<dl class="Bl-tag">
  <dt id="TCP_WINDOW_CLAMP"><a class="permalink" href="#TCP_WINDOW_CLAMP"><b>TCP_WINDOW_CLAMP</b>
    (since Linux 2.4)</a></dt>
  <dd>Bound the size of the advertised window to this value. The kernel imposes
      a minimum size of SOCK_MIN_RCVBUF/2. This option should not be used in
      code intended to be portable.</dd>
  <dt id="TCP_FASTOPEN"><a class="permalink" href="#TCP_FASTOPEN"><b>TCP_FASTOPEN</b>
    (since Linux 3.6)</a></dt>
  <dd>This option enables Fast Open (RFC&nbsp;7413) on the listener socket.
      The value specifies the maximum length of pending SYNs (similar to the
      backlog argument in <b>listen</b>(2)). Once enabled, the listener socket
      grants the TCP Fast Open cookie on incoming SYN with TCP Fast Open
    option.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>More importantly it accepts the data in SYN with a valid Fast Open cookie
      and responds SYN-ACK acknowledging both the data and the SYN sequence.
      <b>accept</b>(2) returns a socket that is available for read and write
      when the handshake has not completed yet. Thus the data exchange can
      commence before the handshake completes. This option requires enabling the
      server-side support on sysctl <i>net.ipv4.tcp_fastopen</i> (see above).
      For TCP Fast Open client-side support, see <b>send</b>(2)
      <b>MSG_FASTOPEN</b> or <b>TCP_FASTOPEN_CONNECT</b> below.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="TCP_FASTOPEN_CONNECT"><a class="permalink" href="#TCP_FASTOPEN_CONNECT"><b>TCP_FASTOPEN_CONNECT</b>
    (since Linux 4.11)</a></dt>
  <dd>This option enables an alternative way to perform Fast Open on the active
      side (client). When this option is enabled, <b>connect</b>(2) would behave
      differently depending on if a Fast Open cookie is available for the
      destination.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If a cookie is not available (i.e. first contact to the destination),
      <b>connect</b>(2) behaves as usual by sending a SYN immediately, except
      the SYN would include an empty Fast Open cookie option to solicit a
      cookie.</dd>
  <dt></dt>
  <dd>If a cookie is available, <b>connect</b>(2) would return 0 immediately but
      the SYN transmission is deferred. A subsequent <b>write</b>(2) or
      <b>sendmsg</b>(2) would trigger a SYN with data plus cookie in the Fast
      Open option. In other words, the actual connect operation is deferred
      until data is supplied.</dd>
  <dt></dt>
  <dd><b>Note:</b> While this option is designed for convenience, enabling it
      does change the behaviors and certain system calls might set different
      <i>errno</i> values. With cookie present, <b>write</b>(2) or
      <b>sendmsg</b>(2) must be called right after <b>connect</b>(2) in order to
      send out SYN+data to complete 3WHS and establish connection. Calling
      <b>read</b>(2) right after <b>connect</b>(2) without <b>write</b>(2) will
      cause the blocking socket to be blocked forever.</dd>
  <dt></dt>
  <dd>The application should either set <b>TCP_FASTOPEN_CONNECT</b> socket
      option before <b>write</b>(2) or <b>sendmsg</b>(2), or call
      <b>write</b>(2) or <b>sendmsg</b>(2) with <b>MSG_FASTOPEN</b> flag
      directly, instead of both on the same connection.</dd>
  <dt></dt>
  <dd>Here is the typical call flow with this new option:</dd>
  <dt></dt>
  <dd>
    <br>
    <pre>s = socket();
setsockopt(s, IPPROTO_TCP, TCP_FASTOPEN_CONNECT, 1, ...);
connect(s);
write(s); /* write() should always follow connect()
<br>
           * in order to trigger SYN to go out. */
read(s)/write(s);
/* ... */
close(s);
    </pre>
    <br>
  </dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Sockets_API"><a class="permalink" href="#Sockets_API">Sockets
  API</a></h2>
<p class="Pp">TCP provides limited support for out-of-band data, in the form of
    (a single byte of) urgent data. In Linux this means if the other end sends
    newer out-of-band data the older urgent data is inserted as normal data into
    the stream (even when <b>SO_OOBINLINE</b> is not set). This differs from
    BSD-based stacks.</p>
<p class="Pp">Linux uses the BSD compatible interpretation of the urgent pointer
    field by default. This violates RFC&nbsp;1122, but is required for
    interoperability with other stacks. It can be changed via
    <i>/proc/sys/net/ipv4/tcp_stdurg</i>.</p>
<p class="Pp">It is possible to peek at out-of-band data using the
    <b>recv</b>(2) <b>MSG_PEEK</b> flag.</p>
<p class="Pp">Since Linux 2.4, Linux supports the use of <b>MSG_TRUNC</b> in the
    <i>flags</i> argument of <b>recv</b>(2) (and <b>recvmsg</b>(2)). This flag
    causes the received bytes of data to be discarded, rather than passed back
    in a caller-supplied buffer. Since Linux 2.4.4, <b>MSG_TRUNC</b> also has
    this effect when used in conjunction with <b>MSG_OOB</b> to receive
    out-of-band data.</p>
</section>
<section class="Ss">
<h2 class="Ss" id="Ioctls"><a class="permalink" href="#Ioctls">Ioctls</a></h2>
<p class="Pp">The following <b>ioctl</b>(2) calls return information in
    <i>value</i>. The correct syntax is:</p>
<p class="Pp"></p>
<div class="Bd-indent">
<pre><b>int</b><i> value</i><b>;</b>
<i>error</i><b> = ioctl(</b><i>tcp_socket</i><b>, </b><i>ioctl_type</i><b>, &amp;</b><i>value</i><b>);</b></pre>
</div>
<p class="Pp"><i>ioctl_type</i> is one of the following:</p>
<dl class="Bl-tag">
  <dt id="SIOCINQ"><a class="permalink" href="#SIOCINQ"><b>SIOCINQ</b></a></dt>
  <dd>Returns the amount of queued unread data in the receive buffer. The socket
      must not be in LISTEN state, otherwise an error (<b>EINVAL</b>) is
      returned. <b>SIOCINQ</b> is defined in <i>&lt;linux/sockios.h&gt;</i>.
      Alternatively, you can use the synonymous <b>FIONREAD</b>, defined in
      <i>&lt;sys/ioctl.h&gt;</i>.</dd>
  <dt id="SIOCATMARK"><a class="permalink" href="#SIOCATMARK"><b>SIOCATMARK</b></a></dt>
  <dd>Returns true (i.e., <i>value</i> is nonzero) if the inbound data stream is
      at the urgent mark.</dd>
</dl>
<dl class="Bl-tag">
  <dt></dt>
  <dd>If the <b>SO_OOBINLINE</b> socket option is set, and <b>SIOCATMARK</b>
      returns true, then the next read from the socket will return the urgent
      data. If the <b>SO_OOBINLINE</b> socket option is not set, and
      <b>SIOCATMARK</b> returns true, then the next read from the socket will
      return the bytes following the urgent data (to actually read the urgent
      data requires the <b>recv(MSG_OOB)</b> flag).</dd>
  <dt></dt>
  <dd>Note that a read never reads across the urgent mark. If an application is
      informed of the presence of urgent data via <b>select</b>(2) (using the
      <i>exceptfds</i> argument) or through delivery of a <b>SIGURG</b> signal,
      then it can advance up to the mark using a loop which repeatedly tests
      <b>SIOCATMARK</b> and performs a read (requesting any number of bytes) as
      long as <b>SIOCATMARK</b> returns false.</dd>
</dl>
<dl class="Bl-tag">
  <dt id="SIOCOUTQ"><a class="permalink" href="#SIOCOUTQ"><b>SIOCOUTQ</b></a></dt>
  <dd>Returns the amount of unsent data in the socket send queue. The socket
      must not be in LISTEN state, otherwise an error (<b>EINVAL</b>) is
      returned. <b>SIOCOUTQ</b> is defined in <i>&lt;linux/sockios.h&gt;</i>.
      Alternatively, you can use the synonymous <b>TIOCOUTQ</b>, defined in
      <i>&lt;sys/ioctl.h&gt;</i>.</dd>
</dl>
</section>
<section class="Ss">
<h2 class="Ss" id="Error_handling"><a class="permalink" href="#Error_handling">Error
  handling</a></h2>
<p class="Pp">When a network error occurs, TCP tries to resend the packet. If it
    doesn't succeed after some time, either <b>ETIMEDOUT</b> or the last
    received error on this connection is reported.</p>
<p class="Pp">Some applications require a quicker error notification. This can
    be enabled with the <b>IPPROTO_IP</b> level <b>IP_RECVERR</b> socket option.
    When this option is enabled, all incoming errors are immediately passed to
    the user program. Use this option with care  it makes TCP less
    tolerant to routing changes and other normal network conditions.</p>
</section>
</section>
<section class="Sh">
<h1 class="Sh" id="ERRORS"><a class="permalink" href="#ERRORS">ERRORS</a></h1>
<dl class="Bl-tag">
  <dt id="EAFNOTSUPPORT"><a class="permalink" href="#EAFNOTSUPPORT"><b>EAFNOTSUPPORT</b></a></dt>
  <dd>Passed socket address type in <i>sin_family</i> was not
    <b>AF_INET</b>.</dd>
  <dt id="EPIPE"><a class="permalink" href="#EPIPE"><b>EPIPE</b></a></dt>
  <dd>The other end closed the socket unexpectedly or a read is executed on a
      shut down socket.</dd>
  <dt id="ETIMEDOUT"><a class="permalink" href="#ETIMEDOUT"><b>ETIMEDOUT</b></a></dt>
  <dd>The other end didn't acknowledge retransmitted data after some time.</dd>
</dl>
<p class="Pp">Any errors defined for <b>ip</b>(7) or the generic socket layer
    may also be returned for TCP.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="VERSIONS"><a class="permalink" href="#VERSIONS">VERSIONS</a></h1>
<p class="Pp">Support for Explicit Congestion Notification, zero-copy
    <b>sendfile</b>(2), reordering support and some SACK extensions (DSACK) were
    introduced in Linux 2.4. Support for forward acknowledgement (FACK),
    TIME_WAIT recycling, and per-connection keepalive socket options were
    introduced in Linux 2.3.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="BUGS"><a class="permalink" href="#BUGS">BUGS</a></h1>
<p class="Pp">Not all errors are documented.</p>
<p class="Pp">IPv6 is not described.</p>
</section>
<section class="Sh">
<h1 class="Sh" id="SEE_ALSO"><a class="permalink" href="#SEE_ALSO">SEE
  ALSO</a></h1>
<p class="Pp"><b>accept</b>(2), <b>bind</b>(2), <b>connect</b>(2),
    <b>getsockopt</b>(2), <b>listen</b>(2), <b>recvmsg</b>(2),
    <b>sendfile</b>(2), <b>sendmsg</b>(2), <b>socket</b>(2), <b>ip</b>(7),
    <b>socket</b>(7)</p>
<p class="Pp">The kernel source file
    <i>Documentation/networking/ip-sysctl.txt</i>.</p>
<p class="Pp">RFC&nbsp;793 for the TCP specification.
  <br>
  RFC&nbsp;1122 for the TCP requirements and a description of the Nagle
    algorithm.
  <br>
  RFC&nbsp;1323 for TCP timestamp and window scaling options.
  <br>
  RFC&nbsp;1337 for a description of TIME_WAIT assassination hazards.
  <br>
  RFC&nbsp;3168 for a description of Explicit Congestion Notification.
  <br>
  RFC&nbsp;2581 for TCP congestion control algorithms.
  <br>
  RFC&nbsp;2018 and RFC&nbsp;2883 for SACK and extensions to SACK.</p>
</section>
</div>
<table class="foot">
  <tbody><tr>
    <td class="foot-date">(date)</td>
    <td class="foot-os">Linux man-pages (unreleased)</td>
  </tr>
</tbody></table>
</div>


<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>