<!DOCTYPE html><html class="translated-ltr" style=""><!--
 Page saved with SingleFile 
 url: http://lamport.azurewebsites.net/pubs/pubs.html?from=https://research.microsoft.com/users/lamport/pubs/pubs.html&type=path#do-loops 
 saved date: Wed Jul 12 2023 16:30:19 GMT+0800 (Hong Kong Standard Time)
--><head>
<meta name="dc.identifier" content="res/3e3fcea2ca645dfb54901e256f38de95ab94f9bd">
<meta charset="utf-8">
 <style type="text/css"></style><style type="text/css"></style><style type="text/css">:root{--color-yellow:#FFD76F;--color-green:#34FFB6;--color-black:rgba(0,0,0,0.9);--color-border:rgba(255,255,255,0.1);--color-icon:rgba(255,255,255,0.6);--color-icon-hover:rgba(255,255,255,0.8);--color-text-gray:rgba(255,255,255,0.6);--color-placeholder:rgba(255,255,255,0.6);--color-light-hover:rgba(255,255,255,0.1)}</style><style type="text/css"></style><style type="text/css"></style><style type="text/css">@keyframes fadeindown{from{opacity:0;transform:translateY(-60px)}to{opacity:1;transform:translateY(0)}}@keyframes fadeoutup{from{opacity:1;transform:translateY(0)}to{opacity:0;transform:translateY(-60px)}}</style><style>@keyframes fadeindown{from{opacity:0;transform:translateY(-60px)}to{opacity:1;transform:translateY(0)}}</style><style></style><style></style><style>@-webkit-keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@keyframes spinner-rotator{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(270deg);transform:rotate(270deg)}}@-webkit-keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}@keyframes spinner-dash{0%{stroke-dashoffset:187}50%{stroke-dashoffset:46.75;-webkit-transform:rotate(135deg);transform:rotate(135deg)}100%{stroke-dashoffset:187;-webkit-transform:rotate(450deg);transform:rotate(450deg)}}.VIpgJd-yAWNEb-L7lbkb div,.VIpgJd-yAWNEb-L7lbkb span,.VIpgJd-yAWNEb-L7lbkb iframe,.VIpgJd-yAWNEb-L7lbkb img,.VIpgJd-yAWNEb-L7lbkb form{margin:0;padding:0;border:0;font:inherit;font-size:100%;vertical-align:baseline;text-align:left;line-height:normal}.VIpgJd-yAWNEb-L7lbkb{color:#222;background-color:#fff;border:1px solid #eee;box-shadow:0 4px 16px rgba(0,0,0,.2);-moz-box-shadow:0 4px 16px rgba(0,0,0,.2);-webkit-box-shadow:0 4px 16px rgba(0,0,0,.2);display:none;font-size:10pt;width:420px;position:absolute;z-index:10000}.VIpgJd-yAWNEb-L7lbkb .VIpgJd-yAWNEb-nVMfcd-fmcmS{clear:both;position:relative}.VIpgJd-yAWNEb-L7lbkb span:focus{outline:none}.VIpgJd-yAWNEb-hvhgNd{font-family:"Google Sans",Arial,sans-serif}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-l4eHX-i3jM8c{position:absolute;top:10px;left:14px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-k77Iif-i3jM8c{margin:16px;padding:0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-IuizWc{margin:0 0 0 36px;padding:0;color:#747775;font-size:14px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-axAV1{width:auto;padding:12px 0 0;color:#1f1f1f;font-size:16px;text-align:initial}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid{border-radius:0 0 12px 12px;margin:0;background:#f1f4f9;position:relative;min-height:50px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-N7Eqid-B7I4Od{display:inline-block;width:77%;padding:12px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-UTujCb{color:#1f1f1f;font-size:12px;font-weight:500}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-eO9mKe{color:#444746;font-size:12px;padding-top:4px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-xgov5{position:absolute;top:10px;right:5px}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-THI6Vb{fill:#0b57d0}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf{margin:-4px 2px 0 0;padding:2px 0 0;width:48px;height:48px;border:none;border-radius:24px;cursor:pointer;background:none}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-bgm6sf:hover{background:#e8ebec}.VIpgJd-yAWNEb-hvhgNd .VIpgJd-yAWNEb-hvhgNd-aXYTce{display:none}</style><title>莱斯利·兰波特的著作</title><link rel="canonical" href="http://lamport.azurewebsites.net/pubs/pubs.html?from=https://research.microsoft.com/users/lamport/pubs/pubs.html&amp;type=path#do-loops"><style>img[src="data:,"],source[src="data:,"]{display:none!important}</style><link id="res-style" rel="stylesheet" href="/res/dist/res/style.css" type="text/css">
</head>

<body style="max-width:700px;padding:10px;background-color:#fffff0">

<div id="book-container">

  <h1><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的著作</font></font></h1><h1>My Writings </h1> 
  <h2><font style="vertical-align:inherit"><font style="vertical-align:inherit">莱斯利·兰波特</font></font></h2><h2>Leslie Lamport</h2>
  <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">最后修改时间：2023 年 1 月 10 日</font></font></i>


<p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这份文件是一种科学自传。</font><font style="vertical-align:inherit">它不仅列出了我写过的论文，还描述了它们并解释了我是如何写其中一些论文的。</font><font style="vertical-align:inherit">我已经收录了几乎所有的技术论文以及其中许多的电子版本以供下载。</font><font style="vertical-align:inherit">省略了一些我不再拥有副本和不完整的论文。</font><font style="vertical-align:inherit">我还省略了其中一些论文的早期版本——即使标题发生了变化。</font><font style="vertical-align:inherit">其中包括一些我在修复其中的错误或其他问题之前放弃的论文初稿。</font><font style="vertical-align:inherit">描述之前有一个目录。</font><font style="vertical-align:inherit">我还附上了一份简短的
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">简历</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><a href="http://lamport.azurewebsites.net/pubs/pubs.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文档的可打印版本以pdf 文件</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">形式提供</font><font style="vertical-align:inherit">。&nbsp;

</font></font></p><p>This document is a sort of scientific
autobiography.&nbsp; It not only lists the papers I have written, but also
describes them and explains how I came to write some of them.&nbsp; I have
included almost all my technical papers and electronic versions
of many of them for downloading.&nbsp; Omitted are some papers for which I
no longer have copies and papers that are incomplete.&nbsp; I have also
omitted early versions of some of these papers--even in cases where
the title changed.&nbsp; Included are some initial drafts of papers that I
abandoned before fixing errors or other problems in them.&nbsp; A table of
contents precedes the descriptions.&nbsp; I also include a brief
<i>curriculum vitae</i>.&nbsp; A printable version of this document
is available as a <a href="http://lamport.azurewebsites.net/pubs/pubs.pdf">pdf file</a>.&nbsp;

</p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">每个描述都试图解释作品的起源。</font><font style="vertical-align:inherit">然而，我已经忘记了我是如何写出大部分论文的。</font><font style="vertical-align:inherit">即使当我详细讨论这些想法的发展时，我也只是基于我不可靠的记忆给出了主观观点。</font><font style="vertical-align:inherit">只要有可能，我都会要求其他相关人员检查我所写内容的准确性。</font><font style="vertical-align:inherit">然而，我最常忘记的是影响我自己工作的其他人的工作。</font><font style="vertical-align:inherit">这可能会给人一种印象，即我对想法的认可超过了我应得的，对此我深表歉意。&nbsp;

</font></font></p><p> Each description attempts to explain the genesis of the
work.&nbsp; However, I have forgotten how I came to write most of my
papers.&nbsp; Even when I discourse at length about the development of the
ideas, I am giving only a subjective view based on my unreliable
memory.&nbsp; Whenever possible, I have asked other people involved to
check the accuracy of what I've written.&nbsp; However, what I have most
often forgotten is the work of others that influenced my own work.&nbsp;
This may give the impression that I am claiming more credit for ideas
than I deserve, for which I apologize.&nbsp;

</p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
在我认为有趣的地方，我会给出一篇论文发表或不发表背后的故事。</font><font style="vertical-align:inherit">有些故事读起来像是对编辑或审稿人不公平待遇的抱怨。</font><font style="vertical-align:inherit">任何基于人类判断的活动都必然会出现此类情况。</font><font style="vertical-align:inherit">总的来说，我的论文发表没有遇到什么困难。</font><font style="vertical-align:inherit">事实上，我受益于编辑和审稿人对知名科学家的工作不那么挑剔的自然倾向。</font><font style="vertical-align:inherit">但我认为值得一提的是系统无法正常工作的情况。&nbsp;

</font></font></p><p> 
Where I think it's interesting, I give the story behind the
publication or non-publication of a paper.&nbsp; Some of the stories read
like complaints of unfair treatment by editors or referees.&nbsp; Such
cases are bound to arise in any activity based on human judgment.&nbsp; On
the whole, I have had little trouble getting my papers published.&nbsp; In
fact, I have profited from the natural tendency of editors and
referees to be less critical of the work of established scientists.&nbsp;
But I think it's worth mentioning the cases where the system didn't
work as it should.&nbsp;

</p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我希望在论文撰写日期之前订购它们。</font><font style="vertical-align:inherit">然而，我通常没有记录我什么时候真正写过东西。</font><font style="vertical-align:inherit">因此，我按照出版日期订购它们，对于未出版的作品，按照我拥有的版本的日期订购。</font><font style="vertical-align:inherit">由于发布延迟时间较长且变化无常，这意味着该顺序仅大致按时间顺序排列。&nbsp;

</font></font></p><p>
I would like to have ordered my papers by the date they were written.&nbsp;
However, I usually have no record of when I actually wrote something.&nbsp;
So, I have ordered them by date of publication or, for unpublished
works, by the date of the version that I have.&nbsp; Because of long and
variable publication delays, this means that the order is only
approximately chronological.&nbsp;

</p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
只要有可能，我都会收录作品的电子版本。</font><font style="vertical-align:inherit">我有大约 1985 年之后写的大多数作品的电子版本。对于期刊文章，这些可能是“预印本”版本，格式不同，有时与已发表的版本略有不同。</font><font style="vertical-align:inherit">我一直在扫描没有源文件的论文，因为我找到了它们的副本。&nbsp;

</font></font></p><p>
Whenever possible, 
 I have included
electronic versions of the works.&nbsp; I have electronic versions of most
works written after about 1985.&nbsp; For journal articles, these may be
"preprint" versions, formatted differently and sometimes differing
slightly from the published versions.&nbsp; I have been scanning papers for
which I don't have source files as I find copies of them.&nbsp;

</p><hr><h3><font style="vertical-align:inherit"><font style="vertical-align:inherit">教育</font></font></h3><h3>Education</h3><ul>
<li><font style="vertical-align:inherit"><font style="vertical-align:inherit">BS——麻省理工学院，1960 年。（数学） 
</font></font></li><li> B.S. -- M.I.T., 1960. (Mathematics) 
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">文学硕士——布兰迪斯大学，1963 年。（数学） 
</font></font></li><li> M.A. -- Brandeis University, 1963. (Mathematics) 
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">博士 </font><font style="vertical-align:inherit">——布兰迪斯大学，1972 年。（数学）
</font></font></li><li> Ph.D. -- Brandeis University, 1972. (Mathematics)
</li></ul>

<h3><font style="vertical-align:inherit"><font style="vertical-align:inherit">就业</font></font></h3><h3>Employment</h3><ul>
<li><font style="vertical-align:inherit"><font style="vertical-align:inherit">Mitre Corporation（兼职，1962-1965）
</font></font></li><li> Mitre Corporation (part-time, 1962-1965)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">万宝路学院 (1965-1969)
</font></font></li><li> Marlboro College (1965-1969)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">马萨诸塞州计算机协会 (1970-1977)
</font></font></li><li> Massachusetts Computer Associates (1970-1977)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRI 国际 (1977-1985)
</font></font></li><li> SRI International (1977-1985)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">数字设备公司/康柏 (1985-2001)
</font></font></li><li> Digital Equipment Corporation / Compaq (1985-2001)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">微软研究院（2001 年至今）
</font></font></li><li> Microsoft Research (2001-present)
</li></ul>

<h3><font style="vertical-align:inherit"><font style="vertical-align:inherit">荣誉资质</font></font></h3><h3>Honors</h3><ul>
<li><font style="vertical-align:inherit"><font style="vertical-align:inherit">美国国家工程院院士 (1991)
</font></font></li><li> National Academy of Engineering (1991)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">PODC影响力论文奖（2000年）（论文</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> PODC Influential Paper Award (2000) 
                    (for paper <a href="#time-clocks">[27]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">雷恩大学荣誉博士学位 (2003)
</font></font></li><li> Honorary Doctorate, University of Rennes (2003)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">基尔基督教阿尔布雷希茨大学荣誉博士学位（2003 年）
</font></font></li><li> Honorary Doctorate, Christian Albrechts University,
                  Kiel (2003)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">洛桑联邦理工学院荣誉博士学位（2004年）
</font></font></li><li> Honorary Doctorate, Ecole Polytechnique
                  Fédérale de Lausanne (2004)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE Piore 奖 (2004) 
</font></font></li><li> IEEE Piore Award (2004) 
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">Edsger W. Dijkstra 分布式计算奖 (2005)（论文</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> Edsger W. Dijkstra Prize in Distributed Computing (2005)
                    (for paper <a href="#reaching">[41]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">意大利卢加诺大学荣誉博士学位（2006 年）
</font></font></li><li> Honorary Doctorate, Università della Svizzera Italiana,
Lugano (2006)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGOPS 名人堂奖 (2007)（论文</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> ACM SIGOPS Hall of Fame Award (2007) 
                     (for paper <a href="#time-clocks">[27]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">南锡亨利庞加莱大学荣誉博士学位（2007 年）
</font></font></li><li> Honorary Doctorate, 
                  Université 
                    Henri Poincaré, Nancy (2007)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">LICS 1988 Test of Time 奖 (2008)（论文</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> LICS 1988 Test of Time Award (2008) 
                     (for paper <a href="#abadi-existence">[92]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE 约翰·​​冯·诺依曼奖章 (2008) 
</font></font></li><li> IEEE John von Neumann Medal (2008) 
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">美国国家科学院院士 (2011) 
</font></font></li><li> National Academy of Sciences (2011) 
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGOPS 名人堂奖 (2012)（论文</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> ACM SIGOPS Hall of Fame Award (2012) 
                     (for paper <a href="#lamport-paxos">[123]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">Jean-Claude Laprie 可靠计算奖 (2013)（论文</font></font><a href="#byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[46]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> Jean-Claude Laprie Award in Dependable Computing (2013) 
                     (for paper <a href="#byz">[46]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGOPS 名人堂奖 (2013)（论文</font></font><a href="#chandy"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[66]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）

</font></font></li><li> ACM SIGOPS Hall of Fame Award (2013) 
                     (for paper <a href="#chandy">[66]</a>)

</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">2013 ACM 图灵奖 (2014) 

</font></font></li><li> 2013 ACM Turing Award (2014) 

</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">美国艺术与科学学院 (2014) 

</font></font></li><li> American Academy of Arts and Sciences (2014) 

</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">Jean-Claude Laprie 可靠计算奖 (2014)（论文</font></font><a href="#sift"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[30]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）

</font></font></li><li> Jean-Claude Laprie Award in Dependable Computing (2014) 
                     (for paper <a href="#sift">[30]</a>)

</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">Edsger W. Dijkstra 分布式计算奖 (2014)（论文</font></font><a href="#chandy"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[66]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
</font></font></li><li> Edsger W. Dijkstra Prize in Distributed Computing (2014)
                    (for paper <a href="#chandy">[66]</a>)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">布兰迪斯大学荣誉博士学位（2017）
</font></font></li><li> Honorary Doctorate, Brandeis University (2017)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机历史博物馆研究员 (2019)
</font></font></li><li> Fellow of the Computer History Museum (2019)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">NEC C&amp;C 奖 (2019)
</font></font></li><li> NEC C&amp;C Prize (2019)
</li><li><font style="vertical-align:inherit"><font style="vertical-align:inherit">NSA 年度最佳科学网络安全论文竞赛奖（2022）（论文</font></font><a href="#hyper2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[191]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）
                    
</font></font></li><li> NSA Annual Best Scientific Cybersecurity Paper Competition
award (2022) (for paper <a href="#hyper2">[191]</a>)
                    
</li></ul>





<hr><small></small><p><small><a name="endofpage"><font style="vertical-align:inherit"><font style="vertical-align:inherit">当我创建这个网页时，搜索引擎还不是很好，破坏者还没有入侵网络。</font><font style="vertical-align:inherit">我将搜索字符串
  </font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">alllamportspubsontheweb</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">放在
这里是为了使该页面易于查找，并且我要求人们不要将该字符串放在 Web 上。</font><font style="vertical-align:inherit">搜索引擎现在变得更好，破坏者已经将字符串放在其他网页上。</font><font style="vertical-align:inherit">这些天来，寻找</font></font><q><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的著作</font></font></q><font style="vertical-align:inherit"><font style="vertical-align:inherit">效果很好。</font></font></a></small><a name="endofpage"> 

</a></p><p><small><a name="endofpage">When I created this Web page,
search engines weren't very good and vandals had not yet invaded
the Web.&nbsp;  I put the search string
  <tt>alllamportspubsontheweb</tt>
here to make this page easy to find, and I asked people not to put
that string on the Web.&nbsp; Search engines are now better and
vandals have put the string on other Web pages.&nbsp; These
days, searching for <q>lamport my writings</q> works fine.</a></small><a name="endofpage"> 

</a></p><p></p><hr><h2><a name="endofpage"><font style="vertical-align:inherit"><font style="vertical-align:inherit">内容</font></font></a></h2><h2><a name="endofpage">Contents</a></h2><a name="endofpage"> </a><ol><a name="endofpage">
</a><a href="#bxscience"></a><li><a href="#bxscience"><font style="vertical-align:inherit"><font style="vertical-align:inherit">辫子理论</font></font></a>
<a href="#summer-vision"></a></li><li><a href="#bxscience">Braid Theory</a>
<a href="#summer-vision"></a></li><li><a href="#summer-vision"><font style="vertical-align:inherit"><font style="vertical-align:inherit">暑期视力计划</font></font></a>
<a href="#monitor1"></a></li><li><a href="#summer-vision">Summer Vision Programs</a>
<a href="#monitor1"></a></li><li><a href="#monitor1"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Monitor 1 初步用户指南</font></font></a>
<a href="#advanced-calculus"></a></li><li><a href="#monitor1">Preliminary User's Guide to
Monitor&nbsp;1</a>
<a href="#advanced-calculus"></a></li><li><a href="#advanced-calculus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">高级微积分文本无标题草稿</font></font></a>
<a href="#geometry-of-space-time"></a></li><li><a href="#advanced-calculus">Untitled Draft of Advanced 
    Calculus Text</a>
<a href="#geometry-of-space-time"></a></li><li><a href="#geometry-of-space-time"><font style="vertical-align:inherit"><font style="vertical-align:inherit">空间和时间的几何</font></font></a>
<a href="#hash"></a></li><li><a href="#geometry-of-space-time">The Geometry of Space and Time</a>
<a href="#hash"></a></li><li><a href="#hash"><font style="vertical-align:inherit"><font style="vertical-align:inherit">评贝尔的二次商算法</font></font></a>
<a href="#thesis"></a></li><li><a href="#hash">Comment on Bell's Quadratic Quotient 
Algorithm</a>
<a href="#thesis"></a></li><li><a href="#thesis"><font style="vertical-align:inherit"><font style="vertical-align:inherit">奇异数据的解析柯西问题</font></font></a>
<a href="#thesis-note"></a></li><li><a href="#thesis">The Analytic Cauchy Problem with Singular 
Data</a>
<a href="#thesis-note"></a></li><li><a href="#thesis-note"><font style="vertical-align:inherit"><font style="vertical-align:inherit">奇异数据柯西问题Hamada定理的推广</font></font></a>
<a href="#coordinate"></a></li><li><a href="#thesis-note">An Extension of a Theorem of Hamada on the Cauchy
Problem with Singular Data</a>
<a href="#coordinate"></a></li><li><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">DO循环并行执行的协调方法</font></font></a>
<a href="#do-loops"></a></li><li><a href="#coordinate">The Coordinate Method for the Parallel
Execution of DO Loops</a>
<a href="#do-loops"></a></li><li><a href="#do-loops"><font style="vertical-align:inherit"><font style="vertical-align:inherit">DO 循环的并行执行</font></font></a>
<a href="#hyperplane"></a></li><li><a href="#do-loops">The Parallel Execution of DO Loops</a>
<a href="#hyperplane"></a></li><li><a href="#hyperplane"><font style="vertical-align:inherit"><font style="vertical-align:inherit">阵列计算机的超平面方法</font></font></a>
<a href="#bakery"></a></li><li><a href="#hyperplane">The Hyperplane Method for an Array
   Computer</a>
<a href="#bakery"></a></li><li><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Dijkstra并发编程问题的一种新解法</font></font></a>
<a href="#on-self-stabilizing-systems"></a></li><li><a href="#bakery">A New Solution of Dijkstra's Concurrent Programming
   Problem</a>
<a href="#on-self-stabilizing-systems"></a></li><li><a href="#on-self-stabilizing-systems"><font style="vertical-align:inherit"><font style="vertical-align:inherit">自稳定系统</font></font></a>
<a href="#prog-parallel"></a></li><li><a href="#on-self-stabilizing-systems">On Self-stabilizing
Systems</a>
<a href="#prog-parallel"></a></li><li><a href="#prog-parallel"><font style="vertical-align:inherit"><font style="vertical-align:inherit">论并行计算机编程</font></font></a>
<a href="#parallel-execution"></a></li><li><a href="#prog-parallel">On Programming Parallel
   Computers</a>
<a href="#parallel-execution"></a></li><li><a href="#parallel-execution"><font style="vertical-align:inherit"><font style="vertical-align:inherit">阵列和向量计算机上的并行执行</font></font></a>
<a href="#multiple-byte"></a></li><li><a href="#parallel-execution">Parallel Execution on Array and Vector
   Computers</a>
<a href="#multiple-byte"></a></li><li><a href="#multiple-byte"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用全字指令进行多字节处理</font></font></a>
<a href="#synchronization"></a></li><li><a href="#multiple-byte">Multiple Byte Processing with Full-Word
   Instructions</a>
<a href="#synchronization"></a></li><li><a href="#synchronization"><font style="vertical-align:inherit"><font style="vertical-align:inherit">独立进程的同步</font></font></a>
<a href="#comments"></a></li><li><a href="#synchronization">The Synchronization of Independent
   Processes</a>
<a href="#comments"></a></li><li><a href="#comments"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对“同步异常”的评论</font></font></a>
<a href="#multi-garbage"></a></li><li><a href="#comments">Comments on `A Synchronization
   Anomaly'</a>
<a href="#multi-garbage"></a></li><li><a href="#multi-garbage"><font style="vertical-align:inherit"><font style="vertical-align:inherit">多进程垃圾收集：并行性练习</font></font></a>
<a href="#coord-method"></a></li><li><a href="#multi-garbage">Garbage Collection with Multiple Processes:
   an Exercise in Parallelism</a>
<a href="#coord-method"></a></li><li><a href="#coord-method"><font style="vertical-align:inherit"><font style="vertical-align:inherit">迭代循环并行执行的协调方法</font></font></a>
<a href="#multi-user"></a></li><li><a href="#coord-method">The Coordinate Method for the Parallel Execution of
   Iterative Loops</a>
<a href="#multi-user"></a></li><li><a href="#multi-user"><font style="vertical-align:inherit"><font style="vertical-align:inherit">走向多用户数据库系统正确性理论</font></font></a>
<a href="#glitch"></a></li><li><a href="#multi-user">Towards a Theory of Correctness for Multi-User
   Data Base Systems</a>
<a href="#glitch"></a></li><li><a href="#glitch"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于故障现象</font></font></a>
<a href="#proving"></a></li><li><a href="#glitch">On the Glitch Phenomenon</a>
<a href="#proving"></a></li><li><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明多进程程序的正确性</font></font></a>
<a href="#formal"></a></li><li><a href="#proving">Proving the Correctness of Multiprocess
   Programs</a>
<a href="#formal"></a></li><li><a href="#formal"><font style="vertical-align:inherit"><font style="vertical-align:inherit">多进程算法的形式正确性证明</font></font></a>
<a href="#rd-wr"></a></li><li><a href="#formal">Formal Correctness Proofs for Multiprocess
   Algorithms</a>
<a href="#rd-wr"></a></li><li><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发阅读和写作</font></font></a>
<a href="#state-the-problem"></a></li><li><a href="#rd-wr">Concurrent Reading and Writing</a>
<a href="#state-the-problem"></a></li><li><a href="#state-the-problem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在描述解决方案之前先陈述问题</font></font></a>
<a href="#time-clocks"></a></li><li><a href="#state-the-problem">State the Problem Before 
Describing the Solution</a>
<a href="#time-clocks"></a></li><li><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式系统中的时间、时钟和事件顺序</font></font></a>
<a href="#interactive"></a></li><li><a href="#time-clocks">Time, Clocks and the Ordering of Events in a
   Distributed System</a>
<a href="#interactive"></a></li><li><a href="#interactive"><font style="vertical-align:inherit"><font style="vertical-align:inherit">交互程序的规范和正确性证明</font></font></a>
<a href="#implementation"></a></li><li><a href="#interactive">The Specification and Proof of Correctness of
   Interactive Programs</a>
<a href="#implementation"></a></li><li><a href="#implementation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可靠的分布式多进程系统的实现</font></font></a>
<a href="#sift"></a></li><li><a href="#implementation">The Implementation of Reliable Distributed
   Multiprocess Systems</a>
<a href="#sift"></a></li><li><a href="#sift"><font style="vertical-align:inherit"><font style="vertical-align:inherit">SIFT：飞机控制容错计算机的设计与分析</font></font></a>
<a href="#garbage"></a></li><li><a href="#sift">SIFT: Design and Analysis of a Fault-Tolerant Computer for
   Aircraft Control</a>
<a href="#garbage"></a></li><li><a href="#garbage"><font style="vertical-align:inherit"><font style="vertical-align:inherit">即时垃圾收集：合作练习</font></font></a>
<a href="#general-construction"></a></li><li><a href="#garbage">On-the-fly Garbage Collection: an Exercise in
    Cooperation</a>
<a href="#general-construction"></a></li><li><a href="#general-construction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">表达重复的一般结构</font></font></a>
<a href="#new-approach"></a></li><li><a href="#general-construction">A General Construction for
Expressing Repetition</a>
<a href="#new-approach"></a></li><li><a href="#new-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明多进程程序正确性的新方法</font></font></a>
<a href="#howto"></a></li><li><a href="#new-approach">A New Approach to Proving the Correctness of
   Multiprocess Programs</a>
<a href="#howto"></a></li><li><a href="#howto"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何发表论文</font></font></a>
<a href="#multi"></a></li><li><a href="#howto">How to Present a Paper</a>
<a href="#multi"></a></li><li><a href="#multi"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何制作能够正确执行多进程程序的多处理器计算机</font></font></a>
<a href="#dig-sig"></a></li><li><a href="#multi">How to Make a Multiprocessor Computer That Correctly
   Executes Multiprocess Programs</a>
<a href="#dig-sig"></a></li><li><a href="#dig-sig"><font style="vertical-align:inherit"><font style="vertical-align:inherit">从单向函数构建数字签名</font></font></a>
<a href="#calendar"></a></li><li><a href="#dig-sig">Constructing Digital Signatures from a One Way
   Function</a>
<a href="#calendar"></a></li><li><a href="#calendar"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于日历程序正确性的证明</font></font></a>
<a href="#letter-to-editor"></a></li><li><a href="#calendar">On the Proof of Correctness of a Calendar
   Program</a>
<a href="#letter-to-editor"></a></li><li><a href="#letter-to-editor"><font style="vertical-align:inherit"><font style="vertical-align:inherit">给编辑的一封信</font></font></a>
<a href="#sometime"></a></li><li><a href="#letter-to-editor">Letter to the Editor</a>
<a href="#sometime"></a></li><li><a href="#sometime"><font style="vertical-align:inherit"><font style="vertical-align:inherit">“有时”有时是“不是永远”</font></font></a>
<a href="#hoare"></a></li><li><a href="#sometime">`Sometime' is Sometimes `Not
   Never'</a>
<a href="#hoare"></a></li><li><a href="#hoare"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序的“霍尔逻辑”</font></font></a>
<a href="#reaching"></a></li><li><a href="#hoare">The `Hoare Logic' of Concurrent Programs</a>
<a href="#reaching"></a></li><li><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在存在缺陷的情况下达成协议</font></font></a>
<a href="#program"></a></li><li><a href="#reaching">Reaching Agreement in the Presence of Faults</a>
<a href="#program"></a></li><li><a href="#program"><font style="vertical-align:inherit"><font style="vertical-align:inherit">程序验证：可靠的硬件和软件的方法</font></font></a>
<a href="#password"></a></li><li><a href="#program">Program Verification: An Approach to Reliable Hardware
   and Software</a>
<a href="#password"></a></li><li><a href="#password"><font style="vertical-align:inherit"><font style="vertical-align:inherit">不安全通信的密码认证</font></font></a>
<a href="#lamport-timesets"></a></li><li><a href="#password">Password Authentication with Insecure
   Communication</a>
<a href="#lamport-timesets"></a></li><li><a href="#lamport-timesets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TIMESETS--程序时间推理的新方法</font></font></a>
<a href="#trans"></a></li><li><a href="#lamport-timesets">TIMESETS--A New Method for Temporal 
   Reasoning About Programs</a>
<a href="#trans"></a></li><li><a href="#trans"><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军和交易提交协议</font></font></a>
<a href="#byz"></a></li><li><a href="#trans">Byzantine Generals and Transaction Commit Protocols</a>
<a href="#byz"></a></li><li><a href="#byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军问题</font></font></a>
<a href="#liveness"></a></li><li><a href="#byz">The Byzantine Generals Problem</a>
<a href="#liveness"></a></li><li><a href="#liveness"><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明并发程序的活跃性</font></font></a>
<a href="#dist"></a></li><li><a href="#liveness">Proving Liveness Properties of Concurrent
   Programs</a>
<a href="#dist"></a></li><li><a href="#dist"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式程序的断言正确性证明</font></font></a>
<a href="#nonatomic"></a></li><li><a href="#dist">An Assertional Correctness Proof of a Distributed
   Program</a>
<a href="#nonatomic"></a></li><li><a href="#nonatomic"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于非原子操作的推理</font></font></a>
<a href="#spec"></a></li><li><a href="#nonatomic">Reasoning About Nonatomic
   Operations</a>
<a href="#spec"></a></li><li><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定并发程序模块</font></font></a>
<a href="#spec-and-proof"></a></li><li><a href="#spec">Specifying Concurrent Program Modules</a>
<a href="#spec-and-proof"></a></li><li><a href="#spec-and-proof"><font style="vertical-align:inherit"><font style="vertical-align:inherit">容错实时算法的规范和证明</font></font></a>
<a href="#weak-byz"></a></li><li><a href="#spec-and-proof">Specification and Proof of a
   Fault-Tolerant Real-Time Algorithm</a>
<a href="#weak-byz"></a></li><li><a href="#weak-byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">弱拜占庭将军问题</font></font></a>
<a href="#phil"></a></li><li><a href="#weak-byz">The Weak Byzantine Generals Problem</a>
<a href="#phil"></a></li><li><a href="#phil"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PHIL：语义结构图形编辑器</font></font></a>
<a href="#what-good"></a></li><li><a href="#phil">PHIL: A Semantic Structural Graphical Editor</a>
<a href="#what-good"></a></li><li><a href="#what-good"><font style="vertical-align:inherit"><font style="vertical-align:inherit">时序逻辑有什么好处？</font></font></a>
<a href="#using-time"></a></li><li><a href="#what-good">What Good Is Temporal Logic?</a>
<a href="#using-time"></a></li><li><a href="#using-time"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于容错分布式系统使用时间而不是超时</font></font></a>
<a href="#ghl"></a></li><li><a href="#using-time">Using Time Instead of Timeout for
   Fault-Tolerant Distributed Systems</a>
<a href="#ghl"></a></li><li><a href="#ghl"><font style="vertical-align:inherit"><font style="vertical-align:inherit">CSP 的霍尔逻辑以及所有这些</font></font></a>
<a href="#clocks2"></a></li><li><a href="#ghl">The Hoare Logic Of CSP, and All That</a>
<a href="#clocks2"></a></li><li><a href="#clocks2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭时钟同步</font></font></a>
<a href="#solved-and-unsolved"></a></li><li><a href="#clocks2">Byzantine Clock Synchronization</a>
<a href="#solved-and-unsolved"></a></li><li><a href="#solved-and-unsolved"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发中已解决的问题、未解决的问题和非问题</font></font></a>
<a href="#peterson-theorem"></a></li><li><a href="#solved-and-unsolved">Solved Problems, Unsolved Problems 
    and NonProblems in Concurrency</a>
<a href="#peterson-theorem"></a></li><li><a href="#peterson-theorem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">论彼得森的一个“定理”</font></font></a>
<a href="#buridan"></a></li><li><a href="#peterson-theorem">On a "Theorem" of Peterson</a>
<a href="#buridan"></a></li><li><a href="#buridan"><font style="vertical-align:inherit"><font style="vertical-align:inherit">布里丹原理</font></font></a>
<a href="#mutual"></a></li><li><a href="#buridan">Buridan's Principle</a>
<a href="#mutual"></a></li><li><a href="#mutual"><font style="vertical-align:inherit"><font style="vertical-align:inherit">互斥问题--第一部分：进程间通信理论，第二部分：陈述和解决方案</font></font></a>
<a href="#clocks"></a></li><li><a href="#mutual">The Mutual Exclusion Problem--Part I: A Theory of
   Interprocess Communication, Part II: Statement and
   Solutions</a>
<a href="#clocks"></a></li><li><a href="#clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">存在故障时同步时钟</font></font></a>
<a href="#priority"></a></li><li><a href="#clocks">Synchronizing Clocks in the Presence of Faults</a>
<a href="#priority"></a></li><li><a href="#priority"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序满足规范意味着什么：为什么没有人指定优先级</font></font></a>
<a href="#alias"></a></li><li><a href="#priority">What It Means for a Concurrent Program to Satisfy a
   Specification: Why No One Has Specified Priority</a>
<a href="#alias"></a></li><li><a href="#alias"><font style="vertical-align:inherit"><font style="vertical-align:inherit">约束：别名和类型的统一方法</font></font></a>
<a href="#recursive-compiling"></a></li><li><a href="#alias">Constraints: A Uniform Approach to Aliasing and
   Typing</a>
<a href="#recursive-compiling"></a></li><li><a href="#recursive-compiling"><font style="vertical-align:inherit"><font style="vertical-align:inherit">递归编译和编程环境（摘要）</font></font></a>
<a href="#chandy"></a></li><li><a href="#recursive-compiling">Recursive Compiling and Programming
Environments (Summary)</a>
<a href="#chandy"></a></li><li><a href="#chandy"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式快照：确定分布式系统的全局状态</font></font></a>
<a href="#munich"></a></li><li><a href="#chandy">Distributed Snapshots: Determining Global States of a
   Distributed System</a>
<a href="#munich"></a></li><li><a href="#munich"><font style="vertical-align:inherit"><font style="vertical-align:inherit">规范和验证的正式基础</font></font></a>
<a href="#semantics"></a></li><li><a href="#munich">Formal Foundation for Specification and
   Verification</a>
<a href="#semantics"></a></li><li><a href="#semantics"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发编程语言的公理语义</font></font></a>
<a href="#latex"></a></li><li><a href="#semantics">An Axiomatic Semantics of Concurrent Programming
   Languages</a>
<a href="#latex"></a></li><li><a href="#latex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">LaTeX：文档准备系统</font></font></a>
<a href="#interprocess"></a></li><li><a href="#latex">LaTeX: A Document Preparation
   System</a>
<a href="#interprocess"></a></li><li><a href="#interprocess"><font style="vertical-align:inherit"><font style="vertical-align:inherit">论进程间通信——第一部分：基本形式主义，第二部分：算法</font></font></a>
<a href="#the-byz-generals"></a></li><li><a href="#interprocess">On Interprocess Communication--Part I: Basic 
   Formalism, Part II: Algorithms</a>
<a href="#the-byz-generals"></a></li><li><a href="#the-byz-generals"><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军</font></font></a>
<a href="#formal-basis"></a></li><li><a href="#the-byz-generals">The Byzantine Generals</a>
<a href="#formal-basis"></a></li><li><a href="#formal-basis"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发系统规范的形式基础</font></font></a>
<a href="#fast-mutex"></a></li><li><a href="#formal-basis">A Formal Basis for the Specification of 
   Concurrent Systems</a>
<a href="#fast-mutex"></a></li><li><a href="#fast-mutex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">一种快速互斥算法</font></font></a>
<a href="#derivation-simple"></a></li><li><a href="#fast-mutex">A Fast Mutual Exclusion Algorithm</a>
<a href="#derivation-simple"></a></li><li><a href="#derivation-simple"><font style="vertical-align:inherit"><font style="vertical-align:inherit">简单同步算法的推导</font></font></a>
<a href="#distributed-system"></a></li><li><a href="#derivation-simple">Derivation of a Simple Synchronization
   Algorithm</a>
<a href="#distributed-system"></a></li><li><a href="#distributed-system"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分配</font></font></a>
<a href="#document-production"></a></li><li><a href="#distributed-system">Distribution</a>
<a href="#document-production"></a></li><li><a href="#document-production"><font style="vertical-align:inherit"><font style="vertical-align:inherit">文件制作：视觉还是逻辑？</font></font></a>
<a href="#synchronizing-time-servers"></a></li><li><a href="#document-production">Document Production: Visual or
   Logical?</a>
<a href="#synchronizing-time-servers"></a></li><li><a href="#synchronizing-time-servers"><font style="vertical-align:inherit"><font style="vertical-align:inherit">同步时间服务器</font></font></a>
<a href="#control"></a></li><li><a href="#synchronizing-time-servers">Synchronizing Time Servers</a>
<a href="#control"></a></li><li><a href="#control"><font style="vertical-align:inherit"><font style="vertical-align:inherit">控制谓词比虚拟变量更好地表示程序控制</font></font></a>
<a href="#lamport-ewd1013"></a></li><li><a href="#control">Control Predicates Are Better than Dummy Variables for
   Representing Program Control</a>
<a href="#lamport-ewd1013"></a></li><li><a href="#lamport-ewd1013"><font style="vertical-align:inherit"><font style="vertical-align:inherit">“EWD 1013”</font></font></a>
<a href="#position"></a></li><li><a href="#lamport-ewd1013">"EWD 1013"</a>
<a href="#position"></a></li><li><a href="#position"><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一份关于公平的立场文件</font></font></a>
<a href="#welch-lattice"></a></li><li><a href="#position">Another Position Paper on Fairness</a>
<a href="#welch-lattice"></a></li><li><a href="#welch-lattice"><font style="vertical-align:inherit"><font style="vertical-align:inherit">最小生成树算法的格结构证明</font></font></a>
<a href="#simple-approach"></a></li><li><a href="#welch-lattice">A Lattice-Structured Proof of a Minimum Spanning 
   Tree Algorithm</a>
<a href="#simple-approach"></a></li><li><a href="#simple-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定并发系统的简单方法</font></font></a>
<a href="#pretending"></a></li><li><a href="#simple-approach">A Simple Approach to Specifying Concurrent
   Systems</a>
<a href="#pretending"></a></li><li><a href="#pretending"><font style="vertical-align:inherit"><font style="vertical-align:inherit">假装原子性</font></font></a>
<a href="#abadi-realizable"></a></li><li><a href="#pretending">Pretending Atomicity</a>
<a href="#abadi-realizable"></a></li><li><a href="#abadi-realizable"><font style="vertical-align:inherit"><font style="vertical-align:inherit">反应式系统的可实现和不可实现的规范</font></font></a>
<a href="#old-tla-src"></a></li><li><a href="#abadi-realizable">Realizable and Unrealizable Specifications of
   Reactive Systems</a>
<a href="#old-tla-src"></a></li><li><a href="#old-tla-src"><font style="vertical-align:inherit"><font style="vertical-align:inherit">行动的时间逻辑</font></font></a>
<a href="#lamport-win"></a></li><li><a href="#old-tla-src">A Temporal Logic of Actions</a>
<a href="#lamport-win"></a></li><li><a href="#lamport-win"><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">win</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">sin</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">：并发谓词转换器</font></font></a>
<a href="#lamport-theorem"></a></li><li><a href="#lamport-win"><i>win</i> and <i>sin</i>: Predicate Transformers
   for Concurrency</a>
<a href="#lamport-theorem"></a></li><li><a href="#lamport-theorem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式算法原子性定理</font></font></a>
<a href="#lamport-chapter"></a></li><li><a href="#lamport-theorem">A Theorem on Atomicity in Distributed
   Algorithms</a>
<a href="#lamport-chapter"></a></li><li><a href="#lamport-chapter"><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算：模型和方法</font></font></a>
<a href="#lamport-completion"></a></li><li><a href="#lamport-chapter">Distributed Computing: Models and
   Methods</a>
<a href="#lamport-completion"></a></li><li><a href="#lamport-completion"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 的完备性定理</font></font></a>
<a href="#lamport-concurrent-clocks"></a></li><li><a href="#lamport-completion">A Completeness Theorem for TLA</a>
<a href="#lamport-concurrent-clocks"></a></li><li><a href="#lamport-concurrent-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">时钟的并发读写</font></font></a>
<a href="#lamport-mutual-solved"></a></li><li><a href="#lamport-concurrent-clocks">The Concurrent Reading and
   Writing of Clocks</a>
<a href="#lamport-mutual-solved"></a></li><li><a href="#lamport-mutual-solved"><font style="vertical-align:inherit"><font style="vertical-align:inherit">互斥问题已解决</font></font></a>
<a href="#abadi-existence"></a></li><li><a href="#lamport-mutual-solved">The Mutual Exclusion Problem Has Been
   Solved</a>
<a href="#abadi-existence"></a></li><li><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">细化映射的存在</font></font></a>
<a href="#abadi-preserving"></a></li><li><a href="#abadi-existence">The Existence of Refinement 
  Mappings</a>
<a href="#abadi-preserving"></a></li><li><a href="#abadi-preserving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">保持活力：对“从方法论角度看安全性和活力”的评论</font></font></a>
<a href="#lamport-critique"></a></li><li><a href="#abadi-preserving">Preserving Liveness: Comments on `Safety and
   Liveness from a Methodological Point of
   View'</a>
<a href="#lamport-critique"></a></li><li><a href="#lamport-critique"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对箭头湖三号的批评</font></font></a>
<a href="#lamport-reduction-tlanote"></a></li><li><a href="#lamport-critique">Critique of the Lake Arrowhead
   Three</a>
<a href="#lamport-reduction-tlanote"></a></li><li><a href="#lamport-reduction-tlanote"><font style="vertical-align:inherit"><font style="vertical-align:inherit">约简定理</font></font></a>
<a href="#engberg-mechanical"></a></li><li><a href="#lamport-reduction-tlanote">The Reduction 
   Theorem</a>
<a href="#engberg-mechanical"></a></li><li><a href="#engberg-mechanical"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA 进行并行系统的机械验证</font></font></a>
<a href="#reconfiguration-patent"></a></li><li><a href="#engberg-mechanical">Mechanical Verification of Concurrent Systems
   with TLA</a>
<a href="#reconfiguration-patent"></a></li><li><a href="#reconfiguration-patent"><font style="vertical-align:inherit"><font style="vertical-align:inherit">高速网状连接局域网的重构系统和方法</font></font></a>
<a href="#abadi-composing"></a></li><li><a href="#reconfiguration-patent">Reconfiguration system and method for high-speed mesh
connected local area network</a>
<a href="#abadi-composing"></a></li><li><a href="#abadi-composing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">撰写规范</font></font></a>
<a href="#kurshan-multiplier"></a></li><li><a href="#abadi-composing">Composing
   Specifications</a>
<a href="#kurshan-multiplier"></a></li><li><a href="#kurshan-multiplier"><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘法器的验证：64 位及以上</font></font></a>
<a href="#lamport-verification"></a></li><li><a href="#kurshan-multiplier">Verification of a Multiplier: 64 Bits and
   Beyond</a>
<a href="#lamport-verification"></a></li><li><a href="#lamport-verification"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序的验证和规范</font></font></a>
<a href="#lamport-hybrid"></a></li><li><a href="#lamport-verification">Verification and Specification of
   Concurrent Programs</a>
<a href="#lamport-hybrid"></a></li><li><a href="#lamport-hybrid"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 中的混合系统</font></font></a>
<a href="#lamport-how-to-write"></a></li><li><a href="#lamport-hybrid">Hybrid Systems in
   TLA+</a>
<a href="#lamport-how-to-write"></a></li><li><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何写证明</font></font></a>
<a href="#lamport-actions"></a></li><li><a href="#lamport-how-to-write">How to Write a Proof</a>
<a href="#lamport-actions"></a></li><li><a href="#lamport-actions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">动作的时间逻辑</font></font></a>
<a href="#abadi-decomposing"></a></li><li><a href="#lamport-actions">The Temporal Logic of Actions</a>
<a href="#abadi-decomposing"></a></li><li><a href="#abadi-decomposing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发系统的分解规范</font></font></a>
<a href="#abadi-open"></a></li><li><a href="#abadi-decomposing">Decomposing Specifications of Concurrent
   Systems</a>
<a href="#abadi-open"></a></li><li><a href="#abadi-open"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 中的开放系统</font></font></a>
<a href="#tlz"></a></li><li><a href="#abadi-open">Open Systems in
   TLA</a>
<a href="#tlz"></a></li><li><a href="#tlz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLZ（摘要）</font></font></a>
<a href="#lamport-old-fashioned"></a></li><li><a href="#tlz">TLZ (Abstract)</a>
<a href="#lamport-old-fashioned"></a></li><li><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"><font style="vertical-align:inherit">老式的实时配方</font></font></a>
<a href="#lamport-ftrtft94"></a></li><li><a href="#lamport-old-fashioned">An Old-Fashioned Recipe for Real
   Time</a>
<a href="#lamport-ftrtft94"></a></li><li><a href="#lamport-ftrtft94"><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定和验证容错系统</font></font></a>
<a href="#lamport-howtowrite"></a></li><li><a href="#lamport-ftrtft94">Specifying and Verifying Fault-Tolerant
   Systems</a>
<a href="#lamport-howtowrite"></a></li><li><a href="#lamport-howtowrite"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何写一个长公式</font></font></a>
<a href="#intro-to-tla"></a></li><li><a href="#lamport-howtowrite">How to Write a Long Formula</a>
<a href="#intro-to-tla"></a></li><li><a href="#intro-to-tla"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA简介</font></font></a>
<a href="#adding-process-algebra"></a></li><li><a href="#intro-to-tla">Introduction to TLA</a>
<a href="#adding-process-algebra"></a></li><li><a href="#adding-process-algebra"><font style="vertical-align:inherit"><font style="vertical-align:inherit">将“过程代数”添加到 TLA</font></font></a>
<a href="#ccs-proofs"></a></li><li><a href="#adding-process-algebra">Adding "Process Algebra" to 
    TLA</a>
<a href="#ccs-proofs"></a></li><li><a href="#ccs-proofs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">代数证明使用什么过程代替不变性</font></font></a>
<a href="#abadi-conjoining"></a></li><li><a href="#ccs-proofs">What Process Algebra Proofs Use Instead of 
   Invariance</a>
<a href="#abadi-conjoining"></a></li><li><a href="#abadi-conjoining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">连接规格</font></font></a>
<a href="#lamport-pictures"></a></li><li><a href="#abadi-conjoining">Conjoining
   Specifications</a>
<a href="#lamport-pictures"></a></li><li><a href="#lamport-pictures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">图片中的 TLA</font></font></a>
<a href="#broy-specification-problem"></a></li><li><a href="#lamport-pictures">TLA in Pictures</a>
<a href="#broy-specification-problem"></a></li><li><a href="#broy-specification-problem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">RPC 内存规范问题：问题陈述</font></font></a>
<a href="#abadi-dagstuhl"></a></li><li><a href="#broy-specification-problem">The RPC-Memory Specification Problem:
   Problem Statement</a>
<a href="#abadi-dagstuhl"></a></li><li><a href="#abadi-dagstuhl"><font style="vertical-align:inherit"><font style="vertical-align:inherit">RPC内存规范问题的TLA解决方案</font></font></a>
<a href="#automobile"></a></li><li><a href="#abadi-dagstuhl">A TLA Solution to the RPC-Memory Specification
   Problem</a>
<a href="#automobile"></a></li><li><a href="#automobile"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何区分程序和汽车</font></font></a>
<a href="#refinement"></a></li><li><a href="#automobile">How to Tell a Program from an Automobile</a>
<a href="#refinement"></a></li><li><a href="#refinement"><font style="vertical-align:inherit"><font style="vertical-align:inherit">基于国家的形式主义的细化</font></font></a>
<a href="#lamport-drummers"></a></li><li><a href="#refinement">Refinement in State-Based Formalisms</a>
<a href="#lamport-drummers"></a></li><li><a href="#lamport-drummers"><font style="vertical-align:inherit"><font style="vertical-align:inherit">向许多远方的鼓手行进</font></font></a>
<a href="#lamport-eye-of-beholder"></a></li><li><a href="#lamport-drummers">Marching to Many Distant 
   Drummers</a>
<a href="#lamport-eye-of-beholder"></a></li><li><a href="#lamport-eye-of-beholder"><font style="vertical-align:inherit"><font style="vertical-align:inherit">过程是情人眼里出西施</font></font></a>
<a href="#lamport-how-to-make"></a></li><li><a href="#lamport-eye-of-beholder">Processes are in the Eye of the
   Beholder</a>
<a href="#lamport-how-to-make"></a></li><li><a href="#lamport-how-to-make"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何使正确的多进程程序在多处理器上正确执行</font></font></a>
<a href="#substitution"></a></li><li><a href="#lamport-how-to-make">How to Make a Correct Multiprocess Program
   Execute Correctly on a Multiprocessor</a>
<a href="#substitution"></a></li><li><a href="#substitution"><font style="vertical-align:inherit"><font style="vertical-align:inherit">替代：句法与语义</font></font></a>
<a href="#lamport-paxos"></a></li><li><a href="#substitution">Substitution: Syntactic versus Semantic</a>
<a href="#lamport-paxos"></a></li><li><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">兼职议会</font></font></a>
<a href="#cohen-tlareduction"></a></li><li><a href="#lamport-paxos">The Part-Time Parliament</a>
<a href="#cohen-tlareduction"></a></li><li><a href="#cohen-tlareduction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">减少 TLA</font></font></a>
<a href="#lamport-composition"></a></li><li><a href="#cohen-tlareduction">Reduction in TLA</a>
<a href="#lamport-composition"></a></li><li><a href="#lamport-composition"><font style="vertical-align:inherit"><font style="vertical-align:inherit">组合：一种让证明更难的方法</font></font></a>
<a href="#lamport-possibility"></a></li><li><a href="#lamport-composition">Composition: A Way to Make Proofs
   Harder</a>
<a href="#lamport-possibility"></a></li><li><a href="#lamport-possibility"><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明可能性属性</font></font></a>
<a href="#ladkin-gerth"></a></li><li><a href="#lamport-possibility">Proving Possibility
   Properties</a>
<a href="#ladkin-gerth"></a></li><li><a href="#ladkin-gerth"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA中的惰性缓存证明</font></font></a>
<a href="#lamport-spec-tla-plus"></a></li><li><a href="#ladkin-gerth">A Lazy Caching Proof in TLA</a>
<a href="#lamport-spec-tla-plus"></a></li><li><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 指定并发系统</font></font></a>
<a href="#fm99"></a></li><li><a href="#lamport-spec-tla-plus">Specifying Concurrent Systems with
   TLA+</a>
<a href="#fm99"></a></li><li><a href="#fm99"><font style="vertical-align:inherit"><font style="vertical-align:inherit">缓存一致性协议的 TLA+ 验证</font></font></a>
<a href="#lamport-types"></a></li><li><a href="#fm99">TLA+ Verification of Cache-Coherence
  Protocols</a>
<a href="#lamport-types"></a></li><li><a href="#lamport-types"><font style="vertical-align:inherit"><font style="vertical-align:inherit">应该输入您的规范语言吗？</font></font></a>
<a href="#yuanyu-model-checking"></a></li><li><a href="#lamport-types">Should Your Specification Language Be
   Typed?</a>
<a href="#yuanyu-model-checking"></a></li><li><a href="#yuanyu-model-checking"><font style="vertical-align:inherit"><font style="vertical-align:inherit">模型检查 TLA+ 规格</font></font></a>
<a href="#lamport-latex-interview"></a></li><li><a href="#yuanyu-model-checking">Model Checking TLA+
   Specifications</a>
<a href="#lamport-latex-interview"></a></li><li><a href="#lamport-latex-interview"><font style="vertical-align:inherit"><font style="vertical-align:inherit">(La)TeX 如何改变数学的面貌</font></font></a>
<a href="#lamport-fairness"></a></li><li><a href="#lamport-latex-interview">How (La)TeX changed the face of
   Mathematics</a>
<a href="#lamport-fairness"></a></li><li><a href="#lamport-fairness"><font style="vertical-align:inherit"><font style="vertical-align:inherit">公平与超公平</font></font></a>
<a href="#www9"></a></li><li><a href="#lamport-fairness">Fairness and Hyperfairness</a>
<a href="#www9"></a></li><li><a href="#www9"><font style="vertical-align:inherit"><font style="vertical-align:inherit">网页的档案参考</font></font></a>
<a href="#disk-paxos"></a></li><li><a href="#www9">Archival References to Web Pages</a>
<a href="#disk-paxos"></a></li><li><a href="#disk-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">磁盘 Paxos</font></font></a>
<a href="#disk-paxos-disc"></a></li><li><a href="#disk-paxos">Disk Paxos</a>
<a href="#disk-paxos-disc"></a></li><li><a href="#disk-paxos-disc"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Disk Paxos（会议版）</font></font></a>
<a href="#when-mutex"></a></li><li><a href="#disk-paxos-disc">Disk Paxos (Conference Version)</a>
<a href="#when-mutex"></a></li><li><a href="#when-mutex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">正确的互斥算法什么时候能保证互斥</font></font></a>
<a href="#consensus-bounds"></a></li><li><a href="#when-mutex">When Does a Correct Mutual Exclusion Algorithm
  Guarantee Mutual Exclusion</a>
<a href="#consensus-bounds"></a></li><li><a href="#consensus-bounds"><font style="vertical-align:inherit"><font style="vertical-align:inherit">共识的下限</font></font></a>
<a href="#wildfire-challenge"></a></li><li><a href="#consensus-bounds">Lower Bounds on Consensus</a>
<a href="#wildfire-challenge"></a></li><li><a href="#wildfire-challenge"><font style="vertical-align:inherit"><font style="vertical-align:inherit">野火挑战问题</font></font></a>
<a href="#paxos-simple"></a></li><li><a href="#wildfire-challenge">The Wildfire Challenge Problem</a>
<a href="#paxos-simple"></a></li><li><a href="#paxos-simple"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Paxos 变得简单</font></font></a>
<a href="#spec-and-verifying"></a></li><li><a href="#paxos-simple">Paxos Made Simple</a>
<a href="#spec-and-verifying"></a></li><li><a href="#spec-and-verifying"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 指定和验证系统</font></font></a>
<a href="#arbiter-free"></a></li><li><a href="#spec-and-verifying">Specifying and Verifying Systems with 
  TLA+</a>
<a href="#arbiter-free"></a></li><li><a href="#arbiter-free"><font style="vertical-align:inherit"><font style="vertical-align:inherit">无仲裁器同步</font></font></a>
<a href="#ds-interview"></a></li><li><a href="#arbiter-free">Arbiter-Free Synchronization</a>
<a href="#ds-interview"></a></li><li><a href="#ds-interview"><font style="vertical-align:inherit"><font style="vertical-align:inherit">与莱斯利·兰波特的讨论</font></font></a>
<a href="#bertinoro"></a></li><li><a href="#ds-interview">A 
Discussion With Leslie Lamport</a>
<a href="#bertinoro"></a></li><li><a href="#bertinoro"><font style="vertical-align:inherit"><font style="vertical-align:inherit">异步共识的下限</font></font></a>
<a href="#tla+-book"></a></li><li><a href="#bertinoro">Lower Bounds for Asynchronous
Consensus</a>
<a href="#tla+-book"></a></li><li><a href="#tla+-book"><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定系统：面向硬件和软件工程师的 TLA+ 语言和工具</font></font></a>
<a href="#fmsd"></a></li><li><a href="#tla+-book">Specifying Systems: The TLA+
Language and Tools for Hardware and Software Engineers</a>
<a href="#fmsd"></a></li><li><a href="#fmsd"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 检查缓存一致性协议</font></font></a>
<a href="#high-level"></a></li><li><a href="#fmsd">Checking Cache-Coherence Protocols with
TLA+</a>
<a href="#high-level"></a></li><li><a href="#high-level"><font style="vertical-align:inherit"><font style="vertical-align:inherit">高级规范：行业经验教训</font></font></a>
<a href="#future-of-computing"></a></li><li><a href="#high-level">High-Level Specifications: Lessons from
Industry</a>
<a href="#future-of-computing"></a></li><li><a href="#future-of-computing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算的未来：逻辑或生物学</font></font></a>
<a href="#paxos-commit"></a></li><li><a href="#future-of-computing">The Future of Computing: Logic or 
Biology</a>
<a href="#paxos-commit"></a></li><li><a href="#paxos-commit"><font style="vertical-align:inherit"><font style="vertical-align:inherit">交易提交共识</font></font></a>
<a href="#hair"></a></li><li><a href="#paxos-commit">Consensus on Transaction Commit</a>
<a href="#hair"></a></li><li><a href="#hair"><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于法国的头发颜色</font></font></a>
<a href="#wsfm-web"></a></li><li><a href="#hair">On Hair Color in France</a>
<a href="#wsfm-web"></a></li><li><a href="#wsfm-web"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Web 服务协议的正式规范</font></font></a>
<a href="#web-dsn-submission"></a></li><li><a href="#wsfm-web">Formal Specification of a Web Services
Protocol</a>
<a href="#web-dsn-submission"></a></li><li><a href="#web-dsn-submission"><font style="vertical-align:inherit"><font style="vertical-align:inherit">便宜的 Paxos</font></font></a>
<a href="#combining"></a></li><li><a href="#web-dsn-submission">Cheap Paxos</a>
<a href="#combining"></a></li><li><a href="#combining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">实施和组合规范</font></font></a>
<a href="#lower-bound"></a></li><li><a href="#combining">Implementing and Combining Specifications</a>
<a href="#lower-bound"></a></li><li><a href="#lower-bound"><font style="vertical-align:inherit"><font style="vertical-align:inherit">异步共识的下限</font></font></a>
<a href="#generalized"></a></li><li><a href="#lower-bound">Lower Bounds for Asynchronous Consensus</a>
<a href="#generalized"></a></li><li><a href="#generalized"><font style="vertical-align:inherit"><font style="vertical-align:inherit">广义共识和 Paxos</font></font></a>
<a href="#real-simple"></a></li><li><a href="#generalized">Generalized Consensus and Paxos</a>
<a href="#real-simple"></a></li><li><a href="#real-simple"><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时其实很简单</font></font></a>
<a href="#PaxosGST"></a></li><li><a href="#real-simple">Real Time is Really Simple</a>
<a href="#PaxosGST"></a></li><li><a href="#PaxosGST"><font style="vertical-align:inherit"><font style="vertical-align:inherit">最终同步能以多快的速度达成共识？</font></font></a>
<a href="#charme2005"></a></li><li><a href="#PaxosGST">How Fast Can Eventual Synchrony Lead to
Consensus?</a>
<a href="#charme2005"></a></li><li><a href="#charme2005"><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时模型检查非常简单</font></font></a>
<a href="#fast-paxos"></a></li><li><a href="#charme2005">Real-Time Model Checking is Really
Simple</a>
<a href="#fast-paxos"></a></li><li><a href="#fast-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">快速 Paxos</font></font></a>
<a href="#celebrity"></a></li><li><a href="#fast-paxos">Fast Paxos</a>
<a href="#celebrity"></a></li><li><a href="#celebrity"><font style="vertical-align:inherit"><font style="vertical-align:inherit">衡量名人</font></font></a>
<a href="#dcas"></a></li><li><a href="#celebrity">Measuring Celebrity</a>
<a href="#dcas"></a></li><li><a href="#dcas"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 +CAL 检查多线程算法</font></font></a>
<a href="#pluscal"></a></li><li><a href="#dcas">Checking a Multithreaded Algorithm with +CAL</a>
<a href="#pluscal"></a></li><li><a href="#pluscal"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PlusCal 算法语言</font></font></a>
<a href="#spec-book-chap"></a></li><li><a href="#pluscal">The PlusCal Algorithm Language</a>
<a href="#spec-book-chap"></a></li><li><a href="#spec-book-chap"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+</font></font></a>
<a href="#synchronizing"></a></li><li><a href="#spec-book-chap">TLA+</a>
<a href="#synchronizing"></a></li><li><a href="#synchronizing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用线程实现数据流</font></font></a>
<a href="#commentary-web"></a></li><li><a href="#synchronizing">Implementing Dataflow With Threads</a>
<a href="#commentary-web"></a></li><li><a href="#commentary-web"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Leslie Lamport：规范语言 TLA+</font></font></a>
<a href="#state-machine"></a></li><li><a href="#commentary-web">Leslie Lamport: The Specification Language
TLA+</a>
<a href="#state-machine"></a></li><li><a href="#state-machine"><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算和状态机</font></font></a>
<a href="#keappa08-web"></a></li><li><a href="#state-machine">Computation and State Machines</a>
<a href="#keappa08-web"></a></li><li><a href="#keappa08-web"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 证明系统</font></font></a>
<a href="#mailbox-web"></a></li><li><a href="#keappa08-web">A TLA+ Proof System</a>
<a href="#mailbox-web"></a></li><li><a href="#mailbox-web"><font style="vertical-align:inherit"><font style="vertical-align:inherit">邮箱问题</font></font></a>
<a href="#teaching-concurrency"></a></li><li><a href="#mailbox-web">The Mailbox Problem</a>
<a href="#teaching-concurrency"></a></li><li><a href="#teaching-concurrency"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发教学</font></font></a>
<a href="#vertical-paxos"></a></li><li><a href="#teaching-concurrency">Teaching Concurrency</a>
<a href="#vertical-paxos"></a></li><li><a href="#vertical-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">垂直Paxos和主备复制</font></font></a>
<a href="#deroever-festschrift"></a></li><li><a href="#vertical-paxos">Vertical Paxos and Primary-Backup
Replication</a>
<a href="#deroever-festschrift"></a></li><li><a href="#deroever-festschrift"><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机科学和状态机</font></font></a>
<a href="#reconfiguration-tutorial"></a></li><li><a href="#deroever-festschrift">Computer Science and State
Machines</a>
<a href="#reconfiguration-tutorial"></a></li><li><a href="#reconfiguration-tutorial"><font style="vertical-align:inherit"><font style="vertical-align:inherit">重新配置状态机</font></font></a>
<a href="#stoppable"></a></li><li><a href="#reconfiguration-tutorial">Reconfiguring a State Machine</a>
<a href="#stoppable"></a></li><li><a href="#stoppable"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可阻止的 Paxos</font></font></a>
<a href="#pnueli"></a></li><li><a href="#stoppable">Stoppable Paxos</a>
<a href="#pnueli"></a></li><li><a href="#pnueli"><font style="vertical-align:inherit"><font style="vertical-align:inherit">时态逻辑：三害相权取其轻</font></font></a>
<a href="#verifying-safety"></a></li><li><a href="#pnueli">Temporal Logic: The Lesser of Three
  Evils</a>
<a href="#verifying-safety"></a></li><li><a href="#verifying-safety"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 证明系统验证安全特性</font></font></a>
<a href="#web-byzpaxos"></a></li><li><a href="#verifying-safety">Verifying Safety Properties With the 
  TLA+ Proof System</a>
<a href="#web-byzpaxos"></a></li><li><a href="#web-byzpaxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">通过细化拜占庭化 Paxos</font></font></a>
<a href="#disc-leaderless-web"></a></li><li><a href="#web-byzpaxos">Byzantizing Paxos by Refinement</a>
<a href="#disc-leaderless-web"></a></li><li><a href="#disc-leaderless-web"><font style="vertical-align:inherit"><font style="vertical-align:inherit">无领导的拜占庭 Paxos</font></font></a>
<a href="#euclid"></a></li><li><a href="#disc-leaderless-web">Leaderless Byzantine Paxos</a>
<a href="#euclid"></a></li><li><a href="#euclid"><font style="vertical-align:inherit"><font style="vertical-align:inherit">欧几里得写了一个算法：一个童话</font></font></a>
<a href="#proof"></a></li><li><a href="#euclid">Euclid Writes an Algorithm: A
Fairytale</a>
<a href="#proof"></a></li><li><a href="#proof"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何写出 21 世纪的证明</font></font></a>
<a href="#tlaps"></a></li><li><a href="#proof">How to Write a 21st Century Proof</a>
<a href="#tlaps"></a></li><li><a href="#tlaps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 证明</font></font></a>
<a href="#wired"></a></li><li><a href="#tlaps">TLA+ Proofs</a>
<a href="#wired"></a></li><li><a href="#wired"><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么我们应该像建造房屋一样构建软件</font></font></a>
<a href="#adaptive"></a></li><li><a href="#wired">Why We Should Build 
Software Like We Build Houses</a>
<a href="#adaptive"></a></li><li><a href="#adaptive"><font style="vertical-align:inherit"><font style="vertical-align:inherit">具有线性数量寄存器的自适应寄存器分配</font></font></a>
<a href="#coalescing"></a></li><li><a href="#adaptive">Adaptive Register Allocation with a Linear Number
of Registers</a>
<a href="#coalescing"></a></li><li><a href="#coalescing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">合并：一阶模态逻辑推理的句法抽象</font></font></a>
<a href="#blueprints"></a></li><li><a href="#coalescing">Coalescing: Syntactic Abstraction for Reasoning in
 First-Order Modal Logics</a>
<a href="#blueprints"></a></li><li><a href="#blueprints"><font style="vertical-align:inherit"><font style="vertical-align:inherit">谁不画蓝图就盖房子？</font></font></a>
<a href="#turing"></a></li><li><a href="#blueprints">Who Builds a House without Drawing Blueprints?</a>
<a href="#turing"></a></li><li><a href="#turing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发计算机科学：早期</font></font></a>
<a href="#auxiliary"></a></li><li><a href="#turing">The Computer Science of Concurrency: The Early Years</a>
<a href="#auxiliary"></a></li><li><a href="#auxiliary"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 中的辅助变量</font></font></a>
<a href="#eatcs"></a></li><li><a href="#auxiliary">Auxiliary Variables in TLA+</a>
<a href="#eatcs"></a></li><li><a href="#eatcs"><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果你不编写程序，就不要使用编程语言</font></font></a>
<a href="#recursive-ops"></a></li><li><a href="#eatcs">If You’re Not Writing a Program,
 Don’t Use a Programming Language</a>
<a href="#recursive-ops"></a></li><li><a href="#recursive-ops"><font style="vertical-align:inherit"><font style="vertical-align:inherit">递归运算符定义</font></font></a>
<a href="#toolbox"></a></li><li><a href="#recursive-ops">Recursive Operator Definitions</a>
<a href="#toolbox"></a></li><li><a href="#toolbox"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 工具箱</font></font></a>
<a href="#simple"></a></li><li><a href="#toolbox">The TLA+ Toolbox</a>
<a href="#simple"></a></li><li><a href="#simple"><font style="vertical-align:inherit"><font style="vertical-align:inherit">预言变得简单</font></font></a>
<a href="#hyper2"></a></li><li><a href="#simple">Prophecy Made Simple</a>
<a href="#hyper2"></a></li><li><a href="#hyper2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA 验证超属性</font></font></a>
<a href="#generations"></a></li><li><a href="#hyper2">Verifying Hyperproperties with TLA</a>
<a href="#generations"></a></li><li><a href="#generations"><font style="vertical-align:inherit"><font style="vertical-align:inherit">代际间的数学证明</font></font></a>
</li><li><a href="#generations">Mathematical Proof Between Generations</a>
</li></ol><p></p><hr><h2><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文</font></font></h2><h2>The Papers</h2><ol>


<li> <a name="bxscience"><b><font style="vertical-align:inherit"></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">布朗克斯科学高中</font><b><font style="vertical-align:inherit">辫子理论</font></b></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/bxscience.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">数学公报 (1957)，第 6,7 和 9 页。 PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这似乎是我的第一篇出版物，是在我高中时写的。</font><font style="vertical-align:inherit">这说明我不是神童。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="bxscience"><b>Braid Theory</b><br>Mathematics Bulletin of the Bronx High School of 
Science (1957), pages 6,7, and 9.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/bxscience.pdf">PDF</a><hr>


This appears to be my first publication, written when I was a high
school student.&nbsp; It shows that I was not a child prodigy.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="summer-vision"> <b><font style="vertical-align:inherit"></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">麻省理工学院</font><b><font style="vertical-align:inherit">夏季视觉计划，MAC 项目备忘录 MAC-M-332，人工智能项目备忘录编号 Vision 111（1966 年 10 月）。</font></b></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/summer-vision.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1966 年夏天，我在 MIT 人工智能实验室工作，为计算机视觉项目进行 Lisp 编程。</font><font style="vertical-align:inherit">我不记得这份文档，但它似乎描述了我那个夏天编写的程序。</font><font style="vertical-align:inherit">它没有任何技术意义，但它确实表明，即使在那些日子里，我也在编写精确的文档。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="summer-vision"> <b>Summer Vision Programs</b><br>Massachusetts
Institute of Technology, Project MAC Memorandum MAC-M-332, Artificial
Intelligence Project Memo Number Vision 111 (October 1966).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/summer-vision.pdf">PDF</a><hr>


In the summer of 1966, I worked at the M.I.T. Artificial Intelligence
Laboratory, doing Lisp programming for a computer vision project.&nbsp; I
have no memory of this document, but it appears to describe the
programs I wrote that summer.&nbsp; It's of no technical interest, but it
does show that, even in those days, I was writing precise
documentation.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="monitor1"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Monitor 1 的初步用户指南</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Roland Silver）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">Mitre 技术报告（1966 年 12 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/monitor1.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1962 年至 1965 年间，我在研究生院期间在 Mitre 公司暑期兼职工作。我想我在那里写了三到四份技术报告，但这似乎是 Mitre 图书馆唯一的一份。</font><font style="vertical-align:inherit">我在 Mitre 的大部分时间都花在了为一台名为 Phoenix 的计算机开发操作系统上。</font><font style="vertical-align:inherit">这是操作系统的手册，显然是 Silver 根据我们俩所做的工作编写的。</font><font style="vertical-align:inherit">这里没有任何技术兴趣，但它提供了 20 世纪 60 年代初期计算机世界正在发生的事情的快照。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="monitor1"><b>Preliminary User's Guide to
Monitor&nbsp;1</b>&nbsp; (with Roland Silver)<br>Mitre Technical Report
(December 1966).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/monitor1.pdf">PDF</a><hr>


While in graduate school, I worked summers and part-time at the Mitre
Corporation from 1962 to 1965.&nbsp; I think I wrote three or four
technical reports there, but this is the only one the Mitre library
seems to have.&nbsp; A large part of my time at Mitre was spent working on
the operating system for a computer being built there called Phoenix.&nbsp;
This is the operating system's manual, apparently written by Silver
based on work we had both done.&nbsp; There is nothing of technical
interest here, but it provides a snapshot of what was going on in the
world of computers in the early 60s.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="advanced-calculus"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">无标题的高级微积分文本草稿</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未出版（</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">约</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1967 年）。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1965-1969 学年，我在万宝路学院教数学。</font><font style="vertical-align:inherit">我不记得这个项目是何时或如何开始的，但我为 Prentice-Hall 写了一本高级微积分教科书的初稿，我从他那里收到了 500 美元的预付款。</font><font style="vertical-align:inherit">（这笔钱现在看来小得可笑，但当时却占了我工资的很大一部分。） 普伦蒂斯霍尔的审稿人喜欢这份草案。</font><font style="vertical-align:inherit">我记得一位审稿人评论说，外代数这一章让他第一次对这个主题有了直观的理解。</font><font style="vertical-align:inherit">然而，由于一封显然在邮件中丢失的信，普伦蒂斯霍尔编辑和我都认为对方已经对该项目失去了兴趣。</font><font style="vertical-align:inherit">等到这个误会解除之后，</font><font style="vertical-align:inherit">我已经准备好继续做其他事情，但不想写最终稿。</font><font style="vertical-align:inherit">（那是在计算机文本处理时代之前，所以写一份新草稿意味着完全重新打字数百页的手稿。）&nbsp;


</font></font><br>&nbsp;<p></p></a></li><li> <a name="advanced-calculus"><b>Untitled Draft of Advanced 
    Calculus Text</b><br>Unpublished (<i>circa</i> 1967).<br>
No electronic version available.<hr>


During the 1965-1969 academic years, I taught math at Marlboro
College.&nbsp; I don't remember exactly when or how the project got
started, but I wrote the first draft of an advanced calculus textbook
for Prentice-Hall, from whom I received an advance of 500
dollars.&nbsp; (That sum, which seems ridiculously small now, was a
significant fraction of my salary at the time.)&nbsp; The Prentice-Hall
reviewers liked the draft.&nbsp; I remember one reviewer commenting that
the chapter on exterior algebra gave him, for the first time, an
intuitive understanding of the topic.&nbsp; However, because of a letter
that was apparently lost in the mail, the Prentice-Hall editor and I
both thought that the other had lost interest in the project.&nbsp; By the
time this misunderstanding had been cleared up, I was ready to move on
to other things and didn't feel like writing a final draft.&nbsp; (This was
before the days of computer text processing, so writing a new draft
meant completely retyping hundreds of pages of manuscript.)&nbsp;


<br>&nbsp;<p></p></a></li><li><a name="advanced-calculus"> </a><a name="geometry-of-space-time"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">空间和时间的几何</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未出版（</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">约</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1968 年）。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1965 年至 1969 年间，我在万宝路学院教授数学，该学院每周为公众举办一系列讲座，每次讲座均由一名教职人员或受教职人员邀请的外部演讲者进行。</font><font style="vertical-align:inherit">我做了一个关于相对论的讲座，后来我把它变成了这本简短的专着。</font><font style="vertical-align:inherit">我半心半意地试图出版它，但没有成功。</font><font style="vertical-align:inherit">但它太短（75页），不可能是一本“真正的”书，而且六十年代末公众对科学兴趣不大。</font><font style="vertical-align:inherit">我认为这本专着仍然是对这个主题的很好的阐述。</font><font style="vertical-align:inherit">不幸的是，关于广义相对论的后半部分已经过时了，因为它没有提到黑洞。</font><font style="vertical-align:inherit">虽然黑洞出现在广义相对论方程最早的数学解中，&nbsp;


</font></font><br>&nbsp;<p></p></a></li><li><a name="advanced-calculus"> </a><a name="geometry-of-space-time"><b>The Geometry of Space and Time</b><br>Unpublished
(<i>circa</i> 1968).<br>
No electronic version available.<hr>


Marlboro College, where I taught math from 1965-1969, had a weekly
series of lectures for the general public, each given by a faculty
member or an outside speaker invited by a faculty member.&nbsp; I gave a
lecture about relativity that I later turned into this short
monograph.&nbsp; I made a half-hearted, unsuccessful effort to get it
published.&nbsp; But it was too short (75 pages) to be a "real" book, and
there was very little interest in science among the general public in
the late sixties.&nbsp; I think this monograph is still a very good
exposition of the subject.&nbsp; Unfortunately, the second half, on general
relativity, is obsolete because it says nothing about black holes.&nbsp;
While black holes appear in the earliest mathematical solutions to the
equations of general relativity, it was only in the late 60s that many
physicists began seriously to consider that they might exist and to
study their properties.&nbsp;


<br>&nbsp;<p></p></a></li><li><a name="geometry-of-space-time"> </a><a name="hash"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">对贝尔二次商算法的评论</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 通讯 13</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 9 （1970 年 9 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/hash.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1970 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇简短的说明描述了我在 James Bell 发布的哈希表算法中注意到的一个轻微的低效率问题。</font><font style="vertical-align:inherit">这让我开始思考哈希表，我发明了所谓的线性商算法——回想起来，这种算法似乎非常明显。</font><font style="vertical-align:inherit">当我运行模拟来收集有关该算法的论文的数据时，最新一期的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">发布了 Bell 和 Charles Kaman 发表的题为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">“线性商哈希代码”</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的论文。</font><font style="vertical-align:inherit">我设计了该算法的三种变体，但未包含在他们的文章中。</font><font style="vertical-align:inherit">因此，我写了一篇关于这三个变体的论文并将其提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">编辑拒绝了它，没有将其发送出去进行审阅，称其贡献太小，不值得发表。</font><font style="vertical-align:inherit">在接下来的几年里，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">发表了其他人关于该主题的两篇论文，每一篇都完全致力于我的三个变体之一。</font><font style="vertical-align:inherit">（这些论文已提交给不同的编辑。）我的论文可能是马萨诸塞州计算机协会（Compass）的技术报告，但已经丢失了。</font><font style="vertical-align:inherit">（Compass 几年前停业了，我推测它的库已被破坏。）线性商方法可能是当今最常用的哈希编码算法。&nbsp;

</font></font><br>&nbsp;<p></p></li><li><a name="geometry-of-space-time"> </a><a name="hash"><b>Comment on Bell's Quadratic Quotient 
Algorithm</b><br><i>Communications of the ACM 13</i>, 9 &nbsp; (September 1970).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/hash.pdf">PDF</a>
<br><font size="-2">Copyright © 1970 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This short note describes a minor inefficiency I noticed in a
hash-table algorithm published by James Bell.&nbsp; It got me thinking
about hash tables, and I invented what I called the linear quotient
algorithm--an algorithm that seems quite obvious in retrospect.&nbsp;
While I was running simulations to gather data for a paper on that
algorithm, the latest issue of <i>CACM</i> arrived with a paper by
Bell and Charles Kaman titled <i>The Linear Quotient Hash Code</i>.&nbsp; I
had devised three variants of the algorithm not contained in their
article.&nbsp; So, I wrote a paper about those three variants and submitted
it to <i>CACM</i>.&nbsp; The editor rejected it, without sending
it out for review, saying that it was too small a contribution to
merit publication.&nbsp; In the next few years, <i>CACM</i> published two
papers by others on the subject, each completely devoted to one of my
three variants.&nbsp; (Those papers had been submitted to different
editors.)&nbsp; My paper, which was probably a Massachusetts Computer
Associates (Compass) technical report, has been lost.&nbsp; (Compass went
out of business a few years ago, and I presume that its library was
destroyed.)&nbsp; The linear quotient method is probably the most common
hash-coding algorithm used today.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="thesis"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">奇异数据的解析柯西问题</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">博士 </font><font style="vertical-align:inherit">论文，布兰迪斯大学（1972）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/thesis.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1969 年，我离开万宝路学院，回到布兰迪斯完成博士学位。</font><font style="vertical-align:inherit">当时我打算研究并写一篇数学物理方面的论文。</font><font style="vertical-align:inherit">然而，我最终写了一篇关于解析偏微分方程的纯数学论文。</font><font style="vertical-align:inherit">除了我的论文研究所需的知识之外，我对解析偏微分方程一无所知，从那以后我再也没有看过它们。</font><font style="vertical-align:inherit">这篇论文本身就是一篇小而扎实的非常经典的数学文章。</font><font style="vertical-align:inherit">如果柯西从坟墓里起来读这本书，他一定不会发现数学中有什么陌生的地方。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="thesis"><b>The Analytic Cauchy Problem with Singular 
Data</b><br>Ph.D. Thesis, Brandeis University (1972).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/thesis.pdf">PDF</a><hr>


I left Marlboro College and went back to Brandeis in 1969 to complete
my Ph.D.&nbsp; At that time, I intended to study and write a
thesis in mathematical physics.&nbsp; However, I wound up doing a thesis in
pure mathematics, on analytic partial differential equations.&nbsp; I
learned nothing about analytic partial differential equations except
what was needed for my thesis research, and I have never looked at
them since then.&nbsp; The thesis itself was a small, solid piece of very
classical math.&nbsp; Had Cauchy arisen from the grave to read it, he would
have found nothing unfamiliar in the mathematics.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="thesis-note"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Hamada 定理关于带有奇异数据的柯西问题的扩展</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Amer 公告。</font><font style="vertical-align:inherit">数学。</font><font style="vertical-align:inherit">学会 79，4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1973 年 7 月），776-780。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/thesis-note.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">




当时，或许直到今天，一名数学系学生通过在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">AMS 公报上</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的简短说明中宣布他的（很少是她的）论文结果，对其论文结果进行了“版权保护” 。</font><font style="vertical-align:inherit">通常情况下，完整的论文会在稍后发表。</font><font style="vertical-align:inherit">但我从未这样做过，因为我在完成论文后离开了数学专业，转向了计算机科学。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="thesis-note"><b>An Extension of a Theorem of Hamada on the Cauchy
Problem with Singular Data</b><br><i>Bulletin of the Amer.&nbsp; Math.&nbsp; Society 79</i>, 4 (July 1973), 776-780.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/thesis-note.pdf">PDF</a><hr>




At the time, and perhaps still today, a math student "copyrighted"
his (seldom her) thesis results by announcing them in a short note in
the <i>Bulletin of the AMS</i>.&nbsp; Normally, a complete paper
would be published later.&nbsp; But I never did that, since I left math for
computer science after completing my thesis.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="coordinate"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">DO 循环并行执行的协调方法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1973 年 Sagamore 并行处理会议论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，T. Feng 编辑，1-12。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Compass（马萨诸塞州计算机协会）签订了一份为 Illiac-IV 计算机编写 Fortran 编译器的合同，该计算机是一台具有 64 个处理器的阵列计算机，所有处理器都在单个指令流上以锁步方式运行。</font><font style="vertical-align:inherit">我开发了在编译器使用的阵列计算机上并行执行顺序 DO 循环的理论和相关算法。</font><font style="vertical-align:inherit">这个理论非常简单。</font><font style="vertical-align:inherit">创造力在于对问题的正确数学表述。</font><font style="vertical-align:inherit">今天，这将被认为是一项相当初级的工作。</font><font style="vertical-align:inherit">但在那些日子里，我们并不擅长将数学应用于编程问题。</font><font style="vertical-align:inherit">事实上，当我为 Compass 的同事写下我的工作的完整描述时，他们似乎将其视为神圣的文本，需要精神启蒙来解释线性代数的神秘奥秘。&nbsp;

</font></font></a><p><a name="coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">
不管怎样，这篇论文是我第一次写出该理论的完整版本并发表。</font><font style="vertical-align:inherit">我强烈怀疑它从未被读过。</font><font style="vertical-align:inherit">似乎没有人注意到，由于文本编辑错误，算法的描述缺少了说明什么可以并行执行的妙语。</font><font style="vertical-align:inherit">本文已被未发表的</font></font></a><a href="#coord-method"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[20]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">取代。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="coordinate"><b>The Coordinate Method for the Parallel
Execution of DO Loops</b><br><i>Proceedings of the 1973 Sagamore
Conference on Parallel Processing</i>, T. Feng, ed., 1-12.<br>
No electronic version available.<hr>


Compass (Massachusetts Computer Associates) had a contract to write
the Fortran compiler for the Illiac-IV computer, an array computer
with 64 processors that all operated in lock-step on a single
instruction stream.&nbsp; I developed the theory and associated algorithms
for executing sequential DO loops in parallel on an array computer
that were used by the compiler.&nbsp; The theory is pretty straightforward.&nbsp;
The creativity lay in the proper mathematical formulation of the
problem.&nbsp; Today, it would be considered a pretty elementary piece of
work.&nbsp; But in those days, we were not as adept at applying math to
programming problems.&nbsp; Indeed, when I wrote up a complete description
of my work for my colleagues at Compass, they seemed to treat it as a
sacred text, requiring spiritual enlightenment to interpret the occult
mysteries of linear algebra.&nbsp;

</a><p><a name="coordinate">
Anyway, this paper was my first pass at writing up the complete
version of the theory for publication.&nbsp; I strongly suspect that it has
never been read.&nbsp; No one seems to have noticed that, because of a
text-editing error, the description of the algorithm is missing the
punch line that says what can be executed in parallel.&nbsp; This paper is
superseded by the unpublished </a><a href="#coord-method">[20]</a>.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="do-loops"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">DO 循环的并行执行</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 的通信 17</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1974 年 2 月）, 83-93。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/do-loops.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1974 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[9]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


描述中提到的工作中唯一发表的期刊论文</font><font style="vertical-align:inherit">。</font></font><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它本质上包含[9]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中单个紧密嵌套循环的</font><font style="vertical-align:inherit">结果的特殊情况。</font><font style="vertical-align:inherit">这是有关该主题的早期文章之一，我相信它被经常引用。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="do-loops"><b>The Parallel Execution of DO Loops</b><br><i>Communications of the ACM 17</i>, 2 &nbsp;
(February 1974), 83-93.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/do-loops.pdf">PDF</a>
<br><font size="-2">Copyright © 1974 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This is the only journal paper to come out of the work mentioned in
the description of <a href="#coordinate">[9]</a>.&nbsp; It contains essentially the
special case of the results in <a href="#coordinate">[9]</a> for a single tight
nesting of loops.&nbsp; It was one of the early articles on the topic, and
I believe it was cited fairly often.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="hyperplane"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">阵列计算机的超平面方法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1974 年 Sagamore 并行处理会议论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，T. Feng 编辑，Springer Verlag，1-12。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


19世纪末，范德比尔特家族（美国富裕家族）在纽约州阿迪朗达克山脉中部拥有500公顷美丽的土地，其中包括长约一公里的萨加莫尔湖。</font><font style="vertical-align:inherit">他们在那里建造了一座质朴的夏季庄园。</font><font style="vertical-align:inherit">在 70 年代，也许直到今天，这个地方完全与世隔绝，远离任何其他文明的迹象。</font><font style="vertical-align:inherit">该庄园拥有土地和湖泊，被赠予雪城大学，该大学将其作为会议中心运营。</font><font style="vertical-align:inherit">1973 年夏末到 1975 年，在那里举行了一次关于并行处理的年度会议。萨加莫尔是我见过的最美丽的会议地点。</font><font style="vertical-align:inherit">这次会议还不错，有一些优秀的人参加，尽管不是一流的。</font><font style="vertical-align:inherit">但我会忍受一场关于中世纪神学的会议，以获得划独木舟的机会，&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
为了证明我出席萨加莫尔的合理性，我总是提交一篇论文。</font><font style="vertical-align:inherit">但当我发现这不是一流的会议时，我就没有提交一流的论文。</font><font style="vertical-align:inherit">但是，我不会重新发布旧材料（除非有必要避免强迫人们阅读早期论文），因此本文必定包含一些有关并行顺序循环超平面方法的新结果。</font><font style="vertical-align:inherit">然而，我找不到这份文件的副本，也不记得里面写了什么。&nbsp;


</font></font><br>&nbsp;</p><p></p></a></li><li> <a name="hyperplane"><b>The Hyperplane Method for an Array
   Computer</b><br><i>Proceedings of the 1974 Sagamore Conference on
   Parallel Processing</i>, T. Feng, ed., Springer Verlag, 1-12.<br>
No electronic version available.<hr>


In the late 19th century, the Vanderbilts (a rich American family)
owned 500 hectares of beautiful land in the central Adirondack
Mountains of New York State that included Sagamore Lake, which is
about a kilometer in length.&nbsp; There, they built a rustic summer
estate.&nbsp; In the 70s, and probably still today, the place was
completely isolated, away from any other signs of civilization.&nbsp; The
estate, with land and lake, was given to Syracuse University,
which operated it as a conference center.&nbsp; An annual conference on
parallel processing was held there late in the summers of 1973 through
1975.&nbsp; Sagamore was the most beautiful conference site I have ever
seen.&nbsp; The conference wasn't bad, with a few good people attending,
though it wasn't first rate.&nbsp; But I would have endured a conference on
medieval theology for the opportunity to canoe on, swim in, and walk
around the lake.&nbsp;

<p> 
To justify my attendance at Sagamore, I always submitted a paper.&nbsp;
But once I discovered that it was not a first-rate conference, I did not
submit first-rate papers.&nbsp; However, I don't republish old material
(except as necessary to avoid forcing people to read earlier papers),
so this paper must have included some new results about the hyperplane
method for parallelizing sequential loops.&nbsp; However, I can't find a
copy of the paper and don't remember what was in it.&nbsp;


<br>&nbsp;</p><p></p></a></li><li><a name="hyperplane"> </a><a name="bakery"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Dijkstra 并发编程问题的新解决方案</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 通讯 17</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 8 (1974 年 8 月), 453-455。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/bakery.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1974 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文描述了实现互斥的面包店算法。</font><font style="vertical-align:inherit">我发明了很多并发算法。</font><font style="vertical-align:inherit">我觉得面包店算法不是我发明的，是我发现的。</font><font style="vertical-align:inherit">与所有共享内存同步算法一样，bakery 算法要求一个进程能够在另一个进程写入内存字时读取该内存字。</font><font style="vertical-align:inherit">（每个内存位置仅由一个进程写入，因此永远不会发生并发写入。）与任何先前的算法以及几乎所有后续算法不同，面包房算法无论与写入重叠的读取获得什么值，都会起作用。</font><font style="vertical-align:inherit">如果写入将值从 0 更改为 1，则并发读取可以获得值 7456（假设 7456 是可能位于内存位置的值）。</font><font style="vertical-align:inherit">该算法仍然有效。</font><font style="vertical-align:inherit">我没有尝试设计具有此属性的算法。</font><font style="vertical-align:inherit">在编写了其正确性的证明并注意到该证明并不取决于与写入重叠的读取返回的值后，我发现面包店算法具有此属性。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
不知道有多少人意识到这个算法有多么的了不起。</font><font style="vertical-align:inherit">也许比任何人都更清楚地认识到这一点的是马萨诸塞州计算机协会的前同事阿纳托尔·霍尔特。</font><font style="vertical-align:inherit">当我向他展示算法及其证明并指出其惊人的特性时，他感到震惊。</font><font style="vertical-align:inherit">他拒绝相信这可能是真的。</font><font style="vertical-align:inherit">他没发现我的证明有什么问题，但他确信一定有缺陷。</font><font style="vertical-align:inherit">那天晚上他离开时决心要找到它。</font><font style="vertical-align:inherit">我不知道他什么时候终于接受了算法的正确性。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
有几本书包含了该算法的阉割版本，其中读取和写入是原子操作，并将这些版本称为“面包店算法”。</font><font style="vertical-align:inherit">我觉得这很可悲。</font><font style="vertical-align:inherit">发布简化版并没有什么问题，只要叫简化版就可以了。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
Bakery 算法的重要之处在于它实现了互斥，而不依赖于任何较低级别的互斥。</font><font style="vertical-align:inherit">假设对内存位置的读取和写入是原子操作，正如之前的互斥算法所做的那样，相当于假设对该位置的互斥访问。</font><font style="vertical-align:inherit">因此，假设原子读写的互斥算法是假设较低级别的互斥。</font><font style="vertical-align:inherit">这样的算法并不能真正说解决了互斥问题。</font><font style="vertical-align:inherit">在面包店算法出现之前，人们认为互斥问题是无法解决的——只有使用较低级别的互斥才能实现互斥。</font><font style="vertical-align:inherit">Brinch Hansen 在 1972 年的一篇论文中准确地说了这一点。</font><font style="vertical-align:inherit">许多人显然仍然相信这一点。</font><font style="vertical-align:inherit">（参见
</font></font><a href="#lamport-mutual-solved"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[91]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。）&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
论文本身并没有声明它是一个“真正的”互斥算法。</font><font style="vertical-align:inherit">这表明我直到后来才意识到该算法的全部意义，但我不记得了。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
在我发现面包店算法几年后，我学到的关于并发的一切都来自于对它的研究。</font></font><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[25]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><a href="#new-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[33]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><a href="#interprocess"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[70]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">等论文</font><font style="vertical-align:inherit">
是该研究的直接结果。</font><font style="vertical-align:inherit">在面包店算法中，我还引入了属于进程的变量的概念，即可以由多个进程读取但只能由单个进程写入的变量。</font><font style="vertical-align:inherit">我从一开始就意识到此类算法具有简单的分布式实现，其中变量驻留在拥有进程中，其他进程通过向所有者发送消息来读取它。</font><font style="vertical-align:inherit">于是，面包店算法标志着我研究分布式算法的开始。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
该论文包含一个小但重要的错误。</font><font style="vertical-align:inherit">在脚注中，它声称我们可以将单个位的读取和写入视为原子的。</font><font style="vertical-align:inherit">它认为，与写入重叠的读取必须获得两个可能值之一；</font><font style="vertical-align:inherit">如果它得到旧值，我们可以认为读取在写入之前，否则就在写入之后。</font><font style="vertical-align:inherit">直到后来，随着
</font></font><a href="#interprocess"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[70]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中最终描述的工作，我才意识到这种推理的谬误。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li><a name="hyperplane"> </a><a name="bakery"><b>A New Solution of Dijkstra's Concurrent Programming
   Problem</b><br><i>Communications of the ACM 17</i>, 8 &nbsp; (August 1974), 453-455.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/bakery.pdf">PDF</a>
<br><font size="-2">Copyright © 1974 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper describes the bakery algorithm for implementing mutual
exclusion.&nbsp; I have invented many concurrent algorithms.&nbsp; I feel that I
did not invent the bakery algorithm, I discovered it.&nbsp; Like all
shared-memory synchronization algorithms, the bakery algorithm
requires that one process be able to read a word of memory while
another process is writing it.&nbsp; (Each memory location is written by
only one process, so concurrent writing never occurs.)&nbsp; Unlike any
previous algorithm, and almost all subsequent algorithms, the bakery
algorithm works regardless of what value is obtained by a read that
overlaps a write.&nbsp; If the write changes the value from 0 to 1, a
concurrent read could obtain the value 7456 (assuming that 7456 is a
value that could be in the memory location).&nbsp; The algorithm still
works.&nbsp; I didn't try to devise an algorithm with this property.&nbsp; I
discovered that the bakery algorithm had this property after writing a
proof of its correctness and noticing that the proof did not depend on
what value is returned by a read that overlaps a write.&nbsp;

<p> 
I don't know how many people realize how remarkable this
algorithm is.&nbsp; Perhaps the person who realized it better than anyone
is Anatol Holt, a former colleague at Massachusetts Computer
Associates.&nbsp; When I showed him the algorithm and its proof and pointed
out its amazing property, he was shocked.&nbsp; He refused to believe it
could be true.&nbsp; He could find nothing wrong with my proof, but he was
certain there must be a flaw.&nbsp; He left that night determined to find
it.&nbsp; I don't know when he finally reconciled himself to the
algorithm's correctness.&nbsp;

</p><p>
Several books have included emasculated versions of the algorithm in
which reading and writing are atomic operations, and called those
versions "the bakery algorithm".&nbsp; I find that deplorable.&nbsp; There's
nothing wrong with publishing a simplified version, as long as it's
called a simplified version.&nbsp;

</p><p>
What is significant about the bakery algorithm is that it implements
mutual exclusion without relying on any lower-level mutual exclusion.&nbsp;
Assuming that reads and writes of a memory location are atomic
actions, as previous mutual exclusion algorithms had done, is
tantamount to assuming mutually exclusive access to the location.&nbsp; So
a mutual exclusion algorithm that assumes atomic reads and writes is
assuming lower-level mutual exclusion.&nbsp; Such an algorithm cannot
really be said to solve the mutual exclusion problem.&nbsp; Before the
bakery algorithm, people believed that the mutual exclusion problem
was unsolvable--that you could implement mutual exclusion only by
using lower-level mutual exclusion.&nbsp; Brinch Hansen said exactly this
in a 1972 paper.&nbsp; Many people apparently still believe it.&nbsp; (See
<a href="#lamport-mutual-solved">[91]</a>.)&nbsp;

</p><p> 
The paper itself does not state that it is a "true" mutual exclusion
algorithm.&nbsp; This suggests that I didn't realize the full significance
of the algorithm until later, but I don't remember.&nbsp;

</p><p> 
For a couple of years after my discovery of the bakery algorithm,
everything I learned about concurrency came from studying it.&nbsp; Papers
like <a href="#rd-wr">[25]</a>, <a href="#new-approach">[33]</a>, and <a href="#interprocess">[70]</a>
were direct results of that study.&nbsp; The bakery algorithm was also
where I introduced the idea of variables belonging to a process--that
is, variables that could be read by multiple processes, but written by
only a single process.&nbsp; I was aware from the beginning that such
algorithms had simple distributed implementations, where the variable
resides at the owning process, and other processes read it by sending
messages to the owner.&nbsp; Thus, the bakery algorithm marked the
beginning of my study of distributed algorithms.&nbsp;

</p><p> 
The paper contains one small but significant error.&nbsp; In a
footnote, it claims that we can consider reads and writes of a single
bit to be atomic.&nbsp; It argues that a read overlapping a write must
get one of the two possible values; if it gets the old value, we can
consider the read to have preceded the write, otherwise to have
followed it.&nbsp; It was only later, with the work eventually described in
<a href="#interprocess">[70]</a>, that I realized the fallacy in this reasoning.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="on-self-stabilizing-systems"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于自稳定系统</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">马萨诸塞州计算机协会技术报告 CA 7412-0511（1974 年 12 月 5 日）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/on-self-stabilizing-systems.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文是在阅读 Dijkstra 的经典论文“Self-stabilizing Systems in Spite of Distributed Control”后撰写的，该论文发表在 1974 年 11 月的CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">


上</font><font style="vertical-align:inherit">（参见
</font></font><a href="#solved-and-unsolved"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[58]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">它将 Dijkstra 论文中的算法之一从一行进程推广到任意进程树。</font><font style="vertical-align:inherit">它还讨论了面包店算法的自稳定特性。</font><font style="vertical-align:inherit">我从未尝试发表这篇笔记——可能是因为我认为它太小了，不值得单独写一篇论文。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

注释中包含一句有趣的句子：“面包店算法有一个复杂的修改版本，其中所有变量的值都是有界的。” </font><font style="vertical-align:inherit">我从未写下那个版本，我不确定我的想法是什么。</font><font style="vertical-align:inherit">但我想我大致在考虑以下修改。</font><font style="vertical-align:inherit">当进程等待进入其临界区时，它会不断减少其数量，直到其数量等于 1 时才会进入临界区。</font><font style="vertical-align:inherit">进程</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">最多可以将其编号减少 1，并且仅当下一个编号较小的进程的编号比</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的编号至少小 2，并且下一个编号较高的进程在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">p</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的编号之一以内时。</font><a href="#rd-wr"><font style="vertical-align:inherit">我想我打算使用[25]</font></a><font style="vertical-align:inherit">的技术</font></font><a href="#rd-wr"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">允许数字的读写保持非原子性，同时保持等待进程的顺序。</font><font style="vertical-align:inherit">（如果最终所有进程都停止更改其数字，那么所有进程最终都会读取正确的数字，从而允许某些进程继续进行。）有一次，我说服自己这个算法是正确的。</font><font style="vertical-align:inherit">但我从来没有写过严格的证明，所以我不知道它是否真的有效。</font><font style="vertical-align:inherit">填写细节并证明正确性应该是一个很好的练习。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="on-self-stabilizing-systems"><b>On Self-stabilizing
Systems</b><br>Massachusetts Computer Associates Technical Report CA
7412-0511 (5 December 1974).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/on-self-stabilizing-systems.pdf">PDF</a><hr>


This note was written upon reading Dijkstra's classic paper
"Self-stabilizing Systems in Spite of Distributed Control" that
appeared in the November 1974 issue of <i>CACM</i> (see
<a href="#solved-and-unsolved">[58]</a>).&nbsp; It generalizes one of the algorithms
in Dijkstra's paper from a line of processes to an arbitrary tree of
processes.&nbsp; It also discusses the self-stabilizing properties of the
bakery algorithm.&nbsp; I never tried to publish this note--probably
because I regarded it as too small a piece of work to be worth a paper
by itself.&nbsp;

<p>

The note contains the intriguing sentence: "There is a complicated
modified version of the bakery algorithm in which the values of all
variables are bounded." I never wrote down that version, and I'm not
sure what I had in mind.&nbsp; But I think I was thinking of roughly the
following modification.&nbsp; As a process waits to enter its critical
section, it keeps reducing its number, not entering the critical
section until its number equals one.&nbsp; A process <i>p</i> can reduce
its number by at most one, and only when the next lower-numbered
process's number is at least two less than <i>p</i>'s number, and the
next higher-numbered process is within one of <i>p</i>'s number.&nbsp; I
think I intended to use the techniques of <a href="#rd-wr">[25]</a> to allow
reading and writing of numbers to remain non-atomic while maintaining
the order of waiting processes.&nbsp; (If eventually all processes stop
changing their numbers, then all processes will eventually read the
correct numbers, allowing some process to progress.)&nbsp; At one time, I
convinced myself that this algorithm is correct.&nbsp; But I never wrote a
rigorous proof, so I don't know if it really works.&nbsp; Filling in the
details and proving correctness should be a nice exercise.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="prog-parallel"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于并行计算机编程 并行</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和向量机编程语言和编译器会议的会议记录</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，作为
   </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGPLAN 公告 10、3</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1975 年 3 月）、25-33 出版。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/prog-parallel.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是一份主张使用高级语言来表达必须计算什么而不是如何计算的立场文件。</font><font style="vertical-align:inherit">它认为编译器在为并行机生成高效代码方面比人类更好。</font><font style="vertical-align:inherit">那时的我真是太天真了！</font><font style="vertical-align:inherit">我很快就了解到编译器到底有多糟糕，以及如何试图让它们变得更聪明只会让它们变得更加错误。</font><font style="vertical-align:inherit">但编译器作者已经进步很多了，所以也许这篇论文现在不再像以前那么愚蠢了。&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="prog-parallel"><b>On Programming Parallel
   Computers</b><br><i>Proceedings of a Conference on Programming Languages
   and Compilers for Parallel and Vector Machines</i>, published as
   <i>ACM SIGPLAN Notices 10</i>, 3 (March 1975), 25-33.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/prog-parallel.pdf">PDF</a><hr>


This is a position paper advocating the use of a higher-level language
that expresses what must be computed rather than how it is to be
computed.&nbsp; It argues that compilers are better than humans at
generating efficient code for parallel machines.&nbsp; I was so naive then!
I soon learned how bad compilers really were, and how trying to make
them smarter just made them buggier.&nbsp; But compiler writers have gotten
a lot better, so maybe this paper isn't as stupid now as it was then.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="parallel-execution"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">阵列和向量计算机上的并行执行</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1975 年 Sagamore 并行处理会议论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，T. Feng 编辑，187-191。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文考虑了当参数值多于处理器数量时有效执行一系列显式并行语句（需要同时执行参数的所有值的语句）的问题。</font><font style="vertical-align:inherit">这是我为萨加莫尔会议保存的较少的论文之一。</font></font></a><a href="#hyperplane"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（参见[11]</font></font></a><font style="vertical-align:inherit"><a name="parallel-execution"><font style="vertical-align:inherit">的讨论</font></a><font style="vertical-align:inherit">。）&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="parallel-execution"><b>Parallel Execution on Array and Vector
   Computers</b><br><i>Proceedings of the 1975 Sagamore Conference on
   Parallel Processing</i>, T. Feng, ed., 187-191.<br>
No electronic version available.<hr>


This paper considers the problem of efficiently executing a sequence
of explicitly parallel statements--ones requiring simultaneous
execution for all values of a parameter--when there are more
parameter values than there are processors.&nbsp; It is one of the lesser
papers that I saved for the Sagamore Conference.&nbsp; (See the discussion
of </a><a href="#hyperplane">[11]</a>.)&nbsp;


<br>&nbsp;<p></p></li><li> <a name="multiple-byte"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用全字指令进行多字节处理</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 通信 18</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 8（1975 年 8 月）, 471-475。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/multiple-byte.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1975 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我的并行循环算法，在以</font></font><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[9]开头的论文中进行了描述</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，效率相当低。</font><font style="vertical-align:inherit">它们可以通过在 Illiac-IV 等阵列处理器上并行执行来加速。</font><font style="vertical-align:inherit">但我意识到，甚至可以比 Illiac 64 处理器提供的 64 倍加速更好。</font><font style="vertical-align:inherit">每个被操作的数据只有几个位，因此我想到将多个数据打包到一个字中并同时操作它们。</font><font style="vertical-align:inherit">这不仅可以加快 Illiac 上的计算速度，而且还允许人们在普通的单处理器上进行数组处理。</font><font style="vertical-align:inherit">本文描述了对打包数据进行此类并行计算的一般技术。</font><font style="vertical-align:inherit">这是一个巧妙的技巧，而且现在比以前更有用，原因有两个。</font><font style="vertical-align:inherit">明显的原因是现在字大小变大了，许多计算机都有 64 位字。</font><font style="vertical-align:inherit">不太明显的原因是条件操作是通过屏蔽而不是分支来实现的。</font><font style="vertical-align:inherit">当不满足条件时，不会在操作中分支，而是构造掩码，以便仅对条件为真的那些数据项执行操作。</font><font style="vertical-align:inherit">现代多发行计算机上的分支比 70 年代的计算机上的分支成本更高。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="multiple-byte"><b>Multiple Byte Processing with Full-Word
   Instructions</b><br><i>Communications of the ACM 18</i>, 8 &nbsp; (August 1975), 471-475.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/multiple-byte.pdf">PDF</a>
<br><font size="-2">Copyright © 1975 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


My algorithms for parallelizing loops, described in papers starting
with <a href="#coordinate">[9]</a>, were rather inefficient.&nbsp; They could be sped
up with parallel execution on an array processor like the
Illiac-IV.&nbsp; But I realized one could do even better than the
64-times speedup provided by the Illiac's 64 processors.&nbsp; Each datum
being manipulated was just a few bits, so I had the idea of packing
several of the data into a single word and manipulating them
simultaneously.&nbsp; Not only could this speed computation on the Illiac,
but it allowed one to do array processing on an ordinary uniprocessor.&nbsp;
This paper describes general techniques for doing such parallel
computation on packed data.&nbsp; It's a neat hack, and it's more useful
now than it was then for two reasons.&nbsp; The obvious reason is that word
size is larger now, with many computers having 64-bit words.&nbsp; The less
obvious reason is that conditional operations are implemented with
masking rather than branching.&nbsp; Instead of branching around the
operation when the condition is not met, masks are constructed so the
operation is performed only on those data items for which the
condition is true.&nbsp; Branching is more costly on modern multi-issue
computers than it was on the computers of the 70s.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="synchronization"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">独立进程的同步</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Acta Informatica 7</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (1976), 15-34。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/synchronization.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


有一类同步问题是互斥的直接概括，因为它们对何时允许进程执行任务断言约束。</font><font style="vertical-align:inherit">它们包括哲学家就餐问题和读者/作家问题。</font><font style="vertical-align:inherit">本文展示了如何使用面包店算法的修改版本来解决任何此类问题。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
一位裁判员在谈到最初提交的证明时表示，证明太长，证明显而易见的事情很乏味。</font><font style="vertical-align:inherit">事实上，最初的版本存在一个错误，这些明显的证据中至少有一个是错误的陈述。</font><font style="vertical-align:inherit">不用说，我修正了算法并写了更仔细的证明。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="synchronization"><b>The Synchronization of Independent
   Processes</b><br><i>Acta Informatica 7</i>, 1 (1976), 15-34.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/synchronization.pdf">PDF</a><hr>


There are a class of synchronization problems that are direct
generalizations of mutual exclusion in that they assert constraints on
when a process is allowed to perform a task.&nbsp; They include the dining
philosophers problem and the readers/writers problem.&nbsp; This paper
shows how a modified version of the bakery algorithm can be used to
solve any such problem.&nbsp;

<p>
A referee said of the initial submission that the proofs were too
long, tediously proving the obvious.&nbsp; In fact, there was a bug in the
initial version, and at least one of those obvious proofs was of a
false statement.&nbsp; Needless to say, I corrected the algorithm and wrote
more careful proofs.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="comments"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">对“同步异常”</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">信息处理快报的评论 4、4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1976 年 1 月）、88-89。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是对 Richard Lipton 和 Robert Tuttle 声称发现 Dijkstra 的 P 和 V 同步原语的不足之处的简短说明的评论。</font><font style="vertical-align:inherit">它指出，他们引入了一个转移注意力的方法，因为这些原语无法解决的问题无法用系统内可观察的实体来表示。</font><font style="vertical-align:inherit">正如我的注释所述：“除非系统的正确性仅取决于系统内可观察到的事件和条件，否则系统不可能是正确的。” </font><font style="vertical-align:inherit">这是值得记住的事情，因为我在其他场合也遇到过同样的转移注意力的情况。</font></font></a><a href="#priority"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的观察与[63]</font></font></a><font style="vertical-align:inherit"><a name="comments"><font style="vertical-align:inherit">相关
，但当我写</font></a></font><a href="#priority"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[63]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">时，我已经忘记了这篇笔记</font><font style="vertical-align:inherit">。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="comments"><b>Comments on `A Synchronization
   Anomaly'</b><br><i>Information Processing Letters 4</i>, 4 (January 1976),
   88-89.<br>
No electronic version available.<hr>


This is a comment on a short note by Richard Lipton and Robert Tuttle
claiming to find an inadequacy in Dijkstra's P and V synchronization
primitives.&nbsp; It points out that they had introduced a red herring
because the problem that those primitives couldn't solve could not be
stated in terms of entities observable within the system.&nbsp; As my note
states: "A system cannot be correct unless its correctness depends
only upon events and conditions observable within the system." That's
something worth remembering, since I've encountered that same sort of
red herring on other occasions.&nbsp; My observation is relevant to
</a><a href="#priority">[63]</a>, but I had forgotten all about this note by the time
I wrote <a href="#priority">[63]</a>.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="multi-garbage"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">多进程垃圾收集：并行性练习</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1976 年国际并行处理会议论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，T. Feng 编辑，50-54。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"></font></a><a href="#garbage"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是对[31]</font></font></a><font style="vertical-align:inherit"><a name="multi-garbage"><font style="vertical-align:inherit">


并发垃圾收集算法的一个小扩展</font></a><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">该算法使用与创建垃圾的“变异器”进程并行运行的单个垃圾收集器进程。</font><font style="vertical-align:inherit">本文介绍了如何使用多个进程来进行收集，以及如何处理多个mutator进程。</font><font style="vertical-align:inherit">这是我作为参加萨加莫尔会议的借口而写的一篇小作品。</font></font><a href="#hyperplane"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（参见[11]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论
</font><font style="vertical-align:inherit">。）然而，会议已更名，并从萨加莫尔搬到了密歇根森林中一个不太有吸引力、蚊子肆虐的地点。</font><font style="vertical-align:inherit">这是我最后一次参加。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="multi-garbage"><b>Garbage Collection with Multiple Processes:
   an Exercise in Parallelism</b><br><i>Proceedings of the 1976 International 
   Conference on Parallel Processing</i>, T. Feng, ed., 50-54.<br>
No electronic version available.<hr>


This is a minor extension to the concurrent garbage collection
algorithm of </a><a href="#garbage">[31]</a>.&nbsp; That algorithm uses a single garbage
collector process running in parallel with the "mutator" process
that creates the garbage.&nbsp; This paper describes how to use multiple
processes to do the collection, and how to handle multiple mutator
processes.&nbsp; It is a minor work that I wrote up as an excuse for
going to the Sagamore conference.&nbsp; (See the discussion of
<a href="#hyperplane">[11]</a>.)&nbsp; However, the conference had been renamed and
moved from Sagamore to a less attractive, mosquito-infected site in the
Michigan woods.&nbsp; It was the last time I attended.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="coord-method"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">迭代循环并行执行的协调方法</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布（1976 年 8 月）。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"></font></a><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[9]</font></font></a><font style="vertical-align:inherit"><a name="coord-method"><font style="vertical-align:inherit">


的完全修订版本，包含证明（ </font></a></font><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[9]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中省略了</font><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">我把它提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM ，但</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的编辑</font><font style="vertical-align:inherit">认为它更适合</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">JACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">当我在那里提交时， JACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的编辑</font><font style="vertical-align:inherit">拒绝了它，没有将其送审，因为基本思想已经出现在会议版本中</font></font><a href="#coordinate"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[9]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我当时年轻，经验不足，所以就接受了编辑的决定。</font><font style="vertical-align:inherit">一两年后，当同一会议的一篇论文在
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM上逐字重新发表时，我开始怀疑出了什么问题。</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">当我意识到编辑的决定有多么疯狂时，似乎不值得重新提交论文。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="coord-method"><b>The Coordinate Method for the Parallel Execution of
   Iterative Loops</b><br>Unpublished (August 1976).<br>
No electronic version available.<hr>


This is a totally revised version of </a><a href="#coordinate">[9]</a>, complete
with proofs (which had been omitted from <a href="#coordinate">[9]</a>).&nbsp; I
submitted it to <i>CACM</i>, but the editor of <i>CACM</i> decided
that it was more appropriate for <i>JACM</i>.&nbsp; When I
submitted it there, the editor of <i>JACM</i> rejected it without
sending it out for review because the basic ideas had already appeared
in the conference version <a href="#coordinate">[9]</a>.&nbsp; I was young and
inexperienced, so I just accepted the editor's decision.&nbsp; I began to
suspect that something was amiss a year or two later, when a paper
from the same conference was republished verbatim in
<i>CACM</i>.&nbsp; By the time I realized how crazy the editor's
decision had been, it didn't seem worth the effort of resubmitting the
paper.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="multi-user"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">走向多用户数据库系统正确性理论被</font></font></b><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">1977 年 IFIP 大会</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝</font><font style="vertical-align:inherit"> 
   （1976 年 10 月）。</font><font style="vertical-align:inherit">
没有电子版。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br><font style="vertical-align:inherit"></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">
  

这篇论文只是一些想法的草稿，并非所有想法都是正确的。</font><font style="vertical-align:inherit">我不记得它是如何被知道的，但几年后我收到了索要副本的请求。&nbsp;

</font></font><br>&nbsp;<p></p></a></li><li> <a name="multi-user"><b>Towards a Theory of Correctness for Multi-User
   Data Base Systems</b><br>Rejected by the <i>1977 IFIP Congress</i> 
   (October 1976).<br>
No electronic version available.<hr>
  

This paper was a rough draft of some ideas, not all of which were
correct.&nbsp; I don't remember how it became known, but I received
requests for copies for years afterwards.&nbsp;

<br>&nbsp;<p></p></a></li><li><a name="multi-user"> </a><a name="glitch"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">On the Glitch Phenomenon</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp; （与 Richard Palais 合作）被</font><i><font style="vertical-align:inherit">IEEE Transactions on Computers</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝</font><font style="vertical-align:inherit">（1976 年 11 月）。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/glitch.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/glitch.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/glitch.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


当我写</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">时，马萨诸塞州计算机协会的一位同事指出，面包店算法中假设的单个寄存器的并发读写需要一个仲裁器——一种根据输入做出二元决策的设备，这些输入可能是改变。</font><font style="vertical-align:inherit">20 世纪 70 年代初，计算机设计者重新发现不可能构建一个保证在有限时间内做出决定的仲裁器。</font><font style="vertical-align:inherit">（这一点在 50 年代就已经实现，但已被遗忘。）我同事的观察引起了我对仲裁器问题（有时被称为“故障”问题）的兴趣。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">仲裁器不能具有有限响应时间的基本证明使用连续性来证明，如果有两个输入可以将触发器驱动到两个不同的状态，则必须存在一个使触发器挂起的输入。</font><font style="vertical-align:inherit">当时，很难让别人相信这个论点是有效的。</font><font style="vertical-align:inherit">他们似乎相信，因为触发器只有离散的稳定状态，所以连续性不适用。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我向帕莱描述了仲裁者问题，他曾是我</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">法律上的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文导师，后来成为我的同事和朋友。</font><font style="vertical-align:inherit">他认识到，观察正在发生的事情的正确数学方法是根据触发器行为空间上的紧凑开放拓扑。</font><font style="vertical-align:inherit">因此，我们写这篇论文是为了解释为什么仲裁器表面上不连续的行为在适当的拓扑中实际上是连续的。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这篇论文被</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE Transactions on Computers</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝
，因为审阅它的工程师无法理解数学。</font><font style="vertical-align:inherit">六年后，该杂志显然获得了数学上更加复杂的审稿人，并且发表了一个不太笼统的结果和更复杂的证明。</font><font style="vertical-align:inherit">我相信有人终于发表了一篇关于这个主题的论文，取代了我们的论文。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li><a name="multi-user"> </a><a name="glitch"><b>On the Glitch Phenomenon</b>&nbsp; (with Richard Palais)<br>Rejected
  by <i>IEEE Transactions on Computers</i> (November 1976).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/glitch.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/glitch.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/glitch.pdf">PDF</a><hr>


When I wrote <a href="#bakery">[12]</a>, a colleague at Massachusetts Computer
Associates pointed out that the concurrent reading and writing of a
single register, assumed in the bakery algorithm, requires an
arbiter--a device for making a binary decision based on inputs that
may be changing.&nbsp; In the early 70s, computer designers rediscovered
that it's impossible to build an arbiter that is guaranteed to reach a
decision in a bounded length of time.&nbsp; (This had been realized in the
50s but had been forgotten.)&nbsp; My colleague's observation led to my
interest in the arbiter problem--or "glitch" problem, as it was
sometimes called.&nbsp;

<p> The basic proof that an arbiter cannot have a bounded
response time uses continuity to demonstrate that, if there are two
inputs that can drive a flip-flop into two different states, then
there must exist an input that makes the flip-flop hang.&nbsp; At the time,
it was very difficult to convince someone that this argument was
valid.&nbsp; They seemed to believe that, because a flip-flop has only
discrete stable states, continuity doesn't apply.&nbsp;

</p><p>
I described the arbiter problem to Palais, who had been my <i>de
jure</i> thesis adviser and afterwards became a colleague and a friend.&nbsp;
He recognized that the correct mathematical way to view what was going
on is in terms of the compact-open topology on the space of flip-flop
behaviors.&nbsp; So, we wrote this paper to explain why the apparently
discontinuous behavior of an arbiter is actually continuous in the
appropriate topology.&nbsp;

</p><p>
This paper was rejected by the <i>IEEE Transactions on Computers</i>
because the engineers who reviewed it couldn't understand the
mathematics.&nbsp; Six years later, the journal apparently acquired more
mathematically sophisticated reviewers, and it published a less
general result with a more complicated proof.&nbsp; I believe someone has
finally published a paper on the subject that does supersede ours.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="proving"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明多进程程序的正确性</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE 软件工程汇刊 SE-3，2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1977 年 3 月），125-143。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/proving.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1977 允许个人使用本材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


当我第一次了解互斥问题时，它看起来很简单，而且已发布的算法似乎不必要地复杂。</font><font style="vertical-align:inherit">因此，我草拟了一个简单的算法并将其提交给
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">很快我就收到了裁判的报告，指出了错误。</font><font style="vertical-align:inherit">这有两个影响。</font><font style="vertical-align:inherit">首先，这让我对自己很生气，坐下来想出了一个真正的解决方案。</font><font style="vertical-align:inherit">结果是</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的面包店算法。</font><font style="vertical-align:inherit">第二个作用是引起了我对验证并发算法的兴趣。</font><font style="vertical-align:inherit">这是一个非常实际的兴趣。</font><font style="vertical-align:inherit">我想验证我写的算法。</font><font style="vertical-align:inherit">我认为对我的日常使用不实用的方法不会引起我的兴趣。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

在并行化顺序代码的工作过程中（参见
</font></font><a href="#do-loops"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[10]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">），我本质上重新发现了 Floyd 的方法作为提取程序属性的一种方法。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">当我向一位同事展示我正在做的事情时，他去了我们马萨诸塞州计算机协会的图书馆，给了我一份弗洛伊德经典论文《为程序分配含义》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的原始技术报告版本</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我不记得什么时候读过霍尔的《</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机编程的公理基础》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，但可能是在不久之后。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
70 年代中期，有几个人在思考验证并发程序的问题。</font><font style="vertical-align:inherit">这篇开创性的论文是 Ed Ashcroft 的
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Proving Assertions About Parallel Programs</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，于 1975 年发表在《计算机与系统科学杂志》上。该论文介绍了不变性的基本思想。</font><font style="vertical-align:inherit">我发现了如何使用不变性的思想将弗洛伊德的方法推广到多进程程序。</font><font style="vertical-align:inherit">正如经常出现的情况一样，回想起来，这个想法似乎是完全显而易见的。</font><font style="vertical-align:inherit">然而，我花了一段时间才意识到这一点。</font><font style="vertical-align:inherit">我记得，有一次，我认为证明需要对进程数量进行归纳。&nbsp; 

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文引入了安全性和活跃性的概念，作为并发程序的部分正确性和终止性的适当概括。</font><font style="vertical-align:inherit">它还为这些类别的属性引入了术语“安全性”和“活性”。</font><font style="vertical-align:inherit">我从 Petri 网中窃取了这些术语，它们具有相似但形式上截然不同的含义。</font><font style="vertical-align:inherit">（Petri 网的安全性是一种特殊的安全属性；Petri 网的活跃性不是活跃性属性。）&nbsp; 

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

在我设计自己的方法的同时，苏珊·奥维奇 (Susan Owicki) 正在康奈尔大学大卫·格里斯 (David Gries) 的指导下撰写论文，并提出了几乎相同的想法。</font><font style="vertical-align:inherit">弗洛伊德证明并发程序安全性的方法的推广被称为 Owicki-Gries 方法。</font><font style="vertical-align:inherit">奥维奇和格里斯没有做任何与我论文中证明活性的方法相媲美的事情。</font><font style="vertical-align:inherit">（Nissim Francez 和 Amir Pnueli 开发了一种处理活性属性的通用证明方法，但它缺乏证明不变性属性的好方法。）我的方法存在缺陷，这些缺陷通过引入时序逻辑得到了纠正，[47] 中对此进行了</font></font><a href="#liveness"><font style="vertical-align:inherit"><font style="vertical-align:inherit">讨论</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
证明安全性的 Owicki-Gries 版本的方法与我的方法有两个不同之处。</font><font style="vertical-align:inherit">重要的方法是我将控制状态明确化，而他们却无法直接谈论它。</font><font style="vertical-align:inherit">相反，他们引入了虚拟变量来捕获控制状态。</font><font style="vertical-align:inherit">无关紧要的方式是我使用流程图语言，而他们使用类似 Algol 的语言。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
方法中微不足道的语法差异被证明具有重要的影响。</font><font style="vertical-align:inherit">对于编写简单的并发算法，流程图实际上比传统的玩具编程语言更好，因为它们使原子操作以及控制状态变得明确。</font><font style="vertical-align:inherit">然而，到了 70 年代中期，流程图已经过时，结构化编程风靡一时，所以我的论文被遗忘了，人们只阅读他们的论文。</font><font style="vertical-align:inherit">大约十年后，这篇论文被重新发现，现在通常在对先前工作的强制引用中与他们的论文一起被引用。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
但更重要的是，因为他们使用了“结构化”语言，奥维奇和格里斯认为他们已经推广了霍尔的方法。</font><font style="vertical-align:inherit">弗洛伊德和霍尔的方法之所以不同，是因为霍尔的方法基于证明的层次分解的思想。</font><font style="vertical-align:inherit">Owicki-Gries 方法不允许这种干净的层次分解。</font><font style="vertical-align:inherit">格里斯在 1999 年评论道：“我们几乎没有看过弗洛伊德的作品，只是根据霍尔的公理理论做一切事情。” </font><font style="vertical-align:inherit">我怀疑，因为他们根本没有考虑弗洛伊德的方法，他们没有注意到两者之间的区别，因此他们没有意识到他们正在概括弗洛伊德的方法而不是霍尔的方法。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
在霍尔的服装中概括弗洛伊德的方法的结果让所有人感到困惑。</font><font style="vertical-align:inherit">在大约十年的时间里，几乎没有人真正理解 Owicki-Gries 方法只是构造全局不变量证明的一种特殊方法。</font><font style="vertical-align:inherit">我想不出比《EWD
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">奥威基-格里斯理论的个人总结》更好地说明这种混乱的方法了</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Dijkstra 撰写并随后出版在一本他最喜欢的 EWD 书中。（在他的整个职业生涯中，Edsger Dijkstra 写了一系列由“EWD”编号标识的笔记。）如果像 Dijkstra 这样聪明且思维清晰的人也能写出这样的内容这是一个令人困惑的大杂烩，想象一下其他人一定会感到多么困惑。</font><font style="vertical-align:inherit">霍尔方法对并发程序的真正推广直到几年后才在
</font></font><a href="#hoare"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[40]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中出现。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我认为很快就很明显人们想要明确地谈论控制状态。</font><font style="vertical-align:inherit">Susan Owicki 显然同意，因为我们在</font><a href="#liveness"><font style="vertical-align:inherit">[47]中引入了</font></a></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">at</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">in</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">after</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">谓词来做到这一点</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">过了一会儿，我在</font><a href="#control"><font style="vertical-align:inherit">[78]</font></a><font style="vertical-align:inherit">中对虚拟变量与控制状态进行了更多的讨论。&nbsp;

</font></font><a href="#liveness"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font><a href="#control"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
虚拟变量不仅仅是避免控制变量的丑陋黑客。</font><font style="vertical-align:inherit">它们还允许您捕捉历史。</font><font style="vertical-align:inherit">添加历史变量可以将行为推理引入断言证明中。</font><font style="vertical-align:inherit">（在极限范围内，您可以添加一个捕获整个历史记录的变量，并在断言框架中提供完整的行为证明。）程序接下来执行的操作取决于其当前状态，而不是其历史记录。</font><font style="vertical-align:inherit">因此，基于历史变量的证明并不能捕获程序运行的真正原因。</font><font style="vertical-align:inherit">我总是发现不使用历史变量的证明可以教会您更多关于算法的知识。</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（如[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">所示
</font><font style="vertical-align:inherit">，如果正确性条件本身是历史的，则历史变量可能是必要的。）&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
当我们开发我们的方法时，奥威基和我以及大多数其他人都认为奥威基-格里斯方法比阿什克罗夫特的方法有很大改进，因为它使用程序文本来分解证明。</font><font style="vertical-align:inherit">从那时起我就意识到这是一个错误。</font><font style="vertical-align:inherit">最好写一个全局不变量。</font><font style="vertical-align:inherit">将不变量写为注释可以让您隐藏不变量对控制状态的一些显式依赖。</font><font style="vertical-align:inherit">然而，即使您将算法编写为程序，通常情况下，将不变量编写为注释而不是单个全局不变量会使事情变得更加复杂。</font><font style="vertical-align:inherit">但更糟糕的是，注释让您根据单独的断言而不是单个全局不变量进行思考。</font><font style="vertical-align:inherit">重要的是全局不变量。</font><font style="vertical-align:inherit">阿什克罗夫特说对了。</font><font style="vertical-align:inherit">奥维奇、格里斯和我把事情搞砸了。</font><font style="vertical-align:inherit">我花了很长时间才弄清楚这一点。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
在 80 年代的某个时候，Jay Misra 注意到有充分根据的定义（第 136 页上的定义 8）显然是不正确的。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="proving"><b>Proving the Correctness of Multiprocess
   Programs</b><br><i>IEEE Transactions on Software Engineering SE-3</i>, 2
   (March 1977), 125-143.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/proving.pdf">PDF</a>
<br><font size="-2">Copyright © 1977 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


When I first learned about the mutual exclusion problem, it seemed
easy and the published algorithms seemed needlessly complicated.&nbsp; So,
I dashed off a simple algorithm and submitted it to
<i>CACM</i>.&nbsp; I soon received a referee's report pointing
out the error.&nbsp; This had two effects.&nbsp; First, it made me mad enough at
myself to sit down and come up with a real solution.&nbsp; The result was
the bakery algorithm described in <a href="#bakery">[12]</a>.&nbsp; The second effect
was to arouse my interest in verifying concurrent algorithms.&nbsp; This
has been a very practical interest.&nbsp; I want to verify the algorithms
that I write.&nbsp; A method that I don't think is practical for my
everyday use doesn't interest me.&nbsp;

<p> 

In the course of my work on parallelizing sequential code (see
<a href="#do-loops">[10]</a>), I essentially rediscovered Floyd's method as a way
of extracting properties of a program.&nbsp; When I showed a colleague what
I was doing, he went to our library at Massachusetts Computer
Associates and gave me a copy of the original tech report version of
Floyd's classic paper <i>Assigning Meanings to Programs</i>.&nbsp; I don't
remember when I read Hoare's <i>An Axiomatic Basis for Computer
Programming</i>, but it was probably not long afterwards.&nbsp;

</p><p>
In the mid-70s, several people were thinking about the problem of
verifying concurrent programs.&nbsp; The seminal paper was Ed Ashcroft's
<i>Proving Assertions About Parallel Programs</i>, published in the
Journal of Computer and System Sciences in 1975.&nbsp; That paper
introduced the fundamental idea of invariance.&nbsp; I discovered how to
use the idea of invariance to generalize Floyd's method to
multiprocess programs.&nbsp; As is so often the case, in retrospect the
idea seems completely obvious.&nbsp; However, it took me a while to come to
it.&nbsp; I remember that, at one point, I thought that a proof would
require induction on the number of processes.&nbsp; 

</p><p>
This paper introduced the concepts of safety and liveness as the
proper generalizations of partial correctness and termination to
concurrent programs.&nbsp; It also introduced the terms "safety" and
"liveness" for those classes of properties.&nbsp; I stole those terms
from Petri nets, where they have similar but formally very different
meanings.&nbsp; (Safety of a Petri net is a particular safety property;
liveness of a Petri net is not a liveness property.)&nbsp; 

</p><p> 

At the same time I was devising my method, Susan Owicki was writing
her thesis at Cornell under David Gries and coming up with very much
the same ideas.&nbsp; The generalization of Floyd's method for proving
safety properties of concurrent programs became known as the
Owicki-Gries method.&nbsp; Owicki and Gries did not do anything comparable
to the method for proving liveness in my paper.&nbsp; (Nissim Francez and
Amir Pnueli developed a general proof method that did handle liveness
properties, but it lacked a nice way of proving invariance
properties.)&nbsp; My method had deficiencies that were corrected with the
introduction of temporal logic, discussed in <a href="#liveness">[47]</a>.&nbsp;

</p><p>
The Owicki-Gries version of the method for proving safety properties
differed from mine in two ways.&nbsp; The significant way was that I made
the control state explicit, while they had no way to talk about it
directly.&nbsp; Instead, they introduced dummy variables to capture the
control state.&nbsp; The insignificant way was that I used a flowchart
language while they used an Algol-like language.&nbsp;

</p><p>
The insignificant syntactic difference in the methods turned out to
have important ramifications.&nbsp; For writing simple concurrent
algorithms, flowcharts are actually better than conventional toy
programming languages because they make the atomic actions, and hence
the control state, explicit.&nbsp; However, by the mid-70s, flowcharts were
passé and structured programming was all the rage,
so my paper was forgotten and people read only theirs.&nbsp; The paper was
rediscovered about ten years later, and is now generally cited
alongside theirs in the mandatory references to previous work.&nbsp;

</p><p>
More important though is that, because they had used a "structured"
language, Owicki and Gries thought that they had generalized Hoare's
method.&nbsp; To the extent that Floyd's and Hoare's methods are different,
it is because Hoare's method is based on the idea of hierarchical
decomposition of proofs.&nbsp; The Owicki-Gries method doesn't permit this
kind of clean hierarchical decomposition.&nbsp; Gries, commenting in 1999,
said: "We hardly ever looked at Floyd's work and simply did
everything based on Hoare's axiomatic theory." I suspect that,
because they weren't thinking at all about Floyd's approach, they
didn't notice the difference between the two, and thus they didn't
realize that they were generalizing Floyd's method and not Hoare's.&nbsp;

</p><p>
The result of presenting a generalization of Floyd's method in Hoare's
clothing was to confuse everyone.&nbsp; For a period of about ten years,
hardly anyone really understood that the Owicki-Gries method was just
a particular way of structuring the proof of a global invariant.&nbsp; I
can think of no better illustration of this confusion than the 
EWD
<i>A Personal Summary of the Owicki-Gries
Theory</i> that Dijkstra wrote and subsequently published in a book of his
favorite EWDs.( Throughout his career, Edsger Dijkstra
         wrote a series of notes identified by an "EWD" number.) 
If even someone as smart and generally clear-thinking as Dijkstra
could write such a confusing hodge-podge of an explanation, imagine
how befuddled others must have been.&nbsp; A true generalization of Hoare's
method to concurrent programs didn't come until several years later in
<a href="#hoare">[40]</a>.&nbsp;

</p><p>
I think it soon became evident that one wanted to talk explicitly
about the control state.&nbsp; Susan Owicki obviously agreed, since we
introduced the <i>at</i>, <i>in</i>, and <i>after</i> predicates for
doing just that in <a href="#liveness">[47]</a>.&nbsp; Quite a bit later, I had more
to say about dummy variables versus control state in <a href="#control">[78]</a>.&nbsp;

</p><p>
Dummy variables were more than just an ugly hack to avoid control
variables.&nbsp; They also allowed you to capture history.&nbsp; Adding history
variables makes it possible to introduce behavioral reasoning into an
assertional proof.&nbsp; (In the limit, you can add a variable that
captures the entire history and clothe a completely behavioral proof
in an assertional framework.)&nbsp; What a program does next depends on its
current state, not on its history.&nbsp; Therefore, a proof that is based
on a history variable doesn't capture the real reason why a program
works.&nbsp; I've always found that proofs that don't use history variables
teach you more about the algorithm.&nbsp; (As shown in
<a href="#abadi-existence">[92]</a>, history variables may be necessary if the
correctness conditions themselves are in terms of history.)&nbsp;

</p><p>
When we developed our methods, Owicki and I and most everyone else
thought that the Owicki-Gries method was a great improvement over
Ashcroft's method because it used the program text to decompose the
proof.&nbsp; I've since come to realize that this was a mistake.&nbsp; It's
better to write a global invariant.&nbsp; Writing the invariant as an
annotation allows you to hide some of the explicit dependence of the
invariant on the control state.&nbsp; However, even if you're writing your
algorithm as a program, more often than not, writing the invariant as
an annotation rather than a single global invariant makes things more
complicated.&nbsp; But even worse, an annotation gets you thinking in terms
of separate assertions rather than in terms of a single global
invariant.&nbsp; And it's the global invariant that's important.&nbsp; Ashcroft
got it right.&nbsp; Owicki and Gries and I just messed things up.&nbsp; It took
me quite a while to figure this out.&nbsp;

</p><p>
Sometime during the '80s, Jay Misra noticed that the definition
of well-foundedness (Definition 8 on page 136) is obviously incorrect.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="formal"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">多进程算法编程的形式正确性证明</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">- 2me Colloque International</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，B. Robinet 编辑，Dunod，巴黎 (1977)，1-8。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"></font></a><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[23]</font></font></a><font style="vertical-align:inherit"><a name="formal"><font style="vertical-align:inherit">


的缩写会议版本</font></a><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">（当时，出版速度足够快，期刊版本可以在会议版本之前出现。）我写这篇论文是为了参加巴黎会议的借口。</font><font style="vertical-align:inherit">但后来发现我因为其他原因去了欧洲，没能参加会议。</font><font style="vertical-align:inherit">我试图撤回那张纸，但为时已晚。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="formal"><b>Formal Correctness Proofs for Multiprocess
   Algorithms</b><br><i>Programmation-2me Colloque
   International</i>, B. Robinet, ed., Dunod, Paris (1977), 1-8.<br>
No electronic version available.<hr>


This is an abbreviated, conference version of </a><a href="#proving">[23]</a>.&nbsp; (In
those days, publication was fast enough that the journal version could
appear before the conference version.)&nbsp; I wrote this paper as an
excuse for attending a conference in Paris.&nbsp; However, it turned out
that I went to Europe for other reasons that made it impossible for me
to attend the conference.&nbsp; I tried to withdraw the paper, but it
was too late.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="rd-wr"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 的</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">并发读写</font></b><font style="vertical-align:inherit">通信20、11（1977 年 11 月）、806-811。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/rd-wr.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1977 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇论文来自我对
</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]的面包店算法的研究</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">该算法的问题在于它需要无界状态。</font><font style="vertical-align:inherit">为了使状态在实践中受到限制，我需要一种算法来读取和写入多位数字，一次一位，以便读取与写入重叠时不会获得太大的值。</font><font style="vertical-align:inherit">本文表明，这可以通过简单地在一个方向上写入数字并在另一个方向上读取它们来完成。</font><font style="vertical-align:inherit">它还有一些其他不错的算法。</font><font style="vertical-align:inherit">该论文假设读取和写入单个数字是原子操作。</font><font style="vertical-align:inherit">原始版本引入了规则寄存器的概念，并在各个数字是规则的较弱假设下证明了结果。</font><font style="vertical-align:inherit">然而，编辑发现非原子读取和写入单个数字的想法对于
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM来说过于异端</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">读者们，他坚持要求我做出更强的原子性假设。</font></font><a href="#interprocess"><font style="vertical-align:inherit"><font style="vertical-align:inherit">因此，世界不得不再等十年，直到[70]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的出版</font><font style="vertical-align:inherit">，才能了解常规寄存器。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="rd-wr"><b>Concurrent Reading and Writing</b><br><i>Communications of the ACM 20</i>, 11 &nbsp;
   (November 1977), 806-811.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/rd-wr.pdf">PDF</a>
<br><font size="-2">Copyright © 1977 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper came out of my study of the bakery algorithm of
<a href="#bakery">[12]</a>.&nbsp; The problem with that algorithm is that it requires
unbounded state.&nbsp; To allow the state to be bounded in practice, I
needed an algorithm for reading and writing multidigit numbers, one
digit at a time, so that a read does not obtain too large a value if
it overlaps a write.&nbsp; This paper shows that this can be done by simply
writing the digits in one direction and reading them in the other.&nbsp; It
also has some other nice algorithms.&nbsp;

The paper assumes that reading and writing a single digit are atomic
operations.&nbsp; The original version introduced the notion of a regular
register and proved the results under the weaker assumption that the
individual digits were regular.&nbsp; However, the editor found the idea of
nonatomic reads and writes to individual digits too heretical for
<i>CACM</i> readers, and he insisted that I make the stronger
assumption of atomicity.&nbsp; So, the world had to wait another decade,
until the publication of <a href="#interprocess">[70]</a>, to learn about regular
registers.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="state-the-problem"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">在描述解决方案之前先陈述问题</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGSOFT 软件工程笔记 3</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1（1978 年 1 月）26. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/state-the-problem.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1978 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


标题说明了一切。</font><font style="vertical-align:inherit">这篇一页纸的笔记今天和我写它时一样相关。</font><font style="vertical-align:inherit">用“编写程序”代替“描述解决方案”，它成为改进软件的实用秘诀。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="state-the-problem"><b>State the Problem Before 
Describing the Solution</b><br><i>ACM SIGSOFT Software Engineering Notes 
3</i>, 1 (January 1978) 26.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/state-the-problem.pdf">PDF</a>
<br><font size="-2">Copyright © 1978 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


The title says it all.&nbsp; This one-page note is as relevant today as
when I wrote it.&nbsp; Replace "describing the solution" by "writing the
program" and it becomes a practical recipe for improving software.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="time-clocks"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">分布式系统通信中的时间、时钟和事件排序</font></b><font style="vertical-align:inherit">21 , 7（1978 年 7 月）, 558-565。</font><font style="vertical-align:inherit">在多个合集中重印，包括</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《分布式计算：概念和实现》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，McEntire 等人编辑。</font><font style="vertical-align:inherit">IEEE 出版社，1984 年</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">。PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1978 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


吉姆·格雷（Jim Gray）曾经告诉我，他听到过关于这篇论文的两种不同的观点：它是微不足道的，它是精彩的。</font><font style="vertical-align:inherit">我无法与前者争论，也懒得与后者争论。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文源自 Paul Johnson 和 Bob Thomas 的注释《 
</font></font><a href="https://www.rfc-archive.org/getrfc.php?rfc=677"><font style="vertical-align:inherit"><font style="vertical-align:inherit">
  重复数据库的维护》</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
。</font><font style="vertical-align:inherit">我相信他们的笔记介绍了在分布式算法中使用消息时间戳的想法。</font><font style="vertical-align:inherit">我碰巧对狭义相对论有扎实的、发自内心的理解（参见</font></font><a href="#geometry-of-space-time"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[5]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">这使我能够立即掌握他们想要做的事情的本质。</font><font style="vertical-align:inherit">狭义相对论告诉我们，时空中不存在不变的事件总顺序；</font><font style="vertical-align:inherit">不同的观察者可能对两个事件中哪一个先发生存在分歧。</font><font style="vertical-align:inherit">仅存在部分顺序，其中事件</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">e1</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">先于事件
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">e2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，且仅当</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">e1</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可以因果影响</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">e2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我意识到约翰逊和托马斯算法的本质是使用时间戳来提供与因果顺序一致的事件总排序。</font><font style="vertical-align:inherit">这种认识可能是辉煌的。</font><font style="vertical-align:inherit">意识到这一点后，其他一切都变得微不足道了。</font><font style="vertical-align:inherit">因为托马斯和约翰逊并不清楚他们在做什么，所以他们没有得到完全正确的算法。</font><font style="vertical-align:inherit">他们的算法允许本质上违反因果关系的异常行为。</font><font style="vertical-align:inherit">我很快写了一篇简短的注释指出了这一点并纠正了算法。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">没过多久我就意识到完全排序事件的算法可以用来实现任何分布式系统。</font><font style="vertical-align:inherit">分布式系统可以描述为使用处理器网络实现的特定顺序状态机。</font><font style="vertical-align:inherit">对输入请求进行完全排序的能力立即导致一种通过处理器网络实现任意状态机的算法，从而实现任何分布式系统。</font><font style="vertical-align:inherit">所以，我写了这篇论文，是关于如何实现任意分布式状态机的。</font><font style="vertical-align:inherit">作为说明，我使用了我能想到的最简单的分布式系统示例——分布式互斥算法。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这是我最常被引用的论文。</font><font style="vertical-align:inherit">许多计算机科学家声称读过这本书。</font><font style="vertical-align:inherit">但我很少遇到任何人知道这篇论文谈到了有关状态机的内容。</font><font style="vertical-align:inherit">人们似乎认为它要么是分布式系统中事件的因果关系，要么是分布式互斥问题。</font><font style="vertical-align:inherit">人们坚持认为论文中没有任何关于状态机的内容。</font><font style="vertical-align:inherit">我什至不得不回去重读一遍，以说服自己我确实记得自己写过什么。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该论文描述了逻辑时钟的同步。</font><font style="vertical-align:inherit">作为事后的想法，我决定看看它为实时时钟提供了什么样的同步。</font><font style="vertical-align:inherit">因此，我添加了一个关于实时同步的定理。</font><font style="vertical-align:inherit">我对证明的难度感到相当惊讶。</font><font style="vertical-align:inherit">这表明了</font></font><a href="#clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[62]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中即将发生的事情。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这篇论文荣获2000年PODC影响力论文奖（后更名为Edsger W. Dijkstra分布式计算奖）。</font><font style="vertical-align:inherit">它于 2007 年荣获 ACM SIGOPS 名人堂奖。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="time-clocks"><b>Time, Clocks and the Ordering of Events in a
   Distributed System</b><br><i>Communications of the ACM 21</i>, 7 &nbsp; (July 1978), 558-565.&nbsp; Reprinted in
   several collections, including <i>Distributed Computing:
   Concepts and Implementations</i>, McEntire et al., ed.&nbsp; IEEE Press, 1984.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/time-clocks.pdf">PDF</a>
<br><font size="-2">Copyright © 1978 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Jim Gray once told me that he had heard two different opinions of this
paper: that it's trivial and that it's brilliant.&nbsp; I can't argue with
the former, and I am disinclined to argue with the latter.&nbsp;

<p>
The origin of this paper was 
the
note 
<a href="https://www.rfc-archive.org/getrfc.php?rfc=677">
  The Maintenance of Duplicate Databases</a>
by Paul Johnson and Bob Thomas.&nbsp; I believe their
note introduced the idea of using message timestamps in a distributed
algorithm.&nbsp; I happen to have a solid, visceral understanding of
special relativity (see <a href="#geometry-of-space-time">[5]</a>).&nbsp; This
enabled me to grasp immediately the essence of what they were trying
to do.&nbsp; Special relativity teaches us that there is no invariant total
ordering of events in space-time; different observers can disagree
about which of two events happened first.&nbsp; There is only a partial
order in which an event <i>e1</i> precedes an event
<i>e2</i> iff <i>e1</i> can causally
affect <i>e2</i>.&nbsp; I realized that the essence of
Johnson and Thomas's algorithm was the use of timestamps to provide a
total ordering of events that was consistent with the causal order.&nbsp;
This realization may have been brilliant.&nbsp; Having realized it,
everything else was trivial.&nbsp; Because Thomas and Johnson didn't
understand exactly what they were doing, they didn't get the algorithm
quite right; their algorithm permitted anomalous behavior that
essentially violated causality.&nbsp; I quickly wrote a short note pointing
this out and correcting the algorithm.&nbsp;

</p><p> It didn't take me long to realize that an algorithm for
totally ordering events could be used to implement any distributed
system.&nbsp; A distributed system can be described as a particular
sequential state machine that is implemented with a network of
processors.&nbsp; The ability to totally order the input requests leads
immediately to an algorithm to implement an arbitrary state machine by
a network of processors, and hence to implement any distributed
system.&nbsp; So, I wrote this paper, which is about how to implement an
arbitrary distributed state machine.&nbsp; As an illustration, I used the
simplest example of a distributed system I could think of--a
distributed mutual exclusion algorithm.&nbsp;

</p><p>
This is my most often cited paper.&nbsp; Many computer scientists claim to
have read it.&nbsp; But I have rarely encountered anyone who was
aware that the paper said anything about state machines.&nbsp; People seem to
think that it is about either the causality relation on events in a
distributed system, or the distributed mutual exclusion problem.&nbsp;
People have insisted that there is nothing about state machines in the
paper.&nbsp; I've even had to go back and reread it to convince myself that
I really did remember what I had written.&nbsp;

</p><p>
The paper describes the synchronization of logical clocks.&nbsp; As
something of an afterthought, I decided to see what kind of
synchronization it provided for real-time clocks.&nbsp; So, I included a
theorem about real-time synchronization.&nbsp; I was rather surprised by
how difficult the proof turned out to be.&nbsp; This was an indication of
what lay ahead in <a href="#clocks">[62]</a>.&nbsp;

</p><p>
This paper won the 2000 PODC Influential Paper Award (later
renamed the Edsger W. Dijkstra Prize in Distributed Computing).&nbsp;
It won an ACM SIGOPS Hall of Fame Award in 2007.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="interactive"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">交互程序正确性的规范和证明</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">信息处理数学研究国际会议论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，日本京都（1978 年 8 月），477-540。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 70 年代末，人们正在谈论设计能够使程序验证更容易的编程语言。</font><font style="vertical-align:inherit">我并没有想太多这个主意。</font><font style="vertical-align:inherit">我觉得验证的困难来自于算法，而不是描述它的编程语言的细节。</font><font style="vertical-align:inherit">为了证明这一观点，我在本文中发表了 TECO 程序正确性的证明。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
TECO 代表文本编辑和校正。</font><font style="vertical-align:inherit">它是 TECO 编辑器的命令语言，也是构建 Emacs 原始版本的基础宏语言。</font><font style="vertical-align:inherit">它是一种晦涩的低级语言，其目标是用最少的击键次数执行强大的文本编辑操作。</font><font style="vertical-align:inherit">旨在使验证变得容易的编程语言将完全不同于东元。</font><font style="vertical-align:inherit">本文表明，验证 TECO 程序的方式与验证用更传统的语言编写的程序的方式相同。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该证明也许还具有一些历史意义，因为它是交互式程序证明的早期示例，即与用户交互而不仅仅是产生答案的程序。</font><font style="vertical-align:inherit">因此，必须根据输入操作的顺序来断言正确性。</font><font style="vertical-align:inherit">本文概括了弗洛伊德/霍尔方法来处理环境行为的历史。&nbsp; 



</font></font><br>&nbsp;</p><p></p></a></li><li> <a name="interactive"><b>The Specification and Proof of Correctness of
   Interactive Programs</b><br><i>Proceedings of the International
   Conference on Mathematical Studies of Information Processing</i> Kyoto,
   Japan (August, 1978), 477-540.<br>
No electronic version available.<hr>


In the late 70s, people were talking about designing programming
languages that would make program verification easier.&nbsp; I didn't think
much of that idea.&nbsp; I felt that the difficulty in verification comes
from the algorithm, not the details of the programming language in
which it is described.&nbsp; To demonstrate this view, I published in this
paper a proof of correctness of a TECO program.&nbsp; 

<p>
TECO stands for Text Editing and Correction.&nbsp; It was the command
language for the TECO editor, and it was the underlying macro language
on which the original version of Emacs was built.&nbsp; It was an obscure,
low-level language whose goal was to perform powerful text editing
operations with the minimum number of keystrokes.&nbsp; A programming
language designed to make verification easy would be completely unlike
TECO.&nbsp; The paper shows that you verify a TECO program the
same way you verify a program written in a more conventional language.&nbsp;

</p><p>
The proof is perhaps also of some historical interest because it was an 
early example of a proof of an interactive program--that is, one that
interacts with the user instead of just producing an answer.&nbsp; Thus,
correctness had to be asserted in terms of the sequence of input
actions.&nbsp; The paper generalizes the Floyd/Hoare method to deal with
the history of environment actions.&nbsp; 



<br>&nbsp;</p><p></p></a></li><li><a name="interactive"> </a><a name="implementation"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可靠的分布式多进程系统计算机网络</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">的实现</font></b><font style="vertical-align:inherit">2 (1978), 95-114。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/implementation.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1978 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我介绍了通过使用算法在分布式系统中实现任意状态机来实现任何分布式系统的想法。</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">然而， [27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的算法
</font><font style="vertical-align:inherit">假设处理器永远不会失败并且所有消息都被传递。</font><font style="vertical-align:inherit">本文给出了一种容错算法。</font><font style="vertical-align:inherit">它是一种实时算法，假设在没有故障的情况下消息延迟的上限，并且无故障进程的时钟同步到已知范围内。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

据我所知，这是第一篇讨论任意故障（后来称为拜占庭故障）的发表论文。</font><font style="vertical-align:inherit">它实际上考虑了恶意行为，而不是简单地将这种行为用作完全不可预测的故障的隐喻。</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">其算法受到了[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">数字签名算法的启发</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">通过实时的使用，本文预示了
</font></font><a href="#using-time"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[55]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的想法。&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li><a name="interactive"> </a><a name="implementation"><b>The Implementation of Reliable Distributed
   Multiprocess Systems</b><br><i>Computer Networks 2</i> (1978), 95-114.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/implementation.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1978.</font><hr>


In <a href="#time-clocks">[27]</a>, I introduced the idea of implementing any
distributed system by using an algorithm to implement an arbitrary
state machine in a distributed system.&nbsp; However, the algorithm in
<a href="#time-clocks">[27]</a> assumed that processors never fail and all
messages are delivered.&nbsp; This paper gives a fault-tolerant algorithm.&nbsp;
It's a real-time algorithm, assuming upper bounds on message delays in
the absence of faults, and that nonfaulty processes had clocks
synchronized to within a known bound.&nbsp; 

<p>

To my knowledge, this is the first published paper to discuss
arbitrary failures (later called Byzantine failures).&nbsp; It actually
considered malicious behavior, not using such behavior simply as a
metaphor for completely unpredictable failures.&nbsp; Its algorithm was the
inspiration for the digital signature algorithm of <a href="#reaching">[41]</a>.&nbsp;
With its use of real-time, this paper presaged the ideas in
<a href="#using-time">[55]</a>.&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="sift"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">SIFT：用于飞机控制的容错计算机的设计和分析</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 John Wensley 等人合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE 66 报文</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，10（1978 年 10 月），1240-1255。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/sift.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


当人们清楚计算机将在商用飞机上飞行时，美国宇航局开始资助研究，以找出如何使计算机足够可靠地完成这项任务。</font><font style="vertical-align:inherit">这项工作的一部分是 SRI 的 SIFT 项目。</font><font style="vertical-align:inherit">该项目最著名的可能是产生拜占庭将军问题及其解决方案，首次在</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中报告。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文概述了完整的 SIFT 项目，包括硬件和软件设计以及形式验证系统的正确性。</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它公布了[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中出现的结果</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这也是我仍然提倡的基本规范和验证方法的一个非常早期的例子：将规范编写为状态转换系统，并表明较低级别规范的每个步骤要么实现较高级别规范的步骤，要么是一个“结结巴巴”的步骤，使更高级别的状态保持不变。</font><font style="vertical-align:inherit">该论文没有提到不变量的使用，但可能为了节省空间而省略了这一点。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这篇论文是我在最后的疯狂活动中精心设计的集体成果，以便在本期截止日期前及时发表论文。</font><font style="vertical-align:inherit">我不记得谁写了什么，但验证部分似乎是我写的。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="sift"><b>SIFT: Design and Analysis of a Fault-Tolerant Computer for
   Aircraft Control</b>&nbsp; (with John Wensley et al.)<br><i>Proceedings of the IEEE
   66</i>, 10 (October 1978), 1240-1255.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/sift.pdf">PDF</a><hr>


When it became clear that computers were going to be flying commercial
aircraft, NASA began funding research to figure out how to make them
reliable enough for the task.&nbsp; Part of that effort was the SIFT
project at SRI.&nbsp; This project was perhaps most
notable for producing the Byzantine generals problem and its
solutions, first reported in <a href="#reaching">[41]</a>.&nbsp;

<p> This paper gives an overview of the complete SIFT project,
which included designing the hardware and software and formally
verifying the system's correctness.&nbsp; It announces the results that
appear in <a href="#reaching">[41]</a>.&nbsp; It also is a very early example of the
basic specification and verification method I still advocate: writing
a specification as a state-transition system and showing that each
step of the lower-level specification either implements a step of the
higher-level one or is a "stuttering" step that leaves the
higher-level state unchanged.&nbsp; The paper doesn't mention the use of an
invariant, but that was probably omitted to save space.&nbsp;

</p><p>
This paper was a group effort that I choreographed in a final frenzy
of activity to get the paper out in time for the issue's deadline.&nbsp; I
don't remember who wrote what, but the section on verification seems
to be my writing.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="garbage"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">动态垃圾收集：合作练习</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Edsger Dijkstra 等人）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Communications of the ACM 21</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 11（1978 年 11 月），966-975。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/garbage.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1978 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文提出了第一个并发垃圾收集算法，即收集器与创建垃圾的进程同时运行的算法。</font><font style="vertical-align:inherit">这篇论文相当有名；</font><font style="vertical-align:inherit">它的历史并非如此。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我从 Dijkstra 那里收到了这篇论文的早期版本，我提出了一些建议。</font><font style="vertical-align:inherit">Dijkstra 将它们纳入其中，并相当慷慨地将我添加到作者名单中。</font><font style="vertical-align:inherit">他将论文提交给了</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我第二次听说这件事是当我收到迪杰斯特拉写给编辑的一封撤回论文的信的副本时。</font><font style="vertical-align:inherit">信中说有人发现了算法中的错误，但没有说明错误是什么。</font><font style="vertical-align:inherit">由于 Dijkstra 的证明如此令人信服，我认为这一定是一个很容易纠正的小错误。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我最近写了</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">因此，我决定使用该证明方法编写一个证明，认为这样我就能找到并纠正错误。</font><font style="vertical-align:inherit">在大约 15 分钟内，尝试编写证明时导致了错误。</font><font style="vertical-align:inherit">令我惊讶的是，这是一个严重的错误。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我有预感，可以通过更改两个操作的执行顺序来修复该算法。</font><font style="vertical-align:inherit">但我没有充分的理由相信这会起作用。</font><font style="vertical-align:inherit">事实上，我看不出任何简单的非正式论据可以证明它是有效的。</font><font style="vertical-align:inherit">然而，我决定继续尝试写一个正式的正确性证明。</font><font style="vertical-align:inherit">我花了大约两天的时间认真工作，但我构造了证明。</font><font style="vertical-align:inherit">当我完成后，我确信该算法现在是正确的，但我对它为何起作用并没有直观的理解。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">与此同时，Dijkstra 发现可以通过交换另外两个操作来修复该算法，并且他编写了与以前相同类型的行为证明。</font><font style="vertical-align:inherit">他的修复产生了一个可以说比我的更有效的算法，所以这就是我们使用的版本。</font><font style="vertical-align:inherit">我勾勒出该算法的断言证明。</font><font style="vertical-align:inherit">鉴于他的证明风格不可靠，我试图让迪杰斯特拉同意严格的断言证明。</font><font style="vertical-align:inherit">他不愿意这样做，尽管他确实同意让他的证明更加断言并且不太可操作。</font><font style="vertical-align:inherit">以下是他于 2000 年 7 月写的对此的评论：
 </font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
当然，目前有两个问题：(A) 证据表明可以解决细粒度交错的即时垃圾收集问题，以及 (B) 如何有效地推理此类工件。</font><font style="vertical-align:inherit">我也确信当时我们所有人都意识到这两个问题之间的区别。</font><font style="vertical-align:inherit">我清楚地记得，当我们说服自己这件事完全可以做到时，我的兴奋之情溢于言表。</font><font style="vertical-align:inherit">从情感上来说，这与我解决自我稳定问题的第一个解决方案非常相似。</font><font style="vertical-align:inherit">那些我发表的没有校样的！</font><font style="vertical-align:inherit">可能在我生命中的某个时期，问题（A）总体上仍然是我脑海中最重要的部分：为那些可解决性根本不明显的问题提供解决方案。</font><font style="vertical-align:inherit">这或多或少是我的风格。</font><font style="vertical-align:inherit">我已经通过互斥做到了（CACM，1965 年 9 月）。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我也一直最感兴趣的是证明可以做一些事情，而不是寻找更好的算法来完成已知可能的事情。</font><font style="vertical-align:inherit">也许这就是为什么我一直对 Dijkstra 在并发算法方面的出色工作印象深刻。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
David Gries 后来发表了 Owicki-Gries 风格的算法证明，该算法与我草拟的算法基本相同。</font><font style="vertical-align:inherit">他通过将两个原子操作合并为一个来简化事情。</font><font style="vertical-align:inherit">他在脚注中提到了这一点，但</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">未能打印该脚注。</font><font style="vertical-align:inherit">（但是，他们确实在文本中打印了脚注编号。）&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我从中学到的教训是，行为证明是不可靠的，并发算法应该始终使用基于状态的推理，即基于不变性的推理。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="garbage"><b>On-the-fly Garbage Collection: an Exercise in
    Cooperation</b>&nbsp; (with Edsger Dijkstra et al.)<br><i>Communications of the ACM 21</i>, 11 &nbsp;
   (November 1978), 966-975.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/garbage.pdf">PDF</a>
<br><font size="-2">Copyright © 1978 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper presents the first concurrent garbage collection
algorithm--that is, an algorithm in which the collector operates
concurrently with the process that creates the garbage.&nbsp; The paper is
fairly well known; its history is not.&nbsp;

<p>
I received an early version of the paper from Dijkstra, and I made a
couple of suggestions.&nbsp; Dijkstra incorporated them and, quite
generously, added me to the list of authors.&nbsp; He submitted the paper
to <i>CACM</i>.&nbsp; The next I heard about it was when I received a
copy of a letter from Dijkstra to the editor withdrawing the paper.&nbsp;
The letter said that someone had found an error in the algorithm, but
gave no indication of what the error was.&nbsp; Since Dijkstra's proof was
so convincing, I figured that it must be a trivial error that could
easily be corrected.&nbsp;

</p><p>
I had fairly recently written <a href="#proving">[23]</a>.&nbsp; So, I decided to
write a proof using that proof method, thinking that I would then find
and correct the error.&nbsp; In about 15 minutes, trying to write the proof
led me to the error.&nbsp; To my surprise, it was a serious error.&nbsp;

</p><p>
I had a hunch that the algorithm could be fixed by changing the order
in which two operations were performed.&nbsp; But I had no good reason to
believe that would work.&nbsp; Indeed, I could see no simple informal
argument to show that it worked.&nbsp; However, I decided to go ahead and
try to write a formal correctness proof anyway.&nbsp; It took me about two
days of solid work, but I constructed the proof.&nbsp; When I was through,
I was convinced that the algorithm was now correct, but I had no
intuitive understanding of why it worked.&nbsp;

</p><p> In the meantime, Dijkstra figured out that the algorithm
could be fixed by interchanging two other operations, and he wrote the
same kind of behavioral proof as before.&nbsp; His fix produced an arguably
more efficient algorithm than mine, so that's the version we used.&nbsp; I
sketched an assertional proof of that algorithm.&nbsp; Given the evidence
of the unreliability of his style of proof, I tried to get Dijkstra to
agree to a rigorous assertional proof.&nbsp; He was unwilling to do that,
though he did agree to make his proof somewhat more assertional and
less operational.&nbsp; Here are his comments on that, written in July,
2000:
 </p><blockquote><p> 
There were, of course, two issues at hand: (A) a witness showing that
the problem of on-the-fly garbage collection with fine-grained
interleaving could be solved, and (B) how to reason effectively about
such artifacts.&nbsp; I am also certain that at the time all of us were
aware of the distinction between the two issues.&nbsp; I remember very well
my excitement when we convinced ourselves that it could be done at
all; emotionally it was very similar to my first solutions to the
problem of self-stabilization.&nbsp; Those I published without proofs! It
was probably a period in my life that issue (A) in general was still
very much in the foreground of my mind: showing solutions to problems
whose solvability was not obvious at all.&nbsp; It was more or less my
style.&nbsp; I had done it (CACM, Sep. 1965) with the mutual
exclusion.&nbsp;
 </p></blockquote>
I, too, have always been most interested in showing that something
could be done, rather than in finding a better algorithm for doing
what was known to be possible.&nbsp; Perhaps that is why I have always been
so impressed by the brilliance of Dijkstra's work on concurrent
algorithms.&nbsp;

<p>
David Gries later published an Owicki-Gries style proof of the
algorithm that was essentially the same as the one I had sketched.&nbsp; He
simplified things a bit by combining two atomic operations into one.&nbsp;
He mentioned that in a footnote, but <i>CACM</i> failed to print the
footnote.&nbsp; (However, they did print the footnote number in the text.)&nbsp;

</p><p>
The lesson I learned from this is that behavioral proofs are
unreliable and one should always use state-based reasoning for
concurrent algorithms--that is, reasoning based on invariance.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="general-construction"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">表达重复的一般结构</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGPLAN 公告 14</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3 (1979 年 3 月) 38-42。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/general-construction.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1979 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


幸运的是，这张纸条已经被完全遗忘了。</font><font style="vertical-align:inherit">它是在人们仍在提出新的编程语言结构时编写的。</font><font style="vertical-align:inherit">这里介绍的可能没有什么值得推荐的，但它并不比许多其他的差。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="general-construction"><b>A General Construction for
Expressing Repetition</b><br><i>ACM SIGPLAN Notices 14</i>, 3 (March 1979)
38-42.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/general-construction.pdf">PDF</a>
<br><font size="-2">Copyright © 1979 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Fortunately, this note has been completely forgotten.&nbsp; It was written
when people were still proposing new programming-language constructs.&nbsp;
The one presented here may have little to recommend it, but it was no
worse than many others.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="new-approach"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明多进程程序正确性的新方法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 1</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1（1979 年 7 月），84-97。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/new-approach.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1979 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


更正已发表在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 2 , 1 (1980 年 1 月), 134 上，可</font></font></i><font style="vertical-align:inherit"></font><a href="http://lamport.azurewebsites.net/pubs/a_new_approach-corrigendum.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">获取 
   </font><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

和当时的其他人一样，当我开始研究并发算法时，我从行为上对它们进行推理。</font><font style="vertical-align:inherit">这种推理通常涉及基于事件发生顺序的论证。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我发现，通过推理操作（可以由多个事件组成）和它们的两个关系：先行</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（由实线箭头表示）和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可以影响</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（由虚线表示），</font><font style="vertical-align:inherit">可以使证明变得更简单、更优雅、更数学化。</font><font style="vertical-align:inherit">箭）。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果A</font></font></i><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">的</font></i><font style="vertical-align:inherit">所有事件
</font><font style="vertical-align:inherit">先于</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">B</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的所有事件，则</font><font style="vertical-align:inherit">操作A 优先于操作</font><i><font style="vertical-align:inherit">B</font></i><font style="vertical-align:inherit">；</font><i><font style="vertical-align:inherit">如果A</font></i><font style="vertical-align:inherit">中的某个事件</font><font style="vertical-align:inherit">先于中的某个事件，</font><font style="vertical-align:inherit">则</font><i><font style="vertical-align:inherit">A</font></i><font style="vertical-align:inherit">可以影响
</font><i><font style="vertical-align:inherit">B</font></i></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">B.</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> _ </font><font style="vertical-align:inherit">这些关系遵循一些简单的规则，可以将行为推理简化为数学符号推送。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文介绍了利用两个箭头关系进行推理的方法，并将其应用于面包店算法的一种变体中。</font><font style="vertical-align:inherit">1976 年春天，我</font><font style="vertical-align:inherit">在埃因霍温的飞利浦</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Nat 实验室与 Carel Scholten 一起工作了一个月。</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Scholten 是 Dijkstra 的同事和朋友，我们三个人每周都会花一个下午在 Dijkstra 的家里工作、聊天、喝啤酒。</font><font style="vertical-align:inherit">该算法是在某个下午出现的。</font><font style="vertical-align:inherit">我认为我是它的主要作者，但正如我在论文中提到的，啤酒和时间的流逝使我无法确定谁对什么负责。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

实线和虚线箭头形式为小型算法（例如面包店算法）提供了非常优雅的证明。</font><font style="vertical-align:inherit">但是，就像所有的行为推理一样，它很难完全形式化，并且在复杂问题的重压下崩溃了。</font><font style="vertical-align:inherit">您应该使用断言方法来推理复杂的算法。</font><font style="vertical-align:inherit">然而，标准断言推理要求算法按照其原子操作来编写。</font></font><a href="#lamport-win"><font style="vertical-align:inherit"><font style="vertical-align:inherit">直接推理非原子操作（不将其转换为原子操作序列）的唯一断言方法是[86]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的方法
</font><font style="vertical-align:inherit">，该方法不容易使用。</font><font style="vertical-align:inherit">双箭头形式主义对于一小部分问题仍然有好处。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

即使在理论上的并发社区中，形式主义似乎也几乎被完全忽视了。</font><font style="vertical-align:inherit">我觉得这很讽刺。</font><font style="vertical-align:inherit">有一个研究领域以“真正的并发”这个自命不凡的名字而闻名。</font><font style="vertical-align:inherit">它的拥护者避开基于交错模型的断言方法，因为此类模型并不是真正并发的。</font><font style="vertical-align:inherit">相反，他们赞成基于将系统建模为事件的部分排序的形式主义，他们认为这是唯一真正并发的模型。</font><font style="vertical-align:inherit">然而，这些形式主义假设事件是原子的且不可分割的。</font><font style="vertical-align:inherit">原子事件不会像真正的并发操作那样在时间上重叠。</font><font style="vertical-align:inherit">双箭头形式是我所知道的唯一一种基于非原子操作的形式，因此可以被认为是真正并发的。</font><font style="vertical-align:inherit">但是，据我所知，&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="new-approach"><b>A New Approach to Proving the Correctness of
   Multiprocess Programs</b><br><i>ACM Transactions on Programming Languages and Systems 1</i>, 1 (July 1979), 84-97.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/new-approach.pdf">PDF</a>
<br><font size="-2">Copyright © 1979 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


A corrigendum was published in <i>ACM Transactions on Programming Languages and Systems 2</i>, 1 
(January 1980), 134 and is available 
   <a href="http://lamport.azurewebsites.net/pubs/a_new_approach-corrigendum.pdf">here</a>.&nbsp;

<p>

Like everyone else at the time, when I began studying concurrent
algorithms, I reasoned about them behaviorally.&nbsp; Such reasoning
typically involved arguments based on the order in which events occur.&nbsp;
I discovered that proofs can be made simpler, more elegant, and more
mathematical by reasoning about operations (which can be composed of
multiple events) and two relations on them: <i>precedes</i> (denoted
by a solid arrow)
and <i>can affect</i> (denoted by a dashed arrow).&nbsp;
Operation <i>A</i> precedes operation <i>B</i> if all the events of
<i>A</i> precede all the events of <i>B</i>; and <i>A</i> can affect
<i>B</i> if some event in <i>A</i> precedes some event in <i>B</i>.&nbsp;
These relations obey some simple rules that can reduce behavioral
reasoning to mathematical symbol pushing.&nbsp;

</p><p>
This paper introduced the method of reasoning with the two arrow
relations and applied it to a variant of the bakery algorithm.&nbsp; In the
spring of 1976 I spent a month working with Carel Scholten at the
Philips <i>Nat Lab</i> in Eindhoven.&nbsp; Scholten was a colleague and
friend of Dijkstra, and the three of us spent one afternoon a week
working, talking, and drinking beer at Dijkstra's house.&nbsp; The
algorithm emerged from one of those afternoons.&nbsp; I think I was its
primary author, but as I mention in the paper, the beer and the
passage of time made it impossible for me to be sure of who was
responsible for what.&nbsp;

</p><p> 

The solid and dashed arrow formalism provides very elegant proofs for
tiny algorithms such as the bakery algorithm.&nbsp; But, like all
behavioral reasoning, it is hard to make completely formal, and it
collapses under the weight of a complex problem.&nbsp; You should use
assertional methods to reason about complex algorithms.&nbsp; However,
standard assertional reasoning requires that the algorithm be written
in terms of its atomic operations.&nbsp; The only assertional approach to
reasoning directly about nonatomic operations (without translating
them into sequences of atomic operations) is the one in
<a href="#lamport-win">[86]</a>, which is not easy to use.&nbsp; The two-arrow
formalism is still good for a small class of problems.&nbsp;

</p><p> 

The formalism seems to have been almost completely ignored, even among
the theoretical concurrency community.&nbsp; I find this ironic.&nbsp; There is
a field of research known by the pretentious name of "true
concurrency".&nbsp; Its devotees eschew assertional methods that are based
on interleaving models because such models are not truly concurrent.&nbsp;
Instead, they favor formalisms based on modeling a system as a partial
ordering of events, which they feel is the only truly concurrent kind
of model.&nbsp; Yet, those formalisms assume that events are atomic and
indivisible.&nbsp; Atomic events don't overlap in time the way real
concurrent operations do.&nbsp; The two-arrow formalism is the only one I
know that is based on nonatomic operations and could therefore be
considered truly concurrent.&nbsp; But, as far as I know, the true
concurrency community has paid no attention to it.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="howto"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何提交</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表的论文笔记，1979 年 8 月 4 日。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/howto.txt"><font style="vertical-align:inherit"><font style="vertical-align:inherit">文本文件</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇三页纸的笔记是关于在会议上发表论文的，但它为任何演讲提供了很好的建议。</font><font style="vertical-align:inherit">除了一些关于手写幻灯片的建议外，它今天仍然适用。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="howto"><b>How to Present a Paper</b><br>Unpublished note, 4 August 1979.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/howto.txt">Text File</a><hr>


This three-page note is about presenting a paper at a conference, but
it offers good advice for any talk.&nbsp; Except for a couple of
suggestions about hand-written slides, it still applies today.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="multi"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何制作正确执行多进程程序的多处理器计算机</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE Transactions on Computers C-</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 28，9（1979 年 9 月）690-691。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/multi.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1979 允许个人使用本材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我忘记了是什么促使我考虑内存缓存，但有一天我突然想到，多处理器同步算法假设每个处理器访问内存中的同一个字，但每个处理器实际上访问其缓存中自己的副本。</font><font style="vertical-align:inherit">几乎不需要三位数的智商就能意识到这可能会导致问题。</font><font style="vertical-align:inherit">我想这篇论文之所以值得一读，是因为它对顺序一致性的简单、精确的定义作为所需的正确性条件。</font><font style="vertical-align:inherit">这不是第一篇关于缓存一致性的论文。</font><font style="vertical-align:inherit">然而，它是缓存一致性文献中最常引用的早期论文。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="multi"><b>How to Make a Multiprocessor Computer That Correctly
   Executes Multiprocess Programs</b><br><i>IEEE Transactions on Computers
   C-28</i>, 9 (September 1979) 690-691.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/multi.pdf">PDF</a>
<br><font size="-2">Copyright © 1979 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


I forget what prompted me to be thinking about memory caching, but it
occurred to me one day that multiprocessor synchronization algorithms
assume that each processor accesses the same word in memory, but each
processor actually accesses its own copy in its cache.&nbsp; It hardly
required a triple-digit IQ to realize that this could cause problems.&nbsp;
I suppose what made this paper worth reading was its simple, precise
definition of sequential consistency as the required correctness
condition.&nbsp; This was not the first paper about cache coherence.&nbsp;
However, it is the early paper most often cited in the cache-coherence
literature.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="dig-sig"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">从单向函数构建数字签名</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRI 国际技术报告 CSL-98（1979 年 10 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/dig-sig.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1975 年左右，在伯克利的一家咖啡馆，Whitfield Diffie 向我描述了他一直试图解决的一个问题：为文档构建数字签名。</font><font style="vertical-align:inherit">我立即提出了解决方案。</font><font style="vertical-align:inherit">虽然不太实用——它可能需要 64 位的公开密钥来签署单个位——但它是第一个数字签名算法。</font><font style="vertical-align:inherit">迪菲和赫尔曼在他们的经典论文中提到了这一点：
 </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
惠特菲尔德·迪菲和马丁·E·赫尔曼。</font><font style="vertical-align:inherit">密码学的新方向。&nbsp;&nbsp;
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE 信息论汇刊 IT-22</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 6 (1976), 644-654。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
（我认为它位于第 650 页的右下角。）&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
1978 年，Michael Rabin 发表了一篇题为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《数字化签名》的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文，其中包含生成文档数字签名的更实用的方案。</font><font style="vertical-align:inherit">（我不记得已经提出了哪些其他数字签名算法。）但是，他的解决方案有一些缺点，限制了其实用性。</font><font style="vertical-align:inherit">本报告描述了对拉宾算法的改进，消除了这些缺点。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我不知道为什么我从未发表过这份报告。</font><font style="vertical-align:inherit">然而，我认为这是因为，在写完它之后，我意识到该算法可以相当容易地直接从拉宾算法中推导出来。</font><font style="vertical-align:inherit">所以，我并不认为这对拉宾所做的事情有多大帮助。</font><font style="vertical-align:inherit">然而，我被告知这篇论文在密码学文献中被引用，并且被认为很重要，所以也许我错了。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="dig-sig"><b>Constructing Digital Signatures from a One Way
   Function</b><br>SRI International Technical Report CSL-98 (October 1979).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/dig-sig.pdf">PDF</a><hr>


At a coffee house in Berkeley around 1975, Whitfield Diffie described
a problem to me that he had been trying to solve: constructing a
digital signature for a document.&nbsp; I immediately proposed a solution.&nbsp;
Though not very practical--it required perhaps 64 bits of published
key to sign a single bit--it was the first digital signature
algorithm.&nbsp; Diffie and Hellman mention it in 
their classic paper:
 <blockquote><p> 
Whitfield Diffie and Martin E. Hellman.&nbsp;&nbsp;
 New Directions in Cryptography.&nbsp;&nbsp;
<i>IEEE Transactions on Information Theory IT-22</i>, 6
(1976), 644-654.&nbsp;
 </p></blockquote>
(I think it's at the bottom right of page 650.)&nbsp;

<p>
In 1978, Michael Rabin published a paper titled <i>Digitalized
Signatures</i> containing a more practical scheme for generating digital
signatures of documents.&nbsp; (I don't remember what other digital
signature algorithms had already been proposed.)&nbsp; However, his
solution had some drawbacks that limited its utility.&nbsp; This report
describes an improvement to Rabin's algorithm that eliminates those
drawbacks.&nbsp;

</p><p>
I'm not sure why I never published this report.&nbsp; However, I think it
was because, after writing it, I realized that the algorithm could be
fairly easily derived directly from Rabin's algorithm.&nbsp; So, I didn't
feel that it added much to what Rabin had done.&nbsp; However, I've been
told that this paper is cited in the cryptography literature and is
considered significant, so perhaps I was wrong.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="calendar"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于ACM</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">日历程序通信的正确性证明</font></b><font style="vertical-align:inherit">22 , 10 (1979 年 10 月), 554-556。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/calendar.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1979 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 1978 年 5 月的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">上，Matthew Geller 发表了一篇题为“
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">测试数据作为证明程序正确性的辅助工具”的论文</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">他认为，有些程序的正确性很难正式声明，因此正式验证它们是没有用的，因为规范很可能是错误的。</font><font style="vertical-align:inherit">他举了一个计算同一年中两个日期之间的天数的程序作为例子，声称很难检查程序正确性的精确陈述的正确性。</font><font style="vertical-align:inherit">这篇论文证明他错了。</font><font style="vertical-align:inherit">（它还提出了一个有趣的观察结果，即盖勒的解决方案是错误的，因为它对于公历出现之前的日期失败。）作为奖励，本文的读者提前很早就被告知 2000 年是闰年。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="calendar"><b>On the Proof of Correctness of a Calendar
   Program</b><br><i>Communications of the ACM 22</i>, 10 &nbsp; (October 1979), 554-556.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/calendar.pdf">PDF</a>
<br><font size="-2">Copyright © 1979 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


In the May, 1978 <i>CACM</i>, Matthew Geller published a paper titled
<i>Test Data as an Aid in Proving Program Correctness</i>.&nbsp; He argued
that there were some programs whose correctness is so hard to state
formally that formally verifying them is useless because the
specification is likely to be wrong.&nbsp; He gave as an example a program
to compute the number of days between two dates in the same year,
claiming that it would be hard to check the correctness of a precise
statement of what it meant for the program to be correct.&nbsp; This paper
proved him wrong.&nbsp; (It also makes the amusing observation that
Geller's solution is wrong because it fails for dates before the
advent of the Gregorian calendar.)&nbsp; As a bonus, readers of this paper
were alerted well in advance that the year 2000 is a leap year.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="letter-to-editor"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">致编辑</font></b><font style="vertical-align:inherit">通讯 22 , 11 (1979 年 11 月), 624. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/letter-to-editor.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1979 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1979 年 5 月，</font><font style="vertical-align:inherit">De Millo、Lipton 和 Perlis在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM上发表了一篇颇具影响力的论文，题为</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">“社会过程以及定理和程序的证明”</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">本文提出了一些出色的观察结果。</font><font style="vertical-align:inherit">然而，通过抛出一些转移注意力的东西，他们得出了一些关于程序验证的错误结论。</font><font style="vertical-align:inherit">更阴险的是，他们将这场争论定义为完全忽视验证的合理工程方法与仅由最天真的支持者所提倡的完全不切实际的验证观点之间的争论。</font><font style="vertical-align:inherit">（不幸的是，这样的支持者有不少。）当时，一些 ACM 出版物有专门关于算法的章节。</font><font style="vertical-align:inherit">讽刺的是，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM的同一期</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">
执行 ACM 关于算法提交的官方政策。</font><font style="vertical-align:inherit">其中包括对代码形式的各种要求，甚至对注释的要求。</font><font style="vertical-align:inherit">缺少以任何方式证明算法正确性的任何要求。</font><font style="vertical-align:inherit">我对这样的想法感到震惊：在弗洛伊德和霍尔进行验证工作十年后，ACM 愿意发布没有正确性论证的算法。</font><font style="vertical-align:inherit">我写这封信的目的是表达我的沮丧。</font><font style="vertical-align:inherit">我讽刺地指出，他们在政策上屈服于德米洛、立顿和玻璃市的论点。</font><font style="vertical-align:inherit">结果，我的信被发表，作为对德米洛、利普顿和玻璃市论文的反驳。</font><font style="vertical-align:inherit">似乎没有人真正理解它的本质——请求改变 ACM 算法政策，要求有一些论据来表明算法有效。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="letter-to-editor"><b>Letter to the Editor</b><br><i>Communications of the ACM 22</i>, 11 &nbsp;
(November 1979), 624.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/letter-to-editor.pdf">PDF</a>
<br><font size="-2">Copyright © 1979 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


In the May, 1979 <i>CACM</i>, De Millo, Lipton, and Perlis published
an influential paper titled <i>Social Process and Proofs of
Theorems and Programs</i>.&nbsp; This paper made some excellent observations.&nbsp;
However, by throwing in a few red herrings, they came to some wrong
conclusions about program verification.&nbsp; More insidiously, they framed
the debate as one between a reasonable engineering approach that
completely ignores verification and a completely unrealistic view of
verification advocated only by its most naive proponents.&nbsp; (There
were, unfortunately, quite a few such proponents.)&nbsp;

At that time, some ACM publications had a special section on
algorithms.&nbsp; In an ironic coincidence, the same issue of <i>CACM</i>
carried the official ACM policy on algorithm submissions.&nbsp; It included
all sorts of requirements on the form of the code, and even on the
comments.&nbsp; Missing was any requirement that the correctness of the
algorithm be demonstrated in any way.&nbsp;

I was appalled at the idea that, ten years after Floyd and Hoare's
work on verification, the ACM was willing to publish algorithms with
no correctness argument.&nbsp; The purpose of my letter was to express my
dismay.&nbsp; I ironically suggested that they had succumbed to the
arguments of De Millo, Lipton, and Perlis in their policy.&nbsp; As a
result, my letter was published as a rebuttal to the De Millo, Lipton,
and Perlis paper.&nbsp; No one seems to have taken it for what it was--a
plea to alter the ACM algorithms policy to require that there be some
argument to indicate that an algorithm worked.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="sometime"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">“有时”有时“并非永不”</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第七届 ACM 编程语言原理研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，ACM SIGACT-SIGPLAN（1980 年 1 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/sometime.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1980 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


从康奈尔大学毕业后，苏珊·奥维奇加入了斯坦福大学。</font><font style="vertical-align:inherit">1978 年左右的某个时候，她组织了一次研讨会，研究 Amir Pnueli 最近引入计算机科学的时序逻辑。</font><font style="vertical-align:inherit">我确信时间逻辑是某种抽象的废话，永远不会有任何实际应用，但它看起来很有趣，所以我参加了。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我观察到人们变得非常困惑，因为在 Pnueli 的逻辑中，总是</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
</font><i><font style="vertical-align:inherit">最终</font></i><font style="vertical-align:inherit">的概念</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">意味着他们对普通人所做的事情。</font><font style="vertical-align:inherit">特别是，当且仅当某件事最终是错误的时，它并不总是正确的。</font><font style="vertical-align:inherit">（并不总是下雨意味着它最终会停止下雨。）然而，大多数计算机科学家有不同的思维方式。</font><font style="vertical-align:inherit">对他们来说，当且仅当某件事可能变成错误时，它并不总是正确的。</font><font style="vertical-align:inherit">（程序并不总是产生正确的答案，这意味着它可能会产生错误的答案。）&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我意识到时间逻辑有两种类型：Pnueli 使用的一种我称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">线性时间</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">逻辑；另一种是我使用的。</font><font style="vertical-align:inherit">大多数计算机科学家似乎认为这是一种自然现象，我称之为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分支时间</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">（这些术语是由时间逻辑学家使用的，但他们通过它们满足的公理来区分这两种逻辑，而我则用不同类型的语义来描述它们。） Pnueli 选择了正确的逻辑类型，即对于表达并发系统的属性最有用。</font><font style="vertical-align:inherit">我写这篇论文是为了解释这两种逻辑，并提倡使用线性时间逻辑。</font><font style="vertical-align:inherit">然而，我认为如果没有一些真正的定理，这篇论文就无法发表。</font><font style="vertical-align:inherit">因此，我证明了一些简单的结果，证明这两种逻辑确实不同。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我将这篇论文提交给了埃维昂会议，这是一个在法国举行的并发会议，似乎该领域的每个人都参加了。</font><font style="vertical-align:inherit">我被告知我的论文被拒绝了，因为他们接受了 Pnueli 的一篇关于时态逻辑的论文，他们认为这样一个晦涩的主题不值得写两篇论文。</font><font style="vertical-align:inherit">然后我把论文提交给FOCS，也被拒绝了。</font><font style="vertical-align:inherit">我很少重新提交被拒绝的论文。</font><font style="vertical-align:inherit">幸运的是，我觉得这篇论文应该发表。</font><font style="vertical-align:inherit">它已成为时间逻辑文献中最常被引用的论文之一。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="sometime"><b>`Sometime' is Sometimes `Not
   Never'</b><br><i>Proceedings of the Seventh ACM Symposium on Principles
   of Programming Languages</i>, ACM SIGACT-SIGPLAN (January 1980).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/sometime.pdf">PDF</a>
<br><font size="-2">Copyright © 1980 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


After graduating from Cornell, Susan Owicki joined the faculty of
Stanford.&nbsp; Some time around 1978, she organized a seminar to study the
temporal logic that Amir Pnueli had recently introduced to computer
science.&nbsp; I was sure that temporal logic was some kind of abstract
nonsense that would never have any practical application, but it
seemed like fun, so I attended.&nbsp; I observed that people got very
confused because, in Pnueli's logic, the concepts of <i>always</i> and
<i>eventually</i> mean what they do to ordinary people.&nbsp; In
particular, something is not always true if and only if it is
eventually false.&nbsp; (It doesn't always rain means that it eventually
stops raining.)&nbsp; However, most computer scientists have a different
way of thinking.&nbsp; For them, something is not always true if and only
if it might possibly become false.&nbsp; (The program doesn't always
produce the right answer means that it might produce the wrong
answer.)&nbsp; 

<p>
I realized that there are two types of temporal logic: the one Pnueli
used I called <i>linear time</i> logic; the one most computer
scientists seemed to find natural I called <i>branching time</i>.&nbsp;
(These terms were used by temporal logicians, but they distinguished
the two logics by the axioms they satisfied, while I described them in
terms of different kinds of semantics.)&nbsp; Pnueli chose the right kind
of logic--that is, the one that is most useful for expressing
properties of concurrent systems.&nbsp; I wrote this paper to explain the
two kinds of logic, and to advocate the use of linear-time logic.&nbsp;
However, I figured that the paper wouldn't be publishable without some
real theorems.&nbsp; So, I proved some simple results demonstrating that
the two kinds of logic really are different.&nbsp;

</p><p>
I submitted the paper to the Evian Conference, a conference on
concurrency held in France to which it seems that everyone working in
the field went.&nbsp; I was told that my paper was rejected because they
accepted a paper by Pnueli on temporal logic, and they didn't feel
that such an obscure subject merited two papers.&nbsp; I then submitted the
paper to FOCS, where it was also rejected.&nbsp; I have very rarely
resubmitted a paper that has been rejected.&nbsp; Fortunately, I felt that
this paper should be published.&nbsp; It has become one of the most
frequently cited papers in the temporal-logic literature.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="hoare"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序的“霍尔逻辑” </font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Acta Informatica 14</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (1980), 21-37。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"></font></a><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">正如[23]</font></font></a><font style="vertical-align:inherit"><a name="hoare"><font style="vertical-align:inherit">


的讨论中所解释的</font></a><font style="vertical-align:inherit">，Owicki-Gries 方法及其变体是用于推理顺序程序的 Floyd 方法的概括。</font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">霍尔的方法用一组公理形式化了弗洛伊德的方法，用于导出{P}S{Q}</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">形式的三元组
</font><font style="vertical-align:inherit">，这意味着如果语句
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">S从</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">为 true的状态执行</font><font style="vertical-align:inherit">并终止，则</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Q</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">将为 true。</font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文介绍了霍尔方法对并发程序的推广，用{I}S</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">形式的断言替换霍尔三元组</font><font style="vertical-align:inherit">，这意味着语句</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">S</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的各个操作使谓词</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">I</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">保持不变。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
当我写这篇论文时，我给托尼·霍尔寄了一份副本，以为他会喜欢。</font><font style="vertical-align:inherit">他在一封回信中大致说：“我一直认为并发程序的泛化必须看起来像那样；这就是为什么我从未这样做过。” </font><font style="vertical-align:inherit">（不幸的是，我已经没有那封信了。） 当时，我认为他的言论是老顽固的胡言乱语。</font><font style="vertical-align:inherit">我现在认为他是对的——尽管原因可能与他不同。</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">正如我在[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论中指出的</font><font style="vertical-align:inherit">，我认为阿什克罗夫特是对的；</font><font style="vertical-align:inherit">人们应该简单地推理单个全局不变量，而不是基于程序结构进行这种分解。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="hoare"><b>The `Hoare Logic' of Concurrent Programs</b><br><i>Acta 
   Informatica 14</i>, 1 (1980), 21-37.<br>
No electronic version available.<hr>


As explained in the discussion of </a><a href="#proving">[23]</a>, the Owicki-Gries
method and its variants are generalizations of Floyd's method for
reasoning about sequential programs.&nbsp; Hoare's method formalizes
Floyd's with a set of axioms for deriving triples of the form
<tt>{P}S{Q}</tt>, which means that if statement
<i>S</i> is executed from a state in which <i>P</i> is true and
terminates, then <i>Q</i> will be true.&nbsp; This paper introduces the
generalization of Hoare's method to concurrent programs, replacing
Hoare triples with assertions of the form <tt>{I}S</tt>,
which means that the individual actions of statement <i>S</i> leave
the predicate <i>I</i> invariant.&nbsp; 

<p>
When I wrote this paper, I sent a copy to Tony Hoare thinking that he
would like it.&nbsp; He answered with a letter that said, approximately:
"I always thought that the generalization to concurrent programs
would have to look something like that; that's why I never did it."
(Unfortunately, I no longer have the letter.)&nbsp; At the time, I
dismissed his remark as the ramblings of an old fogey.&nbsp; I now think he
was right--though probably for different reasons than he does.&nbsp; As I
indicated in the discussion of <a href="#proving">[23]</a>, I think Ashcroft was
right; one should simply reason about a single global invariant, and
not do this kind of decomposition based on program structure.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="reaching"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">在存在故障时达成一致</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Marshall Pease 和 Robert Shostak）《</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机协会杂志》27</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1980 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/reaching.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1980 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在本文发表之前，人们普遍认为三处理器系统可以容忍一个有故障的处理器。</font><font style="vertical-align:inherit">本文表明，“拜占庭”故障（其中有故障的处理器向其他处理器发送不一致的信息）可以击败任何传统的三处理器算法。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（拜占庭</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">一词直到</font></font><a href="#byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[46]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">才出现</font><font style="vertical-align:inherit">。）一般来说，3</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">需要 +1 个处理器来容忍</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n 个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">故障。</font><font style="vertical-align:inherit">但是，如果使用数字签名，2</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">+1 个处理器就足够了。</font><font style="vertical-align:inherit">本文介绍了拜占庭故障的处理问题。</font><font style="vertical-align:inherit">我认为它也包含了对共识问题的第一个精确陈述。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我经常被不公平地认为是拜占庭协议问题的发明者。</font><font style="vertical-align:inherit">在我到达 SRI 之前，</font><font style="vertical-align:inherit">这个问题是由 SIFT 工作人员提出的（参见</font></font><a href="#sift"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[30] ）。</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">我已经发现了拜占庭错误的问题并写了
</font></font><a href="#implementation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[29]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">（我不知道这是否早于 SRI 的发现，或者与 SRI 的发现同时发生。）然而，SRI 的人们对这个问题的描述比 [29] 中的更简单、更</font></font><a href="#implementation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">优雅</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

本文提出的4处理器解决方案和一般不可能结果是由Shostak获得的；</font><font style="vertical-align:inherit">皮斯发明了3</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">+1-处理器解决方案。</font><font style="vertical-align:inherit">我对本文工作的贡献是使用数字签名的解决方案，该解决方案基于</font></font><a href="#implementation"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[29]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的算法。</font><font style="vertical-align:inherit">正是我在数字签名方面的工作（参见</font></font><a href="#dig-sig"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[36]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）引导我朝这个方向思考。</font><font style="vertical-align:inherit">然而，这里使用的数字签名是一个隐喻。</font><font style="vertical-align:inherit">由于签名只需针对随机故障，而不是针对智能对手，因此它们比真正的数字签名更容易实现。</font><font style="vertical-align:inherit">然而，这一点似乎大多数人都忽略了，因此他们排除了使用数字签名的算法，因为真正的数字签名算法是昂贵的。</font><font style="vertical-align:inherit">因此，3</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">即使有令人满意的2，也使用+1-处理器解决方案</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">+1-处理器解决方案，

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我对这篇论文的另一个贡献是把它写出来。</font><font style="vertical-align:inherit">写作是一项艰苦的工作，在没有死亡威胁的情况下，学术界以外的研究人员发表的文章通常比大学同事少。</font><font style="vertical-align:inherit">我写了一份初稿，这让肖斯塔克非常不高兴，以至于他完全重写了它以产生最终版本。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
多年来，我经常想知道真正制造飞机的人是否了解拜占庭式失败的问题。</font><font style="vertical-align:inherit">1997年，我收到了曾在波音公司工作的约翰·摩根的电子邮件。</font><font style="vertical-align:inherit">他告诉我，他在 1986 年就看到了我们的工作，因此，波音公司制造客机的人员意识到了这个问题，并相应地设计了他们的系统。</font><font style="vertical-align:inherit">但是，在 80 年代末和 90 年代初，波音公司从事军用飞机和空间站工作的人员以及麦道公司的人员并没有理解这个问题。</font><font style="vertical-align:inherit">我不知道空中客车公司知道什么，也不知道他们什么时候知道的。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该论文荣获 2005 年分布式计算领域的 Edsger W. Dijkstra 奖。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="reaching"><b>Reaching Agreement in the Presence of Faults</b>&nbsp; (with Marshall 
   Pease and Robert Shostak)<br><i>Journal of the
   Association for Computing Machinery 27</i>, 2 (April 1980).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/reaching.pdf">PDF</a>
<br><font size="-2">Copyright © 1980 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Before this paper, it was generally assumed that a three-processor
system could tolerate one faulty processor.&nbsp; This paper shows that
"Byzantine" faults, in which a faulty processor sends inconsistent
information to the other processors, can defeat any traditional
three-processor algorithm.&nbsp; (The term <i>Byzantine</i> didn't appear
until <a href="#byz">[46]</a>.)&nbsp; In general, 3<it>n</it>+1
processors are needed to tolerate <i>n</i> faults.&nbsp; However, if
digital signatures are used, 2<it>n</it>+1 processors
are enough.&nbsp; This paper introduced the problem of handling Byzantine
faults.&nbsp; I think it also contains the first precise statement of the
consensus problem.&nbsp;

<p> I am often unfairly credited with inventing the Byzantine
agreement problem.&nbsp; The problem was formulated by people working on
SIFT (see <a href="#sift">[30]</a>) before I arrived at SRI.&nbsp; I had
already discovered the problem of Byzantine faults and written
<a href="#implementation">[29]</a>.&nbsp; (I don't know if that was earlier than or
concurrent with its discovery at SRI.)&nbsp; However, the people
at SRI had a much simpler and more elegant statement of the problem
than was present in <a href="#implementation">[29]</a>.&nbsp;

</p><p>

The 4-processor solution presented in this paper and the general
impossibility result were obtained by Shostak; Pease invented the
3<it>n</it>+1-processor solution.&nbsp; My contribution to
the work in this paper was the solution using digital signatures,
which is based on the algorithm in <a href="#implementation">[29]</a>.&nbsp; It was my
work on digital signatures (see <a href="#dig-sig">[36]</a>) that led me to think
in that direction.&nbsp; However, digital signatures, as used here, are a
metaphor.&nbsp; Since the signatures need be secure only against random
failure, not against an intelligent adversary, they are much easier to
implement than true digital signatures.&nbsp; However, this point seems to
have escaped most people, so they rule out the algorithms that use
digital signatures because true digital signature algorithms are
expensive.&nbsp; Thus, 3<it>n</it>+1-processor solutions are
used even though there are satisfactory
2<it>n</it>+1-processor solutions,

</p><p>
My other contribution to this paper was getting it written.&nbsp; Writing
is hard work, and without the threat of perishing, researchers outside
academia generally do less publishing than their colleagues at
universities.&nbsp; I wrote an initial draft, which displeased Shostak so
much that he completely rewrote it to produce the final version.&nbsp;

</p><p>
Over the years, I often wondered whether the people who actually build
airplanes know about the problem of Byzantine failures.&nbsp; In 1997, I
received email from John Morgan who used to work at Boeing.&nbsp; He told
me that he came across our work in 1986 and that, as a result, the
people who build the passenger planes at Boeing are aware of the
problem and design their systems accordingly.&nbsp; But, in the late 80s
and early 90s, the people at Boeing working on military aircraft and
on the space station, and the people at McDonnell-Douglas, did not
understand the problem.&nbsp; I have no idea what Airbus knows or when
they knew it.&nbsp;

</p><p>
This paper was awarded the 2005 Edsger W. Dijkstra Prize in
Distributed Computing.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="program"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">程序验证：可靠硬件和软件的方法</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 J S. Moore 合着）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Transactions of the American Nuclear Society 35</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1980 年 11 月），252-253。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1980年，我和J Moore都在SRI，曾参与SIFT的验证（见</font></font></a><a href="#sift"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[30]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">出于显而易见的原因，核电行业对计算机系统的正确性感兴趣。</font><font style="vertical-align:inherit">我忘记了它是如何通过的，但摩尔和我被邀请在电力行业工程师的一些会议上发表一篇关于验证的论文。</font><font style="vertical-align:inherit">结果就是这样。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="program"><b>Program Verification: An Approach to Reliable Hardware
   and Software</b>&nbsp; (with J S. Moore)<br><i>Transactions of the American Nuclear
   Society 35</i> (November 1980), 252-253.<br>
No electronic version available.<hr>


In 1980, J&nbsp;Moore and I were both at SRI and had been
involved in the verification of SIFT (see </a><a href="#sift">[30]</a>).&nbsp; The nuclear
power industry was, for obvious reasons, interested in the correctness
of computer systems.&nbsp; I forget how it came to pass, but Moore and I
were invited to present a paper on verification at some meeting of
power industry engineers.&nbsp; This was the result.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="password"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">密码认证与不安全通信</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 24 的通信</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，11（1981 年 11 月），770-772。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/password.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1981 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


尽管对民用密码学的起源有偶然的兴趣（参见</font></font><a href="#dig-sig"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[36]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论），这是我在该领域唯一的出版物。</font><font style="vertical-align:inherit">它提供了一种可爱的黑客方法，可以使用单个密码多次登录系统，而不会让对手通过窃听来访问系统。</font><font style="vertical-align:inherit">这种黑客攻击是 Bellcore 的 S/KEY 系统以及 Rivest 和 Shamir 的 PayWord 系统的基础。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="password"><b>Password Authentication with Insecure
   Communication</b><br><i>Communications of the ACM 24</i>, 11 &nbsp; (November 1981), 770-772.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/password.pdf">PDF</a>
<br><font size="-2">Copyright © 1981 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Despite a casual interest in civilian cryptography going back to its
origins (see the discussion of <a href="#dig-sig">[36]</a>), this is my only
publication in the field.&nbsp; It presents a cute hack for using a single
password to login to a system multiple times without allowing an
adversary to gain access to the system by eavesdropping.&nbsp; This hack is
the basis of Bellcore's S/KEY system and of the PayWord system of
Rivest and Shamir.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="lamport-timesets"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TIMESETS - A New Method for Temporal Reasoning About Programs </font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Logics of Programs</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Dexter Kozen 编辑，Springer-Verlag 计算机科学讲义第 131 卷 (1982)，177-196。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Pnueli 在 1977 年引入时态逻辑，引发了寻找新逻辑来指定和推理并发系统的尝试。</font><font style="vertical-align:inherit">每个人都在寻找能够解决该领域问题的灵丹妙药逻辑。</font><font style="vertical-align:inherit">这篇论文证明我也未能幸免于这种发烧。</font></font></a><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">由于[50]</font></font></a><font style="vertical-align:inherit"><a name="lamport-timesets"><font style="vertical-align:inherit">讨论中解释的原因
</font></a><font style="vertical-align:inherit">，最好忘记它。</font><font style="vertical-align:inherit">有些人可能会发现这具有历史意义，因为它是区间逻辑的早期示例。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-timesets"><b>TIMESETS--A New Method for Temporal 
   Reasoning About Programs</b><br><i>Logics of Programs</i>, Dexter Kozen
   editor, Springer-Verlag Lecture Notes in Computer Science 
   Volume 131 (1982), 177-196.<br>
No electronic version available.<hr>


Pnueli's introduction of temporal logic in 1977 led to an explosion of
attempts to find new logics for specifying and reasoning about
concurrent systems.&nbsp; Everyone was looking for the silver-bullet logic
that would solve the field's problems.&nbsp; This paper is proof that I was
not immune to this fever.&nbsp; For reasons explained in the discussion of
</a><a href="#spec">[50]</a>, it is best forgotten.&nbsp; Some people may find this of
historical interest because it is an early example of an interval
logic.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="trans"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军和交易提交协议</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Michael Fischer 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布（1982 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/trans.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/trans.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/trans.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1982年春天，我在耶鲁大学拜访了Michael Fischer。众所周知，解决能够处理
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭失败的拜占庭将军问题需要</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> +1轮通信。</font><font style="vertical-align:inherit">当我在耶鲁大学时，费舍尔和我证明，即使是处理更良性的故障，也需要这么多轮次。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
在回加州的途中，早上，我在拉瓜迪亚机场登上了飞机，暴风雪袭来。大约八小时后，我在拉瓜迪亚机场下了飞机，写完这篇论文。</font><font style="vertical-align:inherit">然后我将其发送给费舍尔征求他的意见。</font><font style="vertical-align:inherit">我等了大约一年半。</font><font style="vertical-align:inherit">当他最终决定不再在这篇论文上做任何更多的工作时，其他人的后续工作已经发表，取代了它。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="trans"><b>Byzantine Generals and Transaction Commit Protocols</b>&nbsp; (with Michael 
  Fischer)<br>Unpublished (April 1982).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/trans.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/trans.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/trans.pdf">PDF</a><hr>


I visited Michael Fischer at Yale in the spring of 1982.&nbsp; It was known
that solutions to the Byzantine generals problem that can handle
<i>n</i> Byzantine failures require <i>n</i>+1 rounds of
communication.&nbsp; While I was at Yale, Fischer and I proved that this
number of rounds were needed even to handle more benign failures.&nbsp;

<p>
On the trip back home to California, I got on an airplane at Laguardia
Airport in the morning with a snowstorm coming in.&nbsp; I got off the
airplane about eight hours later, still at Laguardia Airport, having
written this paper.&nbsp; I then sent it to Fischer for his comments.&nbsp; I
waited about a year and a half.&nbsp; By the time he finally decided that
he wasn't going to do any more work on the paper, subsequent work by
others had been published that superseded it.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="byz"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军问题</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Marshall Pease 和 Robert Shostak 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions onProgramming Languages and Systems 4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1982 年 7 月），382-401。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/byz.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1982 Association for Computer Machinery, Inc。允许免费制作本作品部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">

   
我长期以来一直认为，由于迪杰斯特拉的哲学家就餐问题是作为一个关于坐在桌子周围的哲学家的可爱问题而提出的，所以它受到了比应有的更多的关注。</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（例如，它可能比读者/作者问题在理论界受到更多关注，它说明了相同的原理，并且具有更实际的重要性。）我认为[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中引入的问题非常重要，值得讨论</font><font style="vertical-align:inherit">。计算机科学家的关注。</font><font style="vertical-align:inherit">哲学家就餐问题的流行告诉我，吸引人们注意问题的最好方法是以故事的形式呈现它。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算中存在一个问题，有时被称为“中国将军问题”，即两名将军必须就进攻或撤退达成共识，但只能通过派遣可能永远不会到达的信使来进行沟通。</font><font style="vertical-align:inherit">我窃取了将军们的想法，并以一群将军（其中一些可能是叛徒）的形式提出了这个问题，他们必须达成共同的决定。</font><font style="vertical-align:inherit">我想给将军们指定一个不会冒犯任何读者的国籍。</font><font style="vertical-align:inherit">当时阿尔巴尼亚是一个完全封闭的社会，我觉得不太可能有阿尔巴尼亚人反对，所以这篇论文的原标题是《
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">阿尔巴尼亚将军问题》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">杰克·戈德堡很聪明，他意识到阿尔巴尼亚以外的世界上还有阿尔巴尼亚人，而阿尔巴尼亚可能并不总是一个黑洞，所以他建议我再找一个名字。</font><font style="vertical-align:inherit">然后我想到了显然更合适的拜占庭将军。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
撰写本文的主要原因是为该问题指定新名称。</font><font style="vertical-align:inherit">但新论文也需要新结果。</font><font style="vertical-align:inherit">我想出了一个更简单的方法来描述一般 3</font></font><it><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></it><font style="vertical-align:inherit"><font style="vertical-align:inherit">+1-处理器算法。</font><font style="vertical-align:inherit">（肖斯塔克的 4 处理器算法很微妙，但很容易理解；皮斯的泛化是一项非凡的杰作。）我们还为未完全连接的网络添加了泛化。</font><font style="vertical-align:inherit">（我不记得那是谁的工作了。）我还添加了一些实际实现细节的讨论。&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li> <a name="byz"><b>The Byzantine Generals Problem</b>&nbsp; (with Marshall Pease and Robert
   Shostak)<br><i>ACM Transactions on Programming Languages and Systems 4</i>, 3 (July 1982), 382-401.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/byz.pdf">PDF</a>
<br><font size="-2">Copyright © 1982 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>

   
I have long felt that, because it was posed as a cute problem about
philosophers seated around a table, Dijkstra's dining philosopher's
problem received much more attention than it deserves.&nbsp; (For example,
it has probably received more attention in the theory community than
the readers/writers problem, which illustrates the same principles and
has much more practical importance.)&nbsp; I believed that the problem
introduced in <a href="#reaching">[41]</a> was very important and deserved the
attention of computer scientists.&nbsp; The popularity of the dining
philosophers problem taught me that the best way to attract attention
to a problem is to present it in terms of a story.&nbsp;

<p> There is a problem in distributed computing that is
sometimes called the Chinese Generals Problem, in which two generals
have to come to a common agreement on whether to attack or retreat,
but can communicate only by sending messengers who might never arrive.&nbsp;
I stole the idea of the generals and posed the problem in terms of a
group of generals, some of whom may be traitors, who have to reach a
common decision.&nbsp; I wanted to assign the generals a nationality that
would not offend any readers.&nbsp; At the time, Albania was a completely
closed society, and I felt it unlikely that there would be any
Albanians around to object, so the original title of this paper was
<i>The Albanian Generals Problem</i>.&nbsp; Jack Goldberg was smart enough
to realize that there were Albanians in the world outside Albania, and
Albania might not always be a black hole, so he suggested that I find
another name.&nbsp; The obviously more appropriate Byzantine generals then
occurred to me.&nbsp;

</p><p>
The main reason for writing this paper was to assign the new name to
the problem.&nbsp; But a new paper needed new results as well.&nbsp; I came up
with a simpler way to describe the general
3<it>n</it>+1-processor algorithm.&nbsp; (Shostak's
4-processor algorithm was subtle but easy to understand; Pease's
generalization was a remarkable tour de force.)&nbsp; We also added a
generalization to networks that were not completely connected.&nbsp; (I
don't remember whose work that was.)&nbsp; I also added some discussion of
practical implementation details.&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="liveness"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明并发程序的活跃性</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Susan Owicki 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1982 年 7 月），455-495。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/liveness.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1982 Association for Computer Machinery, Inc。允许免费制作本作品部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 70 年代末和 80 年代初，Susan Owicki 和我经常一起工作。</font><font style="vertical-align:inherit">我们甚至计划写一本关于并发程序验证的书。</font><font style="vertical-align:inherit">但这篇论文是我们唯一一起写过的东西。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
在</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我介绍了一种通过绘制谓词网格来证明并发程序的偶发性属性的方法，其中从谓词</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">到谓词</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Q1</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , </font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">...</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Qn</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的箭头意味着，如果程序达到满足</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">P</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的状态此后必须达到一种满足</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">气</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的状态。</font><font style="vertical-align:inherit">这种方法似乎从来都不实用。</font><font style="vertical-align:inherit">将非正式证明形式化的工作量太大。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
Pnueli 引入时态逻辑使得格中的谓词可以被任意时态公式替换。</font><font style="vertical-align:inherit">这将点阵证明变成了证明活性特性的有用方法。</font><font style="vertical-align:inherit">它允许将证明的特殊写作风格直接形式化。</font></font><a href="#lamport-actions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">尽管证明是用 TLA 形式化的（参见[103]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ） ，但我仍然使用这种证明样式来证明导数属性
</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">不过，我不再费心去画格子了。</font><font style="vertical-align:inherit">本文还引入了</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">at</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">、
 </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">in</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">after</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">谓词来描述程序控制。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
人们习惯上按字母顺序列出作者，除非其中一个人的贡献明显多于另一个人，但当时我并不知道这种习惯。</font><font style="vertical-align:inherit">以下是奥维奇关于如何确定作者排序的说明。&nbsp;

</font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我记得，你提出了顺序问题，我建议按字母顺序排列。</font><font style="vertical-align:inherit">你拒绝了——我认为你期望这篇论文很重要，并且认为根据我们姓名的静态属性获得第一作者身份是不公平的。</font><font style="vertical-align:inherit">在我们完成论文的那天晚上，我们出去吃饭庆祝，你提议如果账单的最后一位数字是偶数（或者可能是奇数），我的名字就排在第一位。</font><font style="vertical-align:inherit">事实上，结果就是这样。&nbsp;
</font></font></p></blockquote>



<br>&nbsp;<p></p></li><li> <a name="liveness"><b>Proving Liveness Properties of Concurrent
   Programs</b>&nbsp; (with Susan Owicki)<br><i>ACM Transactions on Programming Languages and Systems 4</i>, 3 (July 1982), 455-495.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/liveness.pdf">PDF</a>
<br><font size="-2">Copyright © 1982 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


During the late 70s and early 80s, Susan Owicki and I worked together
quite a bit.&nbsp; We were even planning to write a book on concurrent
program verification.&nbsp; But this paper is the only thing we ever wrote
together.&nbsp; 

<p>
In <a href="#proving">[23]</a>, I had introduced a method of proving eventuality
properties of concurrent programs by drawing a lattice of predicates,
where arrows from a predicate <i>P</i> to predicates <i>Q1</i>, <tt>...</tt>, <i>Qn</i> mean that, if the
program reaches a state satisfying <i>P</i>, it must thereafter reach
a state satisfying one of the <i>Qi</i>.&nbsp; That method
never seemed practical; formalizing an informal proof was too much
work.&nbsp;

</p><p> 
Pnueli's introduction of temporal logic allowed the predicates in the
lattice to be replaced by arbitrary temporal formulas.&nbsp; This turned
lattice proofs into a useful way of proving liveness properties.&nbsp; It
permitted a straightforward formalization of a particularly style of
writing the proofs.&nbsp; I still use this proof style to prove leads-to
properties, though the proofs are formalized with TLA (see
<a href="#lamport-actions">[103]</a>).&nbsp; However, I no longer bother drawing
pictures of the lattices.&nbsp; This paper also introduced <i>at</i>,
<i>in</i>, and <i>after</i> predicates for describing program control.&nbsp;

</p><p> 
It's customary to list authors alphabetically, unless one contributed
significantly more than the other, but at the time, I was unaware of
this custom.&nbsp; Here is Owicki's account of how the ordering of the
authors was determined.&nbsp;

</p><blockquote><p> As I recall it, you raised the
question of order, and I proposed alphabetical order.&nbsp; You
declined--I think you expected the paper to be important and didn't
think it would be fair to get first authorship on the basis of a
static property of our names.&nbsp; On the night we finished the paper, we
went out to dinner to celebrate, and you proposed that if the last
digit of the bill was even (or maybe odd), my name would be first.&nbsp;
And, indeed, that's the way it came out.&nbsp;
</p></blockquote>



<br>&nbsp;<p></p></li><li> <a name="dist"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式程序的断言正确性证明</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机编程科学 2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3 (1982 年 12 月), 175-206。</font></font><br></a><a href="https://www.sciencedirect.com/science/article/pii/016764238390014X"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我在</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中表明，定义分布式系统的全局状态没有不变的方法。</font><font style="vertical-align:inherit">断言方法，例如</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，关于全局状态的推理。</font><font style="vertical-align:inherit">因此，我得出的结论是，这些方法不适合推理分布式系统。</font><font style="vertical-align:inherit">当我写这篇论文时，我在 SRI，部分资金来自政府合同，我们承诺为分布式算法编写正确性证明。</font><font style="vertical-align:inherit">我试图弄清楚如何在不推理全局状态的情况下编写正式证明，但我做不到。</font><font style="vertical-align:inherit">最终报告到期了，所以我决定除了写断言证明之外别无选择。</font><font style="vertical-align:inherit">我知道编写这样的证明是没有问题的，但我预计，由于它依赖于任意的全局状态，这个证明会很丑陋。</font><font style="vertical-align:inherit">令我惊讶的是，我发现证明非常优雅。</font><font style="vertical-align:inherit">哲学考虑告诉我，我不应该推理全球国家，</font><font style="vertical-align:inherit">但这次经验表明，这种推理是有效的。</font><font style="vertical-align:inherit">我一直更依赖经验而不是哲学，因此从那时起我就编写了分布式系统的断言证明。</font><font style="vertical-align:inherit">（其他更倾向于哲学的人花了几十年的时间寻找特殊的方法来推理分布式系统。）&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="dist"><b>An Assertional Correctness Proof of a Distributed
   Program</b><br><i>Science of Computer Programming 2</i>, 3 (December
   1982), 175-206.<br></a><a href="https://www.sciencedirect.com/science/article/pii/016764238390014X">Available On-Line</a><hr>


I showed in <a href="#time-clocks">[27]</a> that there is no invariant way of
defining the global state of a distributed system.&nbsp; Assertional
methods, such as <a href="#proving">[23]</a>, reason about the global state.&nbsp; So,
I concluded that these methods were not appropriate for reasoning
about distributed systems.&nbsp; When I wrote this paper, I was at SRI and
partly funded by a government contract for which we had promised to
write a correctness proof of a distributed algorithm.&nbsp; I tried to
figure out how to write a formal proof without reasoning about the
global state, but I couldn't.&nbsp; The final report was due, so I decided
that there was no alternative to writing an assertional proof.&nbsp; I knew
there would be no problem writing such a proof, but I expected that,
with its reliance on an arbitrary global state, the proof would be
ugly.&nbsp; To my surprise, I discovered that the proof was quite elegant.&nbsp;
Philosophical considerations told me that I shouldn't reason about
global states, but this experience indicated that such reasoning
worked fine.&nbsp; I have always placed more reliance on experience than
philosophy, so I have written assertional proofs of distributed
systems ever since.&nbsp; (Others who were more inclined to philosophy spent
decades looking for special ways to reason about distributed systems.)&nbsp;



<br>&nbsp;<p></p></li><li> <a name="nonatomic"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于非原子操作的</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">推理第十届 ACM 编程语言原理研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，ACM SIGACT-SIGPLAN（1983 年 1 月），28-37。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/nonatomic.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1983 Association for Computer Machinery, Inc。允许免费制作本作品部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">从我发现面包店算法（参见[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ）


 开始</font><font style="vertical-align:inherit">，我就对推理并发程序而不必将其分解为不可分割的原子操作的问题着迷。</font><font style="vertical-align:inherit">在</font></font><a href="#new-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[33]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我描述了如何进行行为推理。</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">但我意识到，如[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中所述
</font><font style="vertical-align:inherit">，断言推理是唯一可以扩展到更复杂问题的证明方法。</font><font style="vertical-align:inherit">这篇论文是我对非原子操作的断言推理的第一次尝试。</font><font style="vertical-align:inherit">它引入了后来出现在</font><a href="#lamport-win"><font style="vertical-align:inherit">[86]中的</font></a></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">win</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
（最弱不变式）运算符
</font><font style="vertical-align:inherit">，但使用了 Pratt 动态逻辑的表示法，而不是 Dijkstra 的谓词变换器。&nbsp;

</font></font><a href="#lamport-win"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font><p><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我的档案中有一封来自大卫·哈雷尔（David Harel）的信，他当时是《信息与控制</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">》杂志
的编辑</font><font style="vertical-align:inherit">，告诉我这篇论文在经过修改以满足审稿人的一些担忧后被该杂志接受。</font><font style="vertical-align:inherit">我不记得为什么我没有提交修改版本。</font><font style="vertical-align:inherit">我不认为裁判的要求无理。</font><font style="vertical-align:inherit">我不太可能放弃这篇论文，因为我已经在</font></font><a href="#lamport-win"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[86]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中开发了该方法，因为直到四年后它才作为 SRC 研究报告出现。</font><font style="vertical-align:inherit">也许我只是太忙了。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="nonatomic"><b>Reasoning About Nonatomic
   Operations</b><br><i>Proceedings of the Tenth ACM Symposium on Principles
   of Programming Languages</i>, ACM SIGACT-SIGPLAN (January 1983), 28-37.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/nonatomic.pdf">PDF</a>
<br><font size="-2">Copyright © 1983 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


 From the time I discovered the bakery algorithm (see <a href="#bakery">[12]</a>),
I was fascinated by the problem of reasoning about a concurrent
program without having to break it into indivisible atomic actions.&nbsp;
In <a href="#new-approach">[33]</a>, I described how to do this for behavioral
reasoning.&nbsp; But I realized that assertional reasoning, as described in
<a href="#proving">[23]</a>, was the only proof method that could scale to more
complex problems.&nbsp; This paper was my first attempt at assertional
reasoning about nonatomic operations.&nbsp; It introduces the <i>win</i>
(weakest invariant) operator that later appeared in
<a href="#lamport-win">[86]</a>, but using the notation of Pratt's dynamic logic
rather than Dijkstra's predicate transformers.&nbsp;

<p>
I have in my files a letter from David Harel, who was then an editor
of <i>Information and Control</i>, telling me that the paper was
accepted by the journal, after revision to satisfy some concerns of
the referees.&nbsp; I don't remember why I didn't submit a revised version.&nbsp;
I don't think I found the referees' requests unreasonable.&nbsp; It's
unlikely that I abandoned the paper because I had already developed
the method in <a href="#lamport-win">[86]</a>, since that didn't appear as a SRC
research report until four years later.&nbsp; Perhaps I was just too busy.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="spec"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定并发程序模块</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on 编程语言和系统 5</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1983 年 4 月），190-222。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1983 Association for Computer Machinery, Inc。允许免费制作本作品部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


早期推理并发程序的方法涉及证明程序满足某些属性——通常是不变性属性。</font><font style="vertical-align:inherit">但是，证明特定属性仅表明该程序满足这些属性。</font><font style="vertical-align:inherit">该程序仍然有可能是不正确的，因为它无法满足其他一些属性。</font><font style="vertical-align:inherit">大约在 80 年代初期，从事断言验证的人们开始寻找编写完整系统规范的方法。</font><font style="vertical-align:inherit">规范应该准确地说明系统正确意味着什么，这样如果我们证明系统满足其规范，那么我们就可以说系统确实是正确的。</font><font style="vertical-align:inherit">（自 70 年代中期以来，过程代数学家就已经在研究这个问题了，&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
在 SRI，我们致力于编写时序逻辑规范。</font><font style="vertical-align:inherit">人们可以使用时态逻辑来描述属性，因此通过简单地列出系统必须满足的所有属性来指定一个系统似乎是很自然的。</font><font style="vertical-align:inherit">Richard Schwartz、Michael Melliar-Smith 和我合作撰写了一篇题为“</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式系统的时间逻辑规范”的论文</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，发表于 1981 年在巴黎举行的第二届国际分布式计算系统会议的会议记录中。然而，当我看到 Schwartz、Melliar-Smith 和 Fritz Vogt 如何花费数天时间试图指定时态逻辑时，我对时态逻辑感到失望。一个简单的 FIFO 队列——争论他们列出的属性是否足够。</font><font style="vertical-align:inherit">我意识到，尽管它具有美学吸引力，但将规范编写为时间属性的结合在实践中行不通。</font><font style="vertical-align:inherit">因此，在论文发表之前，我把自己的名字从论文中删除了，然后我开始寻找一种实用的方法来编写规范。</font><font style="vertical-align:inherit">我提出了本文中描述的方法，后来我将其称为
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">转换公理</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">方法。</font><font style="vertical-align:inherit">Schwartz 在 80 年代中期停止了规范和验证工作。</font><font style="vertical-align:inherit">他最近（2000 年 6 月）写道：
</font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
对时态逻辑的使用同样的挫败感促使迈克尔、弗里茨·沃格特和我想出了区间逻辑作为一个更高层次的模型来表达事件的时间顺序属性。</font><font style="vertical-align:inherit">[参见</font></font><a href="#lamport-timesets"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[44]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> .] 正如您所记得的，区间逻辑表达了围绕重大事件向前和向后的约束，以便更紧密地捕捉人们描述事件驱动行为的方式。</font><font style="vertical-align:inherit">最终，从达到实际水平的角度来看，我对我们的任何尝试仍然不满意。&nbsp;
</font></font></p></blockquote> 


<p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这篇论文是我第一次使用将状态转换描述为已启动和未启动变量的布尔值函数的想法。</font><font style="vertical-align:inherit">然而，到了 80 年代初，这个想法一定已经足够明显了，我并没有声称它有任何新颖性，而且我什至忘记了我什至在几年后才在本文中使用过它（参见 [103] 的讨论</font></font><a href="#lamport-actions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">）</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="spec"><b>Specifying Concurrent Program Modules</b><br><i>ACM Transactions on Programming Languages and Systems 5</i>, 2
   (April 1983), 190-222.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec.pdf">PDF</a>
<br><font size="-2">Copyright © 1983 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


The early methods for reasoning about concurrent programs dealt with
proving that a program satisfied certain properties--usually
invariance properties.&nbsp; But, proving particular properties showed only
that the program satisfied those properties.&nbsp; There remained the
possibility that the program was incorrect because it failed to
satisfy some other properties.&nbsp; Around the early 80s, people working
on assertional verification began looking for ways to write a complete
specification of a system.&nbsp; A specification should say precisely what
it means for the system to be correct, so that if we prove that the
system meets its specification, then we can say that the system
really is correct.&nbsp; (Process algebraists had already been working on
that problem since the mid-70s, but there was--and I think still
is--little communication between them and the assertional
verification community.)&nbsp;

<p>
At SRI, we were working on writing temporal logic specifications.&nbsp; One
could describe properties using temporal logic, so it seemed very
natural to specify a system by simply listing all the properties it
must satisfy.&nbsp; Richard Schwartz, Michael Melliar-Smith, and I
collaborated on a paper titled <i>Temporal Logic Specification of
Distributed Systems</i>, which was published in the Proceedings of the
2nd International Conference on Distributed Computing Systems, held in
Paris in 1981.&nbsp; However, I became disillusioned with temporal logic
when I saw how Schwartz, Melliar-Smith, and Fritz Vogt were
spending days trying to specify a simple FIFO queue--arguing over
whether the properties they listed were sufficient.&nbsp; I realized that,
despite its aesthetic appeal, writing a specification as a conjunction
of temporal properties just didn't work in practice.&nbsp; So, I had my
name removed from the paper before it was published, and I set about
figuring out a practical way to write specifications.&nbsp; I came up with
the approach described in this paper, which I later called the
<i>transition axiom</i> method.&nbsp; 
Schwartz stopped working on specification and verification
in the mid-80s.&nbsp; He wrote recently (in June 2000):
</p><blockquote><p>
[T]he same frustration with the use of temporal logic led Michael,
Fritz Vogt and me to come up with Interval Logic as a higher level
model in which to express time-ordered properties of events.&nbsp; 
[See <a href="#lamport-timesets">[44]</a>.]&nbsp; As you
recall, interval logic expressed constraints forward and backward
around significant events in order to more closely capture the way that
people describe event-driven behavior.&nbsp; Ultimately, I remain
unsatisfied with any of our attempts, from the standpoint of reaching
practical levels.&nbsp;
</p></blockquote> 


<p>
This paper is the first place I used the idea of describing a state
transition as a boolean-valued function of primed and unprimed
variables.&nbsp; However, by the early 80s, the idea must have been
sufficiently obvious that I didn't claim any novelty for it, and I
forgot that I had even used it in this paper until years later (see
the discussion of <a href="#lamport-actions">[103]</a>).&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="spec-and-proof"><b><font style="vertical-align:inherit"></font></b><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">高可靠性分布式系统</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">中</font><b><font style="vertical-align:inherit">容错实时算法的规范和证明</font></b><font style="vertical-align:inherit">，SRI 项目 4180 的最终报告（合同号 DAEA18-81-G-0062）（1983 年 6 月）。</font><font style="vertical-align:inherit">
没有电子版。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br><font style="vertical-align:inherit"></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1983 年春天，我受邀为 SRI 的一个项目的最终报告贡献一章。</font><font style="vertical-align:inherit">我选择编写拜占庭将军算法（一种分布式实时算法）的规范和正确性证明。</font><font style="vertical-align:inherit">（无故障的组件必须满足实时约束，算法的正确性取决于这些约束。）我在周三早上开始了练习。</font><font style="vertical-align:inherit">到那个周五中午，我得到了最终的排版输出。</font><font style="vertical-align:inherit">我认为其中有很多错误；</font><font style="vertical-align:inherit">读完之后，我从来没有仔细地重读过它，也没有迹象表明其他人也这样做过。</font><font style="vertical-align:inherit">但是，我没有理由怀疑证明的基本正确性。</font><font style="vertical-align:inherit">我从未发表过这篇论文，因为它似乎不值得发表。</font><font style="vertical-align:inherit">我觉得唯一值得注意的是，很多计算机科学家没有意识到，&nbsp;


</font></font><br>&nbsp;<p></p></a></li><li> <a name="spec-and-proof"><b>Specification and Proof of a
   Fault-Tolerant Real-Time Algorithm</b><br>In <i>Highly Dependable
   Distributed Systems</i>, final report for SRI Project 4180 (Contract
   Number DAEA18-81-G-0062) (June 1983).<br>
No electronic version available.<hr>


In the spring of 1983, I was called upon to contribute a chapter for
the final report on a project at SRI.&nbsp; I chose to write a
specification and correctness proof of a Byzantine general's
algorithm--a distributed, real-time algorithm.&nbsp; (Nonfaulty components
must satisfy real-time constraints, and the correctness of the
algorithm depends on these constraints.)&nbsp; I began the exercise on a
Wednesday morning.&nbsp; By noon that Friday, I had the final typeset
output.&nbsp; I presume there are lots of errors; after finishing it, I
never reread it carefully and I have no indication that anyone else
did either.&nbsp; But, I have no reason to doubt the basic correctness of
the proof.&nbsp; I never published this paper because it didn't seem worth
publishing.&nbsp; The only thing I find remarkable about it is that so many
computer scientists are unaware that, even in 1983, writing a formal
correctness proof of a distributed real-time algorithm was an
unremarkable feat.&nbsp;


<br>&nbsp;<p></p></a></li><li><a name="spec-and-proof"> </a><a name="weak-byz"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">弱拜占庭将军问题</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机协会杂志 30</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1983 年 7 月）, 668-676。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/weak-byz.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1983 Association for Computer Machinery, Inc。允许免费制作本作品部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文介绍了</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的拜占庭将军问题的较弱版本。</font><font style="vertical-align:inherit">这个问题“更容易”，因为存在少于 3 </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n 个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">进程的近似解，可以容忍</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n 个错误， </font></font></i><font style="vertical-align:inherit"></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中所示的情况</font><font style="vertical-align:inherit">对于原始拜占庭将军问题来说是不可能的。</font><font style="vertical-align:inherit">我不记得我是怎么想到这个问题的。&nbsp;



</font></font><br>&nbsp;<p></p></li><li><a name="spec-and-proof"> </a><a name="weak-byz"><b>The Weak Byzantine Generals Problem</b><br><i>Journal of
   the Association for Computing Machinery 30</i>, 3 (July 1983), 668-676.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/weak-byz.pdf">PDF</a>
<br><font size="-2">Copyright © 1983 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper introduces a weaker version of the Byzantine generals
problem described in <a href="#reaching">[41]</a>.&nbsp; The problem is "easier"
because there exist approximate solutions with fewer than
3<i>n</i> processes that can tolerate <i>n</i> faults,
something shown in <a href="#reaching">[41]</a> to be impossible for the original
Byzantine generals problem.&nbsp; I don't remember how I came to consider
this problem.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="phil"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">PHIL：语义结构图形编辑器</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Joseph Goguen 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRI 国际技术报告（1983 年 8 月）。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


SRI 与飞利浦签订了合同，为结构化文档（例如程序）设计图形编辑器。</font><font style="vertical-align:inherit">戈根和我是该项目的主要发起者和主要研究者。</font><font style="vertical-align:inherit">这是该项目的最终报告。</font><font style="vertical-align:inherit">飞利浦的 Rindert Schutten 访问了 SRI 并实施了一个非常初步的版本。</font><font style="vertical-align:inherit">我觉得我们的设计既不够新颖，不足以构成重大贡献，也不够谦虚，不足以成为当时实用系统的基础，我认为该项目已经被放弃了。</font><font style="vertical-align:inherit">然而，Goguen 很久之后才告诉我，该系统的某些版本在 90 年代初仍在使用，并且已经发展成为 VLSI 布局的工具，显然称为 MetaView。&nbsp;


</font></font><br>&nbsp;<p></p></a></li><li> <a name="phil"><b>PHIL: A Semantic Structural Graphical Editor</b>&nbsp; (with Joseph 
   Goguen)<br>SRI International Technical Report (August 1983).<br>
No electronic version available.<hr>


SRI had a contract with Philips to design a graphical editor for
structured documents (such as programs).&nbsp; Goguen and I were the prime
instigators and principal investigators of the project.&nbsp; This is the
project's final report.&nbsp; Rindert Schutten of Philips visited SRI and
implemented a very preliminary version.&nbsp; I felt that our design was
neither novel enough to constitute a major contribution nor modest
enough to be the basis for a practical system at that time, and I
thought the project had been dropped.&nbsp; However, Goguen informed me
much later that some version of the system was still being used in the
early 90s, and that it had evolved into a tool for VLSI layout,
apparently called MetaView.&nbsp;


<br>&nbsp;<p></p></a></li><li><a name="phil"> </a><a name="what-good"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">时序逻辑有什么好处？</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">信息处理 83，</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> REA Mason 编辑，Elsevier 出版社 (1983)，657-668。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/what-good.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是一篇受邀论文。</font><font style="vertical-align:inherit">它描述了我当时对规范和验证的看法。</font><font style="vertical-align:inherit">值得注意的是，它引入了口吃不变性的概念，并解释了为什么它是规范逻辑的重要属性。</font><font style="vertical-align:inherit">这也是我写得最好的论文之一。&nbsp;


</font></font><br>&nbsp;<p></p></li><li><a name="phil"> </a><a name="what-good"><b>What Good Is Temporal Logic?</b><br><i>Information
   Processing 83,</i> R. E. A. Mason, ed., Elsevier Publishers (1983),
   657-668.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/what-good.pdf">PDF</a><hr>


This was an invited paper.&nbsp; It describes the state of my views on
specification and verification at the time.&nbsp; It is notable for
introducing the idea of invariance under stuttering and explaining why
it's a vital attribute of a specification logic.&nbsp; It is also one of my
better-written papers.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="using-time"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用时间而不是超时实现容错分布式系统</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 编程语言和系统事务 6</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (1984 年 4 月), 254-280。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/using-time.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1984 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">



这篇论文的起源是我认识到，在具有同步时钟的多进程系统中，没有消息也可以携带信息。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我对一个进程可以通过不</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">发送消息来传达无数信息的想法着迷</font><font style="vertical-align:inherit">。</font></font><a href="#byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[46]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的拜占庭将军算法的实际实现</font><font style="vertical-align:inherit">可以被视为这一思想的应用。</font><font style="vertical-align:inherit">我用这个想法作为一个噱头来证明这篇论文的合理性。</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文的基本信息应该非常明显： [27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中引入的状态机方法
</font><font style="vertical-align:inherit">使我们能够将任何共识算法转变为实现分布式系统的通用方法；</font><a href="#byz"><font style="vertical-align:inherit">[46]</font></a><font style="vertical-align:inherit">的拜占庭将军算法</font></font><a href="#byz"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">是容错共识算法；</font><font style="vertical-align:inherit">因此，我们拥有任意分布式系统的容错实现。</font><font style="vertical-align:inherit">我发表这篇论文是因为我发现很少有计算机科学家能够理解这一点。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="using-time"><b>Using Time Instead of Timeout for
   Fault-Tolerant Distributed Systems</b><br><i>ACM Transactions on Programming Languages and Systems 6</i>, 2 (April 1984),
   254-280.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/using-time.pdf">PDF</a>
<br><font size="-2">Copyright © 1984 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>



The genesis of this paper was my realization that, in a multiprocess
system with synchronized clocks, the absence of a message can carry
information.&nbsp; I was fascinated by the idea that a process could
communicating zillions of bits of information by <i>not</i> sending
messages.&nbsp; The practical implementation of Byzantine generals
algorithms described in <a href="#byz">[46]</a> could be viewed as an application
of this idea.&nbsp; I used the idea as something of a gimmick to
justify the paper.&nbsp; The basic message of this paper should have been
pretty obvious: the state machine approach, introduced in
<a href="#time-clocks">[27]</a>, allows us to turn any consensus algorithm into
a general method for implementing distributed systems; the Byzantine
generals algorithms of <a href="#byz">[46]</a> were fault-tolerant consensus
algorithms; hence, we had fault-tolerant implementations of
arbitrary distributed systems.&nbsp; I published the paper because I had
found few computer scientists who understood this.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="ghl"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">CSP 的霍尔逻辑以及所有这些</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred Schneider 合作）</font></font><br>  
   <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 6</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1984 年 4 月），281-296。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/ghl.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1984 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我觉得在</font></font><a href="#hoare"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[40]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我提出了对并发程序进行断言（也称为 Owicki-Gries 风格）推理的正确方法。</font><font style="vertical-align:inherit">然而，许多人曾经（也许仍然）关注不同编程语言的个别细节，无法理解相同的一般原则适用于所有这些语言。</font><a href="#hoare"><font style="vertical-align:inherit">特别是，人们认为基于交会或消息传递的“分布式”语言与[40]</font></a><font style="vertical-align:inherit">中考虑的共享变量语言有根本的不同。</font></font><a href="#hoare"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">例如，有些人愚蠢地声称，由于没有共享变量，用 CSP 编写并发程序比用更传统的语言更容易。</font><font style="vertical-align:inherit">（我的回答是同样愚蠢的断言，即在 CSP 中编写并发程序更困难，因为控制状态在处理器之间共享。）&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">施耐德同意我的观点，即不变性是推理并发程序的核心概念。</font><font style="vertical-align:inherit">他也是所提出的所有不同风格的消息传递方面的专家。</font><font style="vertical-align:inherit">我们在本文中证明，</font></font><a href="#hoare"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[40]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的基本方法适用于 CSP；</font><font style="vertical-align:inherit">我们声称（没有证据）它也适用于其他“分布式”语言。</font><font style="vertical-align:inherit">我发现特别有趣的是，我们应该为 CSP 提供霍尔逻辑，而霍尔本质上是使用行为方法来推理 CSP 程序。</font><font style="vertical-align:inherit">我还在等待笑声。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="ghl"><b>The Hoare Logic Of CSP, and All That</b>&nbsp; (with Fred Schneider)<br>  
   <i>ACM Transactions on Programming Languages and Systems 6</i>, 2 (April 1984), 281-296.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/ghl.pdf">PDF</a>
<br><font size="-2">Copyright © 1984 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


I felt that in <a href="#hoare">[40]</a>, I had presented the right way to do
assertional (also known as Owicki-Gries style) reasoning about
concurrent programs.&nbsp; However, many people were (and perhaps still
are) hung up on the individual details of different programming
languages and are unable to understand that the same general
principles apply to all of them.&nbsp; In particular, people felt that
"distributed" languages based on rendezvous or message passing were
fundamentally different from the shared-variable language that was
considered in <a href="#hoare">[40]</a>.&nbsp; For example, some people made the silly
claim that the absence of shared variables made it easier to write
concurrent programs in CSP than in more conventional languages.&nbsp; (My
response is the equally silly assertion that it's harder to write
concurrent programs in CSP because the control state is shared between
processors.)&nbsp;

<p> Schneider agreed with me that invariance was the central
concept in reasoning about concurrent programs.&nbsp; He was also an expert
on all the different flavors of message passing that had been
proposed.&nbsp; We demonstrated in this paper that the basic
approach of <a href="#hoare">[40]</a> worked just was well with CSP; and we
claimed (without proof) that it also worked in other "distributed"
languages.&nbsp; I found it particularly funny that we should be the ones
to give a Hoare logic to CSP, while Hoare was using essentially
behavioral methods to reason about CSP programs.&nbsp; I'm still waiting
for the laughter.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="clocks2"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭时钟同步</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Michael Melliar-Smith 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第三届 ACM 分布式计算原理年度研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1984 年 8 月），68-74。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/clocks2.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1984 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[62]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的初步会议版本</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="clocks2"><b>Byzantine Clock Synchronization</b>&nbsp; (with Michael 
   Melliar-Smith)<br><i>Proceedings of the Third Annual ACM Symposium on
   Principles of Distributed Computing</i> (August, 1984), 68-74.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/clocks2.pdf">PDF</a>
<br><font size="-2">Copyright © 1984 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This is the preliminary conference version of <a href="#clocks">[62]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="solved-and-unsolved"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第三届 ACM 分布式计算原理年度研讨会并发论文</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">集中已解决的问题、未解决的问题和非问题</font></b><font style="vertical-align:inherit">（1984 年 8 月）1-11。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/solved-and-unsolved.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1984 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是我在 1983 年 PODC 会议上发表的受邀演讲，是我从演讲录音中转录的。</font><font style="vertical-align:inherit">演讲的前几分钟没有录音，所以我不得不重新设计开头。</font><font style="vertical-align:inherit">这次演讲之所以引人注目，是因为它标志着计算机科学界对 Dijkstra 1974 年</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM的重新发现</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文介绍了自稳定的概念。</font><font style="vertical-align:inherit">自稳定系统是一种无论在任何状态下启动时，最终都能“自我恢复”并正确运行的系统。</font><font style="vertical-align:inherit">自稳定对于容错的重要性对于我和少数人来说是显而易见的，但完全超出了大多数读者的理解范围。</font><font style="vertical-align:inherit">Dijkstra 的论文几乎没有说明这个问题的实际意义，也很少有人理解它的重要性。</font><font style="vertical-align:inherit">所以，这篇论文的瑰宝在 1983 年就消失得无影无踪了。我的演讲让 Dijkstra 的论文引起了 PODC 社区的注意，现在自稳定已经成为分布式计算的一个常规子领域。</font><font style="vertical-align:inherit">我认为 Dijkstra 在自稳定方面的杰出工作的复兴是我对计算机科学的最大贡献之一。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该论文包含一张直接从透明胶片上复制的图表，其算法显然是伪造的。</font><font style="vertical-align:inherit">我试图从记忆中重新创建一个算法并写出完全无意义的内容。</font><font style="vertical-align:inherit">画透明胶片时很容易犯这样的错误，而且我准备纸张时可能懒得看它。</font><font style="vertical-align:inherit">据我所知，这是我发布的唯一不正确的算法。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="solved-and-unsolved"><b>Solved Problems, Unsolved Problems 
    and NonProblems in Concurrency</b><br><i>Proceedings of the Third Annual ACM
   Symposium on Principles of Distributed Computing</i> (August, 1984)
   1-11.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/solved-and-unsolved.pdf">PDF</a>
<br><font size="-2">Copyright © 1984 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This is the invited address I gave at the 1983 PODC conference, which
I transcribed from a tape recording of my presentation.&nbsp; The first few
minutes of the talk were not taped, so I had to reinvent the
beginning.&nbsp; This talk is notable because it marked the rediscovery by
the computer science community of Dijkstra's 1974 <i>CACM</i> paper that
introduced the concept of self-stabilization.&nbsp; A self-stabilizing
system is one that, when started in any state, eventually "rights
itself" and operates correctly.&nbsp; The importance of self-stabilization
to fault tolerance was obvious to me and a handful of people, but went
completely over the head of most readers.&nbsp; Dijkstra's paper gave
little indication of the practical significance of the problem, and
few people understood its importance.&nbsp; So, this gem of a paper had
disappeared without a trace by 1983.&nbsp; My talk brought Dijkstra's paper
to the attention of the PODC community, and now self-stabilization is
a regular subfield of distributed computing.&nbsp; I regard the
resurrection of Dijkstra's brilliant work on self-stabilization to be
one of my greatest contributions to computer science.&nbsp;

<p>
The paper contains one figure--copied directly from a
transparency--with an obviously bogus algorithm.&nbsp; I tried to recreate
an algorithm from memory and wrote complete nonsense.&nbsp; It's easy to
make such a mistake when drawing a transparency, and I probably didn't
bother to look at it when I prepared the paper.&nbsp; To my knowledge, it
is the only incorrect algorithm I have published.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="peterson-theorem"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于彼得森的“定理”</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表（1984 年 10 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">这篇三页纸的注释给出了一个似乎与 Gary Peterson 的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">TOPLAS</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">文章


中的定理相矛盾的例子。</font><font style="vertical-align:inherit">是否确实取决于对定理陈述的解释，该定理仅以英语非正式地给出。</font><font style="vertical-align:inherit">我得出的教训是需要更加严格。</font><font style="vertical-align:inherit">当我把这篇论文寄给彼得森时，他强烈反对。</font><font style="vertical-align:inherit">我不再有他的信息，也不记得他到底写了什么，但我认为他说他知道正确的解释是什么，而我不公平地暗示他的定理可能是不正确的。</font><font style="vertical-align:inherit">所以，我从未发表过这篇笔记。&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="peterson-theorem"><b>On a "Theorem" of Peterson</b><br>Unpublished
  (October, 1984).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/peterson-theorem.pdf">PDF</a><hr>


This three-page note gives an example that appears to contradict a
theorem in a <i>TOPLAS</i> article by Gary Peterson.&nbsp; Whether or not
it does depends on the interpretation of the statement of the theorem,
which is given only informally in English.&nbsp; I draw the moral that
greater rigor is needed.&nbsp; When I sent this paper to Peterson, he
strongly objected to it.&nbsp; I no longer have his message and don't
remember exactly what he wrote, but I think he said that he knew what
the correct interpretation was and that I was unfairly suggesting that
his theorem might be incorrect.&nbsp; So, I never published this note.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="buridan"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Buridan 的</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">物理学原理基础 42</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 8（2012 年 8 月）1056-1066。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/buridan.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"></font><a href="#glitch"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我观察到， [22]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中讨论的仲裁者问题
</font><font style="vertical-align:inherit">发生在日常生活中。</font><font style="vertical-align:inherit">也许最常见的例子是，当我发现自己在一瞬间无法决定是否要在刚刚变黄的交通灯处停车或通过时。</font><font style="vertical-align:inherit">我怀疑这实际上是造成严重事故的一个原因，人们确实会开车撞上电线杆，因为他们无法及时决定是向左走还是向右走。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
一项小研究表明，心理学家完全没有意识到这种现象。</font><font style="vertical-align:inherit">我在心理学文献中发现了一篇论文，内容是关于受试者根据两种选择的接近程度在两种选择之间进行选择所花费的时间。</font><font style="vertical-align:inherit">作者的理论计算得出了一个奇点为零的公式，这是应该的。</font><font style="vertical-align:inherit">他将实验数据与这条理论曲线进行了比较，吻合得非常完美。</font><font style="vertical-align:inherit">然后，他绘制了一个有界连续图，作为拟合数据的曲线。</font><font style="vertical-align:inherit">论文中从未提及零处的奇点。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我觉得仲裁者问题很重要，应该让计算领域之外的科学家知道。</font><font style="vertical-align:inherit">因此，我在 1984 年 12 月写了这篇论文。</font><font style="vertical-align:inherit">它将经典表述中的问题描述为“布里丹驴子问题”——一头驴子会饿死，因为它被放置在两捆干草之间等距离，并且没有理由更喜欢其中一捆干草。</font><font style="vertical-align:inherit">几个世纪以来，哲学家们一直在讨论布里丹的屁股，但显然他们中的任何一个人都没有想到，这个星球上没有到处都是死驴，只是因为驴子出现在正确位置的概率是无穷小的。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我为广大科学界写了这篇论文。</font><font style="vertical-align:inherit">我可能可以将其发表在某些计算机期刊上，但这不是重点。</font><font style="vertical-align:inherit">我首先将其提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《科学》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这四篇评论的范围从“这篇写得很好的论文具有重大的哲学意义”到“这可能是一个精心设计的笑话”。</font><font style="vertical-align:inherit">其他评论之一的评价较为温和，第四条则简单地说“我的感觉是，它相当肤浅”。</font><font style="vertical-align:inherit">论文被拒绝了。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一段时间后，我将论文提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Nature</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我不喜欢将同一篇论文发送到不同的期刊，希望有人会发表它的想法，而且我很少在其他地方重新提交被拒绝的论文。</font><font style="vertical-align:inherit">所以我在投稿信中说它被</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Science拒绝了</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">编辑看了这篇论文并向我发送了一些反对意见。</font><font style="vertical-align:inherit">我回答了他的反对意见，这是基于对这篇论文的合理误解。</font><font style="vertical-align:inherit">事实上，他们让我意识到我应该为更普通的观众以不同的方式解释事情。</font><font style="vertical-align:inherit">然后他又提出了类似性质的进一步反对意见。</font><font style="vertical-align:inherit">在整个交流过程中，我不确定他是否认真对待这件事，或者他是否认为我是个怪人。</font><font style="vertical-align:inherit">因此，在回答了他的下一轮反对意见后，我写道，如果他随后将其发送出去供审阅，我很乐意根据这次讨论修改该论文，但我不想继续这种私人通信。</font><font style="vertical-align:inherit">我收到的下一封信来自另一个
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">自然</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">编辑说第一位编辑已被重新分配，他将接管我的论文。</font><font style="vertical-align:inherit">然后他对这篇论文提出了一些反对意见，这些反对意见基本上与第一位编辑最初提出的反对意见相同。</font><font style="vertical-align:inherit">那时，我厌恶地放弃了。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我不知道在哪里发表这篇论文，所以我就放弃了。</font><font style="vertical-align:inherit">2011 年，一位读者托马斯·雷 (Thomas Ray) 建议将其提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">物理学基金会</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我做到了，并且被接受了。</font><font style="vertical-align:inherit">对于已发布的版本，我添加了一个结论部分，提及了自我撰写原始版本以来 25 年来发生的一些事情，并引用此条目作为有关该论文历史的信息来源。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我在尝试发表本文和
</font></font><a href="#glitch"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[22]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">时遇到的问题是长期传统的一部分。</font><font style="vertical-align:inherit">根据我听过的一个故事（但尚未证实），GE 的某人在 60 年代初发现了计算机电路中的这一现象，但无法让他的经理相信存在问题。</font><font style="vertical-align:inherit">他发表了一篇关于此事的简短说明，并因此被解雇。</font><font style="vertical-align:inherit">Charles Molnar 是该问题研究的先驱之一，他在 1992 年 2 月 11 日在加利福尼亚州帕洛阿尔托的 HP Corporate Engineering 的一次演讲中报告了以下内容：
 </font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
       一位审稿人在拒绝其中一篇早期论文时发表了精彩的评论，他说如果这个问题</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">真的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">
       存在，那么该领域的每个知识渊博的人都必须知道它，并且“我是专家，但我不”我不知道它，所以它一定不存在。”
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
另一个有趣的例子是查尔斯·赛义夫 (Charles Seif)
 2008 年 12 月 4 日发表在</font><i><font style="vertical-align:inherit">《纽约时报》</font></i><font style="vertical-align:inherit">专栏版上的
一篇题为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《并非每张选票都</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">重要》的文章。赛义夫提议，如果投票结果非常接近，则可以通过掷硬币来决定选举结果。从而避免有关确切计票结果的诉讼争议。</font><font style="vertical-align:inherit">虽然计票问题并不完全是布里丹原则的一个例子，但对于任何熟悉该原则的人来说，他的计划中的缺陷都是显而易见的，并且规避该原则的徒劳尝试也是显而易见的。</font><i><font style="vertical-align:inherit">我向《泰晤士报》</font></i><font style="vertical-align:inherit">提交了一封信</font><font style="vertical-align:inherit">解释了这个问题，并向赛义夫发送了电子邮件，但没有收到回复。&nbsp;

</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br>&nbsp;<p></p></li><li> <a name="buridan"><b>Buridan's Principle</b><br><i>Foundations
of Physics 42</i>, 8 (August 2012) 1056-1066.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/buridan.pdf">PDF</a><hr>


I have observed that the arbiter problem, discussed in
<a href="#glitch">[22]</a>, occurs in daily life.&nbsp; Perhaps the most common
example is when I find myself unable to decide for a fraction of a
second whether to stop for a traffic light that just turned yellow or
to go through.&nbsp; I suspect that it is actually a cause of serious
accidents, and that people do drive into telephone poles because they
can't decide in time whether to go to the left or the right.&nbsp;

<p>
A little research revealed that psychologists are totally unaware of
the phenomenon.&nbsp; I found one paper in the psychology literature on the
time taken by subjects to choose between two alternatives based on how
nearly equal they were.&nbsp; The author's theoretical calculation yielded
a formula with a singularity at zero, as there should be.&nbsp; He compared
the experimental data with this theoretical curve, and the fit was
perfect.&nbsp; He then drew, as the curve fitting the data, a bounded
continuous graph.&nbsp; The singularity at zero was never mentioned in the
paper.&nbsp;

</p><p> I feel that the arbiter problem is important and should be
made known to scientists outside the field of computing.&nbsp; So, in
December of 1984 I wrote this paper.&nbsp; It describes the problem in its
classical formulation as the problem of Buridan's ass--an ass that
starves to death because it is placed equidistant between two bales of
hay and has no reason to prefer one to the other.&nbsp; Philosophers have
discussed Buridan's ass for centuries, but it apparently never
occurred to any of them that the planet is not littered with dead
asses only because the probability of the ass being in just the right
spot is infinitesimal.&nbsp;

</p><p>
I wrote this paper for the general scientific community.&nbsp; I
probably could have published it in some computer journal, but that
wasn't the point.&nbsp; I submitted it first to <i>Science</i>.&nbsp; The four
reviews ranged from "This well-written paper is of major
philosophical importance" to "This may be an elaborate joke." One
of the other reviews was more mildly positive, and the fourth said
simply "My feeling is that it is rather superficial." The paper was
rejected.&nbsp;

</p><p> Some time later, I submitted the paper to <i>Nature</i>.&nbsp;
I don't like the idea of sending the same paper to different journals
hoping that someone will publish it, and I rarely resubmit a rejected
paper elsewhere.&nbsp; So, I said in my submission letter that it had been
rejected by <i>Science</i>.&nbsp; The editor read the paper and sent me
some objections.&nbsp; I answered his objections, which were based on
reasonable misunderstandings of the paper.&nbsp; In fact, they made me
realize that I should explain things differently for a more general
audience.&nbsp; He then replied with further objections of a similar
nature.&nbsp; Throughout this exchange, I wasn't sure if he was taking the
matter seriously or if he thought I was some sort of crank.&nbsp; So, after
answering his next round of objections, I wrote that I would be happy
to revise the paper in light of this discussion if he would then send
it out for review, but that I didn't want to continue this private
correspondence.&nbsp; The next letter I received was from another
<i>Nature</i> editor saying that the first editor had been reassigned
and that he was taking over my paper.&nbsp; He then raised some objections
to the paper that were essentially the same as the ones raised
initially by the first editor.&nbsp; At that point, I gave up in disgust.&nbsp;

</p><p> 

I had no idea where to publish the paper, so I let it drop.&nbsp; In 2011,
a reader, Thomas Ray, suggested submitting it to <i>Foundations of
Physics</i>.&nbsp; I did, and it was accepted.&nbsp; For the published version, I
added a concluding section mentioning some of the things that had
happened in the 25 years since I wrote the original version and citing
this entry as a source of information about the paper's history.&nbsp;

</p><p> My problems in trying to publish this paper and
<a href="#glitch">[22]</a> are part of a long tradition.&nbsp; According to one story
I've heard (but haven't verified), someone at G. E. discovered the
phenomenon in computer circuits in the early 60s, but was unable to
convince his managers that there was a problem.&nbsp; He published a short
note about it, for which he was fired.&nbsp; Charles Molnar, one of the
pioneers in the study of the problem, reported the following in a
lecture given on February 11, 1992, at HP Corporate Engineering in
Palo Alto, California:
 </p><blockquote><p> 
       One reviewer made
       a marvelous comment in rejecting one of the
       early papers, saying that if this problem <i>really</i>
       existed it would be so important that
       everybody knowledgeable in the field would
       have to know about it, and "I'm an expert and
       I don't know about it, so therefore it must not
       exist."
 </p></blockquote>
Another amusing example occurred in an article by Charles Seif titled
<i>Not Every Vote Counts</i> that appeared on the op-ed page of the
<i>New York Times</i> on 4 December 2008.&nbsp; Seif proposed that
elections be decided by a coin toss if the voting is very close,
thereby avoiding litigious disputes over the exact vote count.&nbsp; While
the problem of counting votes is not exactly an instance of Buridan's
Principle, the flaw in his scheme will be obvious to anyone familiar
with the principle and the futile attempts to circumvent it.&nbsp; I
submitted a letter to the <i>Times</i> explaining the problem and sent
email to Seif, but I received no response.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="mutual"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">互斥问题 - 第一部分：进程间通信理论，第二部分：陈述和解决方案</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Journal of the Association for Computer Machinery 33</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1986 年 1 月）313-348。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
第 1 部分：</font></font></a><a href="http://lamport.azurewebsites.net/pubs/mutual1.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/mutual1.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/mutual1.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
第 2 部分：</font></font><a href="http://lamport.azurewebsites.net/pubs/mutual2.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/mutual2.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/mutual2.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1985 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


一段时间以来，我一直在寻找一种互斥算法来满足我所需属性的完整列表。</font><font style="vertical-align:inherit">我终于找到了一个——</font><font style="vertical-align:inherit">本文描述的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">N !位算法。</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">该算法非常不切实际，需要</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ! </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">N 个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">处理器的存储位</font><font style="vertical-align:inherit">，但实用性不是我的要求之一。</font><font style="vertical-align:inherit">因此，我决定出版一本我所知道的有关互斥理论的概要。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文描述的 3 位算法是由于 Michael Rabin 的访问而产生的。</font><font style="vertical-align:inherit">他是概率算法的倡导者，他声称互斥问题的概率解决方案比确定性解决方案更好。</font><font style="vertical-align:inherit">我相信正是在他短暂的访问期间，我们提出了一种概率算法，每个处理器只需要三位存储空间。</font><font style="vertical-align:inherit">概率算法对我没有吸引力。</font><font style="vertical-align:inherit">（这是一个美观的问题，而不是实用性的问题。）所以后来我就想出了如何去掉概率，把它变成确定性算法。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文的第一部分涵盖了我自 70 年代以来一直在开发的描述非原子操作的形式主义，这是严格阐述互斥所必需的。</font></font><a href="#interprocess"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（参见[70]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论</font><font style="vertical-align:inherit">。）&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li> <a name="mutual"><b>The Mutual Exclusion Problem--Part I: A Theory of
   Interprocess Communication, Part II: Statement and
   Solutions</b><br><i>Journal of the Association for Computing Machinery
   33</i>, 2 (January 1986) 313-348.<br>
Part 1: </a><a href="http://lamport.azurewebsites.net/pubs/mutual1.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/mutual1.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/mutual1.pdf">PDF</a><br>
Part 2: <a href="http://lamport.azurewebsites.net/pubs/mutual2.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/mutual2.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/mutual2.pdf">PDF</a>
<br><font size="-2">Copyright © 1985 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


For some time I had been looking for a mutual exclusion algorithm that
satisfied my complete list of desirable properties.&nbsp; I finally found
one--the <i>N</i>!-bit algorithm described in this paper.&nbsp;
The algorithm is wildly impractical, requiring <i>N</i>!
bits of storage for <i>N</i> processors, but practicality was not one
of my requirements.&nbsp; So, I decided to publish a compendium of
everything I knew about the theory of mutual exclusion.&nbsp;

<p>
The 3-bit algorithm described in this paper came about because of a
visit by Michael Rabin.&nbsp; He is an advocate of probabilistic
algorithms, and he claimed that a probabilistic solution to the mutual
exclusion problem would be better than a deterministic one.&nbsp; I believe
that it was during his brief visit that we came up with a
probabilistic algorithm requiring just three bits of storage per
processor.&nbsp; Probabilistic algorithms don't appeal to me.&nbsp; (This is a
question of aesthetics, not practicality.)&nbsp; So later, I figured out
how to remove the probability and turn it into a deterministic
algorithm.&nbsp;

</p><p>
The first part of the paper covers the formalism for describing
nonatomic operations that I had been developing since the 70s, and
that is needed for a rigorous exposition of mutual exclusion.&nbsp; (See
the discussion of <a href="#interprocess">[70]</a>.)&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="clocks"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">在存在故障时同步时钟</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Michael Melliar-Smith 合作）</font></font><br> <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机协会杂志 32</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1（1985 年 1 月），52-78。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/clocks.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1985 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


拜占庭协议的实际实现需要同步时钟。</font><font style="vertical-align:inherit">对于能够容忍拜占庭错误的实现，它需要一个能够容忍这些错误的时钟同步算法。</font><font style="vertical-align:inherit">当我到达 SRI 时，有一种普遍的感觉，我们可以通过让每个进程使用拜占庭协议来广播其时钟值来同步时钟。</font><font style="vertical-align:inherit">我从来没有被那只挥舞的手说服过。</font><font style="vertical-align:inherit">因此，在某些时候我尝试写下精确的时钟同步算法并证明它们的正确性。</font><a href="#byz"><font style="vertical-align:inherit">[46]</font></a><font style="vertical-align:inherit">中的两种基本拜占庭协议算法
</font></font><a href="#byz"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">确实推广到时钟同步算法。</font><font style="vertical-align:inherit">此外，Melliar-Smith还设计了交互式收敛算法，该算法也包含在论文中。</font><font style="vertical-align:inherit">（我记得，该算法是他对这篇论文的主要贡献，我写了所有的证明。）&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
事实证明，写证明比我预想的要困难得多（参见</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">我非常努力地使它们尽可能简短且易于理解。</font><font style="vertical-align:inherit">所以，当裁判说证明写得很快，只要稍微努力就能简化时，我就很恼火。</font><font style="vertical-align:inherit">在我对评论的回复中，我称那位裁判为“傲慢的混蛋”。</font><font style="vertical-align:inherit">一段时间后，南希·林奇承认自己就是那个裁判。</font><font style="vertical-align:inherit">那时她已经编写了自己的时钟同步证明，并意识到它们有多么困难。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
多年后，约翰·拉什比 (John Rushby) 和他在 SRI 的同事为我的证明编写了经过机械验证的版本。</font><font style="vertical-align:inherit">他们只发现了一些小错误。</font><font style="vertical-align:inherit">我相当自豪的是，即使在我知道如何编写可靠的、结构化的证明（参见</font></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）之前，我就足够小心和自律，使这些证明基本上是正确的。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="clocks"><b>Synchronizing Clocks in the Presence of Faults</b>&nbsp; (with Michael 
  Melliar-Smith)<br> <i>Journal of the Association for
  Computing Machinery 32</i>, 1 (January 1985), 52-78.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/clocks.pdf">PDF</a>
<br><font size="-2">Copyright © 1985 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Practical implementation of Byzantine agreement requires synchronized
clocks.&nbsp; For an implementation to tolerate Byzantine faults, it needs
a clock synchronization algorithm that can tolerate those faults.&nbsp;
When I arrived at SRI, there was a general feeling that we could
synchronize clocks by just having each process use a Byzantine
agreement protocol to broadcast its clock value.&nbsp; I was never
convinced by that hand waving.&nbsp; So, at some point I tried to write
down precise clock-synchronization algorithms and prove their
correctness.&nbsp; The two basic Byzantine agreement algorithms from
<a href="#byz">[46]</a> did generalize to clock-synchronization algorithms.&nbsp; In
addition, Melliar-Smith had devised the interactive convergence
algorithm, which is also included in the paper.&nbsp; (As I recall, that
algorithm was his major contribution to the paper, and I wrote all the
proofs.)&nbsp;

<p>
Writing the proofs turned out to be much more difficult than I had
expected (see <a href="#time-clocks">[27]</a>).&nbsp; I worked very hard to make them
as short and easy to understand as I could.&nbsp; So, I was rather annoyed
when a referee said that the proofs seemed to have been written
quickly and could be simplified with a little effort.&nbsp; In my replies
to the reviews, I referred to that referee as a "supercilious
bastard".&nbsp; Some time later, Nancy Lynch confessed to being that
referee.&nbsp; She had by then written her own proofs of clock
synchronization and realized how hard they were.&nbsp;

</p><p>
Years later, John Rushby and his colleagues at SRI wrote mechanically
verified versions of my proofs.&nbsp; They found only a couple of minor
errors.&nbsp; I'm rather proud that, even before I knew how to write
reliable, structured proofs (see <a href="#lamport-how-to-write">[102]</a>), I was
sufficiently careful and disciplined to have gotten those proofs
essentially correct.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="priority"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序满足规范意味着什么：为什么没有人指定</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第十二届 ACM 编程语言原理研讨会的优先论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，ACM SIGACT-SIGPLAN（1985 年 1 月），78-83。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/priority.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/priority.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/priority.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1985 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我一定在 SRI 花了很多时间与 Schwartz 和 Melliar-Smith 争论时态逻辑和转移公理的相对优点。</font></font><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（参见[50]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论</font><font style="vertical-align:inherit">。）我不记得到底发生了什么，但本文的致谢部分说“他们不断地在我指定 FCFS [先来先服务] 的尝试中找出漏洞，直到我们最终认识到根本问题[这是不可能完成的]。”


</font></font><br>&nbsp;<p></p></li><li> <a name="priority"><b>What It Means for a Concurrent Program to Satisfy a
   Specification: Why No One Has Specified Priority</b><br><i>Proceedings of
   the Twelfth ACM Symposium on Principles of Programming Languages</i>, ACM
   SIGACT-SIGPLAN (January 1985), 78-83.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/priority.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/priority.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/priority.pdf">PDF</a>
<br><font size="-2">Copyright © 1985 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


I must have spent a lot of time at SRI arguing with Schwartz and
Melliar-Smith about the relative merits of temporal logic and
transition axioms.&nbsp; (See the discussion of <a href="#spec">[50]</a>.)&nbsp; I don't
remember exactly what happened, but this paper's acknowledgment
section says that "they kept poking holes in my attempts to specify
FCFS [first-come, first-served] until we all finally recognized the
fundamental problem [that it can't be done]."


<br>&nbsp;<p></p></li><li> <a name="alias"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">约束：别名和类型的统一方法</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred Schneider 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第十二届 ACM 编程语言原理研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，ACM SIGACT-SIGPLAN（1985 年 1 月），205-216。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/alias.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/alias.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/alias.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1985 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><a href="#liveness"><font style="vertical-align:inherit">我的广义霍尔逻​​辑需要使用[47]中引入的</font></a></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">at</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">、</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">in</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">after</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">
谓词</font><font style="vertical-align:inherit">


来推理控制谓词</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这些不是独立的谓词——例如，在一个语句之后与在下一个语句同义。</font><font style="vertical-align:inherit">在某些时候，施耐德和我意识到控制谓词之间的关系可以被视为别名的广义形式。</font><font style="vertical-align:inherit">我们处理控制谓词的方法产生了一种处理普通霍尔逻辑中的别名的通用方法，本文对此进行了描述。</font><font style="vertical-align:inherit">除了处理程序中常见的别名之外，我们的方法还允许声明变量</font><i><font style="vertical-align:inherit">r</font></i><font style="vertical-align:inherit">和</font><i><font style="vertical-align:inherit">theta</font></i></font><a href="#liveness"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">是根据关系</font><i><font style="vertical-align:inherit">x</font></i><font style="vertical-align:inherit"> &nbsp;=&nbsp; </font><i><font style="vertical-align:inherit">r</font></i><font style="vertical-align:inherit"> &nbsp;* cos( </font><i><font style="vertical-align:inherit">theta</font></i><font style="vertical-align:inherit"> ) 和
 </font><i><font style="vertical-align:inherit">y</font></i><font style="vertical-align:inherit"> &nbsp;=&nbsp; </font><i><font style="vertical-align:inherit">r</font></i><font style="vertical-align:inherit"> &nbsp;* sin( </font><i><font style="vertical-align:inherit">theta</font></i><font style="vertical-align:inherit"> )&nbsp;

</font><font style="vertical-align:inherit">
的变量</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">y的别名。</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我们将这项工作推广到处理数组和指针，甚至引用了后来关于这种推广的论文。</font><font style="vertical-align:inherit">但是，就像我写一篇提到未来论文的论文时经常发生的那样，未来的论文从未被写出来。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="alias"><b>Constraints: A Uniform Approach to Aliasing and
   Typing</b>&nbsp; (with Fred Schneider)<br><i>Proceedings of the Twelfth ACM
   Symposium on Principles of Programming Languages</i>, ACM
   SIGACT-SIGPLAN (January 1985), 205-216.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/alias.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/alias.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/alias.pdf">PDF</a>
<br><font size="-2">Copyright © 1985 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


My generalized Hoare logic requires reasoning about control
predicates, using the <i>at</i>, <i>in</i>, and <i>after</i>
predicates introduced in <a href="#liveness">[47]</a>.&nbsp; These are not independent
predicates--for example, being after one statement is synonymous with
being at the following statement.&nbsp; At some point, Schneider and I
realized that the relations between control predicates could be viewed
as a generalized form of aliasing.&nbsp; Our method of dealing with control
predicates led to a general approach for handling aliasing in ordinary
Hoare logic, which is described in this paper.&nbsp; In addition to
handling the usual aliasing in programs, our method allowed one to
declare that the variables <i>r</i> and <i>theta</i>
were aliases of the variables <i>x</i> and <i>y</i> according to the
relations <i>x</i>&nbsp;=&nbsp;<i>r</i>&nbsp;*&nbsp;cos(<i>theta</i>) and
 <i>y</i>&nbsp;=&nbsp;<i>r</i>&nbsp;*&nbsp;sin(<i>theta</i>).&nbsp;

<p>
We generalized this work to handle arrays and pointers, and even cited
a later paper about this generalization.&nbsp; But, as has happened so often
when I write a paper that mentions a future one, the future paper
was never written.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="recursive-compiling"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">递归编译和编程环境（摘要）</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">被 1985 POPL 会议拒绝.. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是我提交给 1995 年 POPL 会议的扩展摘要。</font><font style="vertical-align:inherit">（我从未写过完整的版本。）它提出了递归编译的思想，其中程序构造一个文本字符串并调用编译器在当前程序环境的上下文中对其进行编译。</font><font style="vertical-align:inherit">因此，字符串中的</font><font style="vertical-align:inherit">变量</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">foo被编译器解释为</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">foo</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">在调用程序中当前点的含义。</font><font style="vertical-align:inherit">没有人觉得这个想法非常引人注目。</font><font style="vertical-align:inherit">当我与 Eric Roberts 讨论这个问题时，他认为运行时链接将是提供相同功能的更简单的方法。</font><font style="vertical-align:inherit">我不知道Java的反射机制是否构成递归编译或只是运行时链接。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="recursive-compiling"><b>Recursive Compiling and Programming
Environments (Summary)</b><br>Rejected from the 1985 POPL Conference..<br>
</a><a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/recursive-compiling.pdf">PDF</a><hr>


This is an extended abstract I submitted to the 1995 POPL conference.&nbsp;
(I never wrote the complete version.)&nbsp; It proposes the idea of
recursive compiling, in which a program constructs a text string and
calls the compiler to compile it in the context of the current program
environment.&nbsp; Thus, a variable <i>foo</i> in the string is interpreted
by the compiler to mean whatever <i>foo</i> means at the current point
in the calling program.&nbsp; No one found the idea very compelling.&nbsp; When
I discussed it with Eric Roberts, he argued that run-time linking
would be a simpler way to provide the same functionality.&nbsp; I don't
know if Java's reflection mechanism constitutes recursive compiling or
just run-time linking.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="chandy"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式快照：确定分布式系统的全局状态</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Mani Chandy 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Computer Systems 3</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1（1985 年 2 月），63-75。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/chandy.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1985 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这里描述的分布式快照算法是在我访问当时在奥斯汀德克萨斯大学的 Chandy 时提出的。</font><font style="vertical-align:inherit">他在晚餐时向我提出了这个问题，但当时我们都喝了太多酒，无法立即考虑这个问题。</font><font style="vertical-align:inherit">第二天早上，在淋浴时，我想出了解决办法。</font><font style="vertical-align:inherit">当我到达 Chandy 的办公室时，他正带着同样的解决方案等着我。</font><font style="vertical-align:inherit">我认为该算法是
</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">基本思想的直接应用。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

2012 年，一位读者注意到该论文的参考文献列表中包括 Chandy 和我发表的一篇题​​为《</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算的偏序事件模型》的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文，并声称该论文已提交出版。</font><font style="vertical-align:inherit">有几次我犯了错误，引用了我的一篇论文“出现”，但它从未出现过。</font><font style="vertical-align:inherit">但我无法想象我会声称一篇不存在的论文已提交发表。</font><font style="vertical-align:inherit">然而，钱迪和我都不记得那篇论文或参考文献。</font><font style="vertical-align:inherit">我的猜测是，当我们打算撰写并提交另一篇论文时，我们在初步版本中插入了参考文献，然后我们忘记将其删除。&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li> <a name="chandy"><b>Distributed Snapshots: Determining Global States of a
   Distributed System</b>&nbsp; (with Mani Chandy)<br><i>ACM Transactions on Computer
   Systems 3</i>, 1 (February, 1985), 63-75.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/chandy.pdf">PDF</a>
<br><font size="-2">Copyright © 1985 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


The distributed snapshot algorithm described here came about when I
visited Chandy, who was then at the University of Texas in Austin.&nbsp; He
posed the problem to me over dinner, but we had both had too much wine
to think about it right then.&nbsp; The next morning, in the shower, I came
up with the solution.&nbsp; When I arrived at Chandy's office, he was
waiting for me with the same solution.&nbsp; I consider the algorithm to
be a straightforward application of the basic ideas from
<a href="#time-clocks">[27]</a>.&nbsp;

<p> 

In 2012, a reader noticed that the paper's reference list includes a
paper by Chandy and me titled <i>On Partially-Ordered Event Models
of Distributed Computations</i>, claiming it had been submitted for
publication.&nbsp; Several times I have made the mistake of referencing a
paper of mine "to appear" that never appeared.&nbsp; But I can't imagine
that I would have claimed that a nonexistent paper had been submitted for
publication.&nbsp; However, neither Chandy nor I have any memory of that
paper or the reference.&nbsp; My guess is that we inserted the reference
in a preliminary version when we expected to write and submit the
other paper, and then we forgot to remove it.&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="munich"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">规范和验证的正式基础</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred Schneider 合作）</font><i><font style="vertical-align:inherit">《分布式系统：规范的方法和工具》</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的第 5 章</font><font style="vertical-align:inherit">，Alford 等人。</font><font style="vertical-align:inherit">计算机科学讲义，第 190 期。Springer-Verlag，柏林（1985 年）。</font><font style="vertical-align:inherit">电子版可从出版商处获得。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br><font style="vertical-align:inherit"></font><hr><font style="vertical-align:inherit"></font></a><a href="#ghl"><font style="vertical-align:inherit"><font style="vertical-align:inherit">本书包含 1984 年 4 月和 1985 年 4 月在慕尼黑举办的为期两周的课程的笔记。 Fred Schneider 和我讲授了[56]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><a href="#liveness"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[47]</font></font></a><font style="vertical-align:inherit"><a name="munich"><font style="vertical-align:inherit">


的内容</font></a><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">本章具有历史意义，因为这是我第一次发布安全属性的精确定义。</font><font style="vertical-align:inherit">（安全性和活跃性的概念在
</font></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中被非正式地引入。）这激发了施耐德思考活跃性的精确定义可能是什么。</font><font style="vertical-align:inherit">此后不久，他和 Bowen Alpern 提出了正式的定义。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="munich"><b>Formal Foundation for Specification and
   Verification</b>&nbsp; (with Fred Schneider)<br>Chapter 5 in <i>Distributed Systems:
   Methods and Tools for Specification</i>, Alford et al.&nbsp; Lecture Notes in
   Computer Science, Number 190.&nbsp; Springer-Verlag, Berlin (1985).<br>Electronic version available from publisher.<hr>


This volume contains the notes for a two-week course given in Munich
in April of 1984 and again in April of 1985.&nbsp; Fred Schneider and I
lectured on the contents of </a><a href="#ghl">[56]</a> and <a href="#liveness">[47]</a>.&nbsp; This
chapter is of historical interest because it's the first place where I
published the precise definition of a safety property.&nbsp; (The concepts
of safety and liveness were introduced informally in
<a href="#proving">[23]</a>.)&nbsp; This inspired Schneider to think about what the
precise definition of liveness might be.&nbsp; Shortly thereafter, he and
Bowen Alpern came up with the formal definition.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="semantics"><b><font style="vertical-align:inherit"></font></b><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">并发系统逻辑和模型</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">中</font><b><font style="vertical-align:inherit">并发编程语言的公理语义</font></b><font style="vertical-align:inherit">，Krzysztof Apt，编辑。</font><font style="vertical-align:inherit">施普林格出版社，柏林（1985），77-122。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/semantics.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/semantics.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/semantics.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1985 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇论文发表于 1984 年 10 月在法国南部卢河畔科勒 (Colle-sur-Loup) 举行的研讨会上。编程语言语义方面的工作有着悠久的历史。</font><font style="vertical-align:inherit">当人们在 70 年代开始研究并发时，他们很自然地写了并发语言的语义。</font><font style="vertical-align:inherit">在我看来，定义并发语言的语义应该不是很困难。</font><font style="vertical-align:inherit">一旦知道如何指定并发系统，通过指定并发编程语言编写的程序来赋予并发编程语言语义就是一项简单的任务。</font><font style="vertical-align:inherit">写这篇论文让我证明了编写语义就像我想象的那么容易。</font><font style="vertical-align:inherit">我在写这篇论文时发现，编程语言的语义是一个非常无聊的主题。</font><font style="vertical-align:inherit">我发现这篇论文写起来很无聊；</font><font style="vertical-align:inherit">我觉得读起来很无聊。</font><font style="vertical-align:inherit">我再也没有研究过编程语言的语义。&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="semantics"><b>An Axiomatic Semantics of Concurrent Programming
   Languages</b><br>In <i>Logics and Models of Concurrent Systems</i>,
   Krzysztof Apt, editor.&nbsp; Springer-Verlag, Berlin (1985), 77-122.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/semantics.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/semantics.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/semantics.pdf">PDF</a>
<br><font size="-2">Copyright 
1985 by Springer-Verlag.</font><hr>


This paper appeared in a workshop held in Colle-sur-Loup, in the south
of France, in October, 1984.&nbsp; There is a long history of work on the
semantics of programming languages.&nbsp; When people began studying
concurrency in the 70s, they naturally wrote about the semantics of
concurrent languages.&nbsp; It always seemed to me that defining the
semantics of a concurrent language shouldn't be very hard.&nbsp; Once you
know how to specify a concurrent system, it's a straightforward task
to give a semantics to a concurrent programming language by specifying
the programs written in it.&nbsp; Writing this paper allowed me to
demonstrate that writing a semantics is as easy as I thought it was.&nbsp;
What I did discover from writing the paper is that the semantics of
programming languages is a very boring subject.&nbsp; I found this paper
boring to write; I find it boring to read.&nbsp; I have never worked on the
semantics of programming languages again.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="latex"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">LaTeX：文档准备系统</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Addison-Wesley，雷丁，马萨诸塞州 (1986)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
没有电子版。</font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


八十年代初，我计划写一本伟大的美国并发书。</font><font style="vertical-align:inherit">我是一名 TeX 用户，所以我需要一组宏。</font><font style="vertical-align:inherit">我认为，只要付出一点额外的努力，我就可以让我的宏可供其他人使用。</font><font style="vertical-align:inherit">Don Knuth 已经开始发布 TeX 当前版本的早期版本，我想我可以编写将成为其标准宏包的内容。</font><font style="vertical-align:inherit">这就是 LaTeX 的开始。</font><font style="vertical-align:inherit">我本来打算写一本用户手册，但我从来没有想到有人会真正为此付钱。</font><font style="vertical-align:inherit">1983 年，Addison-Wesley 的编辑 Peter Gordon 和他的同事到 SRI 拜访了我。</font><font style="vertical-align:inherit">这是他对所发生事件的描述。&nbsp;

</font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我们的主要任务是为 Addison-Wesley 收集信息，“发布专门为学术和专业环境中的科学家和工程师设计的基于计算机的文档处理系统”。</font><font style="vertical-align:inherit">该系统将成为一系列相关产品（软件、手册、书籍）和服务（数据库、产品）的一部分。</font><font style="vertical-align:inherit">(La)TeX 是该系统核心的候选者。</font><font style="vertical-align:inherit">（我引用的是最初的商业计划。）幸运的是，我没有听信你关于有人会购买 LaTeX 手册的怀疑，因为实际上有超过几十万人这样做了。</font><font style="vertical-align:inherit">当然，确切的数字无法准确确定，因为许多人（并非所有朋友和亲戚）不止一次地购买了这本书，而且它的使用率非常高。&nbsp;
</font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
与此同时，我还没有写出伟大的美国并发书。&nbsp;


</font></font><br>&nbsp;<p></p></a></li><li> <a name="latex"><b>LaTeX: A Document Preparation
   System</b><br><i>Addison-Wesley, Reading, Mass. (1986)</i>.<br>
No electronic version available.<hr>


In the early 80s, I was planning to write the Great American
Concurrency Book.&nbsp; I was a TeX user, so I would need a set
of macros.&nbsp; I thought that, with a little extra effort, I could make
my macros usable by others.&nbsp; Don Knuth had begun issuing early
releases of the current version of TeX, and I figured I
could write what would become its standard macro package.&nbsp; That was
the beginning of LaTeX.&nbsp; I was planning to write a user
manual, but it never occurred to me that anyone would actually pay
money for it.&nbsp; In 1983, Peter Gordon, an Addison-Wesley editor, and
his colleagues visited me at SRI.&nbsp; Here is his account of
what happened.&nbsp;

<blockquote><p>
Our primary mission was to gather information for Addison-Wesley "to
publish a computer-based document processing system specifically
designed for scientists and engineers, in both academic and
professional environments." This system was to be part of a series of
related products (software, manuals, books) and services (database,
production).&nbsp; (La)TeX was a candidate to be at the core of
that system.&nbsp; (I am quoting from the original business plan.)&nbsp;
Fortunately, I did not listen to your doubt that anyone would buy the
LaTeX manual, because more than a few hundred thousand
people actually did.&nbsp; The exact number, of course, cannot accurately
be determined, inasmuch as many people (not all friends and relatives)
bought the book more than once, so heavily was it used.&nbsp;
</p></blockquote> 
Meanwhile, I still haven't written the Great American Concurrency
Book.&nbsp;


<br>&nbsp;<p></p></a></li><li><a name="latex"> </a><a name="interprocess"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于进程间通信 - 第一部分：基本形式主义，第二部分：算法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 1</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (1986), 77-101。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 8 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/interprocess.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/interprocess.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/interprocess.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1986 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


大多数计算机科学家将同步问题（例如互斥问题）视为数学问题。</font><font style="vertical-align:inherit">如何使用一类数学对象（例如原子读取和写入）来实现其他一些数学对象（例如互斥算法）？</font><font style="vertical-align:inherit">我一直认为同步问题是物理问题。</font><font style="vertical-align:inherit">如何使用寄存器等物理对象来实现物理目标，例如不要同时激活两个进程？

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
随着面包店算法的发现（参见</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">），我开始考虑两个进程如何通信的问题。</font><font style="vertical-align:inherit">我得出的结论是，异步通信需要某种对象，其状态可以由一个进程更改并由另一个进程观察。</font><font style="vertical-align:inherit">我们将这样的对象称为寄存器。</font><font style="vertical-align:inherit">本文介绍了三类寄存器。</font><font style="vertical-align:inherit">可以实现任意同步的最弱类称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">safe</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">次强的称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">常规的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，算法编写者通常假设的最强的称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">原子的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp; 

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我在 70 年代末获得了这里提出的所有结果，并向许多计算机科学家描述了它们。</font><font style="vertical-align:inherit">没有人觉得它们有趣，所以我从来没有把它们写下来。</font><font style="vertical-align:inherit">1984 年左右，我在 VLSI 的推动下看到了 Jay Misra 撰写的一篇论文，该论文与我的研究结果的总体方向一致。</font><font style="vertical-align:inherit">这让我意识到，由于 VLSI 开始让人们从更物理的角度思考同步，他们现在可能对我关于寄存器的结果感兴趣。</font><font style="vertical-align:inherit">所以，我写了这篇论文。</font><font style="vertical-align:inherit">与</font></font><a href="#mutual"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[61]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">一样，第一部分描述了我用非原子操作描述系统的形式主义。</font><font style="vertical-align:inherit">这一次，人们很感兴趣——也许是因为它提出了实现多读取器和多写入器原子寄存器这一诱人的未解决问题。</font><font style="vertical-align:inherit">这导致了一系列原子登记文件的出现。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
Fred Schneider 是处理这篇论文的编辑。</font><font style="vertical-align:inherit">他一直无法理解我的原子寄存器构造的证明。</font><font style="vertical-align:inherit">经过几轮填写施耐德无法遵循的步骤细节后，我发现算法不正确。</font><font style="vertical-align:inherit">幸运的是，我能够修复算法并写出一个他、我以及据我所知所有后来的读者都相信的证明。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">大约十五年后，堪萨斯大学 EECS 系的成员 Jerry James 在使用 PVS 机械验证系统形式化证明时发现了命题 1 中的一个小错误。</font><font style="vertical-align:inherit">他证明了该命题的修正版本，并展示了如何使用该版本来代替原始版本。</font></font><a href="http://lamport.azurewebsites.net/pubs/james-erratum.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">单击此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">可以获得包含 James 描述错误及其更正的注释的 pdf 文件</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li><a name="latex"> </a><a name="interprocess"><b>On Interprocess Communication--Part I: Basic 
   Formalism, Part II: Algorithms</b><br><i>Distributed Computing 1</i>, 2 (1986),
   77-101.&nbsp; Also appeared as SRC Research Report&nbsp;8.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/interprocess.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/interprocess.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/interprocess.pdf">PDF</a>
<br><font size="-2">Copyright 
1986 by Springer-Verlag.</font><hr>


Most computer scientists regard synchronization problems, such as the
mutual exclusion problem, to be problems of mathematics.&nbsp; How can you
use one class of mathematical objects, like atomic reads and writes,
to implement some other mathematical object, like a mutual exclusion
algorithm?  I have always regarded synchronization problems to be
problems of physics.&nbsp; How do you use physical objects, like registers,
to achieve physical goals, like not having two processes active at the
same time?

<p>
With the discovery of the bakery algorithm (see <a href="#bakery">[12]</a>), I
began considering the question of how two processes communicate.&nbsp; I
came to the conclusion that asynchronous communication requires some
object whose state can be changed by one process and observed by the
other.&nbsp; We call such an object a register.&nbsp; This paper introduced
three classes of registers.&nbsp; The weakest class with which arbitrary
synchronization is possible is called <i>safe</i>.&nbsp; The next strongest
is called <i>regular</i> and the strongest, generally assumed by
algorithm writers, is called <i>atomic</i>.&nbsp; 

</p><p>
I had obtained all the results presented here in the late 70s and had
described them to a number of computer scientists.&nbsp; Nobody found them
interesting, so I never wrote them up.&nbsp; Around 1984, I saw a paper by
Jay Misra, motivated by VLSI, that was heading in the general
direction of my results.&nbsp; It made me realize that, because VLSI had
started people thinking about synchronization from a more physical
perspective, they might now be interested in my results about
registers.&nbsp; So, I wrote this paper.&nbsp; As with <a href="#mutual">[61]</a>, the
first part describes my formalism for describing systems with
nonatomic operations.&nbsp; This time, people were interested--perhaps
because it raised the enticing unsolved problem of implementing
multi-reader and multi-writer atomic registers.&nbsp; It led to a brief
flurry of atomic register papers.&nbsp;

</p><p>
Fred Schneider was the editor who processed this paper.&nbsp; He kept
having trouble understanding the proof of my atomic register
construction.&nbsp; After a couple of rounds of filling in the details of
the steps that Schneider couldn't follow, I discovered that the
algorithm was incorrect.&nbsp; Fortunately, I was able to fix the algorithm
and write a proof that he, I, and, as far as I know, all subsequent
readers did believe.&nbsp;

</p><p> Some fifteen years later, Jerry James, a member of the
EECS department at the University of Kansas, discovered a small error
in Proposition 1 when formalizing the proofs with the PVS mechanical
verification system.&nbsp; He proved a corrected version of the proposition
and showed how that version could be used in place of the original
one.&nbsp; A pdf file containing a note by James describing the
error and its correction can be obtained by <a href="http://lamport.azurewebsites.net/pubs/james-erratum.pdf">clicking here</a>.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="the-byz-generals"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">拜占庭将军</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Danny Dolev、Marshall Pease 和 Robert Shostak）合</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">着</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《分布式系统中的并发控制和可靠性》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Bharat K. Bhargava，编辑，Van Nostrand Reinhold (1987) 348-369。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/the-byz-generals.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF </font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Van Nostrand Reinhold 1987 保留所有版权。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我对这篇论文只有模糊的记忆。</font></font><a href="#reaching"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我相信 Bhargava 让我写一章关于[41]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
</font></font><a href="#byz"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[46]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的结果</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我可能太懒了，要求多列夫写一章，将他关于连接要求的最新结果与我们的原始结果结合起来。</font><font style="vertical-align:inherit">我猜想他完成了所有的工作，尽管我至少必须阅读并批准他所写的内容。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="the-byz-generals"><b>The Byzantine Generals</b>&nbsp; (with Danny Dolev,
  Marshall Pease, and Robert Shostak)<br>In <i>Concurrency Control and 
  Reliability in Distributed Systems</i>, Bharat K. Bhargava, editor,
  Van Nostrand Reinhold (1987) 348-369.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/the-byz-generals.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Van Nostrand Reinhold 1987.</font><hr>


I have only a vague memory of this paper.&nbsp; I believe Bhargava asked me
to write a chapter about the results in <a href="#reaching">[41]</a> and
<a href="#byz">[46]</a>.&nbsp; I was probably too lazy and asked Dolev to write a
chapter that combined his more recent results on connectivity
requirements with our original results.&nbsp; I would guess that he did all
the work, though I must have at least read and approved of what he
wrote.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="formal-basis"><b><font style="vertical-align:inherit"></font></b><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">分布式操作系统</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">中</font><b><font style="vertical-align:inherit">并发系统规范的形式基础</font></b><font style="vertical-align:inherit">：理论与实践，Paker、Banatre 和 Bozyigit，编辑，Springer-Verlag (1987)，1-46。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/formal-basis.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/formal-basis.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/formal-basis.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1987 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文描述了我在
</font></font><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[50]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中介绍的转移公理方法。</font><font style="vertical-align:inherit">它是为 1986 年 8 月在土耳其举行的北约高级研究所编写的，几乎没有什么新内容。&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="formal-basis"><b>A Formal Basis for the Specification of 
   Concurrent Systems</b><br>In <i>Distributed Operating Systems: Theory and
   Practice</i>, Paker, Banatre and Bozyigit, editors,
   Springer-Verlag (1987), 1-46.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/formal-basis.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/formal-basis.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/formal-basis.pdf">PDF</a>
<br><font size="-2">Copyright 
1987 by Springer-Verlag.</font><hr>


This paper describes the transition axiom method I introduced in
<a href="#spec">[50]</a>.&nbsp; It was written for a NATO Advanced Study Institute
that took place in Turkey in August, 1986, and contains little that
was new.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="fast-mutex"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">一种快速互斥算法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Computer Systems 5</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (1987 年 2 月), 1-11。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 7 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/fast-mutex.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fast-mutex.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fast-mutex.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1987 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我到达 SRC 后不久，WRL（Digital 西方研究实验室）的一些人找到了我，他们正在构建一台多处理器计算机。</font><font style="vertical-align:inherit">他们希望避免添加同步指令，因此他们想知道仅使用读写指令如何有效地实现互斥。</font><font style="vertical-align:inherit">他们认为，通过正确设计的程序，对关键部分的争用应该很少见，因此他们对没有争用的情况下的效率感兴趣。</font><font style="vertical-align:inherit">我推导出所需操作数量的下限以及本文中描述的最佳算法。</font><font style="vertical-align:inherit">他们认为它太慢了，所以他们实施了测试和设置指令。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我发现值得注意的是，在 Dijkstra 首次提出互斥问题 20 年后，没有人想到尝试找到在没有争用的情况下快速的解决方案。</font><font style="vertical-align:inherit">这说明了我喜欢在工业界工作的原因：最有趣的理论问题来自于实现实际系统。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="fast-mutex"><b>A Fast Mutual Exclusion Algorithm</b><br><i>ACM
   Transactions on Computer Systems 5</i>, 1 (February 1987), 1-11.&nbsp; Also
   appeared as SRC Research Report&nbsp;7.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/fast-mutex.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fast-mutex.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fast-mutex.pdf">PDF</a>
<br><font size="-2">Copyright © 1987 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Soon after I arrived at SRC, I was approached by some people at WRL
(Digital's Western Research Laboratory) who were building a
multiprocessor computer.&nbsp; They wanted to avoid having to add
synchronization instructions, so they wanted to know how efficiently
mutual exclusion could be implemented with just read and write
instructions.&nbsp; They figured that, with properly designed programs,
contention for a critical section should be rare, so they were
interested in efficiency in the absence of contention.&nbsp; I deduced the
lower bound on the number of operations required and the optimal
algorithm described in this paper.&nbsp; They decided that it was too slow,
so they implemented a test-and-set instruction.&nbsp;

<p>
I find it remarkable that, 20 years after Dijkstra first posed the
mutual exclusion problem, no one had thought of trying to find
solutions that were fast in the absence of contention.&nbsp; This
illustrates why I like working in industry: the most interesting
theoretical problems come from implementing real systems.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="derivation-simple"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">简单同步算法的推导</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">被</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">信息处理快报</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝 
              （1987 年 2 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/derivation-simple.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/derivation-simple.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/derivation-simple.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Chuck Thacker 向我提出了一个小同步问题，我在 Jim Saxe 的帮助下解决了这个问题。</font><font style="vertical-align:inherit">当时，派生并发算法很流行——通过某种形式的黑魔法发现算法，然后验证它的想法已经过时了。</font><font style="vertical-align:inherit">因此，我决定看看是否可以从已批准的一般原则中推导出算法。</font><font style="vertical-align:inherit">我发现我可以——至少非正式地——而且这种非正式的推导似乎捕捉到了最初引导我找到解决方案的思维过程。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="derivation-simple"><b>Derivation of a Simple Synchronization
   Algorithm</b><br>Rejected by <i>Information Processing Letters</i> 
              (February 1987).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/derivation-simple.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/derivation-simple.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/derivation-simple.pdf">PDF</a><hr>


Chuck Thacker posed a little synchronization problem to me, which I
solved with Jim Saxe's help.&nbsp; At that time, deriving concurrent
algorithms was the fashion--the idea that you discover the algorithm
by some form of black magic and then verify it was considered
passé.&nbsp; So, I decided to see if I could have derived
the algorithm from approved general principles.&nbsp; I discovered that I
could--at least, informally--and that this informal derivation
seemed to capture the thought process that led me to the solution in
the first place.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="distributed-system"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">分发</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">电子邮件消息于 87 年 5 月 28 日太平洋夏令时 12:23:29 发送至 DEC SRC 公告栏。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/distributed-system.txt"><font style="vertical-align:inherit"><font style="vertical-align:inherit">文本文件</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


此消息是以下观察的来源，该观察已被相当广泛地引用（和错误引用）：
 </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
在分布式系统中，您甚至不知道其存在的计算机出现故障可能会导致您自己的计算机无法使用。&nbsp;
 </font></font></p></blockquote>

<br>&nbsp;<p></p></li><li> <a name="distributed-system"><b>Distribution</b><br>Email message sent to 
a DEC SRC bulletin board at 12:23:29 PDT on 28 May 87.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/distributed-system.txt">Text File</a><hr>


This message is the source of the following observation, which has 
been quoted (and misquoted) rather widely:
 <blockquote><p> 
A distributed system is one in which the failure of a computer you
didn't even know existed can render your own computer unusable.&nbsp;
 </p></blockquote>

<br>&nbsp;<p></p></li><li> <a name="document-production"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">文件制作：视觉还是逻辑？</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">美国数学会通知</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1987 年 6 月），621-624。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/document-production.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/document-production.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/document-production.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1987 美国数学会。</font></font></font><hr><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理查德·帕莱斯 (Richard Palais) 在《AMS 公告》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">


上发表了一篇关于数学排版的专栏
</font><font style="vertical-align:inherit">，他邀请我担任客座专栏作家。</font><font style="vertical-align:inherit">这就是我写的——对我关于制作数学文档的想法的简短阐述。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="document-production"><b>Document Production: Visual or
   Logical?</b><br><i>Notices of the American Mathematical Society</i> (June
   1987), 621-624.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/document-production.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/document-production.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/document-production.pdf">PDF</a>
<br><font size="-2">Copyright 
1987 by the American Mathematical Society.</font><hr>


Richard Palais ran a column on mathematical typesetting in the
<i>AMS Notices</i>, and he invited me to be guest columnist.&nbsp; This is
what I wrote--a short exposition of my ideas about producing
mathematical documents.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="synchronizing-time-servers"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">同步时间服务器</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRC 研究报告 18（1987 年 6 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">
  

当我 1985 年加入 DEC 时，他们是网络领域的世界领导者。</font><font style="vertical-align:inherit">使用他们的 VMS 操作系统，我可以</font><font style="vertical-align:inherit">
向加利福尼亚州的计算机输入简单的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">复制命令，指定文件和计算机名称，以从马萨诸塞州的计算机复制文件。</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">即使在今天，我也无法使用 Unix 或 Windows 将文件从马萨诸塞州复制到加利福尼亚州。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
负责 DEC 网络系统的人员是网络和通信小组 (NAC)。</font><font style="vertical-align:inherit">1987 年左右，NAC 请求我帮助设计网络授时服务。</font><font style="vertical-align:inherit">我认为时间服务存在两个有些冲突的要求：提供正确的时间，并保持不同计算机上的时钟紧密同步。</font><font style="vertical-align:inherit">本文描述了我为实现这两点而设计的算法。&nbsp; 

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我撤回了这篇论文，因为蒂姆·曼 (Tim Mann) 观察到我证明的算法属性弱于使它们变得有趣所需的属性。</font><font style="vertical-align:inherit">主要问题是，算法的设计目的是保证每个时钟与正确时间源的同步有一个界限 epsilon，以及任何两个时钟之间的同步的独立界限增量，该增量可以比 epsilon 小得多。</font><font style="vertical-align:inherit">曼观察到，我在 delta 上证明的界限并不是我想要证明的独立于 epsilon 的强界限。</font><font style="vertical-align:inherit">我们相信这些算法确实满足了必要的更强的属性，曼恩和我开始用更强的结果重写论文。</font><font style="vertical-align:inherit">但该论文还只完成了部分内容，不太可能面世。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="synchronizing-time-servers"><b>Synchronizing Time Servers</b><br>SRC
   Research Report&nbsp;18 (June 1987).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/synchronizing-time-servers.pdf">PDF</a><hr>
  

When I joined DEC in 1985, they were the world leader in networking.&nbsp;
Using their VMS operating system, I could type a simple <i>copy</i>
command to a computer in California, specifying a file and machine
name, to copy a file from a computer in Massachusetts.&nbsp; Even today, I
can't copy a file from Massachusetts to California nearly as easily
with Unix or Windows.&nbsp;

<p>
The people responsible for DEC's network systems were the Network and
Communications group (NAC).&nbsp; Around 1987, NAC asked for my help in
designing a network time service.&nbsp; I decided that there were two
somewhat conflicting requirements for a time service: delivering the
correct time, and keeping the clocks on different computers closely
synchronized.&nbsp; This paper describes the algorithms I devised for doing
both.&nbsp; 

</p><p> 

I withdrew the paper because Tim Mann observed that the properties I
proved about the algorithms were weaker than the ones needed to make
them interesting.&nbsp; The major problem is that the algorithms were
designed to guarantee both a bound epsilon on the
synchronization of each clock with a source of correct time and an
independent bound delta on the synchronization between
any two clocks that could be made much smaller than
epsilon.&nbsp; Mann observed that the bound I proved on
delta was not the strong one independent of
epsilon that I had intended to prove.&nbsp; We believe
that the algorithms do satisfy the necessary stronger properties, and
Mann and I began rewriting the paper with the stronger results.&nbsp; But
that paper is still only partly written and is unlikely ever to see
the light of day.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="control"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">控制谓词比虚拟变量更好地表示</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">编程语言和系统上的程序控制 ACM 事务 10</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (1988 年 4 月), 267-281。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 11 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/control.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/control.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/control.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1988 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#liveness"><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文描述了我遇到的一个例子，其中[47]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中引入的显式控制谓词</font><font style="vertical-align:inherit">导致了比虚拟变量更简单的证明。</font><font style="vertical-align:inherit">这个例子只是一个借口。</font><font style="vertical-align:inherit">发布它的真正原因是游说控制谓词的使用。</font><font style="vertical-align:inherit">理论计算机科学家曾经非常不愿意提及程序的控制状态。</font><a href="#hoare"><font style="vertical-align:inherit">当我第一次描述[40]</font></a><font style="vertical-align:inherit">中的工作时</font></font><a href="#hoare"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于 Albert Meyer 来说，他立即就迷上了控制谓词。</font><font style="vertical-align:inherit">我们花了一个小时争论它们——我说它们是必要的（正如苏珊在她的论文中首先证明的那样），他说我一定做错了什么。</font><font style="vertical-align:inherit">我有一种感觉，我是在反对宗教信仰来论证逻辑必然性，而逻辑不可能战胜宗教。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="control"><b>Control Predicates Are Better than Dummy Variables for
   Representing Program Control</b><br><i>ACM Transactions on Programming
   Languages and Systems 10</i>, 2 (April 1988), 267-281.&nbsp; Also appeared
   as SRC Research Report&nbsp;11.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/control.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/control.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/control.pdf">PDF</a>
<br><font size="-2">Copyright © 1988 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper describes an example I came across in which the explicit
control predicates introduced in <a href="#liveness">[47]</a> lead to a simpler
proof than do dummy variables.&nbsp; This example served as an excuse.&nbsp; The
real reason for publishing it was to lobby for the use of control
predicates.&nbsp; There used to be an incredible reluctance by theoretical
computer scientists to mention the control state of a program.&nbsp; When I
first described the work in <a href="#hoare">[40]</a> to Albert Meyer, he
immediately got hung up on the control predicates.&nbsp; We spent an hour
arguing about them--I saying that they were necessary (as was first
proved by Susan in her thesis), and he saying that I must be doing
something wrong.&nbsp; I had the feeling that I was arguing logical
necessity against religious belief, and there's no way logic can
overcome religion.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="lamport-ewd1013"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">“EWD 1013”</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未出版。</font><font style="vertical-align:inherit">大概写于 1988 年 4 月左右。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-ewd1013.txt"><font style="vertical-align:inherit"><font style="vertical-align:inherit">文本文件</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Dijkstra 的 EWD 1013，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于“公平性”的立场文件</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，认为公平性是一个毫无意义的要求，因为它无法通过在有限的时间内观察系统来验证。</font><font style="vertical-align:inherit">通过观察它也适用于终止，就揭示了这个论点的弱点。</font><font style="vertical-align:inherit">为了说明这一点，我写了这篇说明，它声称是 EWD 1013 的早期草案，标题</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">为“终止”立场文件</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">当然，它本质上与 EWD 1013 相同，只不过</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">公平性被</font></font></i><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">终止</font></i><font style="vertical-align:inherit">取代了</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">由于当时发生的其他事情，我担心迪杰斯特拉可能不会本着好玩的精神来看待这件事，而且他可能会觉得这很令人反感。</font><font style="vertical-align:inherit">所以，除了几个朋友之外，我从未向任何人展示过它。</font><font style="vertical-align:inherit">我认为时间的流逝已经产生了足够的柔和效果，没有人会再被它冒犯。</font><font style="vertical-align:inherit">现在人们对形式比对内容更感兴趣。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-ewd1013"><b>"EWD 1013"</b><br>Unpublished.&nbsp; Probably written
   around April, 1988.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-ewd1013.txt">Text File</a><hr>


Dijkstra's EWD 1013, <i>Position Paper on "Fairness"</i>, argues
that fairness is a meaningless requirement because it can't be
verified by observing a system for a finite length of time.&nbsp; The
weakness in this argument is revealed by observing that it applies
just as well to termination.&nbsp; To make the point, I wrote this note,
which claims to be an early draft of EWD 1013 titled <i>Position
Paper on "Termination"</i>.&nbsp; It is, of course, essentially the same as
EWD 1013 with <i>fairness</i> replaced by <i>termination</i>.&nbsp; Because
of other things that happened at that time, I was afraid that Dijkstra
might not take it in the spirit of good fun in which it was intended,
and that he might find it offensive.&nbsp; So, I never showed it to anyone
but a couple of friends.&nbsp; I think the passage of time has had enough
of a mellowing effect that no one will be offended any more by it.&nbsp; It
is now of more interest for the form than for the content.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="position"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">另一份关于公平性的立场文件</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred Schneider 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">软件工程笔记 13</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1988 年 7 月）1-2。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/position.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/position.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/position.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1988 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是对 Dijkstra 的 EWD 1013 的更传统的回应（参见
</font></font><a href="#lamport-ewd1013"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[79]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">我们指出，迪杰斯特拉的相同论点可以用来证明终止是一个毫无意义的要求，因为它不能通过在有限的时间内查看程序来反驳。</font><font style="vertical-align:inherit">支持公平性的真正论点（我们没有提到）是，在推理并发系统时，这是一个有用的概念。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="position"><b>Another Position Paper on Fairness</b>&nbsp; (with Fred 
   Schneider)<br><i>Software Engineering Notes 13</i>, 3 (July, 1988) 1-2.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/position.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/position.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/position.pdf">PDF</a>
<br><font size="-2">Copyright © 1988 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This is a more traditional response to Dijkstra's EWD 1013 (see
<a href="#lamport-ewd1013">[79]</a>).&nbsp; We point out that Dijkstra's same argument
can be applied to show that termination is a meaningless requirement
because it can't be refuted by looking at a program for a finite
length of time.&nbsp; The real argument in favor of fairness, which we
didn't mention, is that it is a useful concept when reasoning about
concurrent systems.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="welch-lattice"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">最小生成树算法的格结构证明</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Jennifer Welch 和 Nancy Lynch 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第七届 ACM 分布式计算原理年度研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1988 年 8 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/welch-lattice.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1988 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1983 年，Gallager、Humblet 和 Spira 发表了一种计算最小生成树的分布式算法。</font><font style="vertical-align:inherit">多年来，我一直将其视为验证并发算法的基准问题。</font><font style="vertical-align:inherit">有几次，我试图写一个不变性证明，但不变性变得如此复杂，以至于我放弃了。</font><font style="vertical-align:inherit">在访问麻省理工学院时，我向南希·林奇描述了这个问题，她也对此产生了兴趣。</font><font style="vertical-align:inherit">我不记得它是如何发生的，但我们提出了将证明分解为细化网格的想法，而不是简单的细化层次结构。</font><font style="vertical-align:inherit">作为一名高效的学者，林奇让詹妮弗·韦尔奇（Jennifer Welch）完成了实际撰写证明的工作，作为她博士论文的一部分。</font><font style="vertical-align:inherit">这篇论文是会议版本，主要由她撰写。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

那年 PODC 上提出了最小生成树算法的三个证明：我们的一个，一个是由 Willem-Paul de Roever 和他的学生 Frank Stomp 提出的，第三个是由 Eli Gafni 和他的学生 Ching-Tsun Chou 提出的。</font><font style="vertical-align:inherit">每篇论文都使用了不同的证明方法。</font><font style="vertical-align:inherit">我认为这三者中最好的是 Gafni 和 Chou 的——不是因为他们的证明方法更好，而是因为他们更好地理解算法并利用他们的理解来简化证明。</font><font style="vertical-align:inherit">如果他们试图形式化他们的证明，它就会变成标准的不变性证明。</font><font style="vertical-align:inherit">事实上，周最终在他的博士论文中写出了这样一个形式化的不变性证明。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
Gallager、Humblet 和 Spira 算法很复杂，其正确性也相当微妙。</font><font style="vertical-align:inherit">（林奇告诉我，当她讲授其证明时，加拉格不得不问她为什么它在某种情况下有效。）这种算法的标准不变性证明似乎没有任何替代品。</font><font style="vertical-align:inherit">按照我们的方式分解证明在当时看来是个好主意，但事实上，这只是增加了额外的工作。</font><font style="vertical-align:inherit">（</font><font style="vertical-align:inherit">有关此问题的进一步讨论，&nbsp;


请参阅</font></font><a href="#lamport-composition"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[125] 。）</font></font></a><font style="vertical-align:inherit"></font><br>&nbsp;</p><p></p></li><li> <a name="welch-lattice"><b>A Lattice-Structured Proof of a Minimum Spanning 
   Tree Algorithm</b>&nbsp; (with Jennifer Welch and Nancy Lynch)<br><i>Proceedings 
   of the Seventh Annual ACM Symposium on Principles of 
   Distributed Computing</i> (August, 1988).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/welch-lattice.pdf">PDF</a>
<br><font size="-2">Copyright © 1988 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


In 1983, Gallager, Humblet, and Spira published a distributed
algorithm for computing a minimum spanning tree.&nbsp; For several years, I
regarded it as a benchmark problem for verifying concurrent
algorithms.&nbsp; A couple of times, I attempted to write an invariance
proof, but the invariant became so complicated that I gave up.&nbsp; On a
visit to M.I.T., I described the problem to Nancy Lynch, and she
became interested in it too.&nbsp; I don't remember exactly how it
happened, but we came up with the idea of decomposing the proof not as
a simple hierarchy of refinements, but as a lattice of refinements.&nbsp;
Being an efficient academic, Lynch got Jennifer Welch to do the work
of actually writing the proof as part of her Ph. D. thesis.&nbsp;
This paper is the conference version, written mostly by her.&nbsp;

<p> 

There were three proofs of the minimum spanning-tree algorithm
presented at PODC that year: ours, one by Willem-Paul de Roever and
his student Frank Stomp, and the third by Eli Gafni and his student
Ching-Tsun Chou.&nbsp; Each paper used a different proof method.&nbsp; I
thought that the best of the three was the one by Gafni and
Chou--not because their proof method was better, but because they
understood the algorithm better and used their understanding to
simplify the proof.&nbsp; If they had tried to formalize their proof, it
would have turned into a standard invariance proof.&nbsp; Indeed, Chou
eventually wrote such a formal invariance proof in his doctoral
thesis.&nbsp;

</p><p>
The Gallager, Humblet, and Spira algorithm is complicated and its
correctness is quite subtle.&nbsp; (Lynch tells me that, when she lectured
on its proof, Gallager had to ask her why it works in a certain case.)&nbsp;
There doesn't seem to be any substitute for a standard invariance
proof for this kind of algorithm.&nbsp; Decomposing the proof the way we
did seemed like a good idea at the time, but in fact, it just added
extra work.&nbsp; (See <a href="#lamport-composition">[125]</a> for a further
discussion of this.)&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="simple-approach"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定ACM</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">并发系统通信的简单方法</font></b><font style="vertical-align:inherit">32 , 1（1989 年 1 月）, 32-45。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 15 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/simple-approach.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/simple-approach.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/simple-approach.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1989 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是我在[50]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中介绍的转换公理方法的“流行”描述</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">为了使这些想法更容易理解，我以问答的方式编写了它，这是我从伽利略的对话中复制的。</font><font style="vertical-align:inherit">这篇论文的写作可能是我写过的最好的文章。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="simple-approach"><b>A Simple Approach to Specifying Concurrent
   Systems</b><br><i>Communications of the ACM 32</i>, 1 (January 1989),
   32-45.&nbsp; Also appeared as SRC Research Report&nbsp;15.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/simple-approach.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/simple-approach.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/simple-approach.pdf">PDF</a>
<br><font size="-2">Copyright © 1989 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This is a "popular" account of the transition-axiom method that I
introduced in <a href="#spec">[50]</a>.&nbsp; To make the ideas more accessible, I
wrote it in a question-answer style that I copied from the dialogues
of Galileo.&nbsp; The writing in this paper may be the best I've ever done.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="pretending"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">假装原子性</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred Schneider 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRC 研究报告 44（1989 年 5 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/pretending.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/pretending.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/pretending.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">
  

如果并发系统的独立原子操作较少，那么它们的推理就会更简单。</font><font style="vertical-align:inherit">为了简化系统的推理，我们希望能够将多个小的原子操作组合成一个大的操作。</font><font style="vertical-align:inherit">这个过程称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">还原</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">本文包含多进程程序的约简定理。</font><font style="vertical-align:inherit">经过细微修改后，它被接受发表在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions onProgramming Languages and Systems上</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，写完之后，我发明了 TLA，它使我能够设计出更强大、更优雅的约简定理。</font><font style="vertical-align:inherit">Schneider 和我开始根据 TLA 修改论文。</font><font style="vertical-align:inherit">我们计划提出一个更弱、更简单的 TLA 归约定理版本，该定理基本上涵盖了本报告中考虑的情况。</font><font style="vertical-align:inherit">然而，我们从未完成那篇论文。</font><font style="vertical-align:inherit">更通用的 TLA 约简定理最终发表在</font></font><a href="#cohen-tlareduction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[124]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="pretending"><b>Pretending Atomicity</b>&nbsp; (with Fred Schneider)<br>SRC 
   Research Report&nbsp;44 (May 1989).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/pretending.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/pretending.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/pretending.pdf">PDF</a><hr>
  

Reasoning about concurrent systems is simpler if they have fewer
separate atomic actions.&nbsp; To simplify reasoning about systems, we'd
like to be able to combine multiple small atomic actions into a single
large one.&nbsp; This process is called <i>reduction</i>.&nbsp; This paper
contains a reduction theorem for multiprocess programs.&nbsp; It was
accepted for publication, subject to minor revisions, in <i>ACM
Transactions on Programming Languages and Systems</i>.&nbsp; However, after
writing it, I invented TLA, which enabled me to devise a stronger and
more elegant reduction theorem.&nbsp; Schneider and I began to revise the
paper in terms of TLA.&nbsp; We were planning to present a
weaker, simpler version of the TLA reduction theorem that essentially
covered the situations considered in this report.&nbsp; However, we never
finished that paper.&nbsp; A more general TLA reduction theorem was finally
published in <a href="#cohen-tlareduction">[124]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="abadi-realizable"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">反应式系统的可实现和不可实现的规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 和 Pierre Wolper 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《自动机，语言和编程》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Springer-Verlag（1989 年 7 月）1-17。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1989 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#abadi-composing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">阿巴迪和我在[98]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中提出了可实现性的概念
</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">大约在同一时间，其他几个人独立提出了这个想法，其中包括沃尔珀。</font><font style="vertical-align:inherit">阿巴迪和沃尔珀共同努力，将我们的结果和他的结果合并到一篇论文中。</font><font style="vertical-align:inherit">阿巴迪回忆说，论文中处理一般情况的部分大部分是我们的，沃尔珀主要开发有限情况，包括算法。</font><font style="vertical-align:inherit">他记得从直觉逻辑的可实现性中采用了“可实现性”这个术语，并在看到《符号逻辑杂志》上关于描述性集合论中关于无限博弈的文章后思考了与无限博弈的关系。</font><font style="vertical-align:inherit">我记得，我并没有积极参与这篇论文的写作。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="abadi-realizable"><b>Realizable and Unrealizable Specifications of
   Reactive Systems</b>&nbsp; (with Martín Abadi and
   Pierre Wolper)<br><i>Automata, Languages and Programming</i>,
   Springer-Verlag (July 1989) 1-17.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-realizable.pdf">PDF</a>
<br><font size="-2">Copyright 
1989 by Springer-Verlag.</font><hr>


Abadi and I came upon the concept of realizability in
<a href="#abadi-composing">[98]</a>.&nbsp; Several other people independently came up
with the idea at around the same time, including Wolper.&nbsp; Abadi and
Wolper worked together to combine our results and his into a single
paper.&nbsp; Abadi recollects that the section of the paper dealing with
the general case was mostly ours, and Wolper mostly developed the
finite case, including the algorithms.&nbsp; He remembers adopting the term
"realizability" from realizability in intuitionistic logic, and
thinking of the relation with infinite games after seeing an article
about such games in descriptive set theory in the Journal of Symbolic
Logic.&nbsp; As I recall, I wasn't very involved in the writing of this
paper.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="old-tla-src"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">行动的时间逻辑</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRC 研究报告 47（1990 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/old-tla-src.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/old-tla-src.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/old-tla-src.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是我第一次尝试 TLA，但效果不太好。</font><font style="vertical-align:inherit">它被</font></font><a href="#lamport-actions"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[103]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">取代。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="old-tla-src"><b>A Temporal Logic of Actions</b><br>SRC Research 
    Report&nbsp;47 (April 1990).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/old-tla-src.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/old-tla-src.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/old-tla-src.pdf">PDF</a><hr>


This was my first attempt at TLA, and I didn't get it quite right.&nbsp;
It is superseded by <a href="#lamport-actions">[103]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-win"><b><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">win</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">sin</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">：编程语言和系统上并发</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 事务的谓词转换器 12</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1990 年 7 月）396-428。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 17（1987 年 5 月）出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-win.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-win.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-win.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1990 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">长期以来，我一直对算法着迷，比如[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中的面包店算法</font><font style="vertical-align:inherit">，它们不假设其各个操作的原子性。</font></font><a href="#new-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我设计了首次在[33]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中发表的形式主义
</font><font style="vertical-align:inherit">，用于编写此类算法的行为证明。</font><font style="vertical-align:inherit">我也长期以来一直相信不变性证明，这要求算法用原子动作来表示。</font><font style="vertical-align:inherit">面包店算法的断言证明需要根据多个原子操作对其非原子操作进行建模 - 正如我在</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]中所做的那样</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，通过这种建模很容易引入默认假设。</font><font style="vertical-align:inherit">事实上，在 80 年代初期的某个时候，我意识到面包店算法需要对如何实现某个操作进行假设，而我从未明确说明过这一点，并且在我编写的任何证明中都没有明显体现出来。</font><font style="vertical-align:inherit">本文介绍了一种直接根据算法的非原子操作编写算法的形式断言证明的方法。</font><font style="vertical-align:inherit">它给出了面包店算法的证明，明确揭示了所需的假设。</font><font style="vertical-align:inherit">然而，我发现该方法很难使用。</font><font style="vertical-align:inherit">通过练习，也许人们可以变得足够容易并使其实用。</font><font style="vertical-align:inherit">然而，似乎没有足够的算法需要对非原子行为进行推理，以便任何人都可以获得该设施。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-win"><b><i>win</i> and <i>sin</i>: Predicate Transformers
   for Concurrency</b><br><i>ACM Transactions on Programming Languages and Systems 12</i>, 3 (July 1990) 396-428. Also
  appeared as SRC Research Report&nbsp;17 (May 1987).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-win.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-win.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-win.pdf">PDF</a>
<br><font size="-2">Copyright © 1990 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


I had long been fascinated with algorithms that, like the bakery
algorithm of <a href="#bakery">[12]</a>, do not assume atomicity of their
individual operations.&nbsp; I devised the formalism first published in
<a href="#new-approach">[33]</a> for writing behavioral proofs of such
algorithms.&nbsp; I had also long been a believer in invariance proofs,
which required that the algorithm be represented in terms of atomic
actions.&nbsp; An assertional proof of the bakery algorithm required
modeling its nonatomic operations in terms of multiple atomic
actions--as I did in <a href="#bakery">[12]</a>.&nbsp; However, it's easy to
introduce tacit assumptions with such modeling.&nbsp; Indeed, sometime
during the early 80s I realized that the bakery algorithm required an
assumption about how a certain operation is implemented that I had
never explicitly stated, and that was not apparent in any of the
proofs I had written.&nbsp; This paper introduces a method of writing
formal assertional proofs of algorithms directly in terms of their
nonatomic operations.&nbsp; It gives a proof of the bakery algorithm that
explicitly reveals the needed assumption.&nbsp; However, I find the method
very difficult to use.&nbsp; With practice, perhaps one could become facile
enough with it to make it practical.&nbsp; However, there don't seem to be
enough algorithms requiring reasoning about nonatomic actions for
anyone to acquire that facility.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-theorem"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式算法原子性定理</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (1990), 59-68。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 28 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1990 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">
 

本文给出了分布式算法的约简定理（参见</font></font><a href="#pretending"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[83]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论）。</font><font style="vertical-align:inherit">它包括我认为是活性特性的第一个减少结果。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-theorem"><b>A Theorem on Atomicity in Distributed
   Algorithms</b><br><i>Distributed Computing 4</i>, 2 (1990), 59-68.&nbsp;
   Also appeared as SRC Research Report&nbsp;28.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-theorem.pdf">PDF</a>
<br><font size="-2">Copyright 
1990 by Springer-Verlag.</font><hr>
 

This paper gives a reduction theorem for distributed algorithms (see
the discussion of <a href="#pretending">[83]</a>).&nbsp; It includes what I believe to
be the first reduction result for liveness properties.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-chapter"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算：模型和方法</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Nancy Lynch 合作）《</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学手册》，卷 B：形式模型和语义</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Jan van Leeuwen，编辑，Elsevier (1990)，1157-1199。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩后记</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1990 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Jan van Leeuwen 让我为这本手册写一章关于分布式系统的内容。</font><font style="vertical-align:inherit">我意识到我对分布式算法的文献还不够熟悉，无法自己编写它，所以我请 Nancy Lynch 帮忙。</font><font style="vertical-align:inherit">我还观察到没有关于并发算法的断言验证的章节。</font><font style="vertical-align:inherit">（这可能是由于该手册的地理起源，因为过程代数在欧洲占主导地位。）因此，我包含了关于证明方法的主要部分。</font><font style="vertical-align:inherit">我记得，前三部分的大部分都是我写的，第四部分关于算法的部分几乎是林奇自己写的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-chapter"><b>Distributed Computing: Models and
   Methods</b>&nbsp; (with Nancy Lynch)<br><i>Handbook of Theoretical Computer
   Science, Volume&nbsp;B: Formal Models and Semantics</i>, 
  Jan van Leeuwen,
   editor, Elsevier (1990), 1157-1199.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-chapter.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1990.</font><hr>


Jan van Leeuwen asked me to write a chapter on distributed systems for
this handbook.&nbsp; I realized that I wasn't familiar enough with the
literature on distributed algorithms to write it by myself, so I asked
Nancy Lynch to help.&nbsp; I also observed that there was no chapter on
assertional verification of concurrent algorithms.&nbsp; (That was probably
due to the handbook's geographical origins, since process algebra
rules in Europe.)&nbsp; So I included a major section on proof methods.&nbsp; As
I recall, I wrote most of the first three sections and Lynch wrote the
fourth section on algorithms pretty much by herself.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="lamport-completion"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 的完备性定理</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表（1990 年 10 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-completion.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-completion.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-completion.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是说明并证明在没有时间存在量化（变量隐藏）的情况下 TLA 公理的相对完整性结果的注释的开头。</font><font style="vertical-align:inherit">（用于格式化注释的古老 LaTeX 宏仅适用于第一部分。完整注释和所有其他 TLA 注释的文本版本可在  </font></font><a href="http://lamport.azurewebsites.net/tla/notes.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">找到。证明中无疑存在错误，但我认为这些错误很小。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-completion"><b>A Completeness Theorem for TLA</b><br>Unpublished
(October, 1990).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-completion.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-completion.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-completion.pdf">PDF</a><hr>


This is the beginning of  a note that states and proves a
relative completeness result for the axioms of TLA in the absence of
temporal existential quantification (variable hiding).&nbsp; (The
ancient LaTeX macros used to format the note only work on the first
part. A text version of the complete note and of all other TLA notes
are available  <a href="http://lamport.azurewebsites.net/tla/notes.html">here</a>.&nbsp;
There are undoubtedly errors in the proof, but I think they're minor.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-concurrent-clocks"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">时钟的并发读写</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Computer Systems 8</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 4 (1990 年 11 月), 305-310。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 27 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1990 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文使用[25]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的结果</font><font style="vertical-align:inherit">推导了几种用于读写多字时钟的算法。</font></font><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这些算法与[25]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的算法具有相同的风格</font><font style="vertical-align:inherit">，涉及以相反的方向读取和写入多位数。</font><font style="vertical-align:inherit">事实上，我认为当我写
</font></font><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[25]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">时我就知道算法了。</font><font style="vertical-align:inherit">当 SRC 构建的系统中出现读写两个字时钟的问题时，我惊讶地发现</font></font><a href="#rd-wr"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[25]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中没有解决方案。</font><font style="vertical-align:inherit">我不知道为什么没有，但我很高兴有机会发表一篇论文，提醒人们早期的结果。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-concurrent-clocks"><b>The Concurrent Reading and
   Writing of Clocks</b><br><i>ACM Transactions on Computer Systems 8</i>, 4
   (November 1990), 305-310.&nbsp; Also appeared as SRC Research 
   Report&nbsp;27.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-concurrent-clocks.pdf">PDF</a>
<br><font size="-2">Copyright © 1990 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper uses the results from <a href="#rd-wr">[25]</a> to derive a couple of
algorithms for reading and writing multi-word clocks.&nbsp; These
algorithms are in the same vein as the ones in <a href="#rd-wr">[25]</a>,
involving reading and writing multi-digit numbers in opposite
directions.&nbsp; In fact, I think I knew the algorithms when I wrote
<a href="#rd-wr">[25]</a>.&nbsp; When the problem of reading and writing a two-word
clock arose in a system being built at SRC, I was surprised to
discover that the solution wasn't in <a href="#rd-wr">[25]</a>.&nbsp; I don't know why
it wasn't, but I welcomed the opportunity to publish a paper reminding
people of the earlier results.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="lamport-mutual-solved"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">互斥问题已解决</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 34 通讯</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，1（1991 年 1 月），110。Postscript </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">-</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;压缩&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1991 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1990 年，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">发布了一项自我评估程序，这次是关于并发编程的。</font><font style="vertical-align:inherit">其中一个问题的“正确”答案意味着互斥只能使用原子操作来实现，而原子操作本身是通过较低级别的互斥实现的。</font><font style="vertical-align:inherit">似乎应该指出这是错误的，而且我实际上在 16 年前就已经在
</font></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[12]中解决了互斥问题——讽刺的是，这是</font></font></a><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">上的一篇文章</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">因此，我为此提交了这篇简短的说明。</font><font style="vertical-align:inherit">最后塞缪尔·约翰逊（Samuel Johnson）的引言是鲍勃·泰勒（Bob Taylor）非常喜欢的一句话，并在他担任实验室主任时教给了 SRC 的所有人。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我不再拥有的原始版本引用了所有支持“正确”答案的来源，表明该领域的所有专家都不知道互斥问题已得到解决。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">然而， CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的编辑</font><font style="vertical-align:inherit">却亲自处理了我的投稿。</font><font style="vertical-align:inherit">他坚持要求删除所有这些材料以及随之而来的讽刺。</font><font style="vertical-align:inherit">虽然我不喜欢社论的这种贬低，但我不想打架。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
我对这张纸条最终出现的方式感到震惊。</font><font style="vertical-align:inherit">我从未见过一篇已发表的文章如此有效地向读者隐藏。</font><font style="vertical-align:inherit">我反对任何人在不知道页码的情况下&nbsp;

</font><font style="vertical-align:inherit">找到那期</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM并找到该注释。</font></font></i><font style="vertical-align:inherit"></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-mutual-solved"><b>The Mutual Exclusion Problem Has Been
   Solved</b><br><i>Communications of the ACM 34</i>, 1 (January 1991), 110.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-mutual-solved.pdf">PDF</a>
<br><font size="-2">Copyright © 1991 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


In 1990, <i>CACM</i> published one of their self-assessment
procedures, this time on concurrent programming.&nbsp; The "correct"
answer to one of the questions implied that mutual exclusion can be
implemented only using atomic operations that are themselves
implemented with lower-level mutual exclusion.&nbsp; It seemed appropriate
to point out that this was wrong, and that I had actually solved the
mutual exclusion problem 16 years earlier in
<a href="#bakery">[12]</a>--ironically, an article in <i>CACM</i>.&nbsp;
So, I submitted this short note to that effect.&nbsp; The quotation from
Samuel Johnson at the end is one that Bob Taylor likes very much and
taught to everyone at SRC when he was lab director.&nbsp;

<p>
The original version, which I no longer have, quoted all the sources
cited in support of the "correct" answer, showing how all those
experts in the field had no idea that the mutual exclusion problem had
been solved.&nbsp; However, the editor of <i>CACM</i> took it upon
himself to handle my submission personally.&nbsp; He insisted that all this
material be deleted, along with the accompanying sarcasm.&nbsp; Although I
didn't like this editorial bowdlerization, I didn't feel like
fighting.&nbsp;

</p><p> 
I was appalled at how this note finally appeared.&nbsp; I have never seen a
published article so effectively hidden from the reader.&nbsp; I defy
anyone to take that issue of <i>CACM</i> and find the note without
knowing the page number.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="abadi-existence"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">细化映射的存在</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学 82</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1991 年 5 月）, 253-284。</font><font style="vertical-align:inherit">（删节版出现在《</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第三届计算机科学逻辑年度会议论文集》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1988 年 7 月）中。）也作为 SRC 研究报告 29 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-existence.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-existence.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-existence.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF </font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">1991 年 Elsevier Science 保留所有版权。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


通过使用细化映射来证明一种规范实现另一种规范的方法在 80 年代中期已经很成熟。</font></font><a href="#what-good"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（ [54]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述得很清楚， </font><a href="#spec"><font style="vertical-align:inherit">[50]</font></a><font style="vertical-align:inherit">中也出现了
</font></font><a href="#spec"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">.）众所周知，构建细化映射可能需要向实现添加历史变量。</font><font style="vertical-align:inherit">事实上，Lam 和 Shankar 本质上是用历史变量构建了他们所有的细化映射。</font><font style="vertical-align:inherit">Jim Saxe 发现了一个简单的例子，表明历史变量是不够的。</font><font style="vertical-align:inherit">为了处理这个例子，他设计了一个更复杂的细化映射规则。</font><font style="vertical-align:inherit">我意识到我可以消除这个复杂的规则，并使用普通的细化，通过引入一种新的虚拟变量，我称之为预言变量。</font><font style="vertical-align:inherit">预言变量非常类似于历史变量，只不过它预测未来而不是记住过去。</font><font style="vertical-align:inherit">（南希·林奇后来重新发现了萨克斯规则，并用它通过消除预言变量来“简化”精化证明。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">线性化：可以用预言变量处理的&nbsp;

</font><i><font style="vertical-align:inherit">并发对象的正确性条件。</font></i></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这篇论文是我与阿巴迪的第一次合作。</font><font style="vertical-align:inherit">这是我的回忆，它是如何写的。</font><font style="vertical-align:inherit">我有一种预感，历史和预言变量就是我们所需要的。</font><font style="vertical-align:inherit">阿巴迪最近加入了 SRC，这似乎是一个很好的机会让他对我正在做的事情产生兴趣。</font><font style="vertical-align:inherit">所以我向他描述了我的预感，并建议他考虑证明这一点。</font><font style="vertical-align:inherit">几周后他带着论文中描述的结果回来了。</font><font style="vertical-align:inherit">我的预感是正确的，只是需要一些我没有怀疑过的假设。</font><font style="vertical-align:inherit">然而，阿巴迪回忆说，我对最终定理有了更清晰的了解，并且在编写最终证明时我们一起解决了一些细节。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
我刚刚开发了
</font></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的结构化证明风格，所以我坚持以这种风格编写证明，这意味着重写阿巴迪的原始证明。</font><font style="vertical-align:inherit">在这个过程中，我们在校样中发现了一些小错误，但结果没有错误。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该论文荣获 LICS 1988 Test of Time Award（2008 年颁发）。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="abadi-existence"><b>The Existence of Refinement 
  Mappings</b>&nbsp; (with Martín 
  Abadi)<br><i>Theoretical Computer Science 82</i>, 2 (May
  1991), 253-284.&nbsp; (An abridged version appeared in <i>Proceedings of
   the Third Annual Logic In Computer Science Conference</i> (July 1988).)&nbsp;
  Also appeared as SRC Research Report&nbsp;29.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-existence.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-existence.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-existence.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1991.</font><hr>


The method of proving that one specification implements another by
using a refinement mapping was well-established by the mid-80s.&nbsp; (It
is clearly described in <a href="#what-good">[54]</a>, and it also appears in
<a href="#spec">[50]</a>.)&nbsp; It was known that constructing the refinement mapping
might require adding history variables to the implementation.&nbsp; Indeed,
Lam and Shankar essentially constructed all their refinement mappings
with history variables.&nbsp; Jim Saxe discovered a simple example showing
that history variables weren't enough.&nbsp; To handle that example, he
devised a more complicated refinement-mapping rule.&nbsp; I realized that I
could eliminate that complicated rule, and use ordinary refinement, by
introducing a new kind of dummy variable that I called a prophecy
variable.&nbsp; A prophecy variable is very much like a history variable,
except it predicts the future instead of remembering the past.&nbsp; (Nancy
Lynch later rediscovered Saxe's rule and used it to "simplify"
refinement proofs by eliminating prophecy variables.)&nbsp; I then
remembered a problematic example by Herlihy and Wing in their classic
paper <i>Linearizability: A Correctness Condition for Concurrent
Objects</i> that could be handled with prophecy variables.&nbsp;

<p> This paper was my first collaboration with Abadi.&nbsp; Here's
my recollection of how it was written.&nbsp; I had a hunch that history and
prophecy variables were all one needed.&nbsp; Abadi had recently joined
SRC, and this seemed like a fine opportunity to interest him
in the things I was working on.&nbsp; So I described my hunch to him and
suggested that he look into proving it.&nbsp; He came back in a few weeks
with the results described in the paper.&nbsp; My hunch was right, except
that there were hypotheses needed that I hadn't suspected.&nbsp; Abadi,
however, recalls my having had a clearer picture of the final theorem,
and that we worked out some of the details together when writing the
final proof.&nbsp;

</p><p> 
I had just developed the structured proof style described in
<a href="#lamport-how-to-write">[102]</a>, so I insisted that we write our proofs
in this style, which meant rewriting Abadi's original proofs.&nbsp; In the
process, we discovered a number of minor errors in the proofs, but no
errors in the results.&nbsp;

</p><p>
This paper won the LICS 1988 Test of Time Award (awarded in 2008).&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="abadi-preserving"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">保持活力：对“从方法论角度看安全性和活力”的评论</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 等人合着）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《信息处理快报》40、3</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1991 年 11 月）、141-142。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩后记</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1991 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是一篇非常短的文章——作者名单几乎占据了与正文一样多的空间。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">在IPL</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">上发表的一篇文章中</font><font style="vertical-align:inherit">，Dederichs 和 Weber 重新发现了非机器封闭规范的概念。</font><font style="vertical-align:inherit">我们在这里观察到他们对这些规范的反应很幼稚。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="abadi-preserving"><b>Preserving Liveness: Comments on `Safety and
   Liveness from a Methodological Point of
   View'</b>&nbsp; (with Martín Abadi et
   al.)<br><i>Information Processing Letters 40</i>, 3 (November 1991),
   141-142.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-preserving.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1991.</font><hr>


This is a very short article--the list of authors takes up almost as
much space as the text.&nbsp; In a note published in <i>IPL</i>,
Dederichs and Weber rediscovered the concept of non-machine-closed
specifications.&nbsp; We observed here that their reaction to those
specifications was naive.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-critique"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">对箭头湖三</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算的批评 6</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (1992), 65-71。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-critique.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-critique.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-critique.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1992 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


多年来，我一直是一个委员会的成员，该委员会计划在南加州箭头湖举办年度研讨会。</font><font style="vertical-align:inherit">我最终迫于压力自己组织了一次研讨会。</font><font style="vertical-align:inherit">我让 Brent Hailpern 担任并发系统规范和验证研讨会的主席。</font><font style="vertical-align:inherit">会议的大部分内容都致力于解决指定顺序一致性的挑战问题。</font><font style="vertical-align:inherit">这是我当时觉得很难的一个问题。</font><font style="vertical-align:inherit">（我后来学会了如何编写</font></font><a href="#ladkin-gerth"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[127]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中出现的简单、优雅的规范。）&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">在研讨会上关于挑战问题的演讲中，只有两次认真尝试解决该问题。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（作为组织者，我觉得我不应该提出自己的解决方案。）经过长时间的审查和修改，这两个和第三个随后编写的解决方案出现在《分布式计算》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的特刊中
</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这篇笔记是对我为特刊撰写的三个解决方案的批评。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-critique"><b>Critique of the Lake Arrowhead
   Three</b><br><i>Distributed Computing 6</i>, 1 (1992), 65-71.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-critique.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-critique.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-critique.pdf">PDF</a>
<br><font size="-2">Copyright 
1992 by Springer-Verlag.</font><hr>


For a number of years, I was a member of a committee that planned an
annual workshop at Lake Arrowhead, in southern California.&nbsp; I was
finally pressured into organizing a workshop myself.&nbsp; I got Brent
Hailpern to be chairman of a workshop on specification and
verification of concurrent systems.&nbsp; A large part of the conference
was devoted to a challenge problem of specifying sequential
consistency.&nbsp; This was a problem that, at the time, I found difficult.&nbsp;
(I later learned how to write the simple, elegant specification that
appears in <a href="#ladkin-gerth">[127]</a>.)&nbsp;

<p> Among the presentations at the workshop session on the
challenge problem, there were only two serious attempts at solving the
problem.&nbsp; (As an organizer, I felt that I shouldn't present my own
solution.)&nbsp; After a long period of review and revision, these two and
a third, subsequently-written solution, appeared in a special issue of
<i>Distributed Computing</i>.&nbsp; This note is a critique of the three
solutions that I wrote for the special issue.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="lamport-reduction-tlanote"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">归约定理</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表（1992 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本注释陈述并证明了 TLA 约简定理。</font></font><a href="#cohen-tlareduction"><font style="vertical-align:inherit"><font style="vertical-align:inherit">参见[124]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">此注释和所有其他 TLA 注释的文本版本可 
</font></font><a href="http://lamport.azurewebsites.net/tla/notes.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">获取。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-reduction-tlanote"><b>The Reduction 
   Theorem</b><br>Unpublished (April, 1992).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-reduction-tlanote.pdf">PDF</a><hr>


This note states and proves a TLA reduction theorem.&nbsp; See the
discussion of <a href="#cohen-tlareduction">[124]</a>.&nbsp;
Text versions of this and all other TLA notes are available 
<a href="http://lamport.azurewebsites.net/tla/notes.html">here</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="engberg-mechanical"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA 进行并行系统的机械验证</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Urban Engberg 和 Peter Grønning 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机辅助验证</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，G. v. Bochmann 和 DK Probst 编辑。</font><font style="vertical-align:inherit">（第四届国际会议记录，CAV'92。）计算机科学讲义，第 663 号，Springer-Verlag，（1992 年 6 月）44-55。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1992 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


当我开发 TLA 时，我意识到，我第一次拥有了一种真正完全正式的形式主义——如此正式以至于机械地检查 TLA 证明应该是简单的。</font><font style="vertical-align:inherit">使用 LP 定理证明器制定了一个小示例（互斥的规范和简单实现），我证实了情况确实如此。</font><font style="vertical-align:inherit">我使用 LP 主要是因为我们在 SRC 有 LP 专家，即 Jim Horning 和 Jim Saxe。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
我的小例子让我相信我们想要在 TLA 中推理，而不是在 LP 中。</font><font style="vertical-align:inherit">为此，我们需要将 TLA 证明翻译成定理证明者的语言。</font></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">用户应该以[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的分层风格编写证明</font><font style="vertical-align:inherit">，证明者应该检查每一步。</font><font style="vertical-align:inherit">这种方法的优点之一是它允许对动作推理和时间推理进行单独的翻译。</font><font style="vertical-align:inherit">这很重要，因为大约 95% 的证明由动作推理组成，并且如果使用特殊的翻译来完成，这些证明比处理时间公式的相同翻译要简单得多。</font><font style="vertical-align:inherit">（在动作推理中，
 </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ' 是两个完全独立的变量；</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ' 的处理方式与变量没有什么不同</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> .) 于是，我邀请当时在丹麦读研究生的 Urban Engberg 和 Peter Grønning 来 SRC 工作一年，设计并实现这样一个系统。</font><font style="vertical-align:inherit">本文描述了这一努力的结果。</font><font style="vertical-align:inherit">为了进行博士研究，Engberg 后来将该系统开发为他称之为 TLP 的系统。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
Georges Gonthier 在他对 Damien Doligez 开发的并发垃圾收集器的机械验证中展示了该系统的成功程度，并在他的论文中进行了手工证明。</font><font style="vertical-align:inherit">Gonthier 估计，使用 TLP 而不是直接在 LP 中工作，可以将他证明所需的时间减少大约五倍。</font><font style="vertical-align:inherit">他的证明报告如下：
</font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
 Georges Gonthier，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">验证实用并发垃圾收集器的安全性</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，载于 Rajeev Alur，Thomas A. Henzinger（编辑）：</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机辅助验证，第八届国际会议，CAV '96</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">计算机科学讲义，卷。</font><font style="vertical-align:inherit">1102，施普林格，1996，462-465。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
TLP 的输入语言本质上是 TLA+ 的一个非常有限的子集（在
</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述）——一种在实现 TLP 时不存在的语言。</font><font style="vertical-align:inherit">我将 TLP 视为概念验证，并且在它构建后我没有使用它。</font><font style="vertical-align:inherit">2006 年左右，针对真实 TLA+ 规范的定理证明器的工作开始了。</font><font style="vertical-align:inherit">它催生了
  </font></font><a href="httpss://tla.msr-inria.inria.fr/tlaps/content/Home.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">
TLAPS，即 TLA+ 证明系统</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">TLAPS 使用多个后端定理证明器，包括 Isabelle、Zenon 和 SMT 求解器。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="engberg-mechanical"><b>Mechanical Verification of Concurrent Systems
   with TLA</b>&nbsp; (with Urban Engberg and Peter
   Grønning)<br><i>Computer-Aided Verification</i>,
   G.&nbsp;v.&nbsp;Bochmann and D. K. Probst editors.&nbsp; (Proceedings of the Fourth
   International Conference, CAV'92.)&nbsp; Lecture Notes in Computer Science,
   number 663, Springer-Verlag, (June, 1992) 44-55.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/engberg-mechanical.pdf">PDF</a>
<br><font size="-2">Copyright 
1992 by Springer-Verlag.</font><hr>


When I developed TLA, I realized that, for the first time, I had a
formalism that really was completely formal--so formal that
mechanically checking TLA proofs should be straightforward.&nbsp; Working
out a tiny example (the specification and trivial implementation of
mutual exclusion) using the LP theorem prover, I confirmed that this
was the case.&nbsp; I used LP mainly because we had LP experts at
SRC--namely, Jim Horning and Jim Saxe.&nbsp;

<p> 
My tiny example convinced me that we want to reason in
TLA, not in LP.&nbsp; To do this, we need to translate a TLA
proof into the language of the theorem prover.&nbsp; The user should write
the proof in the hierarchical style of <a href="#lamport-how-to-write">[102]</a>,
and the prover should check each step.&nbsp; One of the advantages of this
approach turned out to be that it allows separate translations for the
action reasoning and temporal reasoning.&nbsp; This is important because
 about 95%
 of a proof consists of action reasoning, and these proofs are much
simpler if done with a special translation than in the same
translation that handles temporal formulas.&nbsp; (In action reasoning,
<i>x</i> and <i>x</i>' are two completely separate
variables; <i>x</i>' is handled no differently than the
variable <i>y</i>.)&nbsp; So, I invited Urban Engberg and Peter
Grønning, who were then graduate students in
Denmark, to SRC for a year to design and implement such a system.&nbsp; The
result of that effort is described in this paper.&nbsp; For his doctoral
research, Engberg later developed the system into one he called TLP.&nbsp;

</p><p>
Georges Gonthier demonstrated how successful this system was in his
mechanical verification of the concurrent garbage collector developed
by Damien Doligez and hand-proved in his thesis.&nbsp; Gonthier estimated
that using TLP instead of working directly in LP reduced the amount of
time it took him to do the proof by about a factor of five.&nbsp;
His proof is reported in:
</p><blockquote><p>
 Georges Gonthier, <i>Verifying the Safety of a
Practical Concurrent Garbage Collector</i>, in Rajeev Alur, Thomas A.&nbsp;
Henzinger (Ed.): <i>Computer Aided Verification, 8th International
Conference, CAV '96</i>.&nbsp; Lecture Notes in Computer Science, 
 Vol. 1102, Springer, 1996, 462-465.&nbsp;
 </p></blockquote> 
TLP's input language was essentially a very restricted subset of
TLA+ (described in
<a href="#lamport-spec-tla-plus">[128]</a>)--a language that did not
exist when TLP was implemented.&nbsp; 
I regarded TLP as a proof of
concept and I did not use it after it was built.&nbsp;
Around 2006, 
work began on a theorem prover for real TLA+
specifications.&nbsp; It led to
  <a href="httpss://tla.msr-inria.inria.fr/tlaps/content/Home.html">
TLAPS, the TLA+ proof system</a>.&nbsp; TLAPS uses
several back-end theorem provers, including Isabelle, Zenon, and SMT
solvers.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="reconfiguration-patent"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">用于高速网状连接局域网的重新配置系统和方法</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">美国专利号5,138,615（1992年8月11日）。</font></font><br></a><a href="https://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=5,138,615.PN.&amp;OS=PN/5,138,615&amp;RS=PN/5,138,615"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是我发明的 19 项专利之一。</font><font style="vertical-align:inherit">我将其放在这里是因为它包含一个我从未发布过的有趣算法。</font><font style="vertical-align:inherit">它是对算法核心算法的增强，该算法在</font></font><a href="#dist"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[48]中被证明是正确的</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">用于维护分布式消息传递系统中的路由表。</font><font style="vertical-align:inherit">该算法最终收敛到正确的路由表。</font><font style="vertical-align:inherit">但是，它不会在收敛时通知进程。</font><font style="vertical-align:inherit">表中表示如何将消息发送到一个特定节点的部分的计算是计算最小深度生成树的经典算法的分布式版本。</font><font style="vertical-align:inherit">该专利涵盖了生成树算法的增强，该算法可以在计算终止时通知进程。</font><font style="vertical-align:inherit">我不知道此后是否还有其他人发现并发布了该算法。</font><font style="vertical-align:inherit">专利上列出的发明人是 Tom Rodeheffer、Mani Chandy 和我。</font><font style="vertical-align:inherit">不过，我相信 Mani 和我是这个算法的发明者。</font><font style="vertical-align:inherit">汤姆可能是该专利中包含的其他想法的唯一发明者。&nbsp;



</font></font><br>&nbsp;<p></p></li><li> <a name="reconfiguration-patent"><b>Reconfiguration system and method for high-speed mesh
connected local area network</b><br>United State Patent number 5,138,615
(August 11, 1992).<br></a><a href="https://patft.uspto.gov/netacgi/nph-Parser?Sect1=PTO1&amp;Sect2=HITOFF&amp;d=PALL&amp;p=1&amp;u=%2Fnetahtml%2FPTO%2Fsrchnum.htm&amp;r=1&amp;f=G&amp;l=50&amp;s1=5,138,615.PN.&amp;OS=PN/5,138,615&amp;RS=PN/5,138,615">Available 
On-Line</a><hr>


This is one of 19 patents for which I was an inventor.&nbsp; I am including
it here because it contains an interesting algorithm that I never
published.&nbsp; It's an enhancement of an algorithm at the heart of the
algorithm proved correct in <a href="#dist">[48]</a> for maintaining routing
tables in a distributed message-passing system.&nbsp; That algorithm
eventually converges to correct routing tables.&nbsp; However, it does not
inform processes when it has converged.&nbsp; The computation of the parts
of the tables that say how to send messages to one particular node is
a distributed version of a classic algorithm for computing a
minimal-depth spanning tree.&nbsp; The patent covers an enhancement of that
spanning tree algorithm that informs processes when the computation
has terminated.&nbsp; I don't know if anyone else has since discovered and
published that algorithm.&nbsp; The inventors listed on the patent are Tom
Rodeheffer, Mani Chandy, and me.&nbsp; However, I believe that Mani and I
were the ones who invented the algorithm.&nbsp; Tom was probably the sole
inventor of the other ideas contained in the patent.&nbsp;



<br>&nbsp;<p></p></li><li> <a name="abadi-composing"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">撰写规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 15</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1（1993 年 1 月），73-132。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 66 出现。初步版本出现在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Stepwise Refinement of Distributed Systems</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，JW de Bakker, W.-P。</font><font style="vertical-align:inherit">de Roever 和 G. Rozenberg 编辑，Springer-Verlag 计算机科学讲义第 430 卷 (1989)，1-41.. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-composing.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-composing.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-composing.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1993 Association for Computer Machinery, Inc。允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


自 80 年代末以来，我对将系统规范与环境需求分开抱有模糊的担忧。</font><font style="vertical-align:inherit">将规范编写为数学公式的能力（首先使用时序逻辑，然后使用 TLA，对于实际规范）提供了答案。</font><font style="vertical-align:inherit">该规范只是</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">暗示
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，其中</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定我们对环境的假设，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定系统保证的内容。</font><font style="vertical-align:inherit">该规范允许系统违反其保证并且环境随后违反其假设的行为——没有正确的实现可能允许的行为。</font><font style="vertical-align:inherit">因此，我们定义了规范的可实现部分的概念，并将规范的可实现部分作为系统规范</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">意味着
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我们后来认为引入显式
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可实现部分运算</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">符是一个错误，最好用使</font><font style="vertical-align:inherit">规范可实现的临时</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">while运算符替换蕴涵。</font></font></i><font style="vertical-align:inherit"></font><a href="#abadi-conjoining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这就是我们在[113]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中采用的方法
</font><font style="vertical-align:inherit">，它取代了本文。&nbsp;


</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这是我们使用结构化证明的第二篇论文，第一篇是</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">在这种情况下，结构化证明对于获得正确的结果至关重要。</font><font style="vertical-align:inherit">我们发现关于可实现性的推理非常棘手，并且有几次我们说服自己得到了错误的结果，只有通过尝试编写结构化证明才能发现错误。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="abadi-composing"><b>Composing
   Specifications</b>&nbsp; (with Martín
   Abadi)<br><i>ACM Transactions on Programming Languages and Systems 15</i>, 1 (January 1993), 73-132.&nbsp; Also appeared
  as SRC Research Report&nbsp;66.&nbsp; A preliminary version 
  appeared in <i>Stepwise Refinement of Distributed Systems</i>,
 J. W. de Bakker, W.-P. de Roever, and G. Rozenberg editors,
  Springer-Verlag Lecture Notes in Computer Science 
   Volume 430 (1989), 1-41..<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-composing.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-composing.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-composing.pdf">PDF</a>
<br><font size="-2">Copyright © 1993 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


Since the late 80s, I had vague concerns about separating the
specification of a system from requirements on the environment.&nbsp; The
ability to write specifications as mathematical formulas (first with
temporal logic and then, for practical specifications, with TLA)
provides an answer.&nbsp; The specification is simply <i>E</i> implies
<i>M</i>, where <i>E</i> specifies what we assume of the environment
and <i>M</i> specifies what the system guarantees.&nbsp; This specification
allows behaviors in which the system violates its guarantee and the
environment later violates its assumption--behaviors that no correct
implementation could allow.&nbsp; So, we defined the notion of the
realizable part of a specification and took as the system
specification the realizable part of <i>E</i> implies
<i>M</i>.&nbsp; We later decided that introducing an explicit
<i>realizable-part</i> operator was a mistake, and that it was better
to replace implication with a temporal <i>while</i> operator that made
the specifications realizable.&nbsp; That's the approach we took in
<a href="#abadi-conjoining">[113]</a>, which supersedes this paper.&nbsp;


<p>
This is the second paper in which we used structured proofs, the first
being <a href="#abadi-existence">[92]</a>.&nbsp; In this case, structured proofs were
essential to getting the results right.&nbsp; We found reasoning about
realizability to be quite tricky, and on several occasions we
convinced ourselves of incorrect results, finding the errors only by
trying to write structured proofs.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="kurshan-multiplier"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">乘法器的验证：64 位及以上</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （使用 RP Kurshan）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机辅助验证</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Costas Courcoubetis，编辑。</font><font style="vertical-align:inherit">（第五届国际会议记录，CAV'93。）计算机科学讲义，第 697 号，Springer-Verlag（1993 年 6 月），166-179。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1993 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


正如我在</font></font><a href="#lamport-composition"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[125]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中观察到的，通过首先将系统分解为单独的子系统来验证系统并不能减少证明的大小，而且通常会增加它。</font><font style="vertical-align:inherit">然而，如果这种分解允许模型检查器自动完成大部分结果证明，则可以减少工作量。</font><font style="vertical-align:inherit">本文展示了如何</font><font style="vertical-align:inherit">使用</font></font><a href="#abadi-conjoining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[113]的分解定理来分解太大而无法仅通过模型检查来验证的硬件组件（在本例中为乘法器）。</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">以下是库尔尚对这篇论文的诞生的回忆。</font><font style="vertical-align:inherit">我的 CAV'92 演讲主要是关于</font></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，“Larch 支持”指的是</font></font><a href="#engberg-mechanical"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[96]</font></font></a>

<p></p><blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">

在您受邀在 CAV92 发表演讲后，我把您逼入绝境。</font><font style="vertical-align:inherit">在 CAV，您谈到了缩进（以及 TLA 及其 Larch 支持）。</font><font style="vertical-align:inherit">我向你提出了一个问题，这个问题是我至少从 1990 年（第一个 CAV 诞生的那一年）起就一直在思考的。</font><font style="vertical-align:inherit">在 CAV90 会议的序言中，我指出 CAV 社区面临的首要挑战是在自动定理证明和模型检查之间创建一个有益的接口。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我问您是否认为将 TLA/Larch 与 S/R 联系起来（由于它们对于有限状态模型的语法和语义非常接近，这应该很简单）可能有用。</font><font style="vertical-align:inherit">我提出了验证由非常复杂的 8x8 乘法器的迭代阶段构建的乘法器的（人为）问题。</font><font style="vertical-align:inherit">8x8 乘法器太复杂，无法使用定理证明器轻松验证。</font><font style="vertical-align:inherit">一个（比如说）64x64 乘法器可以由 8x8 乘法器构建。</font><font style="vertical-align:inherit">我们将使用模型检查器 (cospan) 来验证 8x8，并使用 Larch/TLA 来验证归纳步骤。</font><font style="vertical-align:inherit">你喜欢这个想法，我们就这么做了，你和 Urban 一起工作，我和 Mark [Foissoitte] 一起工作。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
遗憾的是，随着界面的到位，我无法想出一个非人工的可行的应用程序。</font><font style="vertical-align:inherit">迄今为止，尽管已经构建了一系列此类接口（我相信我们的接口是第一个），但没有一个真正在实际应用程序中展示出好处。</font><font style="vertical-align:inherit">（修订后的）挑战是找到一个应用程序，在该应用程序中，该组合比任何一个单独的应用程序都能更快地发现错误。&nbsp;
</font></font></p></blockquote>


<br>&nbsp;<p></p></li><li> <a name="kurshan-multiplier"><b>Verification of a Multiplier: 64 Bits and
   Beyond</b>&nbsp; (with R. P. Kurshan)<br><i>Computer-Aided Verification</i>, Costas
   Courcoubetis, editor.&nbsp; (Proceedings of the Fifth International
   Conference, CAV'93.)&nbsp; Lecture Notes in Computer Science, number 697,
   Springer-Verlag (June, 1993), 166-179.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/kurshan-multiplier.pdf">PDF</a>
<br><font size="-2">Copyright 
1993 by Springer-Verlag.</font><hr>


As I observed in <a href="#lamport-composition">[125]</a>, verifying a system by
first decomposing it into separate subsystems can't reduce the size of
a proof and usually increases it.&nbsp; However, such a decomposition can
reduce the amount of effort if it allows much of the resulting proof
to be done automatically by a model checker.&nbsp; This paper shows how the
decomposition theorem of <a href="#abadi-conjoining">[113]</a> can be used to
decompose a hardware component (in this case, a multiplier) that is
too large to be verified by model checking alone.&nbsp; Here is Kurshan's
recollection of how this paper came to be.&nbsp; My CAV'92 talk was mostly
about <a href="#lamport-how-to-write">[102]</a>, and the "Larch support"
refers to <a href="#engberg-mechanical">[96]</a>

<p></p><blockquote>

I cornered you after your invited address at CAV92.&nbsp; At CAV, you
talked about indenting (and TLA, and its Larch support).&nbsp; I challenged
you with a matter I had been thinking about since at least 1990, the
year of the first CAV.&nbsp; In the preface to the CAV90
proceedings, I stated as a paramount challenge to the CAV community,
to create a beneficial interface between automated theorem proving,
and model checking.&nbsp;

<p>

I asked you if you thought that linking TLA/Larch with S/R (which
should be simple to do on account of their very close syntax and
semantics for finite-state models), could be useful.&nbsp; I suggested the
(artificial) problem of verifying a multiplier constructed from
iterated stages of a very complex 8x8 multiplier.&nbsp;
The 8x8 multiplier would be too complex to verify
handily with a theorem prover.&nbsp; A (say) 64x64
multiplier could be built from the 8x8 one.&nbsp; We'd
use the model checker (cospan) to verify the 8x8,
and Larch/TLA to verify the induction step.&nbsp; You liked the idea, and
we did it, you working with Urban and I working with Mark
[Foissoitte].&nbsp;

</p><p>
Sadly, with the interface in place, I was unable to come up with a
non-artificial feasible application.&nbsp; To this day, although there have
been a succession of such interfaces built (I believe ours was the
first), none has really demonstrated a benefit on a real application.&nbsp;
The (revised) challenge is to find an application in which the
combination finds a bug faster than either one could by itself.&nbsp;
</p></blockquote>


<br>&nbsp;<p></p></li><li> <a name="lamport-verification"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发程序的验证和规范《</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发的十年：反思与展望》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，JW de Bakker，W.-P。</font><font style="vertical-align:inherit">de Roever 和 G. Rozenberg 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 803 期，Springer-Verlag，（1993 年 6 月）347-374。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-verification.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-verification.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-verification.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1993 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


为了与研讨会的主题保持一致，本文对 18 年来验证和指定并发系统的情况进行了简短而有偏见的概述，并介绍了 TLA。</font><font style="vertical-align:inherit">差不多10年后再看这本书，我觉得还是不错的。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-verification"><b>Verification and Specification of
   Concurrent Programs</b><br><i>A Decade of Concurrency: Reflections and
   Perspectives</i>, J. W. de Bakker, W.-P. de Roever, and G. Rozenberg
   editors.&nbsp; Lecture Notes in Computer Science, number 803,
   Springer-Verlag, (June, 1993) 347-374.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-verification.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-verification.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-verification.pdf">PDF</a>
<br><font size="-2">Copyright 
1993 by Springer-Verlag.</font><hr>


In keeping with the theme of the workshop, this paper provides a
brief, biased overview of 18 years of verifying and specifying
concurrent systems, along with an introduction to TLA.&nbsp;
Looking at it almost 10 years later, I find it a rather nice read.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-hybrid"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">混合系统</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的混合系统，Robert L. Grossman、Anil Nerode、Hans Rischel 和 Anders P. Ravn，编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 736 期，Springer-Verlag (1993)，77-102。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1993 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


90年代初，混合系统成为形式化方法中的一个时髦话题。</font><font style="vertical-align:inherit">理论家通常通过发明新的形式主义来应对新的问题领域。</font><font style="vertical-align:inherit">物理学家不必每次研究一种新的系统时都修改微分方程理论，计算机科学家也不应该在遇到一种新的系统时改变他们的形式主义。</font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit">阿巴迪和我在[107]</font></a><font style="vertical-align:inherit">中展示
</font></font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 可以通过简单地引入一个变量来表示当前时间来处理实时规范。</font><font style="vertical-align:inherit">同样明显的是，它可以通过引入变量来表示其他物理量来处理混合系统。</font><font style="vertical-align:inherit">通常有必要向人们展示显而易见的事情，当丹麦有一个专门讨论指定简单燃气燃烧器并证明简单实施的正确性的玩具问题的研讨会时，出现了这样做的机会。</font><font style="vertical-align:inherit">我无法参加研讨会，但我确实编写了这个 TLA+ 解决方案。</font><font style="vertical-align:inherit">（此处使用的 TLA+ 版本与
</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的最新版本略有不同。）&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

问题陈述中给出的正确性条件包括一个
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">临时的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于如果火焰熄灭，煤气可以打开多长时间的一组规则。</font><font style="vertical-align:inherit">这些条件的目的显然是为了防止未燃烧气体的危险积聚。</font><font style="vertical-align:inherit">为了展示 TLA+ 的强大功能，并且因为它使问题变得更有趣，我写了一个更高级别的要求，指出气体浓度应小于某个值。</font><font style="vertical-align:inherit">假设未燃烧气体的耗散满足一个简单的微分方程，我证明了它们的条件暗示了我的更高层次的规范——在对气体扩散速率的适当假设下。</font><font style="vertical-align:inherit">除其他事项外，这还需要正式指定黎曼积分，这需要大约 15 行代码。</font><font style="vertical-align:inherit">我还草拟了下一个实现级别的正确性证明。</font><font style="vertical-align:inherit">所有这一切都完全在 TLA+ 中完成。</font><font style="vertical-align:inherit">该卷的简介说我“使用表示连续状态和时钟的显式变量扩展[ed] ... TLA+”。</font><font style="vertical-align:inherit">这当然是无稽之谈。</font><font style="vertical-align:inherit">显然，按照他们的逻辑，如果你编写一个带有名为的变量的 C 程序，你就扩展了 C</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">时间</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">
和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">火焰</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">而不是</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">t</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-hybrid"><b>Hybrid Systems in
   TLA+</b><br><i>Hybrid Systems</i>, Robert L. Grossman, Anil
   Nerode, Hans Rischel, and Anders P. Ravn, editors.&nbsp; Lecture Notes in
   Computer Science, number 736, Springer-Verlag (1993), 77-102.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-hybrid.pdf">PDF</a>
<br><font size="-2">Copyright 
1993 by Springer-Verlag.</font><hr>


In the early 90s, hybrid systems became a fashionable topic in formal
methods.&nbsp; Theoreticians typically respond to a new problem domain by
inventing new formalisms.&nbsp; Physicists don't have to revise the theory
of differential equations every time they study a new kind of system,
and computer scientists shouldn't have to change their formalisms when
they encounter a new kind of system.&nbsp; Abadi and I showed in
<a href="#lamport-old-fashioned">[107]</a> that TLA can handle real-time
specifications by simply introducing a variable to represent the
current time.&nbsp; It's just as obvious that it can handle hybrid systems
by introducing variables to represent other physical quantities.&nbsp; It
is often necessary to demonstrate the obvious to people, and the
opportunity to do this arose when there was a workshop in Denmark
devoted to a toy problem of specifying a simple gas burner and proving
the correctness of a simple implementation.&nbsp; I was unable to attend
the workshop, but I did write this TLA+ solution.&nbsp; (The
version of TLA+ used here is slightly different from the
more current version that is described in
<a href="#lamport-spec-tla-plus">[128]</a>.)&nbsp;

<p>

The correctness conditions given in the problem statement included an
<i>ad hoc</i> set of rules about how long the gas could be on if the
flame was off.&nbsp; The purpose of those conditions was obviously to
prevent a dangerous build-up of unburned gas.&nbsp; To demonstrate the
power of TLA+, and because it made the problem more fun,
I wrote a higher-level requirement stating that the concentration of
gas should be less than a certain value.&nbsp; Assuming that the
dissipation of unburned gas satisfied a simple differential equation,
I proved that their conditions implied my higher-level
specification--under suitable assumptions about the rate of diffusion
of the gas.&nbsp; This required, among other things, formally specifying
the Riemann integral, which took about 15 lines.&nbsp; I also sketched a
proof of the correctness of the next implementation level.&nbsp; All of
this was done completely in TLA+.&nbsp; The introduction to the
volume says that I
  "extend[ed] ... TLA+ with explicit variables
  that denote continuous states and clocks."
That, of course, is nonsense.&nbsp; Apparently, by their logic, you have
extended C if you write a C program with variables named <i>time</i>
and <i>flame</i> instead of <i>t</i> and <i>f</i>.&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="lamport-how-to-write"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何写证明</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《美国数学月刊》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 102, 7（1995 年 8 月至 9 月）600-608。</font><font style="vertical-align:inherit">还出现在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《现代数学的全局分析》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，Karen Uhlenbeck，编辑。</font><font style="vertical-align:inherit">出版或灭亡出版社，休斯顿。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 94 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


TLA 第一次给了我一种形式主义，让我可以编写完全形式​​化的证明，而无需首先添加额外的形式语义层。</font><font style="vertical-align:inherit">我开始以我以及所有数学家和计算机科学家学会的方式编写证明，使用一系列引理，其证明是散文和公式的混合体。</font><font style="vertical-align:inherit">我很快发现这种方法在任何非平凡证明的复杂性的重压下崩溃了。</font><font style="vertical-align:inherit">我迷失在细节的迷宫中，无法跟踪任何时候已经证明和尚未证明的内容。</font><font style="vertical-align:inherit">程序员很久以前就知道处理复杂性的方法是使用层次结构。</font><font style="vertical-align:inherit">因此，开始分层构造证明是很自然的，我很快就开发了一种简单的分层证明样式。</font><font style="vertical-align:inherit">然后我想到，这种结构化证明风格应该适用于普通的数学证明，而不仅仅是系统的形式验证。</font><font style="vertical-align:inherit">尝试了一下，我发现它很棒。</font><font style="vertical-align:inherit">我现在从不为自己写老式的非结构化证明，只在一些论文中使用它们来制作并不严谨的简短证明草图。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我在理查德·帕莱 (Richard Palais) 60 岁生日的庆祝活动中首次提出了这些想法，他是我的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">法律</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">论文导师、合作者和朋友。</font><font style="vertical-align:inherit">我和 Palais 的所有前博士生一起被邀请，而且我是唯一一位发表演讲的非数学家。</font><font style="vertical-align:inherit">（我相信那天提出的所有其他演讲都出现在乌伦贝克编辑的卷中的文章中。）很多人因为我试图剥夺数学的乐趣而对我大加指责。</font><font style="vertical-align:inherit">他们的强烈反应表明我触动了我的神经。</font><font style="vertical-align:inherit">也许他们确实认为，如果他们想知道已发表论文中的定理是否真正正确，并且必须努力找出为什么证明中的特定步骤应该成立，那么必须自己重新创建证明是很有趣的。</font><font style="vertical-align:inherit">我将这篇论文重新发表在
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">AMM 月刊，</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">这样它就能吸引更多的数学家读者。</font><font style="vertical-align:inherit">也许我应该为计算机科学家重新发布它。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-how-to-write"><b>How to Write a Proof</b><br><i>American
   Mathematical Monthly</i> 102, 7 (August-September 1995) 600-608.&nbsp; Also
   appeared in <i>Global Analysis in Modern Mathematics</i>, Karen
   Uhlenbeck, editor.&nbsp; Publish or Perish Press, Houston.&nbsp; Also appeared
   as SRC Research Report&nbsp;94.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-write.pdf">PDF</a><hr>


TLA gave me, for the first time, a formalism in which it was 
possible to write completely formal proofs without first having to add
an additional layer of formal semantics.&nbsp; I began writing proofs the
way I and all mathematicians and computer scientists had learned to
write them, using a sequence of lemmas whose proofs were a mixture of
prose and formulas.&nbsp; I quickly discovered that this approach collapsed
under the weight of the complexity of any nontrivial proof.&nbsp; I became
lost in a maze of details, and couldn't keep track of what had and had
not been proved at any point.&nbsp; Programmers learned long ago that the
way to handle complexity is with hierarchical structuring.&nbsp; So, it was
quite natural to start structuring the proofs hierarchically, and I
soon developed a simple hierarchical proof style.&nbsp; It then occurred to
me that this structured proof style should be good for ordinary
mathematical proofs, not just for formal verification of systems.&nbsp;
Trying it out, I found that it was great.&nbsp; I now never write
old-fashioned unstructured proofs for myself, and use them only in
some papers for short proof sketches that are not meant to be
rigorous.&nbsp;

<p> 

I first presented these ideas in a talk at a celebration of the 60th
birthday of Richard Palais, my <i>de jure</i> thesis advisor,
collaborator, and friend.&nbsp; I was invited along with all of Palais'
former doctoral students, and I was the only non-mathematician who
gave a talk.&nbsp; (I believe all the other talks presented that day appear
among the articles in the volume edited by Uhlenbeck.)&nbsp; Lots of people
jumped on me for trying to take the fun out of mathematics.&nbsp; The
strength of their reaction indicates that I hit a nerve.&nbsp; Perhaps they
really do think it's fun having to recreate the proofs themselves if
they want to know whether a theorem in a published paper is actually
correct, and to have to struggle to figure out why a particular step
in the proof is supposed to hold.&nbsp; I republished the paper in the
<i>AMM Monthly</i> so it would reach a larger audience of
mathematicians.&nbsp; Maybe I should republish it again for computer
scientists.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="lamport-actions"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">动作的时间逻辑</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on 编程语言和系统 16</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1994 年 5 月）, 872-923。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 79 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-actions.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-actions.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-actions.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1994 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文介绍了 TLA，我现在认为它是描述和推理并发系统的最佳通用形式。</font><font style="vertical-align:inherit">TLA 的新想法是，人们可以在时间公式中使用</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">动作</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（带有启动和未启动变量的公式）。</font><font style="vertical-align:inherit">动作描述了状态转换关系。</font><font style="vertical-align:inherit">例如，操作
</font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">x'=x+1与编程语言语句</font></font></tt><font style="vertical-align:inherit"></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">x := x+1</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">的含义大致相同</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，该操作要简单得多，因为它只讨论
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">x</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">而没有提及另一个变量</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，而赋值语句可能（或可能不）断言</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">y</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">不会改变。</font><font style="vertical-align:inherit">TLA 允许您以基本上与 中提倡的方式相同的方式编写规范</font></font><a href="#simple-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[82]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，该规范变成了一个单一的数学公式。</font><font style="vertical-align:inherit">这开辟了一个全新的可能性领域。</font><font style="vertical-align:inherit">除此之外，它提供了一种优雅的方式来形式化和系统化并发系统验证中使用的所有推理。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
TLA 的寓意是：如果您不编写程序，就不要使用编程语言。</font><font style="vertical-align:inherit">编程语言很复杂，并且具有许多丑陋的特性，因为程序被输入到编译器，编译器必须生成相当有效的代码。</font><font style="vertical-align:inherit">如果您正在描述一个算法，而不是编写一个实际的程序，那么您不应该因为这些复杂性和丑陋的属性而给自己带来负担。</font><font style="vertical-align:inherit">计算机科学家传统上用来描述算法的玩具并发编程语言并不像真正的编程语言那么糟糕，但它们仍然比实际需要的更丑陋和更复杂。</font><font style="vertical-align:inherit">这样的玩具程序与真正的 C 或 Java 程序并不比 TLA 公式更接近。</font><font style="vertical-align:inherit">TLA 公式比玩具程序更容易进行数学处理。

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

Misra 和 Chandy 的 Unity 是超越传统编程语言来描述并发算法的第一个重要步骤。</font><font style="vertical-align:inherit">Unity 只是简单地消除了控制状态，因此您只有一个全局状态，您可以用一个不变量来推理它。</font><font style="vertical-align:inherit">您可以按照您想要的任何方式构造不变量；</font><font style="vertical-align:inherit">您不受描述算法的特定编程结构的限制。</font><font style="vertical-align:inherit">下一步是 TLA，它消除了编程语言并允许您直接用数学编写算法。</font><font style="vertical-align:inherit">这提供了一种更强大、更灵活的方式来描述下一状态关系。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

本文的一个有趣的脚注是，在阅读了早期的草稿后，Simon Lam 声称他将动作描述为具有启动和未启动变量的公式的想法值得赞扬。</font><font style="vertical-align:inherit">编写后置条件的类似表示法可以追溯到 70 年代，但这与实际以这种方式指定操作不同。</font><font style="vertical-align:inherit">我曾引用过 Rick Hehner 1984 年</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CACM</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">文章，但我认为可能有更早的例子。</font><font style="vertical-align:inherit">经过适量的调查后，我发现了一个早期发布的用途——在</font></font><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[50]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。&nbsp;



</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-actions"><b>The Temporal Logic of Actions</b><br><i>ACM Transactions on Programming Languages and Systems 16</i>, 3
   (May 1994), 872-923. Also appeared
   as SRC Research Report&nbsp;79.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-actions.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-actions.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-actions.pdf">PDF</a>
<br><font size="-2">Copyright © 1994 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


This paper introduces TLA, which I now believe is the best general
formalism for describing and reasoning about concurrent systems.&nbsp; The
new idea in TLA is that one can use <i>actions</i>--formulas with
primed and unprimed variables--in temporal formulas.&nbsp; An action
describes a state-transition relation.&nbsp; For example, the action
<tt>x'=x+1</tt> means approximately the same thing as
the programming-language statement <tt>x := x+1</tt>.&nbsp;
However, the action is much simpler because it talks only about
<i>x</i> and says nothing about another variable <i>y</i>, while the
assignment statement may (or may not) assert that <i>y</i> doesn't
change.&nbsp; TLA allows you to write specifications essentially the same
way advocated in <a href="#simple-approach">[82]</a>.&nbsp; However, the specification
becomes a single mathematical formula.&nbsp; This opens up a whole new
realm of possibilities.&nbsp; Among other things, it provides an elegant
way to formalize and systematize all the reasoning used in concurrent
system verification.&nbsp;

<p>
The moral of TLA is: if you're not writing a program, don't use a
programming language.&nbsp; Programming languages are complicated and have
many ugly properties because a program is input to a compiler that
must generate reasonably efficient code.&nbsp; If you're describing an
algorithm, not writing an actual program, you shouldn't burden
yourselves with those complications and ugly properties.&nbsp; The toy
concurrent programming languages with which computer scientists have
traditionally described algorithms are not as bad as real programming
languages, but they are still uglier and more complicated than they
need to be.&nbsp; Such a toy program is no closer to a real C or Java
program than is a TLA formula.&nbsp; And the TLA formula is a lot easier to
deal with mathematically than is a toy program.&nbsp; (Everything I say
about programming languages applies just as well to hardware
description languages.&nbsp; However, hardware designers are generally more
sensible than to try to use low-level hardware languages for
higher-level system descriptions.)&nbsp; Had I only realized this 20 years
ago!

</p><p> 

The first major step in getting beyond traditional programming
languages to describe concurrent algorithms was Misra and Chandy's
Unity.&nbsp; Unity simply eliminated the control state, so you just had a
single global state that you reasoned about with a single invariant.&nbsp;
You can structure the invariant any way you want; you're not
restricted by the particular programming constructs with which the
algorithm is described.&nbsp; The next step was TLA, which eliminated the
programming language and allowed you to write your algorithm directly
in mathematics.&nbsp; This provides a much more powerful and flexible way
of describing the next-state relation.&nbsp;

</p><p> 

An amusing footnote to this paper is that, after reading an earlier
draft, Simon Lam claimed that he deserved credit for the idea of
describing actions as formulas with primed and unprimed variables.&nbsp; A
similar notation for writing postconditions dates from the 70s, but
that's not the same as actually specifying the action in this way.&nbsp; I
had credited Rick Hehner's 1984 <i>CACM</i> article, but I figured
there were probably earlier instances.&nbsp; After a modest amount of
investigation, I found one earlier published use--in <a href="#spec">[50]</a>.&nbsp;



<br>&nbsp;</p><p></p></li><li> <a name="abadi-decomposing"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">并行系统的分解规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《编程概念、方法和演算》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Ernst-Rüdiger Olderog 编辑。</font><font style="vertical-align:inherit">（IFIP TC2/WG2.1/WG2.2/WG2.3 工作会议记录，Procomet '94，圣米尼亚托，意大利。）北荷兰，(1994) 327-340。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩后记</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1994 保留。</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#abadi-conjoining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">参见[113]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的讨论</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="abadi-decomposing"><b>Decomposing Specifications of Concurrent
   Systems</b>&nbsp; (with Martín
   Abadi)<br><i>Programming Concepts, Methods and Calculi</i>,
   Ernst-Rüdiger Olderog editor.&nbsp; (Proceedings of the
   IFIP TC2/WG2.1/WG2.2/WG2.3 Working Conference, Procomet&nbsp;'94, 
   San Miniato, Italy.)&nbsp; North-Holland, (1994) 327-340.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-decomposing.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1994.</font><hr>


See the discussion of <a href="#abadi-conjoining">[113]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="abadi-open"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 中的开放系统</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第十三届 ACM 分布式计算原理年度研讨会论文集，</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1994 年 8 月）81-90。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-open.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-open.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-open.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1994 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#abadi-conjoining"><font style="vertical-align:inherit"><font style="vertical-align:inherit">参见[113]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的讨论</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="abadi-open"><b>Open Systems in
   TLA</b>&nbsp; (with Martín
   Abadi)<br><i>Proceedings of the Thirteenth Annual ACM Symposium on
   Principles of Distributed Computing,</i> (August 1994) 81-90.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-open.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-open.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-open.pdf">PDF</a>
<br><font size="-2">Copyright © 1994 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


See the discussion of <a href="#abadi-conjoining">[113]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="tlz"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLZ（摘要）</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Z 用户研讨会，剑桥 1994 年</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">JP Bowen 和 JA Hall（编）267-268。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/tlz.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/tlz.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/tlz.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1994 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Z 是一种形式化规范语言，它通过编写动作来描述系统——本质上与 TLA 规范中出现的动作类型相同。</font><font style="vertical-align:inherit">它是由 Mike Spivey 和牛津大学的其他人开发的，用于指定顺序程序。</font><font style="vertical-align:inherit">当有人开发一种用于顺序程序的方法时，他们通常认为它也可以处理并发程序——也许通过添加一两个额外的功能。</font><font style="vertical-align:inherit">我听说 Z 开发人员的情况并非如此，而且他们足够聪明，意识到 Z 不处理并发。</font><font style="vertical-align:inherit">此外，Z 基于数学而不是编程语言，因此它是一种相当不错的语言。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
TLA 假定了编写操作的底层逻辑。</font><font style="vertical-align:inherit">下一步很明显：设计一种语言来指定并发系统，用 TLA 运算符扩展 Z。</font><font style="vertical-align:inherit">同样明显的是这种语言的名称：TLZ。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
1991 年春天，我访问了牛津，并就 TLA 做了一次演讲，指出它可以如何自然地与 Z 结合。这个想法在 Yeshiva 大学就像培根和鸡蛋一样受欢迎。</font><font style="vertical-align:inherit">Tony Hoare 在牛津，牛津的并发意味着 CSP。</font><font style="vertical-align:inherit">Z 社区只对 Z 与 CSP 的结合感兴趣——这就像将谓词逻辑与 C++ 结合一样自然。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
几年后，我受邀在 Z 用户会议上发表演讲。</font><font style="vertical-align:inherit">我重新整理了 TLZ 的想法，并在会议上提出了它。</font><font style="vertical-align:inherit">我再次遇到了严重缺乏兴趣的情况。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
如果 TLA 被 Z 社区采用，它可能会变得更受欢迎。</font><font style="vertical-align:inherit">另一方面，不依附于 Z 意味着我不必忍受 Z 的缺点，并且可以自由地设计一种更优雅的语言来指定操作。</font><font style="vertical-align:inherit">结果是 TLA+，如</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中所述。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="tlz"><b>TLZ (Abstract)</b><br><i>Z User's Workshop, Cambridge 1994</i>.&nbsp;
   J.P. Bowen and J.A. Hall (Eds.) 267-268.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/tlz.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/tlz.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/tlz.pdf">PDF</a>
<br><font size="-2">Copyright 
1994 by Springer-Verlag.</font><hr>


Z is a formal specification language that describes a system by
writing actions--essentially the same kinds of actions that appear in
a TLA specification.&nbsp; It was developed by Mike Spivey and others at
Oxford for specifying sequential programs.&nbsp; When someone develops a
method for sequential programs, they usually think that it
will also handle concurrent programs--perhaps by adding an extra
feature or two.&nbsp; I had heard that this wasn't true of the Z
developers, and that they were smart enough to realize that Z did not
handle concurrency.&nbsp; Moreover, Z is based on mathematics not
programming languages, so it is a fairly nice language.&nbsp;

<p>
TLA assumes an underlying logic for writing actions.&nbsp; The next step
was obvious: devise a language for specifying concurrent systems that
extends Z with the operators of TLA.&nbsp; Equally obvious was
the name of such a language: TLZ.&nbsp;

</p><p>
In the Spring of 1991, I visited Oxford and gave a talk on TLA,
pointing out how naturally it could be combined with Z.&nbsp; The
idea was as popular as bacon and eggs at Yeshiva University.&nbsp; Tony
Hoare was at Oxford, and concurrency at Oxford meant CSP.&nbsp;
The Z community was interested only in combining Z with CSP--which is
about as natural as combining predicate logic with C++.&nbsp;

</p><p> 
A couple of years later, I was invited to give a talk at
the Z User's Meeting.&nbsp; I dusted off the TLZ idea and presented it at
the meeting.&nbsp; Again, I encountered a resounding lack of interest.&nbsp;

</p><p>
Had TLA been adopted by the Z community, it might have become a lot
more popular.&nbsp; On the other hand, not being attached to Z meant that I
didn't have to live with Z's drawbacks and was free to design a more
elegant language for specifying actions.&nbsp; The result was
TLA+, described in <a href="#lamport-spec-tla-plus">[128]</a>.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="lamport-old-fashioned"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时的老式方法</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on 编程语言和系统 16</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 5（1994 年 9 月）1543-1571。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 91 出现。初步版本出现在《
   </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时：实践中的理论》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，JW de Bakker、C. Huizing、W. P. de Roever 和 G. Rozenberg，编辑 (1992)，Springer-Verlag，1-27 。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1994 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#spec-and-proof"><font style="vertical-align:inherit"><font style="vertical-align:inherit">正如[51]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的讨论中所解释的</font><font style="vertical-align:inherit">，很长一段时间以来，我们很清楚用于推理并发算法的断言方法可以轻松处理实时算法。</font><font style="vertical-align:inherit">时间只是成为另一个变量。</font><font style="vertical-align:inherit">但这并没有阻止学术界发明新的时间处理形式。</font><font style="vertical-align:inherit">（模型检查实时算法确实会带来新问题，因为它们本质上不是有限状态的。）因此，当 de Roever 举办实时系统形式主义研讨会时，这是一个展示 TLA 处理如何轻松的好机会与实时算法。</font><font style="vertical-align:inherit">我们还证明了一些关于 nonZeno 规范的新结果。</font><font style="vertical-align:inherit">我相信这篇论文介绍了术语</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Zeno</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">nonZeno</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，尽管其他人肯定也想到了芝诺行为的概念。</font><font style="vertical-align:inherit">它似乎确实是第一个观察非Zenoness 与机器闭合之间关系的人。</font><font style="vertical-align:inherit">阿巴迪对这篇论文有如下看法：

 </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
对我来说，这篇论文在一定程度上证明了我与 [Gordon] Plotkin 一起完成的一些工作 [</font></font><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">组合的逻辑视图</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">，
   </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学 114</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (1993 年 6 月), 3-30]，其中我们探讨了定义和属性“while”运算符（</font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">-|&gt;</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">）的。</font><font style="vertical-align:inherit">我相信你认为这个作品是一个正式的游戏，所以我很高兴发现我们可以在本文中使用它。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 


本文使用 Michael Fischer 提出的互斥协议作为示例。</font><font style="vertical-align:inherit">这个例子有一个有趣的历史。</font><font style="vertical-align:inherit">当我在研究</font></font><a href="#fast-mutex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[73]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">时，我给 Fischer 发了一封电子邮件，描述了我的算法，并询问他是否知道更好的解决方案。</font><font style="vertical-align:inherit">他回应道

 </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
不，我不知道，但是这个问题的实际版本听起来与争用网络中的总线分配问题非常相似。</font><font style="vertical-align:inherit">我想知道是否不能使用类似的解决方案？</font><font style="vertical-align:inherit">比如说，怎么样...&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

随后，他制定了一个基于实时延迟的简单、优雅的协议。</font><font style="vertical-align:inherit">由于其实时假设，他的协议没有解决激发</font></font><a href="#fast-mutex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[73]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的问题。</font><font style="vertical-align:inherit">我在</font></font><a href="#fast-mutex"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[73]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中提到了这个算法，但在 de Roever 研讨会时已经忘记了。</font><font style="vertical-align:inherit">弗雷德·施奈德（Fred Schneider）在研讨会上的演讲中用它作为例子时让我想起了这一点。</font><font style="vertical-align:inherit">然后我们将该示例合并到我们的论文中。</font><font style="vertical-align:inherit">后来我向费舍尔提到了这一点，他不记得该协议，甚至声称这不是他的。</font><font style="vertical-align:inherit">幸运的是，我恰好保存了他的原始电子邮件，所以我有证据。</font><font style="vertical-align:inherit">该消息及其消息编号在论文中被引用——据我所知，这是此类引用的唯一实例。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-old-fashioned"><b>An Old-Fashioned Recipe for Real
   Time</b>&nbsp; (with Martín Abadi)<br><i>ACM Transactions on Programming Languages and Systems 16</i>, 5
   (September 1994) 1543-1571.&nbsp; Also appeared as SRC Research 
  Report&nbsp;91.&nbsp;
   A preliminary version appeared in
   <i>Real-Time: Theory in Practice</i>, J. W. de Bakker, C. Huizing, W.&nbsp;
   P. de Roever, and G. Rozenberg, editors (1992), Springer-Verlag,
   1-27.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-old-fashioned.pdf">PDF</a>
<br><font size="-2">Copyright © 1994 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


As explained in the discussion of <a href="#spec-and-proof">[51]</a>, it's been
clear for a long time that assertional methods for reasoning about
concurrent algorithms can easily handle real-time algorithms.&nbsp; Time
just becomes another variable.&nbsp; That hasn't stopped academics from
inventing new formalisms for handling time.&nbsp; (Model checking real-time
algorithms does raise new problems, since they are inherently not
finite-state.)&nbsp; So, when de Roever held a workshop on formalisms for
real-time systems, it was a good opportunity to show off how easily
TLA deals with real-time algorithms.&nbsp; We also proved some new results
about nonZeno specifications.&nbsp; I believe this paper introduced the
terms <i>Zeno</i> and <i>nonZeno</i>, though the notion of Zeno
behaviors had certainly occurred to others.&nbsp; It does seem to have been
the first to observe the relation between nonZenoness and machine
closure.&nbsp; Abadi has the following to say about this paper:

 <blockquote><p>
For me, this paper was partly a vindication of some work I had done
with [Gordon] Plotkin 
 [<b>A 
         Logical View of Composition</b>,
   <i>Theoretical Computer Science 114</i>, 1 (June 1993), 3-30], 
where we explored the definition and properties of the "while"
operator (<tt>-|&gt;</tt>).&nbsp; I believe that you thought
that the work was a formal game, so I was pleased to find that we
could use it in this paper.&nbsp;
 </p></blockquote> 


The paper uses as an example a mutual exclusion protocol due to
Michael Fischer.&nbsp; This example has an amusing history.&nbsp; When I was
working on <a href="#fast-mutex">[73]</a>, I sent Fischer email describing my
algorithm and asking if he knew of a better solution.&nbsp; He responded

 <blockquote><p>
No, I don't, but the practical version of the problem sounds very
similar to the problem of bus allocation in contention networks.&nbsp;
I wonder if similar solutions couldn't be used?  For example, how
about...&nbsp;
 </p></blockquote> 

He followed this with a simple, elegant protocol based on real-time
delays.&nbsp; Because of its real-time assumptions, his protocol didn't
solve the problem that motivated <a href="#fast-mutex">[73]</a>.&nbsp; I mentioned
this algorithm in <a href="#fast-mutex">[73]</a>, but had forgotten about it by
the time of de Roever's workshop.&nbsp; Fred Schneider reminded me of it
when he used it as an example in his talk at the workshop.&nbsp; We
then incorporated the example in our paper.&nbsp; I later mentioned this to
Fischer, who had no memory of the protocol and even claimed that it
wasn't his.&nbsp; Fortunately, I happen to have saved his original email,
so I had the proof.&nbsp; The message, complete with message number, is
cited in the paper--the only instance of such a citation that I know
of.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-ftrtft94"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定和验证容错系统</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Stephan Merz 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时和容错系统中的形式技术</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，H. Langmaack，W.-P。</font><font style="vertical-align:inherit">de Roever，J. Vytopil 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 863 期，Springer-Verlag，（1994 年 9 月）41-76。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1994 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


威廉-保罗·德罗弗邀请我在这次研讨会上做演讲。</font><font style="vertical-align:inherit">我很高兴能有一个讲台来解释为什么验证容错的实时系统不应该是一个新的或特别困难的问题。</font><font style="vertical-align:inherit">这已经在</font></font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[107]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中针对实时系统进行了解释，但我知道会有人认为容错会有所作为。</font><font style="vertical-align:inherit">此外，德罗弗向我保证，举办研讨会的吕贝克是一座美丽的小镇。</font></font><a href="#spec-and-proof"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（他是对的。）所以，我决定在 TLA 中重做[51]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的证明</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，当写论文的时候，我意识到我已经超出了自己的范围，需要帮助。</font><font style="vertical-align:inherit">抽象状态
</font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
  我们正式指定了拜占庭将军问题的一个众所周知的解决方案，并给出了严格的、分层结构的证明其正确性。</font><font style="vertical-align:inherit">我们证明这是一项工程实践，不需要新的科学想法。&nbsp; 
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
然而，很少有计算机科学家能够完成这种简单的工程练习。</font><font style="vertical-align:inherit">斯蒂芬·梅尔茨就是其中之一。</font><font style="vertical-align:inherit">因此，我请他写出证明，他以一贯的优雅和对细节的关注完成了。</font><font style="vertical-align:inherit">我想我提供了大部分的散文和 TLA 规范的初始版本，Merz 对其进行了一些修改。</font><font style="vertical-align:inherit">证据全是默兹的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-ftrtft94"><b>Specifying and Verifying Fault-Tolerant
   Systems</b>&nbsp; (with Stephan Merz)<br><i>Formal Techniques in Real-Time and
   Fault-Tolerant Systems</i>, H. Langmaack, W.-P. de Roever, J. Vytopil
   editors.&nbsp; Lecture Notes in Computer Science, number 863,
   Springer-Verlag, (September 1994) 41-76.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-ftrtft94.pdf">PDF</a>
<br><font size="-2">Copyright 
1994 by Springer-Verlag.</font><hr>


Willem-Paul de Roever invited me to give a talk at this symposium.&nbsp; I
was happy to have a podium to explain why verifying fault-tolerant,
real-time systems should not be a new or especially difficult problem.&nbsp;
This was already explained in <a href="#lamport-old-fashioned">[107]</a> for
real-time systems, but I knew that there would be people who thought
that fault-tolerance made a difference.&nbsp; Moreover, de Roever assured
me that Lübeck, where the symposium was held, is a
beautiful town.&nbsp; (He was right.)&nbsp; So, I decided to redo in TLA the
proof from <a href="#spec-and-proof">[51]</a>.&nbsp; However, when the time
came to write the paper, I realized that I had overextended myself and
needed help.&nbsp; The abstract states
<blockquote><p>
  We formally specify a well known solution to the Byzantine generals
problem and give a rigorous, hierarchically structured proof of its
correctness.&nbsp; We demonstrate that this is an engineering exercise,
requiring no new scientific ideas.&nbsp; 
 </p></blockquote> 
However, there were few computer scientists capable of doing this
straightforward engineering exercise.&nbsp; Stephan Merz was one of them.&nbsp;
So, I asked him to write the proof, which he did with
his usual elegance and attention to detail.&nbsp; I think I provided most
of the prose and the initial version of the TLA specification,
which Merz modified a bit.&nbsp; The proof was all Merz's.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="lamport-howtowrite"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何编写长公式</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">FACJ 6</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (5)（1994 年 9 月/10 月）580-584。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 119 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1994 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


规范通常包含一两页长的公式。</font><font style="vertical-align:inherit">数学家几乎从来不会写那么长的公式，因此他们还没有开发出处理公式所需的符号。</font><font style="vertical-align:inherit">本文介绍了我使用缩进来消除由嵌套连词和析取组成的公式中的括号的符号。</font><font style="vertical-align:inherit">我发现这种符号在编写规范时非常有用。</font><font style="vertical-align:inherit">该符号是 TLA+ 形式语法的一部分（参见
</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-howtowrite"><b>How to Write a Long Formula</b><br><i>FACJ 6</i>(5)
   (September/October 1994) 580-584.&nbsp; Also appeared as SRC Research
   Report&nbsp;119.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-howtowrite.pdf">PDF</a>
<br><font size="-2">Copyright 
1994 by Springer-Verlag.</font><hr>


Specifications often contain formulas that are a page or two long.&nbsp;
Mathematicians almost never write formulas that long, so they haven't
developed the notations needed to cope with them.&nbsp; This article
describes my notation for using indentation to eliminate parentheses
in a formula consisting of nested conjunctions and disjunctions.&nbsp; I
find this notation very useful when writing specifications.&nbsp; The
notation is part of the formal syntax of TLA+ (see
<a href="#lamport-spec-tla-plus">[128]</a>).&nbsp;

<br>&nbsp;<p></p></li><li> <a name="intro-to-tla"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA SRC 技术说明 1994-001 简介</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1994 年 12 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是对 TLA 公式含义的非常简短（7 页）的介绍。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="intro-to-tla"><b>Introduction to TLA</b><br>SRC Technical Note 1994-001
 (December 1994).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/intro-to-tla.pdf">PDF</a><hr>


This is a very brief (7-page) introduction to what TLA formulas mean.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="adding-process-algebra"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">将“过程代数”添加到 TLA</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布（1995 年 1 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 Dagstuhl 研讨会上的讨论中描述了
</font></font><a href="#broy-specification-problem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[115]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">Rob van Glabbeek 提出的过程代数规范的优雅给我留下了深刻的印象。</font><font style="vertical-align:inherit">在过程结构中对控制状态进行编码的能力允许人们在 CCS 中很好地表达某些规范。</font><font style="vertical-align:inherit">然而，纯 CCS 迫使您对流程结构中的整个状态进行编码，这对于实际规范来说是不切实际的。</font><font style="vertical-align:inherit">我的想法是尝试通过结合 CCS 和 TLA 来获得两全其美的效果，并就此撰写了这篇初步说明。</font><font style="vertical-align:inherit">我希望与 van Glabbeek 一起研究这个问题，但尽管他很感兴趣，但他正忙于其他事情，我们从未讨论过它，我也从未对这个想法做过任何事情。</font><font style="vertical-align:inherit">当我写这篇文章时，我不确定这是否是一个好主意。</font><font style="vertical-align:inherit">我现在认为，在 TLA 中添加 CCS 将显着简化规范的例子在实践中不太可能出现。</font><font style="vertical-align:inherit">因此，我认为没有任何理由以这种方式使 TLA 复杂化。</font><font style="vertical-align:inherit">但是，其他人可能会有不同的感觉。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="adding-process-algebra"><b>Adding "Process Algebra" to 
    TLA</b><br>Unpublished (January 1995).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/adding-process-algebra.pdf">PDF</a><hr>


At the Dagstuhl workshop described in the discussion of
<a href="#broy-specification-problem">[115]</a>, I was impressed by the elegance
of the process-algebraic specification presented by Rob van Glabbeek.&nbsp;
The ability to encode control state in the process structure permits
one to express some specifications quite nicely in CCS.&nbsp;
However, pure CCS forces you to encode the entire state in the process
structure, which is impractical for real specifications.&nbsp; I had the
idea of trying to get the best of both worlds by combining CCS and
TLA, and wrote this preliminary note about it.&nbsp; I hoped to work on
this with van Glabbeek but, although he was interested, he was busy
with other things and we never discussed it, and I never did anything
more with the idea.&nbsp; When I wrote this note, I wasn't sure if it was a
good idea.&nbsp; I now think that examples in which adding CCS to TLA would
significantly simplify the specification are unlikely to arise in
practice.&nbsp; So, I don't see any reason to complicate TLA in this way.&nbsp;
But, someone else may feel otherwise.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="ccs-proofs"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">代数证明使用什么过程代替不变性</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表（1995 年 1 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


对</font></font><a href="#adding-process-algebra"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[111]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的研究让我思考过程代数证明是如何工作的。</font><font style="vertical-align:inherit">这篇草稿说明描述了我对这些证明使用什么而不是不变性的初步想法。</font><font style="vertical-align:inherit">我从来没有发展到足以知道它是否正确的程度。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="ccs-proofs"><b>What Process Algebra Proofs Use Instead of 
   Invariance</b><br>Unpublished (January 1995).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/ccs-proofs.pdf">PDF</a><hr>


Working on <a href="#adding-process-algebra">[111]</a> got me thinking about how
process-algebraic proofs work.&nbsp; This draft note describes my
preliminary thoughts about what those proofs use instead of
invariance.&nbsp; I never developed this far enough to know if
it's right.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="abadi-conjoining"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">联合规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on Programming Languages and Systems 17</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1995 年 5 月），507-534。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 118 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1995 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">编写假设/保证规范的明显方法是采用E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">暗示</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M 的</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">


形式</font><font style="vertical-align:inherit">，其中</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定我们对环境的假设，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定系统保证的内容。</font><font style="vertical-align:inherit">这就是我们在</font></font><a href="#abadi-composing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[98]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中所做的。</font><font style="vertical-align:inherit">然而，这样的规范允许系统违反保证并且环境随后违反其假设的行为。</font><font style="vertical-align:inherit">本文提出了一种更好的方式来编写我们后来发现的规范。</font><font style="vertical-align:inherit">我们采用更强的条件
</font><font style="vertical-align:inherit">作为规范，而不是</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">E</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">暗示
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M ，即</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">M必须比</font></font></i><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">E</font></i><font style="vertical-align:inherit">至少多一步保持为真</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">是。</font><font style="vertical-align:inherit">这使我们能够简化和加强我们的结果。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
本文包含两个主要定理，一个用于分解封闭系统规范，另一个用于组成开放系统规范。</font><font style="vertical-align:inherit">封闭系统结果的初步会议版本出现在</font></font><a href="#abadi-decomposing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[104]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。</font><font style="vertical-align:inherit">第二个会议的初步版本出现在</font></font><a href="#abadi-open"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[105]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

虽然本文的命题和定理原则上并不困难，但细节上却相当困难。</font><font style="vertical-align:inherit">如果没有仔细编写、结构化的证明，我们就不可能做到这一点。</font><font style="vertical-align:inherit">所以，我希望公布这些证据。</font><font style="vertical-align:inherit">但严格的结构化证明，其中所有的细节都已制定出来，又长又无聊，而且审稿人也没有阅读它们。</font><font style="vertical-align:inherit">由于审稿人没有阅读校样，编辑不想发表。</font><font style="vertical-align:inherit">相反，她只想在没有校样的情况下发表论文。</font><font style="vertical-align:inherit">令我震惊的是，她愿意发表未经检验的证明的定理，却不愿意发表未经检验的证明。</font><font style="vertical-align:inherit">但是，我同情她不愿杀死所有这些树，所以我们同意她找人来审阅证明，我们将以电子方式发布附录。</font><font style="vertical-align:inherit">裁判仔细阅读了校样，发现了三个小错误，很容易就改正了。</font><font style="vertical-align:inherit">当我们对证明的一部分进行更改而没有对另一部分进行相应更改时，就会发生两个错误。</font><font style="vertical-align:inherit">第三个是低级陈述中的粗心错误。</font><font style="vertical-align:inherit">当被问到时，裁判说，层次结构以及所有底层细节都已解决，使得证明非常清晰且易于检查。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

当我得知 ACM 将仅以电子形式发布一些附录时，我担心他们是否有能力维护电子档案，使人们能够在二十或五十年后获得附录。</font><font style="vertical-align:inherit">事实上，当我在 2011 年 8 月检查时，从 ACM 获取与该文章一起印刷的副本的方法都不起作用，而且附录似乎没有出现在他们的网站上。</font><font style="vertical-align:inherit">它仍然可以从普林斯顿大学的 ftp 站点上获得。</font><font style="vertical-align:inherit">（上面的链接是包含附录的论文版本。）&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="abadi-conjoining"><b>Conjoining
   Specifications</b>&nbsp; (with Martín
   Abadi)<br><i>ACM Transactions on Programming Languages and Systems 17</i>, 3 (May 1995), 507-534.&nbsp; Also appeared as SRC
   Research Report&nbsp;118.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-conjoining.pdf">PDF</a>
<br><font size="-2">Copyright © 1995 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


The obvious way to write an assume/guarantee specification is in the
form <i>E</i> implies <i>M</i>, where <i>E</i> specifies what we
assume of the environment and <i>M</i> specifies what the system
guarantees.&nbsp; That is what we did in <a href="#abadi-composing">[98]</a>.&nbsp;
However, such a specification allows behaviors in which the system
violates the guarantee and the environment later violates its
assumption.&nbsp; This paper presents a better way to write the
specification that we discovered later.&nbsp; Instead of <i>E</i> implies
<i>M</i>, we take as the specification the stronger condition that
<i>M</i> must remain true at least one step longer than <i>E</i> is.&nbsp;
This enabled us to simplify and strengthen our results.&nbsp;

<p>
This paper contains two major theorems, one for decomposing
closed-system specifications and another for composing open-system
specifications.&nbsp; A preliminary conference version of the result for
closed systems appeared in <a href="#abadi-decomposing">[104]</a>.&nbsp; A preliminary
conference version of the second appeared in <a href="#abadi-open">[105]</a>.&nbsp;

</p><p>

Although the propositions and theorems in this paper are not in
principle difficult, it was rather hard to get the details right.&nbsp; We
couldn't have done it without writing careful, structured proofs.&nbsp; So,
I wanted those proofs published.&nbsp; But rigorous structured proofs, in
which all the details are worked out, are long and boring, and the
referees didn't read them.&nbsp; Since the referees hadn't read the proofs,
the editor didn't want to publish them.&nbsp; Instead, she wanted simply to
publish the paper without proofs.&nbsp; I was appalled that she was willing
to publish theorems whose proofs hadn't been checked, but was
unwilling to publish the unchecked proofs.&nbsp; But, I sympathized with
her reluctance to kill all those trees, so we agreed that she would
find someone to referee the proof and we would publish the appendix
electronically.&nbsp; The referee read the proofs carefully and
found three minor errors, which were easily corrected.&nbsp; Two of the
errors occurred when we made changes to one part of the proof without
making corresponding changes to another.&nbsp; The third was a careless
mistake in a low-level statement.&nbsp; When asked, the referee said that
the hierarchical structure, with all the low-level details worked out,
made the proofs quite clear and easy to check.&nbsp;

</p><p>

When I learned that ACM was going to publish some appendices in
electronic form only, I was worried about their ability to maintain an
electronic archive that would enable people to obtain an appendix
twenty or fifty years later.&nbsp; Indeed, when I checked in August of
2011, none of the methods for obtaining a copy from the ACM that were
printed with the article worked, and the appendix did not seem to be
on their web site.&nbsp; It was still available from a Princeton University
ftp site.&nbsp; (The link above is to a version of the paper containing
the appendix.)&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="lamport-pictures"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">图片中的 TLA </font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE 软件工程汇刊 SE-</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 21，1995 年 9 月 9 日），768-775。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 127 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1995 允许个人使用本材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


早在 50 年代和 60 年代，程序员就使用流程图。</font><font style="vertical-align:inherit">最终，在 Dijkstra 和 Hoare 等人的指导下，我们了解到图片并不是描述程序的好方法，因为它们在复杂性的重压下崩溃了，产生了由盒子和箭头组成的难以理解的意大利面条。</font><font style="vertical-align:inherit">按照从错误中学习如何再次犯同样错误的伟大传统，许多人认为绘制图片是指定系统的绝佳方式。</font><font style="vertical-align:inherit">因此，他们设计了图形规范语言。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
不甘示弱，我写这篇论文是为了展示你可以通过画图来编写TLA规范。</font><font style="vertical-align:inherit">它描述了如何将人们用来描述状态转换的典型圆圈和箭头解释为 TLA 公式。</font><font style="vertical-align:inherit">这些图表代表安全特性。</font><font style="vertical-align:inherit">我还可以添加一些巴洛克式的约定来为图片添加活力属性，但我的愚蠢程度是有限度的。</font><font style="vertical-align:inherit">当我写这篇论文时，我确实认为图片可能有助于解释部分规范。</font><font style="vertical-align:inherit">但我还没有遇到过任何可以提供帮助的真实例子。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
据我所知，这篇论文包含我发表过的唯一不正确的“定理”。</font><font style="vertical-align:inherit">这说明我可以像任何人一样懒惰，不去检查“明显”的断言。</font><font style="vertical-align:inherit">我没有发表更正，因为该定理需要额外的假设，本质上是一个脚注，并不影响论文的要点。</font><font style="vertical-align:inherit">另外，我很好奇是否有人会注意到这个错误。</font><font style="vertical-align:inherit">显然，没有人这样做。</font><font style="vertical-align:inherit">我发现了写法的错误</font></font><a href="#abadi-dagstuhl"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[116]</font></font></a>


<br>&nbsp;</p><p></p></li><li> <a name="lamport-pictures"><b>TLA in Pictures</b><br><i>IEEE Transactions on
   Software Engineering SE-21</i>, 9 September 1995), 768-775.&nbsp; Also
   appeared as SRC Research Report&nbsp;127.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-pictures.pdf">PDF</a>
<br><font size="-2">Copyright © 1995 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


Back in the 50s and 60s, programmers used flowcharts.&nbsp; Eventually,
guided by people like Dijkstra and Hoare, we learned that pictures
were a bad way to describe programs because they collapsed under the
weight of complexity, producing an incomprehensible spaghetti of boxes
and arrows.&nbsp; In the great tradition of learning from our mistakes how
to make the same mistake again, many people decided that drawing
pictures was a wonderful way to specify systems.&nbsp; So, they devised
graphical specification languages.&nbsp;

<p>
Not wanting to be outdone, I wrote this paper to show that you can
write TLA specifications by drawing pictures.&nbsp; It describes how to
interpret as TLA formulas the typical circles and arrows with which
people describe state transitions.&nbsp; These diagrams represent safety
properties.&nbsp; I could also have added some baroque conventions for
adding liveness properties to the pictures, but there's a limit to how
silly I will get.&nbsp; When I wrote the paper, I actually did think that
pictures might be useful for explaining parts of specifications.&nbsp; But
I have yet to encounter any real example where they would have helped.&nbsp;

</p><p>
This paper contains, to my knowledge, the only incorrect "theorem" I
have ever published.&nbsp; It illustrates that I can be as lazy as anyone
in not bothering to check "obvious" assertions.&nbsp; I didn't published
a correction because the theorem, which requires an additional
hypothesis, was essentially a footnote and didn't affect the main
point of the paper.&nbsp; Also, I was curious to see if anyone would notice
the error.&nbsp; Apparently, no one did.&nbsp; I discovered the error in
writing <a href="#abadi-dagstuhl">[116]</a>


<br>&nbsp;</p><p></p></li><li> <a name="broy-specification-problem"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">RPC 内存规范问题：问题陈述</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Manfred Broy 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">正式系统规范：RPC 内存规范案例研究</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Manfred Broy、Stephan Merz 和 Katharina Spies 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 1169 号，(1996)，1-4。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1996 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我不记得这是怎么发生的，但 Manfred Broy 和我组织了一个关于并发系统规范和验证的 Dagstuhl 研讨会。</font><font style="vertical-align:inherit">（我确信我同意这一点，因为知道布罗伊和他的同事将负责所有真正的组织工作。）我们决定提出一个所有参与者都应该解决的问题。</font><font style="vertical-align:inherit">这是问题陈述。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
这次研讨会有一个有趣的脚注。</font></font><a href="#spec"><font style="vertical-align:inherit"><font style="vertical-align:inherit">正如[50]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论中所解释的</font><font style="vertical-align:inherit">，我不认为将规范编写为系统应满足的属性的结合。</font><font style="vertical-align:inherit">一些参与者使用了这种方法。</font><font style="vertical-align:inherit">我认为高级规范已经足够简单了，现在人们可以用这种方式来指定它。</font><font style="vertical-align:inherit">然而，Reino Kurki-Suonio 注意到所有“纯公理化”规范中都存在一个错误，即仅提及接口，而没有引入内部变量的规范。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="broy-specification-problem"><b>The RPC-Memory Specification Problem:
   Problem Statement</b>&nbsp; (with Manfred Broy)<br><i>Formal Systems Specification:
   The RPC-Memory Specification Case Study</i>, Manfred Broy, Stephan Merz,
   and Katharina Spies editors.&nbsp; Lecture Notes in Computer Science,
   number 1169, (1996), 1-4.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/broy-specification-problem.pdf">PDF</a>
<br><font size="-2">Copyright 
1996 by Springer-Verlag.</font><hr>


I don't remember how this came about, but Manfred Broy and I organized
a Dagstuhl workshop on the specification and verification of
concurrent systems.&nbsp; (I'm sure I agreed to this knowing that Broy and
his associates would do all the real organizing.)&nbsp; We decided to pose
a problem that all participants were expected to solve.&nbsp; This is the
problem statement.&nbsp;

<p>
There is an interesting footnote to this workshop.&nbsp; As explained in
the discussion of <a href="#spec">[50]</a>, I don't believe in writing
specifications as a conjunction of the properties that the system
should satisfy.&nbsp; Several participants used this approach.&nbsp; I thought
that the high-level specification was sufficiently trivial that by
now, people would be able to specify it in this way.&nbsp; However, Reino
Kurki-Suonio noticed an error that was present in all the "purely
axiomatic" specifications--that is, ones that mentioned only the
interface, without introducing internal variables.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="abadi-dagstuhl"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">RPC 内存规范问题的 TLA 解决方案</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Martín Abadi 和 Stephan Merz 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">正式系统规范：RPC 内存规范案例研究</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Manfred Broy、Stephan Merz 和 Katharina Spies 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 1169 号，(1996)，21-66。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1996 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#broy-specification-problem"><font style="vertical-align:inherit"><font style="vertical-align:inherit">由于[115]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


中提出的问题</font><font style="vertical-align:inherit">是由 Broy 和我共同设计的，因此我认为提出 TLA 解决方案是合理的。</font><font style="vertical-align:inherit">马丁·阿巴迪、斯蒂芬·梅尔茨和我制定了一个解决方案，并在研讨会上展示了我和梅尔茨。</font><font style="vertical-align:inherit">之后，我们进行了更多研究，最终提出了本文中描述的更优雅的方法。</font><font style="vertical-align:inherit">我相信大部分散文都是阿巴迪和我写的。</font><font style="vertical-align:inherit">Merz 编写了实际的证明，后来他使用</font></font><a href="https://www.pst.informatik.uni-muenchen.de/~merz/isabelle/index.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在 Isabelle 中嵌入的 TLA</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">进行了检查。</font><font style="vertical-align:inherit">我们都为规范的编写做出了贡献。&nbsp;

</font></font><p><font style="vertical-align:inherit"></font><a href="#lamport-pictures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是我遇到的唯一一个例子，其中[114]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

中描述的 TLA 公式的图片</font><font style="vertical-align:inherit">有一定的用途。</font><font style="vertical-align:inherit">事实上，当我意识到本文中的一张图片为其错误定理提供了反例时，&nbsp;


我就发现了</font></font><a href="#lamport-pictures"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[114]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的错误。</font></font><br>&nbsp;</p><p></p></li><li> <a name="abadi-dagstuhl"><b>A TLA Solution to the RPC-Memory Specification
   Problem</b>&nbsp; (with Martín Abadi and Stephan
   Merz)<br><i>Formal Systems Specification: The RPC-Memory Specification
   Case Study</i>, Manfred Broy, Stephan Merz, and Katharina Spies editors.&nbsp;
   Lecture Notes in Computer Science, number 1169, (1996), 21-66.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/abadi-dagstuhl.pdf">PDF</a>
<br><font size="-2">Copyright 
1996 by Springer-Verlag.</font><hr>


Since the problem posed in <a href="#broy-specification-problem">[115]</a> was
devised by both Broy and me, I felt it was reasonable for me to
present a TLA solution.&nbsp; Martín
Abadi, Stephan Merz, and I worked out a solution that Merz and I
presented at the workshop.&nbsp; Afterwards, we worked some more on it and
finally came up with a more elegant approach that is described in this
paper.&nbsp; I believe that Abadi and I wrote most of the prose.&nbsp; Merz
wrote the actual proofs, which he later checked using his <a href="https://www.pst.informatik.uni-muenchen.de/~merz/isabelle/index.html">embedding
of TLA in Isabelle</a>.&nbsp; We all contributed to the writing
of the specifications.&nbsp;

<p> 

This is the only example I've encountered in which the pictures of TLA
formulas described in <a href="#lamport-pictures">[114]</a> were of some use.&nbsp; In
fact, I discovered the error in <a href="#lamport-pictures">[114]</a> when I
realized that one of the pictures in this paper provided a
counterexample to its incorrect theorem.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="automobile"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">《如何以</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">动态</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">和快速的智力</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">区分程序和汽车》 ，John Tromp 主编（1996 年）—— </font><font style="vertical-align:inherit">CWI 为纪念 Paul Vitanyi 25 周年而发行的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Liber Amicorum 。</font></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/automobile.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/automobile.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/automobile.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">我在 1977 年 1 月写了这篇简短的笔记。它的诞生是因为我对程序维护</font></i><font style="vertical-align:inherit">


这个术语的使用感到震惊</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这在我的脑海中浮现出润滑分支语句和清洁指针的图像。</font><font style="vertical-align:inherit">所以，我写这篇文章是为了观察程序是可以进行逻辑分析的数学对象。</font><font style="vertical-align:inherit">我对马萨诸塞州计算机协会的同事们激起的强烈情绪感到措手不及，他们强烈反对我的论文。</font><font style="vertical-align:inherit">所以，我把这一切都放下了。</font><font style="vertical-align:inherit">几年后，当我受邀为纪念维塔尼的卷提交一篇短论文时，我认为这篇论文很合适，因为他几年前才学会开车。</font><font style="vertical-align:inherit">这篇论文仍然具有相关性，因为程序员似乎仍然不理解程序和汽车之间的区别。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="automobile"><b>How to Tell a Program from an Automobile</b><br>In <i>A
   Dynamic and Quick Intellect</i>, John Tromp editor (1996)--a <i>Liber
   Amicorum</i> issued by the CWI in honor of Paul Vitanyi's 25-year
   jubilee.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/automobile.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/automobile.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/automobile.pdf">PDF</a><hr>


I wrote this brief note in January, 1977.&nbsp; It came about because I was
struck by the use of the term <i>program maintenance</i>, which
conjured up in my mind images of lubricating the branch statements and
cleaning the pointers.&nbsp; So, I wrote this to make the observation that
programs are mathematical objects that can be analyzed logically.&nbsp; I
was unprepared for the strong emotions this stirred up among my
colleagues at Massachusetts Computer Associates, who objected
vehemently to my thesis.&nbsp; So, I let the whole thing drop.&nbsp; Years
later, when I was invited to submit a short paper for the volume
honoring Vitanyi, I decided that this paper would be appropriate
because he had learned to drive only a few years earlier.&nbsp; The paper
retains its relevance, since programmers still don't seem to
understand the difference between a program and an automobile.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="refinement"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">基于状态的形式主义的细化</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRC 技术说明 1996-001（1996 年 12 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/refinement.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/refinement.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/refinement.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


简短的（7 页）注释解释了细化和虚拟变量的含义。</font><font style="vertical-align:inherit">它还包含了对 TLA 的介绍。</font><font style="vertical-align:inherit">2004年9月，Tommaso Bolognesi指出第4页底部的公式有错误，并建议更正。</font><font style="vertical-align:inherit">我决定将查找和纠正错误的问题作为练习留给读者，而不是修改注释。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="refinement"><b>Refinement in State-Based Formalisms</b><br>SRC Technical 
      Note 1996-001 (December 1996).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/refinement.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/refinement.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/refinement.pdf">PDF</a><hr>


A brief (7-page) note explaining what refinement and dummy variables
are all about.&nbsp; It also sneaks in an introduction to TLA.&nbsp;
In September 2004, Tommaso Bolognesi pointed out an error in the
formula on the bottom of page 4 and suggested a correction.&nbsp; Instead
of modifying the note, I've decided to leave the problem of finding
and correcting the error as an exercise for the reader.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-drummers"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">向许多遥远的鼓手行进</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与蒂姆·曼）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未出版（1997 年 5 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1990 年，有两个关于互联网授时服务的相互竞争的提案。</font><font style="vertical-align:inherit">一份来自 DEC 网络小组，另一份来自 David Mills 的 RFC。</font><font style="vertical-align:inherit">DEC 的人向我寻求理论支持，因为他们相信他们的提案比米尔斯的提案更好。</font><font style="vertical-align:inherit">我请蒂姆·曼帮助我。</font><font style="vertical-align:inherit">我们认为我们不太喜欢这两个提案，而是用我们自己的想法写了一篇笔记，提出了一种在类似互联网的环境中获取正确时间的算法。</font><font style="vertical-align:inherit">我们对这个想法思考了几年，最终 Tim 在 Dagstuhl 时间同步研讨会上提出了它。</font><font style="vertical-align:inherit">然后我们开始就这个主题写一篇更严格的论文。</font><font style="vertical-align:inherit">这是我们目前所能得到的。</font><font style="vertical-align:inherit">论文已基本完成，但定理陈述中存在一些小错误，证明也未完成。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-drummers"><b>Marching to Many Distant 
   Drummers</b>&nbsp; (with Tim Mann)<br>Unpublished (May 1997).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-drummers.pdf">PDF</a><hr>


In 1990, there were two competing proposals for a time service for the
Internet.&nbsp; One was from the DEC networking group and the other was in
an RFC by David Mills.&nbsp; The people in DEC asked me for theoretical
support for their belief that their proposal was better than that of
Mills.&nbsp; I asked Tim Mann to help me.&nbsp; We decided that we didn't like
either proposal very much, and instead we wrote a note with our own
idea for an algorithm to obtain the correct time in an Internet-like
environment.&nbsp; We sat on the idea for a few years, and eventually Tim
presented it at a Dagstuhl workshop on time synchronization.&nbsp; We then
began writing a more rigorous paper on the subject.&nbsp; This is as far as
we got.&nbsp; The paper is mostly finished, but it contains some minor
errors in the statements of the theorems and the proofs are not
completed.&nbsp; We are unlikely ever to work on this paper again.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-eye-of-beholder"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">过程是情人眼中的</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学，179</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，（1997），333-351。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 132 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1997 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">

   
进程的概念已经渗透到并发性的大部分工作中。</font><font style="vertical-align:inherit">早在 70 年代末，单处理器计算机可以实现多进程程序这一事实令我震惊，但我不知道如何证明这种实现的正确性。</font><font style="vertical-align:inherit">一旦我意识到系统可以简单地指定为一组状态序列，问题就消失了。</font><font style="vertical-align:inherit">进程只是查看状态的一种特定方式，同一系统的不同视图可以具有不同数量的处理器。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">一个很好的例子是</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">缓冲区生产者/消费者系统，它通常被视为由生产者和消费者进程组成。</font><font style="vertical-align:inherit">但我们也可以将其视为一个
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">N</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">进程系统，每个缓冲区都是一个进程。</font><font style="vertical-align:inherit">将这些视图转化为具体的程序会产生两个看起来完全不同的程序。</font><font style="vertical-align:inherit">通过大量挥手来证明它们的等价性并不难。</font><font style="vertical-align:inherit">使用 TLA，可以轻松地用完全正式的证明来代替挥手。</font><font style="vertical-align:inherit">本文概述了如何实现。&nbsp;


</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我怀疑用过程代数证明这两个程序的等价性将是相当困难的，甚至可能是不可能的。</font><font style="vertical-align:inherit">因此，在论文的最后，我写道“将过程代数证明……与我们的 TLA 证明进行比较会很有趣。” </font><font style="vertical-align:inherit">据我所知，还没有过程代数学家接受过这个挑战。</font><font style="vertical-align:inherit">我认为与我的证明类似的证明可以通过任何基于跟踪的方法（例如 I/O 自动机）完成。</font><font style="vertical-align:inherit">但是，我预计使用其他方法使其完全正式会很困难。</font><font style="vertical-align:inherit">尤里·古列维奇和吉姆·哈金斯决定使用古列维奇不断发展的代数形式主义（现在称为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">抽象状态机）来解决这个问题</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">处理我论文的编辑告诉我，他们已经提交了他们的解决方案，并建议他们的论文和我的论文发表在同一期，我在他们的论文上写了一些评论。</font><font style="vertical-align:inherit">我同意了，但说我想对最终版本发表评论。</font><font style="vertical-align:inherit">我没有听到更多关于他们论文的消息，所以我认为它已经被拒绝了。</font><font style="vertical-align:inherit">三年后，我惊讶地发现，Gurevich 和 Huggins 的论文《</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">情人眼中的等效性</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">》紧随我的论文发表在同一期
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《理论计算机科学》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">上。</font><font style="vertical-align:inherit">他们选择写一个“以人为本”的证明而不是正式的证明。</font><font style="vertical-align:inherit">读者可以自己判断将他们的证明形式化是多么容易。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-eye-of-beholder"><b>Processes are in the Eye of the
   Beholder</b><br><i>Theoretical Computer Science, 179</i>, (1997), 333-351.&nbsp;
    Also appeared as SRC Research Report&nbsp;132.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-eye-of-beholder.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1997.</font><hr>

   
The notion of a process has permeated much of the work on concurrency.&nbsp;
Back in the late 70s, I was struck by the fact that a uniprocessor
computer could implement a multiprocess program, and that I had no
idea how to prove the correctness of this implementation.&nbsp; Once I had
realized that a system was specified simply as a set of sequences of
states, the problem disappeared.&nbsp; Processes are just a particular way
of viewing the state, and different views of the same system can have
different numbers of processors.&nbsp; 

<p> A nice example of this is an <i>N</i>-buffer
producer/consumer system, which is usually viewed as consisting of a
producer and a consumer process.&nbsp; But we can also view it as an
<i>N</i>-process system, with each buffer being a process.&nbsp;
Translating the views into concrete programs yields two programs that
look quite different.&nbsp; It's not hard to demonstrate their equivalence
with a lot of hand waving.&nbsp; With TLA, it's easy to replace the
hand waving by a completely formal proof.&nbsp; This paper sketches how.&nbsp;


</p><p>

I suspected that it would be quite difficult and perhaps impossible to
prove the equivalence of the two programs with process algebra.&nbsp; So,
at the end of the paper, I wrote "it would be interesting to compare
a process-algebraic proof ... with our TLA proof." As
far as I know, no process algebraist has taken up the challenge.&nbsp; I
figured that a proof similar to mine could be done in any trace-based
method, such as I/O automata.&nbsp; But, I expected that trying to make it
completely formal would be hard with other methods.&nbsp; Yuri Gurevich and
Jim Huggins decided to tackle the problem using Gurevich's evolving
algebra formalism (now called <i>abstract state machines</i>).&nbsp; The
editor processing my paper told me that they had submitted their
solution and suggested that their paper and mine be published in the
same issue, and that I write some comments on their paper.&nbsp; I agreed,
but said that I wanted to comment on the final version.&nbsp; I heard
nothing more about their paper, so I assumed that it had been
rejected.&nbsp; I was surprised to learn, three years later, that the
Gurevich and Huggins paper, <i>Equivalence is in the Eye of the
Beholder</i>, appeared right after mine in the same issue of
<i>Theoretical Computer Science</i>.&nbsp; They chose to write a
"human-oriented" proof rather than a formal one.&nbsp; Readers can judge
for themselves how easy it would be to formalize their proof.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="lamport-how-to-make"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何使正确的多进程程序在多处理器上正确执行</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">IEEE Transactions on Computers 46、7</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（1997 年 7 月）、779-782。</font><font style="vertical-align:inherit">还作为 SRC 研究报告 96 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1997 允许个人使用本材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文的灵感来自 Kourosh Gharachorloo 的论文。</font><font style="vertical-align:inherit">他解决的问题是如何在内存不提供顺序一致性的计算机上执行多进程程序（参见</font></font><a href="#multi"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[35]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">），而是需要显式同步操作（例如Alpha的内存屏障指令）。</font><font style="vertical-align:inherit">他提出了一种方法来推断必须将哪些同步操作添加到程序中。</font></font><a href="#new-approach"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我意识到，如果使用[33]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的双箭头形式证明算法的正确性 
</font><font style="vertical-align:inherit">，那么证明将告诉您哪些同步操作是必要的。</font><font style="vertical-align:inherit">本文解释了如何进行。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-how-to-make"><b>How to Make a Correct Multiprocess Program
   Execute Correctly on a Multiprocessor</b><br><i>IEEE Transactions on
   Computers 46</i>, 7 (July 1997), 779-782.&nbsp; Also appeared as
   SRC Research Report&nbsp;96.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-how-to-make.pdf">PDF</a>
<br><font size="-2">Copyright © 1997 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


This paper was inspired by Kourosh Gharachorloo's
thesis.&nbsp; The problem he addressed was how to execute a multiprocess
program on a computer whose memory did not provide sequential
consistency (see <a href="#multi">[35]</a>), but instead required explicit
synchronization operations (such as Alpha's memory barrier
instruction).&nbsp; He presented a method for deducing what synchronization
operations had to be added to a program.&nbsp; I realized that, if one
proved the correctness of an algorithm using the two-arrow formalism of 
<a href="#new-approach">[33]</a>, the proof would tell you what synchronization
operations were necessary.&nbsp; This paper explains how.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="substitution"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">替代：句法与语义</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">SRC 技术说明 1998-004（1998 年 3 月）。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">被信息处理信件</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝</font><font style="vertical-align:inherit">。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/substitution.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/substitution.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/substitution.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我发现 TLA 中一个微妙且有些丑陋的部分涉及</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Enabled</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">谓词中的替换。</font><font style="vertical-align:inherit">在谓词
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Enabled A中，对</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">A</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的已启动变量进行隐式量化</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">因此，数学替换不会分布在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Enabled</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">运算符上。</font><font style="vertical-align:inherit">这篇长达四页的注释解释了大多数程序逻辑中都会出现同样的问题，因为顺序组合（分号）运算符中也存在隐式量化，因此替换不会分布在分号上。</font><font style="vertical-align:inherit">显然，之前没有人注意到这一点，因为他们没有尝试使用编程逻辑来完成 TLA 中很容易完成的事情。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="substitution"><b>Substitution: Syntactic versus Semantic</b><br>SRC Technical
Note 1998-004 (March 1998).&nbsp; Rejected by <i>Information
Processing Letters</i>.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/substitution.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/substitution.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/substitution.pdf">PDF</a><hr>


What I find to be the one subtle and somewhat ugly part of TLA
involves substitution in <i>Enabled</i> predicates.&nbsp; In the predicate
<i>Enabled&nbsp;A</i>, there is an implicit quantification
over the primed variables in <i>A</i>.&nbsp; Hence, mathematical
substitution does not distribute over the <i>Enabled</i> operator.&nbsp;
This four-page note explains that the same problem arises in most
program logics because there is also an implicit quantification in the
sequential-composition (semicolon) operator, so substitution does not
distribute over semicolon.&nbsp; Apparently, no one had noticed this before
because they hadn't tried using programming logics to do the sort of
things that are easy to do in TLA.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-paxos"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">兼职议会</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 计算机系统交易 16</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（1998 年 5 月）, 133-169。</font><font style="vertical-align:inherit">也以 SRC 研究报告 49 的形式出现。这篇论文于 1990 年首次提交，创下了发表延迟的个人记录，此后被</font></font></a><a href="#buridan"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[60]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">打破。</font></font><br>
<a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1998 由 Association for Computer Machinery, Inc. 允许免费制作部分或全部本作品的数字或硬拷贝供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">名为Echo 的</font></i><font style="vertical-align:inherit">


容错文件系统</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">于 80 年代末在 SRC 建成。</font><font style="vertical-align:inherit">构建者声称，尽管存在任何数量的非拜占庭错误，它将保持一致性，并且如果大多数处理器正常工作，就会取得进展。</font><font style="vertical-align:inherit">与大多数此类系统一样，当没有出现任何问题时，它非常简单，但有一个复杂的算法来处理基于实现者能想到的所有情况的故障处理。</font><font style="vertical-align:inherit">我认为他们想要做的事情是不可能的，并开始证明这一点。</font><font style="vertical-align:inherit">相反，我发现了本文中描述的 Paxos 算法。</font><font style="vertical-align:inherit">该算法的核心是三阶段共识协议。</font><font style="vertical-align:inherit">Dale Skeen 似乎是第一个认识到需要采用三相协议来避免在出现任意单一故障时发生阻塞的人。</font><font style="vertical-align:inherit">然而，据我所知，&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我曾经认为并且仍然认为 Paxos 是一种重要的算法。</font><font style="vertical-align:inherit">通过与拜占庭将军描述共识问题，我成功地普及了共识问题，受到启发，我决定以古希腊岛屿上的议会的形式来构建该算法。</font><font style="vertical-align:inherit">Leo Guibas 建议命名为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Paxos</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于岛屿。</font><font style="vertical-align:inherit">我向希腊立法者提供了在该领域工作的计算机科学家的名字，并在吉巴斯的帮助下音译成伪造的希腊方言。</font><font style="vertical-align:inherit">（彼得·拉德金提出了这个标题。）写一个失落的文明让我能够消除无趣的细节，并通过说议会协议的一些细节已经丢失来表明概括。</font><font style="vertical-align:inherit">为了进一步加深这个形象，我以印第安纳琼斯式的考古学家的形象做了几次讲座，戴着斯泰森帽和酒壶。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我试图在这个主题中加入一些幽默，但失败了。</font><font style="vertical-align:inherit">参加我讲座的人记得印第安纳·琼斯，但不记得算法。</font><font style="vertical-align:inherit">阅读这篇论文的人们显然被希腊寓言所吸引，以至于他们不理解该算法。</font><font style="vertical-align:inherit">我将这篇论文寄给了南希·林奇 (Nancy Lynch)、瓦索斯·哈吉拉科斯 (Vassos Hadzilacos) 和菲尔·伯恩斯坦 (Phil Bernstein)，这些人声称已经读过它。</font><font style="vertical-align:inherit">几个月后，我通过电子邮件向他们提出了以下问题：
 </font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
您能否实现一个分布式数据库，该数据库可以容忍任意数量的进程（可能是所有进程）的故障而不失去一致性，并且当超过一半的进程再次正常工作时将恢复正常行为？
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
他们没有人注意到这个问题和 Paxos 算法之间有任何联系。&nbsp;

</font></font><p><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我在 1990 年向TOCS</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

提交了这篇论文。</font><font style="vertical-align:inherit">三位审稿人都说这篇论文还算有趣，虽然不是很重要，但所有 Paxos 的东西都必须删除。</font><font style="vertical-align:inherit">我对这个领域的每个人似乎都没有幽默感感到非常恼火，所以我对这篇论文没有做任何事情。</font><font style="vertical-align:inherit">几年后，SRC 的几个人需要用于他们正在构建的分布式系统的算法，而 Paxos 正好提供了他们所需要的。</font><font style="vertical-align:inherit">我把论文交给他们阅读，他们没有任何问题。</font><font style="vertical-align:inherit">以下是 Chandu Thekkath 在 SRC 上对 Paxos 历史的描述。&nbsp;
 </font></font></p><blockquote><p><font style="vertical-align:inherit"></font><a href="https://dl.acm.org/doi/10.1145/237090.237157"><font style="vertical-align:inherit"><font style="vertical-align:inherit">当 Ed Lee 和我在Petal</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
上工作时， 
 </font><font style="vertical-align:inherit">
我们需要某种提交协议来确保分布式系统中的全局操作在服务器出现故障的情况下正确完成。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们了解 3PC，并研究了 Bernstein、Hadzilacos 和 Goodman 的著作《数据库系统中的并发控制和恢复》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中对其的描述</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我们发现该协议有点难以理解，因此放弃了实现它的尝试。</font><font style="vertical-align:inherit">大约在这个时候，迈克·施罗德（Mike Schroeder）告诉我们莱斯利·兰波特（Leslie Lamport）发明的共识协议，并建议我们向他询问。</font><i><font style="vertical-align:inherit">莱斯利给了埃德一份兼职议会</font></i><font style="vertical-align:inherit">的副本</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">技术报告，我们都喜欢阅读。</font><font style="vertical-align:inherit">我特别喜欢它的幽默，直到今天，我仍无法理解为什么人们不喜欢这份技术报告。</font><font style="vertical-align:inherit">Paxos 拥有我们系统所需的所有必要属性，并且我们认为我们可以实现它。</font><font style="vertical-align:inherit">据我所知，Leslie 还提供了必要的咨询帮助，这导致了 Paxos 算法（包括动态重新配置）的首次实现。</font><font style="vertical-align:inherit">一年后，当我们需要为 
 </font></font><a href="https://dl.acm.org/doi/10.1145/268998.266694"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Frangipani 文件系统</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">提供分布式锁服务器时
，我们再次使用 Paxos。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
所以，我想也许是时候再次尝试出版它了。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">与此同时，这个悲惨故事中的一个例外是巴特勒·兰普森（Butler Lampson），他立即理解了该算法的重要性。</font><font style="vertical-align:inherit">他在讲座和论文中提到了这一点，南希·林奇对此很感兴趣。</font><font style="vertical-align:inherit">De Prisco、Lynch 和 Lampson 发布了他们的规范和证明版本。</font><font style="vertical-align:inherit">他们的论文更清楚地表明我是时候发表我的论文了。</font><i><font style="vertical-align:inherit">于是，我向当时的TOCS</font></i><font style="vertical-align:inherit">编辑 Ken Birman 求婚了</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，他发布了它。</font><font style="vertical-align:inherit">他建议对其进行修改，或许添加算法的 TLA 规范。</font><font style="vertical-align:inherit">但重读这篇论文让我相信，算法的描述和证明虽然不是我今天要写的，但足够精确和严格。</font><font style="vertical-align:inherit">诚然，该论文需要修改，以考虑到这几年发表的工作。</font><font style="vertical-align:inherit">作为继续开玩笑和节省自己工作的一种方式，我建议不要写修订版，而是将其作为最近重新发现的手稿出版，并由基思·马祖洛 (Keith Marzullo) 进行注释。</font><font style="vertical-align:inherit">马祖洛愿意，伯曼也同意，论文终于出现了。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

对此有一个有趣的排版脚注。</font><font style="vertical-align:inherit">为了衬托 Marzullo 的注释，我决定将它们打印在灰色背景上。</font><font style="vertical-align:inherit">ACM 最近购买了一些出色的新型排版软件，而 TOCS 不接受可拍照的副本。</font><font style="vertical-align:inherit">不幸的是，他们出色的新软件无法进行着色。</font><font style="vertical-align:inherit">因此，我必须为阴影文本提供可用于相机的副本。</font><font style="vertical-align:inherit">此外，他们出色的软件只能接受浮动数字形式的副本，因此 Marzullo 的注释没有出现在应有的位置。</font><font style="vertical-align:inherit">此外，他们无疑昂贵的软件无法排版严肃的数学。</font><font style="vertical-align:inherit">（毕竟，这是一本计算期刊，所以为什么他们必须排版公式？）因此，我必须为 A2 节中不变量的定义提供可拍照的副本，</font><font style="vertical-align:inherit">他们将其插入到已发布的版本中，如图 3 所示。</font><font style="vertical-align:inherit">因此，该图中的字体与论文其余部分的字体不匹配。&nbsp;


</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
该论文于 2012 年荣获 ACM SIGOPS 名人堂奖。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-paxos"><b>The Part-Time Parliament</b><br><i>ACM Transactions
   on Computer Systems 16</i>, 2 (May 1998), 133-169.&nbsp; Also appeared as
   SRC Research Report&nbsp;49.&nbsp; This paper was first 
   submitted in 1990, setting a personal record for publication delay
   that has since been broken by </a><a href="#buridan">[60]</a>.<br>
<a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-paxos.pdf">PDF</a>
<br><font size="-2">Copyright © 1998 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


A fault-tolerant file system called <i>Echo</i> was built at SRC in
the late 80s.&nbsp; The builders claimed that it would maintain consistency
despite any number of non-Byzantine faults, and would make progress if
any majority of the processors were working.&nbsp; As with most such
systems, it was quite simple when nothing went wrong, but had a
complicated algorithm for handling failures based on taking care of
all the cases that the implementers could think of.&nbsp; I decided that
what they were trying to do was impossible, and set out to prove it.&nbsp;
Instead, I discovered the Paxos algorithm, described in this paper.&nbsp;
At the heart of the algorithm is a three-phase consensus protocol.&nbsp;
Dale Skeen seems to have been the first to have recognized the need
for a three-phase protocol to avoid blocking in the presence of an
arbitrary single failure.&nbsp; However, to my knowledge, Paxos contains
the first three-phase commit algorithm that is a real algorithm, with
a clearly stated correctness condition and a proof of correctness.&nbsp;

<p> 

I thought, and still think, that Paxos is an important algorithm.&nbsp;
Inspired by my success at popularizing the consensus problem by
describing it with Byzantine generals, I decided to cast the algorithm
in terms of a parliament on an ancient Greek island.&nbsp; Leo Guibas
suggested the name <i>Paxos</i> for the island.&nbsp; I gave the Greek
legislators the names of computer scientists working in the field,
transliterated with Guibas's help into a bogus Greek dialect.&nbsp; (Peter
Ladkin suggested the title.)&nbsp; Writing about a lost civilization
allowed me to eliminate uninteresting details and indicate
generalizations by saying that some details of the parliamentary
protocol had been lost.&nbsp; To carry the image further, I gave a few
lectures in the persona of an Indiana-Jones-style archaeologist,
replete with Stetson hat and hip flask.&nbsp;

</p><p> 

My attempt at inserting some humor into the subject was a dismal
failure.&nbsp; People who attended my lecture remembered Indiana Jones, but
not the algorithm.&nbsp; People reading the paper apparently got so
distracted by the Greek parable that they didn't understand the
algorithm.&nbsp; Among the people I sent the paper to, and who claimed to
have read it, were Nancy Lynch, Vassos Hadzilacos, and Phil Bernstein.&nbsp;
A couple of months later I emailed them the following question:
 </p><blockquote><p> 
Can you implement a distributed database that can tolerate the failure
of any number of its processes (possibly all of them) without losing
consistency, and that will resume normal behavior when more than half
the processes are again working properly?
 </p></blockquote>
None of them noticed any connection between this question and the
Paxos algorithm.&nbsp;

<p> 

I submitted the paper to <i>TOCS</i> in 1990.&nbsp; All three referees said
that the paper was mildly interesting, though not very important, but
that all the Paxos stuff had to be removed.&nbsp; I was quite annoyed at
how humorless everyone working in the field seemed to be, so I did
nothing with the paper.&nbsp; A number of years later, a couple of people
at SRC needed algorithms for distributed systems they were building,
and Paxos provided just what they needed.&nbsp; I gave them the paper to
read and they had no problem with it.&nbsp; Here is Chandu Thekkath's
account of the history of Paxos at SRC.&nbsp;
 </p><blockquote><p> 
When Ed Lee and I were working on 
 <a href="https://dl.acm.org/doi/10.1145/237090.237157">Petal</a>
we needed some sort of commit protocol to make sure global operations
in the distributed system completed correctly in the presence of
server failures.&nbsp; We knew about 3PC and studied a description of it in
Bernstein, Hadzilacos, and Goodman's book <i>Concurrency Control and
Recovery in Database Systems</i>.&nbsp; We found the protocol a bit difficult
to understand and therefore abandoned our attempts at implementing it.&nbsp;
At around this time, Mike Schroeder told us about a protocol for
consensus that Leslie Lamport had invented and suggested we ask him
about it.&nbsp; Leslie gave Ed a copy of the <i>Part-Time Parliament</i> tech
report, which we both enjoyed reading.&nbsp; I particularly liked its
humour and to this day, cannot understand why people don't like that
tech report.&nbsp; Paxos had all the necessary properties we wanted for our
system and we figured we could implement it.&nbsp; Leslie provided
essential consulting help as well, which resulted in the first
implementation of the Paxos algorithm (including dynamic
reconfiguration) as far as I am aware.&nbsp; A year later, when we needed a
distributed lock server for the 
 <a href="https://dl.acm.org/doi/10.1145/268998.266694">Frangipani file system</a>
we used Paxos again.&nbsp;
 </p></blockquote>
So, I thought that maybe the
time had come to try publishing it again.&nbsp;

<p> Meanwhile, the one exception in this dismal tale was
Butler Lampson, who immediately understood the algorithm's
significance.&nbsp; He mentioned it in lectures and in a paper, and he
interested Nancy Lynch in it.&nbsp; De Prisco, Lynch, and Lampson published
their version of a specification and proof.&nbsp; Their papers made it more
obvious that it was time for me to publish my paper.&nbsp; So, I proposed
to Ken Birman, who was then the editor of <i>TOCS</i>, that he publish
it.&nbsp; He suggested revising it, perhaps adding a TLA specification of
the algorithm.&nbsp; But rereading the paper convinced me that the
description and proof of the algorithm, while not what I would write
today, was precise and rigorous enough.&nbsp; Admittedly, the paper needed
revision to take into account the work that had been published in the
intervening years.&nbsp; As a way of both carrying on the joke and saving
myself work, I suggested that instead of my writing a revision, it be
published as a recently rediscovered manuscript, with annotations by
Keith Marzullo.&nbsp; Marzullo was willing, Birman agreed, and the paper
finally appeared.&nbsp;

</p><p> 

There was an amusing typesetting footnote to this.&nbsp; To set off
Marzullo's annotations, I decided that they should be printed on a
gray background.&nbsp; ACM had recently acquired some wonderful new
typesetting software, and TOCS was not accepting camera-ready copy.&nbsp;
Unfortunately, their wonderful new software could not do shading.&nbsp; So,
I had to provide camera-ready copy for the shaded text.&nbsp; Moreover, their
brilliant software could accept this copy only in floating figures, so
Marzullo's annotations don't appear quite where they should.&nbsp;
Furthermore, their undoubtedly expensive software wasn't up to
typesetting serious math.&nbsp; (After all, it's a computing journal, so
why should they have to typeset formulas?)  Therefore, I had to provide
the camera-ready copy for the definitions of the invariants in section
A2, which they inserted as Figure 3 in the published version.&nbsp; So, the
fonts in that figure don't match those in the rest of the paper.&nbsp;


</p><p>
This paper won an ACM SIGOPS Hall of Fame Award in 2012.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="cohen-tlareduction"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 的缩减</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Ernie Cohen 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">CONCUR'98 并发理论</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，David Sangiorgi 和 Robert de Simone 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 1466 号，(1998)，317-331。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1998 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


归约是一种通过推理粗粒度模型（即具有较大原子动作的模型）来推导系统属性的方法。</font><font style="vertical-align:inherit">归约可能首先被非正式地用于推理多进程程序，以证明使用最粗略的模型（其中每个原子操作仅访问单个共享变量）的合理性。</font><font style="vertical-align:inherit">术语</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">减少</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">由理查德·利普顿（Richard Lipton）创造，他发表了有关该主题的第一篇论文。</font><font style="vertical-align:inherit">传统上，简化结果基于这样的论点：简化（粗粒度）模型在某种意义上与原始模型等效。</font><font style="vertical-align:inherit">对于终止仅产生结果的程序，等效仅意味着产生相同的结果。</font><font style="vertical-align:inherit">但对于反应式程序来说，很难确切地确定等价的含义。</font><font style="vertical-align:inherit">TLA 让我第一次理解了原始系统和简化系统之间的精确关系。</font><a href="#lamport-reduction-tlanote"><font style="vertical-align:inherit">在[95]</font></a><font style="vertical-align:inherit">中</font></font><a href="#lamport-reduction-tlanote"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，我证明了安全规范的结果，该结果推广了标准约简定理。</font><font style="vertical-align:inherit">这一结果将归约表述为与原始规范和简化规范相关的时间定理，即作为个体行为的属性。</font><font style="vertical-align:inherit">这个公式使得扩展结果来处理活性变得很简单，但直到 1996 年末我才开始研究扩展。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">与此同时，厄尼·科恩（Ernie Cohen）一直致力于使用克林代数进行约简，获得了安全属性良好、通用结果的优雅证明。</font><font style="vertical-align:inherit">我向他展示了 TLA 版本和我对活性的初步结果，我们决定合作。</font><font style="vertical-align:inherit">这篇论文就是结果。</font><font style="vertical-align:inherit">我们将他更一般的安全性结果转化为 TLA，并获得了活性特性的新结果。</font><font style="vertical-align:inherit">该论文承诺在以后的论文中提供完整的证明和更普遍的结果。</font><font style="vertical-align:inherit">结果是存在的，但后来的论文不太可能出现。</font><font style="vertical-align:inherit">完整校样的草稿可作为 
 </font></font><a href="http://lamport.azurewebsites.net/pubs/reduction-proof.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">、
 </font></font><a href="http://lamport.azurewebsites.net/pubs/reduction-proof.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩的 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">或
 </font></font><a href="http://lamport.azurewebsites.net/pubs/reduction-proof.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">pdf</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">文件提供。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="cohen-tlareduction"><b>Reduction in TLA</b>&nbsp; (with Ernie
   Cohen)<br><i>CONCUR'98 Concurrency Theory</i>, David Sangiorgi and Robert
   de Simone editors.&nbsp; Lecture Notes in Computer Science, number 1466,
   (1998), 317-331.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/cohen-tlareduction.pdf">PDF</a>
<br><font size="-2">Copyright 
1998 by Springer-Verlag.</font><hr>


Reduction is a method of deducing properties of a system by reasoning
about a coarser-grained model--that is, one having larger atomic
actions.&nbsp; Reduction was probably first used informally for reasoning
about multiprocess programs to justify using the coarsest model in
which each atomic operation accesses only a single shared variable.&nbsp;
The term <i>reduction</i> was coined by Richard Lipton, who published
the first paper on the topic.&nbsp; Reduction results have traditionally
been based on an argument that the reduced (coarser-grained) model is
in some sense equivalent to the original.&nbsp; For terminating programs
that simply produce a result, equivalence just means producing the
same result.&nbsp; But for reactive programs, it has been difficult to pin
down exactly what equivalence means.&nbsp; TLA allowed me for the first
time to understand the precise relation between the original and the
reduced systems.&nbsp; In <a href="#lamport-reduction-tlanote">[95]</a>, I proved a
result for safety specifications that generalized the standard
reduction theorems.&nbsp; This result formulated reduction as a temporal
theorem relating the original and reduced specifications--that is, as
a property of individual behaviors.&nbsp; This formulation made it
straightforward to extend the result to handle liveness, but I didn't
get around to working on the extension until late in 1996.&nbsp;

<p> Meanwhile, Ernie Cohen had been working on reduction using
Kleene algebra, obtaining elegant proofs of nice, general results for
safety properties.&nbsp; I showed him the TLA version and my preliminary
results on liveness, and we decided to collaborate.&nbsp; This paper is the
result.&nbsp; We translated his more general results for safety into TLA
and obtained new results for liveness properties.&nbsp; The paper promises
a complete proof and a more general result in a later paper.&nbsp; The
result exists, but the later paper is unlikely ever to appear.&nbsp;
A draft of the complete proof is available
as a 
 <a href="http://lamport.azurewebsites.net/pubs/reduction-proof.ps">Postscript</a>,
 <a href="http://lamport.azurewebsites.net/pubs/reduction-proof.ps.Z">compressed Postscript</a>, or
 <a href="http://lamport.azurewebsites.net/pubs/reduction-proof.pdf">pdf</a> file.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="lamport-composition"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">组合：使证明更困难的方法</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">组合性：显着差异（COMPOS'97 研讨会论文集）</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Willem-Paul de Roever、Hans Langmaack 和 Amir Pnueli 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 1536 号，(1998)，402-423。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-composition.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-composition.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-composition.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1998 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


系统很复杂。</font><font style="vertical-align:inherit">我们通过用更简单的组件构建它们来控制它们的复杂性。</font><font style="vertical-align:inherit">这表明，要掌握系统推理的复杂性，我们应该证明各个组件的属性，然后组合这些属性来推断整个系统的属性。</font><font style="vertical-align:inherit">在并发系统中，组件的明显选择是进程。</font><font style="vertical-align:inherit">因此，组合推理意味着从系统过程的属性中推断出系统的属性。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我长期以来一直觉得整个方法相当愚蠢。</font><font style="vertical-align:inherit">您不会通过首先设计各个进程然后希望将它们放在一起来保证互斥来设计互斥算法。</font><font style="vertical-align:inherit">同样，任何试图从通过孤立地考虑过程所证明的属性中推论出互斥的人都知道，这是解决问题的错误方法。</font><font style="vertical-align:inherit">您可以通过找到全局不变量来证明互斥，然后证明每个进程的操作都保持该不变量。</font><font style="vertical-align:inherit">TLA使整个推理过程完全数学化——推理的规范是数学公式，证明正确性意味着证明单个数学公式。</font><font style="vertical-align:inherit">数学证明本质上是分解的：&nbsp; 

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">本文解释了为什么传统的组合推理只是一种特殊的、高度受限的分解证明的方式。</font><font style="vertical-align:inherit">在大多数情况下，这不是一种非常自然的方式，并且会导致额外的工作。</font><font style="vertical-align:inherit">如果这项额外的工作可以由计算机完成，那么它就是合理的。</font><font style="vertical-align:inherit">特别是，如果各个流程足够简单，可以通过模型检查进行验证，那么沿流程进行分解就有意义。</font><font style="vertical-align:inherit">TLA 特别适合这样做，因为如</font></font><a href="#lamport-eye-of-beholder"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[120]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">所示，它在选择流程的构成方面具有很大的灵活性。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-composition"><b>Composition: A Way to Make Proofs
   Harder</b><br><i>Compositionality: The Significant Difference
   (Proceedings of the COMPOS'97 Symposium)</i>, Willem-Paul de Roever, Hans
   Langmaack, and Amir Pnueli editors.&nbsp; Lecture Notes in Computer
   Science, number 1536, (1998), 402-423.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-composition.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-composition.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-composition.pdf">PDF</a>
<br><font size="-2">Copyright 
1998 by Springer-Verlag.</font><hr>


Systems are complicated.&nbsp; We master their complexity by building them
from simpler components.&nbsp; This suggests that to master the complexity
of reasoning about systems, we should prove properties of the separate
components and then combine those properties to deduce properties of
the entire system.&nbsp; In concurrent systems, the obvious choice of
component is the process.&nbsp; So, compositional reasoning has come to
mean deducing properties of a system from properties of its processes.&nbsp;

<p> I have long felt that this whole approach is rather silly.&nbsp;
You don't design a mutual exclusion algorithm by first designing the
individual processes and then hoping that putting them together
guarantees mutual exclusion.&nbsp; Similarly, anyone who has tried to deduce
mutual exclusion from properties proved by considering the processes
in isolation knows that it's the wrong way to approach the problem.&nbsp;
You prove mutual exclusion by finding a global invariant, and then
showing that each process's actions maintains the invariant.&nbsp; TLA
makes the entire reasoning process completely mathematical--the
specifications about which one reasons are mathematical formulas, and
proving correctness means proving a single mathematical formula.&nbsp; A
mathematical proof is essentially decompositional: you apply a
deduction rule to reduce the problem of proving a formula to that of
proving one or more simpler formulas.&nbsp; 

</p><p> This paper explains why traditional compositional
reasoning is just one particular, highly constrained way of
decomposing the proof.&nbsp; In most cases, it's not a very natural way and
results in extra work.&nbsp; This extra work is justified if it can
be done by a computer.&nbsp; In particular, decomposition along processes
makes sense if the individual processes are simple enough to be
verified by model checking.&nbsp; TLA is particularly good for doing
this because, as illustrated by <a href="#lamport-eye-of-beholder">[120]</a>,
it allows a great deal of flexibility in choosing what constitutes
a process.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="lamport-possibility"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">证明可能性属性</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学 206，1-2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，（1998 年 10 月），341-352。</font><font style="vertical-align:inherit">还出现为 SRC 研究报告 137。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 1998 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


人们永远不想将可能性属性断言为系统的正确性属性。</font><font style="vertical-align:inherit">知道一个系统
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可能会这样做并不有趣</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">给出正确答案。</font><font style="vertical-align:inherit">您想知道它永远不会产生错误的答案（安全性）并且它最终会产生答案（活性）。</font><font style="vertical-align:inherit">通常，可能性属性用于无法表达活跃性的分支时间逻辑。</font><font style="vertical-align:inherit">如果你不能表达系统必须做某事的活性属性，​​你至少可以表明系统可能会做这件事。</font><font style="vertical-align:inherit">特别是，过程代数通常可以表达安全性，但不能表达活跃性。</font><font style="vertical-align:inherit">但是，不执行任何操作的琐碎系统会实现任何安全属性，因此过程代数学家通常通过要求互模拟来排除此类琐碎的实现，这意味着该实现允许与规范相同的所有可能行为。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

人们有时认为可能性属性很重要，通过使用自然语言的歧义来尝试将活跃性属性转变为可能性属性。</font><font style="vertical-align:inherit">例如，他们可能会说银行 ATM 的用户应该可以从他的帐户中提取资金。</font><font style="vertical-align:inherit">然而，经过仔细检查，您不仅仅希望这是可能的。</font><font style="vertical-align:inherit">（如果中等大小的陨石击中了 ATM 机，即使没有账户，我也可以从 ATM 机上取款。）真正的条件是，如果用户按下正确的按钮序列，那么他必须收到钱。&nbsp;


</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

由于没有理由证明系统的可能性属性，我很惊讶地从 Bob Kurshan（一个非常通情达理的人）那里得知，他经常使用模型检查器来验证可能性属性。</font><font style="vertical-align:inherit">与他交谈时，我意识到，虽然验证可能性属性不会告诉您有关系统的任何有趣信息，但它可以告诉您有关规范的一些有趣信息，即系统的数学模型。</font><font style="vertical-align:inherit">例如，您不需要指定用户可以点击 ATM 上的按钮，因为您指定的是 ATM，而不是用户。</font><font style="vertical-align:inherit">但是，我们不会推理用户与 ATM 的交互；而是会推理用户与 ATM 的交互。</font><font style="vertical-align:inherit">我们对用户和 ATM 的数学模型进行推理。</font><font style="vertical-align:inherit">如果在该数学模型中按钮不可能被按下，那么该模型就是错误的。</font><font style="vertical-align:inherit">证明可能性属性可以对规范进行健全性检查。</font><font style="vertical-align:inherit">因此，我写了这篇论文，解释如何使用 TLA 来证明规范的可能性属性——尽管像 TLA 这样的线性时间时序逻辑无法表达可能性的概念。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">我最初将这篇论文提交给另一本期刊。</font><font style="vertical-align:inherit">然而，编辑坚持认为，为了发表这篇论文，我必须添加关于分支时间逻辑与线性时间逻辑的优点的讨论。</font><font style="vertical-align:inherit">我坚信，编辑的工作是评判作者写的论文，而不是让他写编辑希望他写的论文。</font><font style="vertical-align:inherit">于是，我向主编求助。</font><font style="vertical-align:inherit">几个月没有收到回复后，我撤回了论文并提交给</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">TCS</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="lamport-possibility"><b>Proving Possibility
   Properties</b><br><i>Theoretical Computer Science 206</i>, 1-2, (October
   1998), 341-352.&nbsp; Also appeared as SRC Research
   Report&nbsp;137.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-possibility.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 1998.</font><hr>


One never wants to assert possibility properties as correctness
properties of a system.&nbsp; It's not interesting to know that a system
<i>might</i> produce the correct answer.&nbsp; You want to know that it
will never produce the wrong answer (safety) and that it eventually
will produce an answer (liveness).&nbsp; Typically, possibility properties
are used in branching-time logics that cannot express liveness.&nbsp; If
you can't express the liveness property that the system must do
something, you can at least show that the system might do it.&nbsp; In
particular, process algebras typically can express safety but not
liveness.&nbsp; But the trivial system that does nothing implements any
safety property, so process algebraists usually rule out such trivial
implementations by requiring bisimulation--meaning that the
implementation allows all the same possible behaviors as the
specification.&nbsp;

<p>

People sometimes argue that possibility properties are important by
using the ambiguities of natural language to try to turn a liveness
property into a possibility property.&nbsp; For example, they may say that
it should be possible for the user of a bank's ATM to withdraw money
from his account.&nbsp; However, upon closer examination, you don't just
want this to be possible.&nbsp; (It's possible for me to withdraw money
from an ATM, even without having an account, if a medium-sized
meteorite hits it.)&nbsp; The real condition is that, if the user presses
the right sequence of buttons, then he must receive the money.&nbsp;


</p><p> 

Since there is no reason to prove possibility properties of a system,
I was surprised to learn from Bob Kurshan--a very reasonable
person--that he regularly uses his model checker to verify
possibility properties.&nbsp; Talking to him, I realized that although
verifying possibility properties tells you nothing interesting about a
system, it can tell you something interesting about a specification,
which is a mathematical model of the system.&nbsp; For example, you don't
need to specify that a user can hit a button on the ATM, because
you're specifying the ATM, not the user.&nbsp; However, we don't reason
about a user interacting with the ATM; we reason about a mathematical
model of the user and the ATM.&nbsp; If, in that mathematical
model, it were impossible for the button to be pushed, then the model
would be wrong.&nbsp; Proving possibility properties can provide sanity
checks on the specification.&nbsp; So, I wrote this paper explaining how
you can use TLA to prove possibility properties of a
specification--even though a linear-time temporal logic like TLA
cannot express the notion of possibility.&nbsp;

</p><p> I originally submitted this paper to a different journal.&nbsp;
However, the editor insisted that, to publish the paper, I had to add
a discussion about the merits of branching-time versus linear-time
logic.&nbsp; I strongly believe that it's the job of an editor to judge the
paper that the author wrote, not to get him to write the paper that
the editor wants him to.&nbsp; So, I appealed to the editor-in-chief.&nbsp;
After receiving no reply for several months, I withdrew the paper and
submitted it to <i>TCS</i>.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="ladkin-gerth"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA 中的惰性缓存证明</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Peter Ladkin、Bryan Olivier 和 Denis Roegel 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 12</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2/3, (1999), 151-174。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1999 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在一些聚会上（我相信这是我演讲的研讨会
</font></font><a href="#abadi-decomposing"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[104]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">），Rob Gerth 告诉我，他正在整理 Afek、Brown 和 Merritt 的惰性缓存算法的证明集合。</font><font style="vertical-align:inherit">我认为这是一个展示 TLA 优点的好机会，因此应该有一个 TLA 解决方案。</font><font style="vertical-align:inherit">特别是，我想表明证明是一项简单的工程任务，不需要任何新的理论。</font><font style="vertical-align:inherit">我想写一个完全正式的、高度详细的结构化证明，但我不想自己做所有那些枯燥的工作。</font><font style="vertical-align:inherit">因此，我招募了拉德金、奥利维尔（当时是阿姆斯特丹保罗·维塔尼的研究生）和罗格尔（当时是南锡多米尼克·梅里的研究生），并将任务分配给他们。</font><font style="vertical-align:inherit">然而，编写规范和证明是一个不断完善的过程，直到一切都正确地组合在一起。</font><font style="vertical-align:inherit">在远程协作中完成这项工作并不容易，在写出完整的证明之前，我们已经厌倦了整个工作。</font><font style="vertical-align:inherit">然而，我们已经做了足够的工作来写这篇论文，其中包含规范和证明的高级概述。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="ladkin-gerth"><b>A Lazy Caching Proof in TLA</b>&nbsp; (with Peter Ladkin, Bryan
   Olivier, and Denis Roegel)<br><i>Distributed Computing 12</i>, 2/3,
   (1999), 151-174.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/ladkin-gerth.pdf">PDF</a>
<br><font size="-2">Copyright 
1999 by Springer-Verlag.</font><hr>


At some gathering (I believe it was the workshop where I presented
<a href="#abadi-decomposing">[104]</a>), Rob Gerth told me that he was compiling a
collection of proofs of the lazy caching algorithm of Afek, Brown, and
Merritt.&nbsp; I decided that this was a good opportunity to demonstrate
the virtues of TLA, so there should be a TLA solution.&nbsp; In particular,
I wanted to show that the proof is a straightforward engineering task,
not requiring any new theory.&nbsp; I wanted to write a completely formal,
highly detailed structured proof, but I didn't want to do all that
dull work myself.&nbsp; So, I enlisted Ladkin, Olivier (who was then a
graduate student of Paul Vitanyi in Amsterdam), and Roegel (who was
then a graduate student of Dominique Mery in Nancy), and divided the
task among them.&nbsp; However, writing a specification and proof is a
process of continual refinement until everything fits together right.&nbsp;
Getting this done in a long-distance collaboration is not easy, and we
got tired of the whole business before a complete proof was written.&nbsp;
However, we had done enough to write this paper, which contains
specifications and a high-level overview of the proof.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-spec-tla-plus"><b><font style="vertical-align:inherit"></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+计算系统设计</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">指定并发系统</font></b><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">M. Broy 和 R. Steinbrüggen，编辑。</font><font style="vertical-align:inherit">IOS 出版社，阿姆斯特丹，（1999），183-247。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1998 年，我受邀在 Marktoberdorf 暑期学校演讲。</font><font style="vertical-align:inherit">我接受的一个原因是我正在写一本关于并发的书，我可以使用这本书的前几章作为我的讲义。</font><font style="vertical-align:inherit">然而，我决定把那本书放在一边（也许永远），转而写一本关于 TLA+ 的书。</font><font style="vertical-align:inherit">为此，我能够从原始笔记中回收很多材料。</font></font><a href="#tla+-book"><font style="vertical-align:inherit"><font style="vertical-align:inherit">对于该课程的正式出版笔记，我决定提供这个，它是[145]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">前几章的初稿</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-spec-tla-plus"><b>Specifying Concurrent Systems with
   TLA+</b><br><i>Calculational System Design</i>.&nbsp; M. Broy and R.&nbsp;
   Steinbrüggen, editors.&nbsp; IOS Press, Amsterdam,
   (1999), 183-247.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-spec-tla-plus.pdf">PDF</a><hr>


I was invited to lecture at the 1998 Marktoberdorf summer school.&nbsp; One
reason I accepted was that I was in the process of writing a book on
concurrency, and I could use the early chapters of the book as my
lecture notes.&nbsp; However, I decided to put aside (perhaps forever) that
book and instead write a book on TLA+.&nbsp; I was able to
recycle much material from my original notes for the purpose.&nbsp; For the
official volume of published notes for the course, I decided to
provide this, which is a preliminary draft of the first several
chapters of <a href="#tla+-book">[145]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="fm99"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 缓存一致性协议验证</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Homayoon Akhiani 等人合作）被</font><i><font style="vertical-align:inherit">正式方法 '99</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝 
 </font><font style="vertical-align:inherit"> 
 （1999 年 2 月）。</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/fm99.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fm99.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fm99.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Mark Tuttle、Yuan Yu 和我在康柏组建了一个小组，应用 TLA 来解决验证问题。</font><font style="vertical-align:inherit">我们有其他合作者的两个主要项目是对两个多处理器 Alpha 架构的协议进行验证。</font><font style="vertical-align:inherit">我们认为写一篇论文来描述我们在行业中进行验证的经验是个好主意。</font><font style="vertical-align:inherit">FM'99 会议有一个工业应用轨道，其中包括“可能描述在实践中应用正式方法的案例研究或工业项目的经验报告”。</font><font style="vertical-align:inherit">所以，我们写了这篇论文并提交了。</font><font style="vertical-align:inherit">结果被拒绝了。</font><font style="vertical-align:inherit">一位审稿人写道：“这篇论文与其说是一篇科学论文，不如说是一篇经验报告。” </font><font style="vertical-align:inherit">我们的论文确实缺乏细节，</font><font style="vertical-align:inherit">因为当时这两个系统都还没有发布，而且几乎所有有关它的信息仍然是公司机密。</font><font style="vertical-align:inherit">然而，我认为如果您对工业界发生的事情感兴趣，它仍然值得一读。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="fm99"><b>TLA+ Verification of Cache-Coherence
  Protocols</b>&nbsp; (with Homayoon Akhiani et al.)<br>Rejected from 
 <i>Formal Methods&nbsp;'99</i> 
 (February 1999).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/fm99.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fm99.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fm99.pdf">PDF</a><hr>


Mark Tuttle, Yuan Yu, and I formed a small group applying TLA to
verification problems at Compaq.&nbsp; Our two major projects, in which we
have had other collaborators, have been verifications of protocols for
two multiprocessor Alpha architectures.&nbsp; We thought it would be a good
idea to write a paper describing our experience doing verification in
industry.&nbsp; The FM'99 conference had an Industrial Applications track,
to include "Experience reports [that] might describe a case study or
industrial project where a formal method was applied in practice."
So, we wrote this paper and submitted it.&nbsp; It was rejected.&nbsp; One of
the referees wrote, "The paper is rather an experience report than a
scientific paper." Our paper is indeed short on details, since
neither system had been released at that time and almost all
information about it was still company confidential.&nbsp; However, I think
it still is worth reading if you're interested in what goes on in the
industrial world.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-types"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">应该输入您的规范语言吗？</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Larry Paulson 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《ACM 编程语言和系统汇刊》21</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3（1999 年 5 月）502-526。</font><font style="vertical-align:inherit">也作为 SRC 研究报告 147 出现。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-types.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-types.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-types.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 1999 Association for Computer Machinery, Inc。允许免费制作部分或全部本作品的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1995 年，我写了一篇谩骂，题为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《被认为有害的类型》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">它认为，尽管类型对于编程语言来说是有好处的，但它们对于形式化数学来说却是一种糟糕的方式。</font><font style="vertical-align:inherit">这意味着它们不利于规范和验证，而规范和验证应该是数学而不是编程。</font><font style="vertical-align:inherit">我的笔记显然引起了一些讨论，大多数人不同意。</font><font style="vertical-align:inherit">我认为通过发布它来促进更广泛的讨论可能会很有趣，而</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">TOPLAS</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">对我来说，这是显而易见的地方。</font><font style="vertical-align:inherit">当时的主编安德鲁·阿佩尔（Andrew Appel）很赞成这个想法，所以我提交了它。</font><font style="vertical-align:inherit">我的一些论点并不是非常合理，因为我对类型论几乎一无所知。</font><font style="vertical-align:inherit">审稿人的态度相当严厉，但阿佩尔认为发布修订版并附上反驳仍然是个好主意。</font><font style="vertical-align:inherit">我建议，如果我和审稿人合作写一篇平衡的文章来展示问题的双方，那就更好了。</font><font style="vertical-align:inherit">两名裁判同意匿名参加。</font><font style="vertical-align:inherit">拉里·保尔森是裁判之一。</font><font style="vertical-align:inherit">很快我就发现保尔森和我无法与另一位狂热的职业裁判一起工作。</font><font style="vertical-align:inherit">（有一次，他将自己的处境比作新纳粹分子要求某人将自己的名字写在一份关于种族主义的“平衡”论文上。）所以，</font><font style="vertical-align:inherit">保尔森和我自己写了这篇论文。</font><font style="vertical-align:inherit">我们预计另一位裁判会写下反驳意见，但他显然从未这样做过。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-types"><b>Should Your Specification Language Be
   Typed?</b>&nbsp; (with Larry Paulson)<br><i>ACM Transactions on Programming
   Languages and Systems 21</i>, 3 (May 1999) 502-526.&nbsp; Also
   appeared as SRC Research Report&nbsp;147.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-types.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-types.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-types.pdf">PDF</a>
<br><font size="-2">Copyright © 1999 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


In 1995, I wrote a diatribe titled <i>Types Considered Harmful</i>.&nbsp;
It argued that, although types are good for programming languages,
they are a bad way to formalize mathematics.&nbsp; This implies that they
are bad for specification and verification, which should be
mathematics rather than programming.&nbsp; My note apparently provoked some
discussion, mostly disagreeing with it.&nbsp; I thought it might be fun to
promote a wider discussion by publishing it, and <i>TOPLAS</i> was,
for me, the obvious place.&nbsp; Andrew Appel, the editor-in-chief at the
time, was favorably disposed to the idea, so I submitted it.&nbsp; Some of
my arguments were not terribly sound, since I know almost nothing
about type theory.&nbsp; The referees were suitably harsh, but Appel felt
it would still be a good idea to publish a revised version along with
rebuttals.&nbsp; I suggested that it would be better if I and the referees
cooperated on a single balanced article presenting both sides of the
issue.&nbsp; The two referees agreed to shed their anonymity and
participate.&nbsp; Larry Paulson was one of the referees.&nbsp; It soon became
apparent that Paulson and I could not work with the other referee, who
was rabidly pro-types.&nbsp; (At one point, he likened his situation to
someone being asked by a neo-Nazi to put his name on a "balanced"
paper on racism.)&nbsp; So, Paulson and I wrote the paper by ourselves.&nbsp; We
expected that the other referee would write a rebuttal, but he
apparently never did.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="yuanyu-model-checking"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">模型检查 TLA+ 规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Yuan Yu 和 Panagiotis Manolios 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">正确
   </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的硬件设计和验证方法 (CHARME '99)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Laurence Pierre 和 Thomas Kropf 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 1703 期，Springer-Verlag，（1999 年 9 月）54-66。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 1999 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


尽管我警告他这是不可能的，袁宇还是为 TLA+ 规范编写了一个模型检查器。</font><font style="vertical-align:inherit">他的成功超出了我最乐观的希望。</font><font style="vertical-align:inherit">本文是关于模型检查器的初步报告。</font><font style="vertical-align:inherit">在 Yu 的坚持下，我成为了一名作家，因为我给了他一些关于模型检查器设计的建议（比不做更有用的建议）。</font><font style="vertical-align:inherit">Manolios 在 SRC 作为暑期实习生，贡献了论文中描述的状态压缩算法，但最终没有在模型检查器中使用。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="yuanyu-model-checking"><b>Model Checking TLA+
   Specifications</b>&nbsp; (with Yuan Yu and Panagiotis Manolios)<br>In
   <i>Correct Hardware Design and Verification Methods (CHARME '99)</i>,
   Laurence Pierre and Thomas Kropf editors.&nbsp; Lecture Notes in Computer
   Science, number 1703, Springer-Verlag, (September 1999) 54-66.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/yuanyu-model-checking.pdf">PDF</a>
<br><font size="-2">Copyright 
1999 by Springer-Verlag.</font><hr>


Despite my warning him that it would be impossible, Yuan Yu wrote a
model checker for TLA+ specifications.&nbsp; He succeeded
beyond my most optimistic hopes.&nbsp; This paper is a preliminary report
on the model checker.&nbsp; I was an author, at Yu's insistence, because I
gave him some advice on the design of the model checker (more useful
advice than just don't do it).&nbsp; Manolios worked at SRC as a summer
intern and contributed the state-compression algorithm that is
described in the paper, but which ultimately was not used in the model
checker.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-latex-interview"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">(La)TeX 如何改变 Mathematics Mitteilungen </font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">der Deutschen Mathematiker-Vereinigung 1/2000</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> (Jan 2000) 49-51。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Günther Ziegler 通过电子邮件采访了我，撰写了这篇文章，深入探讨了 LaTeX 的历史。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-latex-interview"><b>How (La)TeX changed the face of
   Mathematics</b><br><i>Mitteilungen der Deutschen Mathematiker-Vereinigung
   1/2000</i> (Jan 2000) 49-51.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-latex-interview.pdf">PDF</a><hr>


Günther Ziegler interviewed me by email for this note, which
delves into the history of LaTeX.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lamport-fairness"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">公平和超公平</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 13</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 4 (2000), 239-245。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">也出现为 SRC 研究报告 152。本文的初步版本被Concur</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;99</font><font style="vertical-align:inherit">拒绝。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩的 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2000 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1993年，Attie、Francez和Grumberg发表了一篇题为“
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">多方交互中的公平性和超公平性”</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的论文。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是 Apt、Francez 和 Katz 于 1988 年发表的论文《评估分布式编程语言的公平性》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">的后续文章</font><font style="vertical-align:inherit">，该论文试图定义公平性。</font><font style="vertical-align:inherit">我长期以来一直认为，公​​平的唯一合理的形式定义是机器封闭，这本质上是 Apt、Francez 和 Katz 提到的条件之一。</font><font style="vertical-align:inherit">（他们称之为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可行性</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">并将其表述为语言的条件，而不是单个规范。）我参考了 Attie、Francez 和 Grumberg 的论文，发现它相当无趣，因为它似乎完全依赖于语言。</font><font style="vertical-align:inherit">它们显然属于 70 年代末和 80 年代初流行的学派，该学派将并发等同于 CSP 编程结构。</font><font style="vertical-align:inherit">我对那篇论文写了一篇相当不友善的评论，但这显然并没有阻止它的发表。</font><font style="vertical-align:inherit">多年后，我突然意识到超公平有一个与语言无关的定义——或者更准确地说，一个与语言无关的概念似乎与他们对某一类 CSP 程序的定义一致。</font><font style="vertical-align:inherit">我发表这篇论文有三个原因：</font><font style="vertical-align:inherit">解释超公平的新定义；</font><font style="vertical-align:inherit">再次解释公平就是机器关闭，并搁置Apt、Francez和Katz的另外两个公平标准条件；</font><font style="vertical-align:inherit">并且，在某种程度上，弥补我对阿蒂、弗朗西斯和格鲁伯格论文的不友善评论。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lamport-fairness"><b>Fairness and Hyperfairness</b><br><i>Distributed 
Computing 13</i>, 4 (2000), 239-245.&nbsp; Also appeared as
SRC Research 
  Report&nbsp;152.&nbsp; 
    A preliminary version of this paper 
   was rejected by <i>Concur</i>&nbsp;99.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/lamport-fairness.pdf">PDF</a>
<br><font size="-2">Copyright 
2000 by Springer-Verlag.</font><hr>


In 1993, Attie, Francez, and Grumberg published a paper titled
<i>Fairness and Hyperfairness in Multi-Party Interactions</i>.&nbsp; This
was a follow-up to the 1988 paper <i>Appraising Fairness in
Languages for Distributed Programming</i> by Apt, Francez, and Katz,
which attempted to define fairness.&nbsp; I have long believed that the
only sensible formal definition of fairness is machine closure, which
is essentially one of the conditions mentioned by Apt, Francez, and
Katz.&nbsp; (They called it <i>feasibility</i> and phrased it as a
condition on a language rather than on an individual specification.)&nbsp;
I refereed the Attie, Francez, and Grumberg paper and found it rather
uninteresting because it seemed to be completely language-dependent.&nbsp;
They apparently belonged to the school, popular in the late 70s and
early 80s, that equated concurrency with the CSP programming
constructs.&nbsp; I wrote a rather unkind review of that paper, which
obviously didn't prevent its publication.&nbsp; Years later, it suddenly
struck me that there was a language-independent definition of
hyperfairness--or more precisely, a language-independent notion that
seemed to coincide with their definition on a certain class of CSP
programs.&nbsp; I published this paper for three reasons: to explain the
new definition of hyperfairness; to explain once again that fairness
is machine closure and put to rest the other two fairness criteria
conditions of Apt, Francez, and Katz; and, in some small way, to make
up for my unkind review of the Attie, Francez, and Grumberg paper.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="www9"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">网页档案参考</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">第九届国际万维网会议：海报会议记录（2000 年 5 月），第 74 页..</font></font><br></a><a href="https://www9.org/final-posters/poster52.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">网页</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


有几次，我不得不引用已发表文章中的网页。</font><font style="vertical-align:inherit">问题在于，文章在图书馆书架上保留了数十年，而 URL 却是众所周知的短暂性。</font><font style="vertical-align:inherit">WWW9 上的这张简短的海报描述了我的一个小技巧，即通过比 URL 更持久的东西来引用网页。</font><font style="vertical-align:inherit">它涉及在页面中嵌入一个唯一的字符串，并解释文档如何告诉人们搜索该字符串，而无需实际将该字符串放入文档中。</font><font style="vertical-align:inherit">不幸的是，会议发布的版本缺少 gif 文件。</font></font><a href="http://lamport.azurewebsites.net/tla/www9.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">提供带有 gif 的版本
 </font><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是一个可爱的想法，不需要基础设施，任何人都可以使用它。</font><font style="vertical-align:inherit">不幸的是，破坏者很快就入侵了网络，并且凭借破坏街道标志的人的聪明才智，他们在许多其他网页上放置了这样的字符串。</font><font style="vertical-align:inherit">幸运的是，网络搜索引擎已经变得更好，并且可以简单地为网页提供描述性标题。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="www9"><b>Archival References to Web Pages</b><br>Ninth 
 International World Wide Web Conference: Poster Proceedings (May 2000), 
  page 74..<br></a><a href="https://www9.org/final-posters/poster52.html">Web 
              Page</a><hr>


On several occasions, I've had to refer to a web page in a published
article.&nbsp; The problem is that articles remain on library shelves for
many decades, while URLs are notoriously transitory.&nbsp; This short
poster at WWW9 describes a little trick of mine for referring to a web
page by something more permanent than a URL.&nbsp; It involved
embedding a unique string in the page, along with an explanation of
how a document could tell people to search for that string without
actually putting the string in the document.&nbsp; Unfortunately, the
version posted by the conference is missing a gif file.&nbsp; A
version with the gif is available
 <a href="http://lamport.azurewebsites.net/tla/www9.html">here</a>.&nbsp;

<p>It was a lovely idea that required no infrastructure and
anyone could just use it.&nbsp; Unfortunately, vandals soon invaded the Web
and, with the intellectual sophistication of people who deface
street signs, they put such a string on lots of other web pages.&nbsp;
Fortunately, web search engines have gotten better and web pages can
simply be given descriptive titles.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="disk-paxos"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">磁盘 Paxos</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp; （与 Eli Gafni 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 16</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (2003) 1-20。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/disk-paxos.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/disk-paxos.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/disk-paxos.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2003 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


1998 年，DEC 存储团队的 Jim Reuter 要求我为他们正在设计的处理器和磁盘网络提供领导者选举算法。</font><font style="vertical-align:inherit">问题的新问题是，他们希望只有两个处理器的系统能够在任一处理器发生故障时继续运行。</font><font style="vertical-align:inherit">我们可以假设系统至少有三个磁盘，因此我们的想法是找到一种通过复制磁盘而不是处理器来实现容错的算法。</font><font style="vertical-align:inherit">我说服他们，他们不需要领导者选举协议，而是分布式状态机实现（参见</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）。</font><font style="vertical-align:inherit">当时，Eli Gafni 正在加州大学洛杉矶分校休假，并在 SRC 担任顾问。</font><font style="vertical-align:inherit">我们一起提出了本文中描述的算法，它是
</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]的 Paxos 算法的基于磁盘的版本</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

Gafni 设计了该算法的初始版本，它看起来不太像 Paxos。</font><font style="vertical-align:inherit">当我们研究出细节时，它演变成现在的形式。</font><font style="vertical-align:inherit">加夫尼想要一篇关于算法的论文沿着算法开发的路径，从他的基本思想出发，通过一系列的变换得出最终版本。</font><font style="vertical-align:inherit">我们就这样写出了论文的第一个版本。</font><font style="vertical-align:inherit">然而，当我试图使其变得严格时，我发现转换步骤并不像看起来那么简单。</font><font style="vertical-align:inherit">我发现最终的论文并不令人满意，但我们还是将其提交给 PODC'99，但被拒绝了。</font><font style="vertical-align:inherit">然后加夫尼愿意让我按照自己的方式做，我就把论文变成了现在的形式。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

论文发表几年后，Mauro J. Jaskelioff 在 Isabelle/HOL 中对证明进行了编码并进行了机械检查。</font><font style="vertical-align:inherit">他发现了大约十几个小错误。</font><font style="vertical-align:inherit">由于我一直建议将 Disk Paxos 作为并发算法机械验证的测试示例，因此我决定不再更新论文来纠正他发现的错误。</font><font style="vertical-align:inherit">任何写出经过严格机械检查的证明的人都会找到它们。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="disk-paxos"><b>Disk Paxos</b>&nbsp; (with Eli Gafni)<br><i>Distributed 
Computing 16</i>, 1 (2003) 1-20.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/disk-paxos.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/disk-paxos.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/disk-paxos.pdf">PDF</a>
<br><font size="-2">Copyright 
2003 by Springer-Verlag.</font><hr>


In 1998, Jim Reuter of DEC's storage group asked me for a
leader-election algorithm for a network of processors and disks that
they were designing.&nbsp; The new wrinkle to the problem was that they
wanted a system with only two processors to continue to operate if
either processor failed.&nbsp; We could assume that the system had at least
three disks, so the idea was to find an algorithm that achieved fault
tolerance by replicating disks rather than processors.&nbsp; I convinced
them that they didn't want a leader-election protocol, but rather a
distributed state-machine implementation (see <a href="#time-clocks">[27]</a>).&nbsp;
At the time, Eli Gafni was on sabbatical from UCLA and was consulting
at SRC.&nbsp; Together, we came up with the algorithm described
in this paper, which is a disk-based version of the Paxos algorithm of
<a href="#lamport-paxos">[123]</a>.&nbsp;

<p> 

Gafni devised the initial version of the algorithm, which didn't look
much like Paxos.&nbsp; As we worked out the details, it evolved into its
current form.&nbsp; Gafni wanted a paper on the algorithm to follow the
path with which the algorithm had been developed, starting from his
basic idea and deriving the final version by a series of
transformations.&nbsp; We wrote the first version of the paper in this way.&nbsp;
However, when trying to make it rigorous, I found that the
transformation steps weren't as simple as they had appeared.&nbsp; I found
the resulting paper unsatisfactory, but we submitted it anyway to
PODC'99, where it was rejected.&nbsp; Gafni was then willing to let me do
it my way, and I turned the paper into its current form.&nbsp;

</p><p>

A couple of years after the paper was published, Mauro J. Jaskelioff
encoded the proof in Isabelle/HOL and mechanically checked it.&nbsp; He
found about a dozen small errors.&nbsp; Since I have been proposing Disk
Paxos as a test example for mechanical verification of concurrent
algorithms, I have decided not to update the paper to correct the
errors he found.&nbsp; Anyone who writes a rigorous mechanically-checked
proof will find them.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="disk-paxos-disc"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Disk Paxos（会议版本）</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp; （与 Eli Gafni 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算：第 14 届国际会议，DISC 2000</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Maurice Herlihy，编辑。</font><font style="vertical-align:inherit">计算机科学讲义，编号 1914，Springer-Verlag，(2000) 330-344。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2000 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#disk-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[135]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的删节会议版本</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="disk-paxos-disc"><b>Disk Paxos (Conference Version)</b>&nbsp; (with Eli
Gafni)<br><i>Distributed Computing: 14th International Conference,
DISC 2000</i>, Maurice Herlihy, editor. Lecture Notes in Computer Science
number 1914, Springer-Verlag, (2000) 330-344.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/disk-paxos-disc.pdf">PDF</a>
<br><font size="-2">Copyright 
2000 by Springer-Verlag.</font><hr>


This is the abridged conference version of <a href="#disk-paxos">[135]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="when-mutex"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">正确的互斥算法何时保证互斥</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Sharon Perl 和 William Weihl 合作）</font></font><br>
  <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《信息处理快报》76、3</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（2000 年 3 月）、131-134。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/when-mutex.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/when-mutex.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/when-mutex.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Elsevier Science 2000 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


互斥通常定义为两个进程不</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">同时</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">处于其临界区。</font><font style="vertical-align:inherit">Dan Scales 在一次谈话中所说的一些话让我突然意识到传统的互斥算法不满足这个属性。</font><font style="vertical-align:inherit">然后我猜想如何满足这个性质，Perl 和 Weihl 证明了我的猜想是正确的。</font><font style="vertical-align:inherit">本文在不到五页的时间内解释了为什么以前没有实现互斥，以及如何实现互斥。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="when-mutex"><b>When Does a Correct Mutual Exclusion Algorithm
  Guarantee Mutual Exclusion</b>&nbsp; (with Sharon Perl and William Weihl)<br>
  <i>Information Processing Letters 76</i>, 3 (March 2000),
   131-134.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/when-mutex.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/when-mutex.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/when-mutex.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Elsevier Science 2000.</font><hr>


Mutual exclusion is usually defined to mean that two processes are not
in their critical section <i>at the same time</i>.&nbsp; Something Dan
Scales said during a conversation made me suddenly realize that
conventional mutual exclusion algorithms do not satisfy that property.&nbsp;
I then conjectured how that property could be satisfied, and Perl and
Weihl proved that my conjecture was correct.&nbsp; This paper explains why
mutual exclusion had not previously been achieved, and how to achieve
it--all in less than five pages.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="consensus-bounds"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">共识下限</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表的说明（2000 年 3 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇短文的摘要是这样描述的：
   </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
   我们得出了非阻塞容错共识算法所需的消息数量和消息延迟数量的下限，并且我们证明了 Paxos 算法的变体达到了这些界限。&nbsp;
   </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
我把它发给了 Idit Keidar，他告诉我我导出的界限已经知道了，所以我忘了它。</font><font style="vertical-align:inherit">大约一年后，她提到她在以下内容中引用了该注释：
   </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
伊迪特·凯达尔和塞尔吉奥·拉杰斯鲍姆。</font><font style="vertical-align:inherit">关于无故障时容错共识的成本 - 教程。</font><font style="vertical-align:inherit">麻省理工学院技术报告 MIT-LCS-TR-821，2001 年 5 月 24 日。SIGACT News 32(2) 中的初步版本，分布式计算专栏，第 45-63 页，2001 年 6 月（5 月 15 日发布）。&nbsp;
   </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
然后我问如果结果已经知道，他们为什么要引用我的笔记。</font><font style="vertical-align:inherit">她回应， 
   </font></font><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
文献中有一些结果相似但不相同，因为它们考虑的模型或问题略有不同。</font><font style="vertical-align:inherit">这是许多人困惑的根源。</font><font style="vertical-align:inherit">Sergio 和我编写了本教程，以便将不同的已知结果整合在一起。</font><font style="vertical-align:inherit">希望它能帮助澄清问题。&nbsp;
   </font></font></p></blockquote>


<br>&nbsp;<p></p></li><li> <a name="consensus-bounds"><b>Lower Bounds on Consensus</b><br>unpublished note
(March 2000).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/consensus-bounds.pdf">PDF</a><hr>


This short note is described by its abstract:
   <blockquote><p> 
   We derive lower bounds on the number of messages and the number of
   message delays required by a nonblocking fault-tolerant consensus
   algorithm, and we show that variants of the Paxos algorithm achieve
   those bounds.&nbsp;
   </p></blockquote>
I sent it to Idit Keidar who told me that the bounds I derived were
already known, so I forgot about it.&nbsp; About a year later, she mentioned
that she had cited the note in:
   <blockquote><p> 
Idit Keidar and Sergio Rajsbaum.&nbsp;
 On the Cost of Fault-Tolerant Consensus When There Are No Faults - A Tutorial.&nbsp;
 MIT Technical Report MIT-LCS-TR-821, May 24 2001.&nbsp;
 Preliminary version in SIGACT News 32(2), Distributed Computing
 column, pages 45-63, June 2001 (published in May 15th).&nbsp;
   </p></blockquote>
I then asked why they had cited my note if the results were already known.&nbsp;
She replied, 
   <blockquote><p> 
There are a few results in the literature that are similar, but not
identical, because they consider slightly different models or
problems.&nbsp; This is a source of confusion for many people. Sergio and I
wrote this tutorial in order to pull the different known results
together. Hopefully, it can help clarify things up.&nbsp;
   </p></blockquote>


<br>&nbsp;<p></p></li><li> <a name="wildfire-challenge"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">野火挑战问题</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Madhu Sharma、Mark Tuttle 和 Yuan Yu）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">
   被 CAV 2001 拒绝（2001 年 1 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


 从 1996 年秋末到 1997 年夏初，Mark Tuttle、Yuan Yu 和我致力于对代号为 Wildfire 的计算机的缓存一致性协议进行规范和验证。</font><font style="vertical-align:inherit">我们与 Wildfire 的设计师之一 Madhu Sharma 密切合作。</font><font style="vertical-align:inherit">我们编写了协议的详细规范以及它应该实现的内存模型的规范。</font><font style="vertical-align:inherit">然后我们证明了各种性质，但没有尝试完整的证明。</font><font style="vertical-align:inherit">2000 年初，Madhu、Mark 和我编写了该协议的高级抽象版本的规范。&nbsp; 

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

该协议中有一个细节让我印象特别微妙。</font><font style="vertical-align:inherit">我的想法是发布一个不正确的规范版本，并省略该细节，作为验证社区的挑战问题。</font><font style="vertical-align:inherit">我这样做了，并于 2000 年 6 月将其发布  
</font></font><a href="http://lamport.azurewebsites.net/tla/wildfire-challenge.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">到网上</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。为了进一步传播该问题，我们为 CAV（计算机辅助验证）会议编写了该问题的描述。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="wildfire-challenge"><b>The Wildfire Challenge Problem</b>&nbsp; (with Madhu 
   Sharma, Mark Tuttle, and Yuan Yu)<br>
   Rejected from CAV 2001 (January 2001).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/wildfire-challenge.pdf">PDF</a><hr>


 From late fall 1996 through early summer 1997, Mark Tuttle, Yuan Yu,
and I worked on the specification and verification of the
cache-coherence protocol for a computer code-named Wildfire.&nbsp; We
worked closely with Madhu Sharma, one of Wildfire's designers.&nbsp; We
wrote a detailed specification of the protocol as well as a
specification of the memory model that it was supposed to implement.&nbsp;
We then proved various properties, but did not attempt a complete
proof.&nbsp; In early 2000, Madhu, Mark, and I wrote a specification of a
higher-level abstract version of the protocol.&nbsp; 

<p> 

There was one detail of the protocol that struck me as particularly
subtle.&nbsp; I had the idea of publishing an incorrect version of the
specification with that detail omitted as a challenge problem for the
verification community.&nbsp; I did that and put it  
<a href="http://lamport.azurewebsites.net/tla/wildfire-challenge.html">on
the Web</a> in June, 2000.&nbsp; To further disseminate the problem, we
wrote this description of it for the CAV (Computer Aided Verification)
conference.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="paxos-simple"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Paxos 变得简单</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGACT 新闻（分布式计算专栏）32</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 4（整数 121，2001 年 12 月）51-58。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩 Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 2001 Association for Computer Machinery, Inc。允许免费制作本作品的部分或全部的数字或硬拷贝以供个人或课堂使用，前提是制作或分发副本不是为了盈利或商业利益，并且副本在首页上附有此通知和完整引文。</font><font style="vertical-align:inherit">必须尊重 ACM 以外的其他人拥有的本作品组件的版权。</font><font style="vertical-align:inherit">允许以信用方式提取。</font><font style="vertical-align:inherit">以其他方式复制、重新发布、在服务器上发布或重新分发到列表，需要事先获得特定许可和/或付费。</font><font style="vertical-align:inherit">请向 ACM Inc. 出版部申请许可，传真：+1 (212) 869-0481，或发送电子邮件至 Permissions@acm.org。</font><font style="vertical-align:inherit">本文的最终版本可以在 ACM 的数字图书馆 --http://www.acm.org/dl/ 中找到。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 PODC 2001 会议上，我厌倦了每个人都说理解 Paxos 算法有多么困难，该算法发表在
</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。</font><font style="vertical-align:inherit">尽管人们对伪希腊名字如此着迷，以至于发现这篇论文很难理解，但算法本身非常简单。</font><font style="vertical-align:inherit">因此，我在会议上围住了几个人，并在没有论文的情况下向他们口头解释了该算法。</font><font style="vertical-align:inherit">当我回到家时，我把解释写成了一个简短的笔记，后来我根据弗雷德·施奈德和巴特勒·兰普森的评论进行了修改。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">当前版本有 13 页长，并且不包含比n</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 1 &gt; </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">n</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2更复杂的公式</font><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
2015 年，亚马逊的 Michael Deardeuff 告诉我，这篇论文中的一个句子含糊不清，错误的解释会导致算法不正确。</font><font style="vertical-align:inherit">Deardeuff 发现 Github 上的许多 Paxos 实现都实现了这个错误的算法。</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">显然，实现者没有费心去阅读[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中算法的精确描述 
 </font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我不会消除这种歧义或透露它在哪里。</font><font style="vertical-align:inherit">散文并不是精确描述算法的方式。&nbsp;
  </font></font><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">不要尝试实现本文中的算法。</font><font style="vertical-align:inherit">请改用</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font></b>



<br>&nbsp;</p><p></p></li><li> <a name="paxos-simple"><b>Paxos Made Simple</b><br><i>ACM SIGACT News
(Distributed Computing Column) 32</i>, 4 (Whole Number 121, December
2001) 51-58.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/paxos-simple.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/paxos-simple.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/paxos-simple.pdf">PDF</a>
<br><font size="-2">Copyright © 2001 by the Association for Computing Machinery, Inc.Permission to make digital or hard copies of part 
or all of this work for personal or classroom use
is granted without fee provided that copies are
not made or distributed for profit or commercial
advantage and that copies bear this notice and
the full citation on the first page.  Copyrights
for components of this work owned by others than
ACM must be honored.  Abstracting with credit is
permitted.  To copy otherwise, to republish, to
post on servers, or to redistribute to lists,
requires prior specific permission and/or a fee.
Request permissions from Publications Dept, ACM
Inc., fax +1 (212) 869-0481, or
permissions@acm.org.  The definitive version of
this paper can be found at ACM's Digital Library
--http://www.acm.org/dl/.
</font><hr>


At the PODC 2001 conference, I got tired of everyone saying how
difficult it was to understand the Paxos algorithm, published in
<a href="#lamport-paxos">[123]</a>.&nbsp; Although people got so hung up in the
pseudo-Greek names that they found the paper hard to understand, the
algorithm itself is very simple.&nbsp; So, I cornered a couple of people at
the conference and explained the algorithm to them orally, with no
paper.&nbsp; When I got home, I wrote down the explanation as a short note,
which I later revised based on comments from Fred Schneider and Butler
Lampson.&nbsp; The current version is 13 pages long, and contains no
formula more complicated than <i>n</i>1 &gt; <i>n</i>2.&nbsp;

<p> 
In 2015, Michael Deardeuff of Amazon informed me that one
sentence in this paper is ambiguous, and interpreting it the wrong way
leads to an incorrect algorithm.&nbsp; Deardeuff found
that a number of Paxos implementations on Github implemented
this incorrect algorithm.&nbsp; Apparently, the implementors did not bother
to read the precise description of the algorithm in 
 <a href="#lamport-paxos">[123]</a>.&nbsp;
I am not going to remove this ambiguity or reveal where it is.&nbsp; Prose
is not the way to precisely describe algorithms.&nbsp;
  <b>Do not try to implement the algorithm
from this paper.&nbsp; Use <a href="#lamport-paxos">[123]</a> instead.</b>



<br>&nbsp;</p><p></p></li><li> <a name="spec-and-verifying"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 指定和验证系统</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 John Matthews、Mark Tuttle 和 Yuan Yu）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">第十届 ACM SIGOPS 欧洲研讨会论文集（2002 年），45-48。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这描述了我们在 DEC/Compaq 在多个系统（主要是缓存一致性协议）上使用 TLA+ 和 TLC 模型检查器的经验。</font></font><a href="#fm99"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它比[129]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">更短并且更新</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="spec-and-verifying"><b>Specifying and Verifying Systems with 
  TLA+</b>&nbsp; (with John Matthews, Mark Tuttle, and Yuan Yu)<br>Proceedings 
   of the Tenth ACM SIGOPS European Workshop (2002), 45-48.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/spec-and-verifying.pdf">PDF</a><hr>


This describes our experience at DEC/Compaq using TLA+
and the TLC model checker on several systems, mainly cache-coherence
protocols.&nbsp; It is shorter than, and more up-to-date
than <a href="#fm99">[129]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="arbiter-free"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">无仲裁器</font></font></b><br>
<i><font style="vertical-align:inherit"><font style="vertical-align:inherit">同步分布式计算 16</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2/3, (2003) 219-237。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/arbiter-free.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/arbiter-free.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/arbiter-free.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2003 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"></font><a href="#bakery"><font style="vertical-align:inherit"><font style="vertical-align:inherit">通过[12]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的烘焙算法</font><font style="vertical-align:inherit">，我发现互斥以及所有传统的同步问题都可以通过简单的读/写寄存器来解决。</font><a href="#glitch"><font style="vertical-align:inherit">然而，正如[22]</font></a><font style="vertical-align:inherit">的描述中所述</font></font><a href="#glitch"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，这样的寄存器需要一个仲裁器。</font><font style="vertical-align:inherit">这就引出了一个问题：没有仲裁器可以解决哪些同步问题？</font><font style="vertical-align:inherit">早期，我设计了一种更原始​​的共享寄存器，可以在没有仲裁器的情况下实现，并且我弄清楚了如何使用此类寄存器解决生产者/消费者问题。</font><font style="vertical-align:inherit">我认为从事自定时电路工作的硬件设计人员可能已经知道生产者/消费者同步可以在没有仲裁器的情况下实现。</font><font style="vertical-align:inherit">（如果没有，他们一定是在我做的同时发现了这一点。）硬件人员使用 Muller C 元素而不是我的共享寄存器，但对他们来说我在做什么是显而易见的。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

在 Petri 网中，仲裁明确表现为冲突。</font><font style="vertical-align:inherit">Anatol Holt 和 Fred Commoner 在 70 年代初研究了一类称为标记图的 Petri 网，它是语法上无冲突的最大一类 Petri 网。</font><font style="vertical-align:inherit">标记图同步是生产者/消费者同步的自然概括。</font><font style="vertical-align:inherit">我很清楚，标记图同步可以在没有仲裁器的情况下实现，尽管我从未费心写下精确的算法。</font><font style="vertical-align:inherit">我假设标记的图准确地描述了无需仲裁器即可解决的同步问题类别。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

对于像 Anatol Holt 和 Chuck Seitz 这样熟悉多进程同步、Petri 网和仲裁器问题的人来说，标记图同步可以在没有仲裁器的情况下实现，这无疑是显而易见的。</font><font style="vertical-align:inherit">然而，这样的人是一个正在消亡的品种。</font><font style="vertical-align:inherit">所以，我想我应该在这个结果丢失之前把它写下来。</font><i><font style="vertical-align:inherit">当我受邀为《分布式计算</font></i><font style="vertical-align:inherit">》特刊提交一篇文章时，我在这方面已经拖延了好几年了</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">庆祝 PODC 会议召开 20 周年。</font><font style="vertical-align:inherit">编辑们希望我用几页的篇幅来谈论分布式计算的过去和未来——但我并不想这样做。</font><font style="vertical-align:inherit">然而，我突然想到贡献一些 25 年前未发表的作品是合适的。</font><font style="vertical-align:inherit">所以，我决定写一篇关于无仲裁同步的文章。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

写这篇论文需要我弄清楚标记图的精确无仲裁器实现，这并不难。</font><font style="vertical-align:inherit">它还要求我证明我的假设，即标记图是无需仲裁者即可实现的。</font><font style="vertical-align:inherit">当我尝试时，我意识到我的假设是错误的。</font><font style="vertical-align:inherit">有些多进程同步问题无法通过标记图来描述，但无需仲裁器即可解决。</font><font style="vertical-align:inherit">问题比我想象的更复杂。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

我希望我确切地知道没有仲裁者可以做什么，但我不知道。</font><font style="vertical-align:inherit">事实证明我并不太理解无仲裁同步。</font><font style="vertical-align:inherit">缺乏理解会导致阐述混乱。</font><font style="vertical-align:inherit">我理解寄存器等效性的结果，并且我有很好、清晰的方法来形式化和证明这些结果。</font><font style="vertical-align:inherit">但论文中的其他结果却是一团糟。</font><font style="vertical-align:inherit">它们很复杂，我没有好的方法将它们形式化。</font><font style="vertical-align:inherit">如果我在二十五年前写下这篇文章，我可能会在发表任何东西之前继续研究这个问题。</font><font style="vertical-align:inherit">但我没有以前那样的时间去思考难题了。</font><font style="vertical-align:inherit">我决定最好发布我的结果，尽管它们很混乱，并希望其他人能够弄清楚如何做得更好。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="arbiter-free"><b>Arbiter-Free Synchronization</b><br>
<i>Distributed Computing 16</i>, 2/3, (2003) 219-237.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/arbiter-free.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/arbiter-free.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/arbiter-free.pdf">PDF</a>
<br><font size="-2">Copyright 
2003 by Springer-Verlag.</font><hr>


With the bakery algorithm of <a href="#bakery">[12]</a>, I discovered that mutual
exclusion, and hence all conventional synchronization problems, could
be solved with simple read/write registers.&nbsp; However, as recounted in
the description of <a href="#glitch">[22]</a>, such a register requires an
arbiter.&nbsp; This leads to the question: what synchronization problems
can be solved without an arbiter?  Early on, I devised a more
primitive kind of shared register that can be implemented without an
arbiter, and I figured out how to solve the producer/consumer problem
with such registers.&nbsp; I think that hardware designers working on
self-timed circuits probably already knew that producer/consumer
synchronization could be implemented without an arbiter.&nbsp; (If not,
they must have figured it out at about the same time I did.)&nbsp;
Hardware people used Muller C-elements instead of my shared registers,
but it would have been obvious to them what I was doing.&nbsp;

<p> 

In Petri nets, arbitration appears explicitly as conflict.&nbsp; A class of
Petri nets called marked graphs, which were studied in the early 70s
by Anatol Holt and Fred Commoner, are the largest class of Petri nets
that are syntactically conflict-free.&nbsp; Marked-graph synchronization is
a natural generalization of producer/consumer synchronization.&nbsp; It was
clear to me that marked-graph synchronization can be implemented
without an arbiter, though I never bothered writing down the precise
algorithm.&nbsp; I assumed that marked graphs describe precisely the class
of synchronization problems that could be solved without an arbiter.&nbsp;

</p><p> 

That marked-graph synchronization can be implemented without an
arbiter is undoubtedly obvious to people like Anatol Holt and Chuck
Seitz, who are familiar with multiprocess synchronization, Petri nets,
and the arbiter problem.&nbsp; However, such people are a dying breed.&nbsp; So,
I thought I should write up this result before it was lost.&nbsp; I had
been procrastinating on this for years when I was invited to submit an
article for a special issue of <i>Distributed Computing</i> celebrating
the 20th anniversary of the PODC conference.&nbsp; The editors wanted me to
pontificate for a few pages on the past and future of distributed
computing--something I had no desire to do.&nbsp; However, it occurred to
me that it would be fitting to contribute some unpublished 25-year-old
work.&nbsp; So, I decided to write about arbiter-free synchronization.&nbsp;

</p><p> 

Writing the paper required me to figure out the precise arbiter-free
implementation of marked graphs, which wasn't hard.&nbsp; It also required
me to prove my assumption that marked graphs were all one could
implement without an arbiter.&nbsp; When I tried, I realized that my
assumption was wrong.&nbsp; There are multiprocess synchronization problems
not describable by marked graphs that can be solved without an
arbiter.&nbsp; The problem was more complicated than I had realized.&nbsp;

</p><p> 

I wish I knew exactly what can be done without an arbiter, but I
don't.&nbsp; It turns out that I don't really understand arbiter-free
synchronization.&nbsp; Lack of understanding leads to messy exposition.&nbsp; I
understand the results about the equivalence of registers, and I have
nice, crisp ways of formalizing and proving these results.&nbsp; But the
other results in the paper are a mess.&nbsp; They're complicated and I
don't have a good way of formalizing them.&nbsp; Had I written this
twenty-five years ago, I would probably have kept working on the
problem before publishing anything.&nbsp; But I don't have the time I once
did for mulling over hard problems.&nbsp; I decided it was better to
publish the results I have, even though they're messy, and hope that
someone else will figure out how to do a better job.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="ds-interview"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">与 Leslie Lamport 的讨论</font></font></b><font style="vertical-align:inherit"><i><font style="vertical-align:inherit">IEEE 分布式系统在线</font></i></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">访谈3 </font><font style="vertical-align:inherit">, 8 
 </font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font></a><a href="https://dsonline.computer.org/portal/site/dsonline/menuitem.9ed3d9924aeb0dcd82ccc6716bbe36ec/index.jsp?&amp;pName=dso_level1&amp;path=dsonline/past_issues/0208/f&amp;file=lam_print_int.xml&amp;xsl=article.xsl&amp;"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（网页）</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><br>
<a href="http://lamport.azurewebsites.net/pubs/ds-interview.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 2002 允许个人使用本材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2002 年春天，Dejan Milojicic 提议为一份 IEEE 在线出版物采访我。</font><font style="vertical-align:inherit">他主动提出提前把问题发给我，事后把成绩单发给我修改。</font><font style="vertical-align:inherit">这看起来很愚蠢，所以我只是写下了我的答案。</font><font style="vertical-align:inherit">这次“采访”是通过几封电子邮件进行的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="ds-interview"><b>A 
Discussion With Leslie Lamport</b><br>An interview in <i>IEEE
Distributed Systems Online 3</i>, 8 
</a><a href="https://dsonline.computer.org/portal/site/dsonline/menuitem.9ed3d9924aeb0dcd82ccc6716bbe36ec/index.jsp?&amp;pName=dso_level1&amp;path=dsonline/past_issues/0208/f&amp;file=lam_print_int.xml&amp;xsl=article.xsl&amp;">(Web Page)</a>.<br>
<a href="http://lamport.azurewebsites.net/pubs/ds-interview.pdf">PDF</a>
<br><font size="-2">Copyright © 2002 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


In the spring of 2002, Dejan Milojicic proposed interviewing me for an
IEEE on-line publication.&nbsp; He volunteered to send me the questions in
advance, and to send me the transcript afterwards for correction.&nbsp;
This seemed pretty silly, so I just wrote my answers.&nbsp; The
"interview" was conducted by a few email exchanges.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="bertinoro"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">异步共识的下界分布式</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算的未来方向</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，André Schiper、Alex A. Shvartsman、Hakim Weatherspoon 和 Ben Y. Zhao，编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 2584 期，Springer，(2003) 22-23。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/bertinoro.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/bertinoro.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/bertinoro.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2003 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


FuDiCo（分布式计算的未来方向）研讨会在博洛尼亚郊外一座经过改建的漂亮修道院中举行。</font><font style="vertical-align:inherit">我本来应该谈论未来的方向，但克制住了我自然的武断倾向，而是提出了一些新的下限结果。</font><font style="vertical-align:inherit">组织者希望制作一本向全世界介绍分布式计算研究的未来的书，因此每个人都应该为他们的演讲写一份五页的摘要。</font><font style="vertical-align:inherit">我只用了两页。</font><font style="vertical-align:inherit">由于我没有严格证明我的结果，并且我期望发现特殊情况的例外，因此我将它们称为近似定理。</font><font style="vertical-align:inherit">这篇论文承诺未来的论文将给出定理的精确陈述和证明，以及表明边界是严格的算法。</font><font style="vertical-align:inherit">尽管我从来没有写过承诺的未来论文，这几乎是完美的记录，</font></font><a href="#lower-bound"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[154]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> . </font><font style="vertical-align:inherit">我打算有一天再写一篇论文，其中包含拜占庭案例的一般结果。</font><font style="vertical-align:inherit">真的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="bertinoro"><b>Lower Bounds for Asynchronous
Consensus</b><br><i>Future Directions in Distributed Computing</i>,
André Schiper, Alex A. Shvartsman, Hakim Weatherspoon,
and Ben Y. Zhao, editors.&nbsp; Lecture Notes in Computer Science
number 2584, Springer, (2003) 22-23.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/bertinoro.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/bertinoro.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/bertinoro.pdf">PDF</a>
<br><font size="-2">Copyright 
2003 by Springer-Verlag.</font><hr>


The FuDiCo (Future Directions in Distributed Computing) workshop was
held in a lovely converted monastery outside Bologna.&nbsp; I was supposed
to talk about future directions, but restrained my natural inclination
to pontificate and instead presented some new lower-bound results.&nbsp;
The organizers wanted to produce a volume telling the world about the
future of distributed computing research, so everyone was supposed to
write a five-page summary of their presentations.&nbsp; I used only two
pages.&nbsp; Since I didn't have rigorous proofs of my results, and I
expected to discover special-case exceptions, I called them
approximate theorems.&nbsp; This paper promises that future papers will
give precise statements and proofs of the theorems, and algorithms
showing that the bounds are tight.&nbsp; Despite my almost perfect record
of never writing promised future papers, I actually wrote up the case
of non-Byzantine failures in <a href="#lower-bound">[154]</a>.&nbsp; I intend some day
to write another paper with the general results for the Byzantine case.&nbsp;
Really.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="tla+-book"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">指定系统：硬件和软件工程师的 TLA+ 语言和工具</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Addison-Wesley (2002)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><br></a><a href="https://lamport.azurewebsites.net/tla/book.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


TLA+全书。</font><font style="vertical-align:inherit">前七章（83页）是</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的重写版本。</font><font style="vertical-align:inherit">我希望人们阅读这本书的内容以及有关 TLC 模型检查器的章节。</font><font style="vertical-align:inherit">该网页包含勘误表以及一些练习和示例。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="tla+-book"><b>Specifying Systems: The TLA+
Language and Tools for Hardware and Software Engineers</b><br><i>Addison-Wesley
(2002)</i>.<br></a><a href="https://lamport.azurewebsites.net/tla/book.html">Available On-Line</a><hr>


The complete book of TLA+.&nbsp; The first seven chapters (83
pages) are a rewritten version of <a href="#lamport-spec-tla-plus">[128]</a>.&nbsp;
That and the chapter on the TLC model checker are about as much of the
book as I expect people to read.&nbsp; The web page contains errata and
some exercises and examples.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="fmsd"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 检查缓存一致性协议</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Rajeev Joshi、John Matthews、Serdar Tasiran、Mark Tuttle 和 Yuan Yu 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">系统设计中的形式方法 22</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（2003 年 3 月）125-131。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/fmsd.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fmsd.ps.Z"><font style="vertical-align:inherit"><font style="vertical-align:inherit">压缩后记</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/fmsd.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">所有版权均由 Kluwer Academy 2003 保留。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


另一份关于康柏 TLA+ 验证活动的报告。</font></font><a href="#spec-and-verifying"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它提到了自我们编写[141]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">以来所做的一些工作
</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="fmsd"><b>Checking Cache-Coherence Protocols with
TLA+</b>&nbsp; (with Rajeev Joshi, John Matthews, Serdar Tasiran, Mark
Tuttle, and Yuan Yu)<br><i>Formal Methods in System
Design 22</i>, 2 (March 2003) 125-131.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/fmsd.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fmsd.ps.Z">Compressed Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/fmsd.pdf">PDF</a>
<br><font size="-2">All copyrights reserved by Kluwer Academic 2003.</font><hr>


Yet another report on the TLA+ verification activity at
Compaq.&nbsp; It mentions some work that's been done since we wrote
<a href="#spec-and-verifying">[141]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="high-level"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">高级规范：来自行业的经验教训</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Brannon Batson 合作）《</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">组件和对象的形式化方法》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Frank S. de Boer、Marcello M. Bonsangue、Susanne Graf 和 Willem-Paul de Roever，编辑。</font><font style="vertical-align:inherit">计算机科学讲义，第 2852 期，Springer，(2003) 242-262。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/high-level.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/high-level.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/high-level.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2003 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我受邀在 FMCO 研讨会上谈论 TLA。</font><font style="vertical-align:inherit">我觉得我没有什么新东西要说，所以我请当时在英特尔工作的布兰农·巴特森（Brannon Batson）帮我准备演讲和论文。</font><font style="vertical-align:inherit">Brannon 是一位硬件设计师，他在 Compaq 期间开始使用 TLA+，并在 Intel 继续使用它。</font><font style="vertical-align:inherit">本文最有趣的部分是第 4 节，主要介绍 Brannon 的团队如何在设计过程中使用 TLA+。</font><font style="vertical-align:inherit">第五部分的灵感来自于研讨会征稿的主题，其中的主题列表包括“面向对象”、“基于组件”和“信息隐藏”等流行术语。</font><font style="vertical-align:inherit">它解释了为什么这些概念对于高级规范来说要么不相关，要么不是一个好主意。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="high-level"><b>High-Level Specifications: Lessons from
Industry</b>&nbsp; (with Brannon Batson)<br><i>Formal Methods for Components and Objects</i>,
Frank S. de Boer, Marcello M. Bonsangue,
Susanne Graf, and Willem-Paul de Roever, editors.&nbsp; Lecture Notes in Computer Science
number 2852, Springer, (2003) 242-262.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/high-level.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/high-level.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/high-level.pdf">PDF</a>
<br><font size="-2">Copyright 
2003 by Springer-Verlag.</font><hr>


I was invited to speak about TLA at the FMCO symposium.&nbsp; I didn't feel
that I had anything new to say, so I asked Brannon Batson who was
then at Intel to
help me prepare the talk and the paper.&nbsp; Brannon is a hardware
designer who started using TLA+ while at Compaq and has
continued using it at Intel.&nbsp; The most interesting part of this paper
is Section 4, which is mainly devoted to Brannon's description of how
his group is using TLA+ in their design process.&nbsp; 

Section 5 was inspired by the symposium's call for papers, whose
list of topics included such fashionable buzzwords as
"object-oriented", "component-based", and "information hiding".&nbsp;
It explains why those concepts are either irrelevant to or are a bad
idea for high-level specification.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="future-of-computing"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算的未来：逻辑或生物学</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">2003 年 7 月 11 日在基尔 Christian Albrechts 大学发表的演讲文本。Postscript</font></font><br>
</a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.ps.gz"><font style="vertical-align:inherit"> gzipped </font></a></font><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.pdf"><font style="vertical-align:inherit"> PDF</font></a></font><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.ps.gz"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.pdf"><font style="vertical-align:inherit"></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我受邀在基尔向普通大学观众发表演讲。</font><font style="vertical-align:inherit">由于我不习惯进行这种非技术性的演讲，所以我提前写好了并阅读了它。</font><font style="vertical-align:inherit">之后，我收到了一些将其副本发布到网络上的请求。</font><font style="vertical-align:inherit">所以，就在这里。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="future-of-computing"><b>The Future of Computing: Logic or 
Biology</b><br>Text of a talk given at Christian Albrechts University, Kiel on 
11 July 2003.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/future-of-computing.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/future-of-computing.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/future-of-computing.pdf">PDF</a><hr>


I was invited to give a talk to a general university audience at Kiel.&nbsp;
Since I'm not used to giving this kind of non-technical talk, I wrote
it out in advance and read it.&nbsp; Afterwards, I received several
requests for a copy to be posted on the Web.&nbsp; So, here it is.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="paxos-commit"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">事务提交共识</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Jim Gray）</font></font><br>
 <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 数据库系统事务 31</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1 (2006), 133-160。</font><font style="vertical-align:inherit">还以 Microsoft Research 技术报告 MSR-TR-2003-96（2005 年 2 月）的形式出现。</font></font><br></a><a href="https://www.microsoft.com/en-us/research/publication/consensus-on-transaction-commit/"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在</font></font><a href="#bertinoro"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[144]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我宣布了共识问题的一些下限结果。</font><font style="vertical-align:inherit">一个结果表明，选择一个值需要两次消息延迟，并且需要相对大量的处理器来实现该界限。</font><font style="vertical-align:inherit">当仔细证明这个结果时，我意识到它需要假设可以在两个消息延迟中选择两个不同处理器提出的值。</font><font style="vertical-align:inherit">这让我意识到，如果只有一个处理器的建议值可以在两个消息延迟中选择，那么需要更少的处理器，而其他处理器建议的值需要更长的时间才能选择。</font><font style="vertical-align:inherit">事实上，对</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的 Paxos 算法进行简单修改就可以实现这一点。&nbsp;


</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

然后我寻找共识的应用程序，其中有一个特殊的提议者，其提议的值需要快速选择。</font><font style="vertical-align:inherit">我意识到有一个“杀手级应用程序”——即分布式事务提交。</font><font style="vertical-align:inherit">不要将事务提交视为选择单值</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">提交</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">或</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中止的一个共识问题</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它可以呈现为一组单独的共识问题，每个问题选择单个参与者的提交/中止愿望。</font><font style="vertical-align:inherit">然后，每个参与者都成为其中一个共识问题的特别提议者。</font><font style="vertical-align:inherit">这导致了我所说的 Paxos Commit 算法。</font><font style="vertical-align:inherit">它是一种容错（非阻塞）提交算法，我认为在正常（无故障）情况下，它的消息延迟比任何以前的算法都要少。</font><font style="vertical-align:inherit">后来我了解到 Guerraoui、Larrea 和 Schiper 在 1996 年发布的算法具有相同的正常情况行为。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

几个月后，Jim Gray 和我聚在一起尝试理解 Paxos 和传统两阶段提交协议之间的关系。</font><font style="vertical-align:inherit">经过几个小时的绞尽脑汁，我们发现两阶段提交是 Paxos 提交的简单版本，可以容忍零错误。</font><font style="vertical-align:inherit">这种认识和几个月的拖延催生了这篇论文，其中描述了两阶段提交和 Paxos 提交算法并对它们进行了比较。</font><font style="vertical-align:inherit">它还包括一个附录，其中包含事务提交问题和两种算法的 TLA+ 规范。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="paxos-commit"><b>Consensus on Transaction Commit</b>&nbsp; (with Jim Gray)<br>
 <i>ACM Transactions on Database Systems 31</i>, 1 (2006), 133-160.&nbsp;
   Also appeared as Microsoft Research 
  Technical Report MSR-TR-2003-96 (February 2005).<br></a><a href="https://www.microsoft.com/en-us/research/publication/consensus-on-transaction-commit/">Available 
  On-Line</a><hr>


In <a href="#bertinoro">[144]</a>, I announced some lower-bound results for the
consensus problem.&nbsp; One result states that two message delays are
required to choose a value, and a relatively large number of
processors are needed to achieve that bound.&nbsp; When writing a careful
proof of this result, I realized that it required the hypothesis that
values proposed by two different processors could be chosen in two
message delays.&nbsp; This led me to realize that fewer processors were
needed if there were only one processor whose proposed value could be
chosen in two message delays, and values proposed by other processors
took longer to be chosen.&nbsp; In fact, a simple modification to the Paxos
algorithm of <a href="#lamport-paxos">[123]</a> accomplished this.&nbsp;


<p>

I then looked for applications of consensus in which there is a single
special proposer whose proposed value needs to be chosen quickly.&nbsp; I
realized there is a "killer app"--namely, distributed transaction
commit.&nbsp; Instead of regarding transaction commit as one consensus
problem that chooses the single value <i>commit</i> or <i>abort</i>,
it could be presented as a set of separate consensus problems, each
choosing the commit/abort desire of a single participant.&nbsp; Each
participant then becomes the special proposer for one of the consensus
problems.&nbsp; This led to what I call the Paxos Commit algorithm.&nbsp; It is
a fault-tolerant (non-blocking) commit algorithm that I believed had
fewer message delays in the normal (failure-free) case than any
previous algorithm.&nbsp; I later learned that an algorithm published by
Guerraoui, Larrea, and Schiper in 1996 had the same normal-case
behavior.&nbsp;

</p><p>

Several months later, Jim Gray and I got together to try to understand
the relation between Paxos and the traditional Two-Phase Commit
protocol.&nbsp; After a couple of hours of head scratching, we figured out
that Two-Phase Commit is the trivial version of Paxos Commit that
tolerates zero faults.&nbsp; That realization and several months of
procrastination led to this paper, which describes the Two-Phase
Commit and Paxos Commit algorithms and compares them.&nbsp; It also
includes an appendix with TLA+ specifications of the
transaction-commit problem and of the two algorithms.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="hair"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">关于法国的头发颜色</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Ellen Gilkerson）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《不可思议的研究年鉴》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，2004 年 1 月/2 月，18-19。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/hair.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/hair.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/hair.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在法国旅行时，吉尔克森和我观察到许多金发女性，但几乎没有金发男性。</font><font style="vertical-align:inherit">由于怀疑我们偶然发现了一项非凡的科学发现，我们忍受了几周的艰辛，走访了法国的小旅馆和餐馆收集数据。</font><font style="vertical-align:inherit">经过几年的分析和严格的拖延，我们写了这篇论文。</font><font style="vertical-align:inherit">我们的大部分精彩散文都被编辑无情地删掉了，为不太重要的研究留下空间。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="hair"><b>On Hair Color in France</b>&nbsp; (with Ellen Gilkerson)<br><i>Annals
of Improbable Research</i>, Jan/Feb 2004, 18-19.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/hair.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/hair.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/hair.pdf">PDF</a><hr>


While traveling in France, Gilkerson and I observed many blonde women,
but almost no blonde men.&nbsp; Suspecting that we had stumbled upon a
remarkable scientific discovery, we endured several weeks of hardship
visiting the auberges and restaurants of France to gather data.&nbsp; After
several years of analysis and rigorous procrastination, we wrote this
paper.&nbsp; Much of our magnificent prose was ruthlessly eliminated by the
editor to leave space for less important research.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="wsfm-web"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Web 服务协议的正式规范</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 James E. Johnson、David E. Langworthy 和 Friedrich H. Vogt）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">理论计算机科学电子笔记 105</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，M. Bravetti 和 G. Zavattaro 编辑。</font><font style="vertical-align:inherit">（2004 年 12 月）147-158。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/wsfm-web.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/wsfm-web.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/wsfm-web.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2003 年夏秋两季，Fritz Vogt 在我们的实验室度过了部分休假。我对在 Microsoft 的产品组中使用 TLA+ 很感兴趣，而 Fritz 正在寻找一个涉及分布式协议的有趣项目。</font><font style="vertical-align:inherit">通过他的联系，我们认识了 Jim Johnson 和 Dave Langworthy，他们在雷德蒙德的 Microsoft 从事 Web 协议工作。</font><font style="vertical-align:inherit">Jim 和 Dave 对正式指定协议的想法很感兴趣，Jim 建议我们将 Web 服务原子事务协议视为一个简单的示例。</font><font style="vertical-align:inherit">弗里茨和我花了几个月的时间来写它，在吉姆和戴夫的帮助下理解了协议。</font><font style="vertical-align:inherit">本文描述了该规范以及我们编写该规范的经验。</font><a href="http://lamport.azurewebsites.net/tla/ws-at.html"><font style="vertical-align:inherit">单击此处</font></a><font style="vertical-align:inherit">可以找到规范本身</font></font><a href="http://lamport.azurewebsites.net/tla/ws-at.html"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这对我来说是一个例行练习，对于任何具有一定指定并发系统经验的人来说都是如此。</font><font style="vertical-align:inherit">第一次使用 TLA+ 对 Fritz 来说是一次学习经历。</font><font style="vertical-align:inherit">对于之前从未接触过正式方法的吉姆和戴夫来说，这是一个全新的世界。</font><font style="vertical-align:inherit">他们对结果感到满意。</font><font style="vertical-align:inherit">Dave 开始自己编写规范，并已成为 Microsoft 网络小组的 TLA+ 专家。</font><font style="vertical-align:inherit">我们向 WS-FM 2004 提交了这篇论文，作为向 Web 服务社区介绍形式化方法和 TLA+ 的一种方式。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">
参考文献 [4] 和 [5] 不再位于参考文献列表中给出的 URL。</font><font style="vertical-align:inherit">参考文献 [5] 似乎不再出现在网络上。</font></font><a href="https://web.archive.org/web/20070315194916/http://msdn2.microsoft.com/en-us/library/ms951228.aspx"><font style="vertical-align:inherit"><font style="vertical-align:inherit">参考文献 [4] 似乎是现在可以在此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">找到的文档
</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">然而，该论文似乎是我们正式规范所依据的论文的修订版本，并且它可能受到我们规范的影响。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="wsfm-web"><b>Formal Specification of a Web Services
Protocol</b>&nbsp; (with James E. Johnson, David E. Langworthy, and Friedrich H.&nbsp;
Vogt)<br><i>Electronic Notes in Theoretical Computer Science 105</i>,
M. Bravetti and G. Zavattaro editors. 
(December 2004) 147-158.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/wsfm-web.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/wsfm-web.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/wsfm-web.pdf">PDF</a><hr>


Fritz Vogt spent part of a sabbatical at our lab during the summer and
fall of 2003.&nbsp; I was interested in getting TLA+ used in
the product groups at Microsoft, and Fritz was looking for an
interesting project involving distributed protocols.&nbsp; Through his
contacts, we got together with Jim Johnson and Dave Langworthy, who
work on Web protocols at Microsoft in Redmond.&nbsp; Jim and Dave were
interested in the idea of formally specifying protocols, and Jim
suggested that we look at the Web Services Atomic Transaction protocol
as a simple example.&nbsp; Fritz and I spent part of our time for a couple
of months writing it, with a lot of help from Jim and Dave in
understanding the protocol.&nbsp; This paper describes the specification
and our experience writing it.&nbsp; The specification itself
can
be found by <a href="http://lamport.azurewebsites.net/tla/ws-at.html">clicking
here</a>.&nbsp;

This was a routine exercise for me, as it would have been for anyone
with a moderate amount of experience specifying concurrent systems.&nbsp;
Using TLA+ for the first time was a learning experience
for Fritz.&nbsp; It was a brand new world for Jim and Dave, who had never
been exposed to formal methods before.&nbsp; They were happy with the
results.&nbsp; Dave began writing specifications by himself, and has become
something of a TLA+ guru for the Microsoft networking
group.&nbsp; We submitted this paper to WS-FM 2004 as a way of introducing
the Web services community to formal methods and TLA+.&nbsp;

<p>
References [4] and [5] are no longer at the URLs given in the reference
list.&nbsp; Reference [5] no longer seems to be on the Web.&nbsp; Reference [4]
seems to be the document now available
<a href="https://web.archive.org/web/20070315194916/http://msdn2.microsoft.com/en-us/library/ms951228.aspx">here</a>.&nbsp;
However, that paper seems to be a revised version of the one on which
we based our formal spec, and it could have been influenced by our spec.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="web-dsn-submission"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Cheap Paxos</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp; （与 Mike Massa）</font><font style="vertical-align:inherit">2004 年 6 月至 7 月在佛罗伦萨举行的</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">国际可靠系统和网络会议 (DSN 2004) 的会议记录。</font></font></i><font style="vertical-align:inherit"></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 © 2004 允许个人使用此材料。</font><font style="vertical-align:inherit">但是，出于广告或促销目的或为了创建新的集体作品以转售或重新分发到服务器或列表，或在其他作品中重复使用本作品的任何受版权保护的组件，必须从 IEEE 获得许可。
</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


能够容忍单个非拜占庭故障的系统需要三个处理器。</font><font style="vertical-align:inherit">人们很早就认识到，只有其中两个处理器需要维护系统状态，但第三个处理器必须参与每个决策以保持一致性。</font><font style="vertical-align:inherit">时任微软工程师的迈克·马萨（Mike Massa）观察到，如果我们削弱容错保证，那么只有在其他两个处理器之一出现故障或修复的情况下才需要使用第三个处理器。</font><font style="vertical-align:inherit">第三个处理器可以是功能较弱的机器，也可以是偶尔在专用于其他任务的计算机上运行的进程。</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我将他的想法概括为[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的 Paxos 算法的一种变体，
称为 Cheap Paxos，它可以容忍</font><i><font style="vertical-align:inherit">f</font></i><font style="vertical-align:inherit"> +1 个主处理器的
</font><font style="vertical-align:inherit">最多
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">f 个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">故障，并且</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">辅助的。</font><font style="vertical-align:inherit">关于该算法的论文被 PODC 和 DISC 会议拒绝。</font><font style="vertical-align:inherit">大多数裁判认为它只是提出了旧的想法，即只有主处理器需要维护系统状态，而没有意识到它与旧方法的不同，因为剩余的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">f</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">处理者不必参与每一个决策。</font><font style="vertical-align:inherit">一篇评论包含一个愚蠢的断言，即以某种方式解决问题很容易。</font><font style="vertical-align:inherit">当试图证明他或她的断言是错误的时，我发现了一个更简单的 Cheap Paxos 版本，它达到了与原始版本相同的结果。</font><font style="vertical-align:inherit">（新算法根本不是裁判说应该做的，这是不可能的。）本文描述了更简单的算法。</font><font style="vertical-align:inherit">原始算法实际上比新算法有一些优势，但它尚未发布。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="web-dsn-submission"><b>Cheap Paxos</b>&nbsp; (with Mike
Massa)<br><i>Proceedings of the International Conference on Dependable
Systems and Networks (DSN 2004)</i> held in Florence in June-July 2004.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/web-dsn-submission.pdf">PDF</a>
<br><font size="-2">Copyright © 2004 Personal use of this material is permitted.
However, permission to reprint/republish this
material for advertising or promotional purposes or
for creating new collective works for resale or
redistribution to servers or lists, or to reuse any
copyrighted component of this work in other works
must be obtained from the IEEE.
</font><hr>


A system that can tolerate a single non-Byzantine failure requires
three processors.&nbsp; It has long been realized that only two of those
processors need to maintain the system state, but the third processor
must take part in every decision to maintain consistency.&nbsp; Mike Massa,
at the time an engineer at Microsoft, observed that if we weaken the
fault-tolerance guarantee, then the third processor needs to be used
only in the case of failure or repair of one of the other two
processors.&nbsp; The third processor can then be a less powerful machine
or a process run occasionally on a computer devoted to other tasks.&nbsp; I
generalized his idea to a variation of the Paxos algorithm of
<a href="#lamport-paxos">[123]</a> called Cheap Paxos that tolerates up to
<i>f</i> failures with <i>f</i>+1 main processors and
<i>f</i> auxiliary ones.&nbsp; A paper on this algorithm was rejected from
the PODC and DISC conferences.&nbsp; Most of the referees thought that it
just presented the old idea that only the main processors need to
maintain the system state, not realizing that it differed from the old
approach because the remaining <i>f</i> processors need not take part
in every decision.&nbsp;

One review contained a silly assertion that it was easy to solve the
problem in a certain way.&nbsp; When trying to prove his or her assertion
false, I discovered a somewhat simpler version of Cheap Paxos that
achieved the same result as the original version.&nbsp; (The new algorithm
wasn't at all what the referee said should be done, which was
impossible.)&nbsp; This paper describes the simpler algorithm.&nbsp; The
original algorithm actually has some advantage over the new one, but
it remains unpublished.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="combining"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">实施和组合规范</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布的说明（2004 年 9 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/combining.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我写这篇文章是为了帮助一些 Microsoft 开发人员了解如何编写他们正在设计的软件的 TLA+ 规范。</font><font style="vertical-align:inherit">他们最大的问题是弄清楚如何在 TLA+ 中指定 API（应用程序编程接口），因为没有发布此类规范的示例。</font><font style="vertical-align:inherit">该说明还解释了他们不理解的另外两件事：实现 API 规范意味着什么以及如何使用 API 规范来指定调用 API 的系统。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="combining"><b>Implementing and Combining Specifications</b><br>Unpublished
note (September 2004).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/combining.pdf">PDF</a><hr>


I wrote this note to help some Microsoft developers understand how
they could write TLA+ specifications of the software they
were designing.&nbsp; Their biggest problem was figuring out how to specify
an API (Application Programming Interface) in TLA+, since
there were no published examples of such specifications.&nbsp; The note
also explains two other things they didn't understand: what it means
to implement an API specification and how to use an API specification
in specifying a system that calls the API.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="lower-bound">
<b><font style="vertical-align:inherit"><font style="vertical-align:inherit">异步共识分布式计算的下限</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">19</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (2006), 104-125。</font><font style="vertical-align:inherit">还以 Microsoft Research 技术报告 MSR-TR-2004-72 的形式出现（2004 年 7 月，2005 年 8 月修订）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/lower-bound.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2006 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文包含</font></font><a href="#bertinoro"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[144]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中针对非拜占庭案例公布的结果的精确陈述和证明。</font><font style="vertical-align:inherit">它还包括另一个结果，表明在存在冲突请求的情况下，完全通用的共识算法不能比</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的 Paxos 算法更快
。</font><font style="vertical-align:inherit">然而，有两种例外情况，该结果不成立，本文针对这两种情况提出了潜在有用的最优算法。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="lower-bound">
<b>Lower Bounds for Asynchronous Consensus</b><br><i>Distributed Computing 19</i>, 2 (2006), 104-125.&nbsp; Also appeared as
Microsoft Research Technical
Report MSR-TR-2004-72 (July 2004, revised August 2005).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/lower-bound.pdf">PDF</a>
<br><font size="-2">Copyright 
2006 by Springer-Verlag.</font><hr>


This paper contains the precise statements and proofs of the results
announced in <a href="#bertinoro">[144]</a> for the non-Byzantine case.&nbsp; It also
includes another result showing that a completely general consensus
algorithm cannot be faster than the Paxos algorithm of
<a href="#lamport-paxos">[123]</a> in the presence of conflicting requests.&nbsp;
However, there are two exceptional cases in which this result does not
hold, and the paper presents potentially useful optimal algorithms for
both cases.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="generalized"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">广义共识和 Paxos</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit"> Microsoft 研究技术报告 MSR-TR-2005-33（2005 年 3 月 15 日）。</font></font><br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-33.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在</font></font><a href="#lower-bound"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[154]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中，我证明了达成共识所需的消息延迟数量的下限。</font><font style="vertical-align:inherit">我证明了最好的算法可以在正常情况下在 2 个消息延迟内达成共识。</font><font style="vertical-align:inherit">这个结果又让我想到了
</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的 Paxos 算法的新版本，称为 Fast Paxos，在
</font></font><a href="#fast-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[159]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中进行了描述，它实现了这个界限。</font><font style="vertical-align:inherit">然而，当同时提出两个值时，如果发生冲突，Fast Paxos 可能会延迟 3 个消息。</font></font><a href="#lower-bound"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我在[154]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中表明
</font><font style="vertical-align:inherit">，这在通用算法中是不可避免的，所以这似乎是最后的结论。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

然后我想到，在状态机方法（在</font></font><a href="#time-clocks"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[27]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中介绍）中，出现这种冲突的建议是因为两个客户端同时发出两个不同的命令，并且两个命令都被建议为命令号</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">i</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">仅当两个提议的命令不能互换时，这种冲突才是必要的。</font><font style="vertical-align:inherit">如果他们这样做，那么就没有必要订购它们。</font><font style="vertical-align:inherit">这导致我遇到了一种新的协议问题，需要动态更改不断增长的部分有序命令集的协议。</font><font style="vertical-align:inherit">我意识到从部分有序的命令集概括为一个新的数学结构，我称之为</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">c 结构</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">导致广义共识问题，涵盖普通共识和新的动态共识问题。</font><font style="vertical-align:inherit">我还意识到 Fast Paxos 可以推广来解决这个新问题。</font><font style="vertical-align:inherit">我在 2004 年 3 月写下了这些结果。然而，我的尴尬处境是，我写了一篇概括 Fast Paxos 的论文，却没有写一篇关于 Fast Paxos 的论文。</font><font style="vertical-align:inherit">所以，我只是把纸放在我的磁盘上。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我受邀在 2004 年 DSN 会议上发表主题演讲，我决定谈论快速和通用的 Paxos。</font><font style="vertical-align:inherit">费尔南多·佩多内 (Fernando Pedone) 在我的演讲结束后走过来并做了自我介绍。</font><font style="vertical-align:inherit">他说，他和 André Schiper 已经发表了一篇论文，该论文从状态机方法的命令序列到部分有序命令集进行了相同的概括，并提供了一种算法，该算法在没有冲突。</font><font style="vertical-align:inherit">事实证明他们的算法与广义的Paxos算法不同。</font><font style="vertical-align:inherit">在某些情况下，广义 Paxos 只需要 2 个消息延迟，而他们的算法则需要 3 个消息延迟。但这两种算法之间的效率差异并不显着。</font><font style="vertical-align:inherit">重要的区别是广义的 Paxos 更加优雅。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我在这篇论文上等待了很长时间，因为在发表有关 Fast Paxos 本身的内容之前先发表一篇关于 Fast Paxos 泛化的论文似乎不太合适。</font><font style="vertical-align:inherit">由于generalized Paxos是泛化，所以本文也对Fast Paxos进行了解释。</font><font style="vertical-align:inherit">但人们的思维并不是这样运作的。</font><font style="vertical-align:inherit">他们需要先了解 Fast Paxos，然后才能真正理解它的概括。</font><font style="vertical-align:inherit">所以，我想我应该把这篇论文变成一篇长论文或专着的第二部分，其第一部分解释了 Fast Paxos。</font><font style="vertical-align:inherit">然而，近年来，我发现新的 Paxonian 结果的速度比我写下来的速度还要快。</font><font style="vertical-align:inherit">因此，不发布我已经写过的关于其中一个结果的论文似乎很愚蠢。</font><a href="#lower-bound"><font style="vertical-align:inherit">因此，我添加了对 Pedone-Schiper 结果的简短讨论以及对[154]</font></a><font style="vertical-align:inherit">的引用
</font></font><a href="#lower-bound"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">并将论文张贴在这里。</font><font style="vertical-align:inherit">现在我已经写了 Fast Paxos 论文并提交出版，我可能会重写这篇论文作为该论文的第二部分。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="generalized"><b>Generalized Consensus and Paxos</b><br>Microsoft Research Technical
Report MSR-TR-2005-33 (15 March 2005).<br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-33.pdf">Available
On-Line</a><hr>


In <a href="#lower-bound">[154]</a>, I proved lower bounds for the number of
message delays required to reach consensus.&nbsp; I showed that the best
algorithms can reach consensus in the normal case in 2 message delays.&nbsp;
This result in turn led me to a new version of the Paxos algorithm of
<a href="#lamport-paxos">[123]</a> called Fast Paxos, described in
<a href="#fast-paxos">[159]</a>,  that achieves this bound.&nbsp;
However, Fast Paxos can take 3 message delays in the event of
conflict, when two values are proposed concurrently.&nbsp; I showed in
<a href="#lower-bound">[154]</a> that this was unavoidable in a general algorithm,
so this seemed to be the last word.&nbsp;

<p>

It then occurred to me that, in the state-machine approach (introduced
in <a href="#time-clocks">[27]</a>), such conflicting proposals arise because two
different commands are issued concurrently by two clients, and both
are proposed as command number <i>i</i>.&nbsp; This conflict is necessary
only if the two proposed commands do not commute.&nbsp; If they do, then
there is no need to order them.&nbsp; This led me to a new kind of
agreement problem that requires dynamically changing agreement on a
growing partially ordered set of commands.&nbsp; I realized that
generalizing from partially ordered sets of commands to a new
mathematical structure I call a <i>c-struct</i> leads to a generalized
consensus problem that covers both ordinary consensus and this new
dynamic agreement problem.&nbsp; I also realized that Fast Paxos can be
generalized to solve this new problem.&nbsp; I wrote up these results in
March 2004.&nbsp; However, I was in the embarrassing position of having
written a paper generalizing Fast Paxos without having written a paper
about Fast Paxos.&nbsp; So, I just let the paper sit on my disk.&nbsp;

</p><p>

I was invited to give a keynote address at the 2004 DSN conference,
and I decided to talk about fast and generalized Paxos.&nbsp; Fernando
Pedone came up after my talk and introduced himself.&nbsp; He said that he
and André Schiper had already published a paper with
the same generalization from the command sequences of the
state-machine approach to partially ordered sets of commands, together
with an algorithm that achieved the same optimal number of message
delays in the absence of conflict.&nbsp; It turns out that their algorithm
is different from the generalized Paxos algorithm.&nbsp; There are cases in
which generalized Paxos takes only 2 message delays while their
algorithm takes 3.&nbsp; But the difference in efficiency between the two
algorithms is insignificant.&nbsp; The important difference is that
generalized Paxos is more elegant.&nbsp;

</p><p>

I've been sitting on this paper for so long because it doesn't seem
right to publish a paper on a generalization of Fast Paxos before
publishing something about Fast Paxos itself.&nbsp; Since generalized Paxos
is a generalization, this paper also explains Fast Paxos.&nbsp; But
people's minds don't work that way.&nbsp; They need to understand Fast
Paxos before they can really understand its generalization.&nbsp; So, I
figured I would turn this paper into the second part of a long paper
or monograph whose first part explains Fast Paxos.&nbsp; However, in recent
years I've been discovering new Paxonian results faster than I can
write them up.&nbsp; It therefore seems silly not to release a paper that
I've already written about one of those results.&nbsp; So, I added a brief
discussion of the Pedone-Schiper result and a citation to
<a href="#lower-bound">[154]</a> and am posting the paper here.&nbsp; Now that I have
written the Fast Paxos paper and submitted it for publication, I may
rewrite this paper as part two of that one.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="real-simple"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时其实很简单</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">Microsoft Research 技术报告 MSR-TR-2005-30（2005 年 3 月 4 日）。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">被系统设计中的正式方法</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">拒绝</font><font style="vertical-align:inherit">。</font></font><br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-30.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


很明显，不需要特殊的逻辑或语言来编写或推理实时规范。</font><font style="vertical-align:inherit">有一个简单的方法可以做到这一点：只需使用一个变量来表示时间。</font><font style="vertical-align:inherit">马丁·阿巴迪和我在
</font></font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[107]中展示</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">这可以在 TLA 中非常优雅地完成。</font><font style="vertical-align:inherit">更简单、更直接的方法适用于任何合理的形式化方法，但它太简单、太明显而无法发布。</font><font style="vertical-align:inherit">因此，人们已经写了数百篇关于特殊实时逻辑和语言的论文和论文——尽管对于大多数目的来说，没有理由使用它们来代替简单、明显的方法。</font><font style="vertical-align:inherit">由于没有人写关于处理实时的简单方法的论文，人们似乎认为他们需要使用实时逻辑。</font><font style="vertical-align:inherit">当然，我觉得这很烦人。</font><font style="vertical-align:inherit">因此，当我听说一位计算机科学家计划写一本关于这些实时逻辑的书时，我决定是时候写另一篇论文来解释这种简单的方法了。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

由于你不能发表关于旧想法的新论文，无论这个想法有多好，我都需要找到一些新的东西来添加。</font><font style="vertical-align:inherit">TLC 模型检查器提供了我需要的机会。</font></font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[107]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">和</font></font><a href="#tla+-book"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[145]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中描述的方法</font><font style="vertical-align:inherit">对于实时系统的指定和推理很有用，但它产生的规范是TLC无法处理的。</font><font style="vertical-align:inherit">TLC 只适用于更简单的方法，所以我有借口写一篇新论文。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

有一种简单的方法可以使用 TLC 检查实时规格，我已经考虑尝试了一段时间。</font><font style="vertical-align:inherit">它涉及检查所有运行的规范，直到某个最大时间值，人们希望该时间值足够大以发现任何错误。</font><font style="vertical-align:inherit">因此，我使用 Fischer 互斥协议的两个版本作为示例，这在</font></font><a href="#lamport-old-fashioned"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[107]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的讨论中提到。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

使用特殊实时方法的一个可能原因是模型检查。</font><font style="vertical-align:inherit">我认为实时使用特殊算法的模型检查器应该比这种简单的方法做得更好，所以我想要一些使用 TLA+ 和 TLC 的理由。</font><font style="vertical-align:inherit">通过查阅文献，我发现所有实时模型检查器似乎都使用只能描述简单控制器的低级语言。</font><font style="vertical-align:inherit">所以我添加了他们无法代表的分布式算法的例子。</font><font style="vertical-align:inherit">然后我发现，自从描述它的论文发表以来，Uppaal 模型检查器已经通过新的语言功能得到了增强，使其能够对该算法进行建模。</font><font style="vertical-align:inherit">这让我别无选择，只能在示例中将 TLC 与 Uppaal 进行比较。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我向 Uppaal 的开发者、奥尔堡大学的 Kim Larsen 寻求帮助，帮助编写该算法的 Uppaal 规范。</font><font style="vertical-align:inherit">虽然我这样做确实是因为我很懒，但我可以证明我的请求是合理的，因为我从未使用过 Uppaal，并且不知道如何用它编写一个好的模型。</font><font style="vertical-align:inherit">Larsen 让他的同事 Arne Skou 编写了一个相当不错的模型，尽管它确实需要一些“黑客”才能用 Uppaal 的低级语言对 TLA+ 的高级结构进行编码。</font><font style="vertical-align:inherit">Skou 得到了 Larsen 和他的同事 Gerd Behrmann 的帮助。</font><font style="vertical-align:inherit">正如我所预料的，Uppaal 比 TLC 快得多——除了一个令人费解的情况，即 Uppaal 内存不足。&nbsp;

 </font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我把纸放在一边一会儿。</font><font style="vertical-align:inherit">当我回过头来时，我意识到有一种简单的方法可以使用 TLC 来完整检查这些实时规范，这比我以前所做的要快得多。</font><font style="vertical-align:inherit">这个想法是如此简单，以至于我认为它是众所周知的，但我后悔自己没有立即看到它。</font><font style="vertical-align:inherit">我咨询了汤姆·亨辛格，他告诉我该方法是已知的，但显然尚未发表。</font><font style="vertical-align:inherit">这似乎是一个对于专家来说是显而易见的想法，而对于其他人来说却是未知的。</font><font style="vertical-align:inherit">因此，这为我发表论文提供了另一个动力，其中有一个新章节介绍如何使用 TLC 等显式时间模型检查器来检查实时规格。</font><font style="vertical-align:inherit">Henzinger 还纠正了我对实时模型检查器的一个基本误解。</font><font style="vertical-align:inherit">他们中的大多数人并没有试图变得更快，而是试图通过使用连续的时间来变得更好。
 </font></font></p><blockquote><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 
如果您对离散时间感到满意，我怀疑您可以做得更好[比我天真的方法]。</font><font style="vertical-align:inherit">Uppaal、Kronos 等处理实数时间，因此依赖于复杂且昂贵的时钟区域结构。&nbsp;
 </font></font></p></blockquote><font style="vertical-align:inherit"><font style="vertical-align:inherit">
然后我受到启发去做一些更认真的数据收集。</font><font style="vertical-align:inherit">我发现了这个令人费解的情况的解释：当两个参数的比率变得太大时，Uppaal 就会耗尽内存。</font><font style="vertical-align:inherit">论文中报告的结果表明，TLC 和 Uppaal 在此示例中都没有明显表现得更好。&nbsp; 


 </font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

Uppaal 发行版附带了 Fischer 算法版本的模型，我决定也获取该示例的一些数据。</font><font style="vertical-align:inherit">Uppaal 在这方面显然比 TLC 做得更好。</font><font style="vertical-align:inherit">然而，我怀疑原因不是因为实时模型检查器更好，而是因为TLC对于这种简单算法的效率低于使用较低级语言的模型检查器。</font><font style="vertical-align:inherit">因此，我获取了两个使用较低级语言 Spin 和 SMV 的普通模型检查器的数据。</font><font style="vertical-align:inherit">我又偷懒了，让这些模型检查器的开发人员 Gerard Holzmann 和 Ken McMillan 来完成所有编写和检查模型的工作。&nbsp; 


 </font></font></p><p><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">我将这篇论文提交给了《系统设计中的形式方法》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">

杂志</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我认为有关模型检查的部分非常有趣，值得放入单独的会议论文中。</font><font style="vertical-align:inherit">因此我写了</font></font><a href="#charme2005"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[158]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">，它在 2005 年 Charme 会议上被接受。</font><font style="vertical-align:inherit">然而，该期刊的投稿被拒绝，因为它没有包含足够的新想法。&nbsp; 


</font></font><br>&nbsp;</p><p></p></li><li> <a name="real-simple"><b>Real Time is Really Simple</b><br>Microsoft Research Technical
Report MSR-TR-2005-30 (4 March 2005).&nbsp; Rejected by <i>Formal
Methods in Systems Design</i>.<br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-30.pdf">Available
On-Line</a><hr>


It should be quite obvious that no special logic or language is needed
to write or reason about real-time specifications.&nbsp; There's a simple
way to do it: just use a variable to represent time.&nbsp;
Martín Abadi and I showed in
<a href="#lamport-old-fashioned">[107]</a> that this can be done very elegantly in
TLA.&nbsp; A simpler, more straightforward approach works with
any sensible formal method, but it's too simple and obvious to
publish.&nbsp; So instead, hundreds of papers and theses have been written
about special real-time logics and languages--even though, for most
purposes, there's no reason to use them instead of the simple, obvious
approach.&nbsp; And since no one writes papers about the simple way of
handling real time, people seem to assume that they need to use a
real-time logic.&nbsp; Naturally, I find this rather annoying.&nbsp; So when I
heard that a computer scientist was planning to write a book about one
of these real-time logics, I decided it was time to write another
paper explaining the simple approach.&nbsp;

<p>

Since you can't publish a new paper about an old idea, no matter how
good the idea may be, I needed to find something new to add.&nbsp; The TLC
model checker provided the opportunity I needed.&nbsp; The method described
in <a href="#lamport-old-fashioned">[107]</a> and <a href="#tla+-book">[145]</a> is good for
specifying and reasoning about real-time systems, but it produces
specifications that TLC can't handle.&nbsp; TLC works only with the simpler
approach, so I had an excuse for a new paper.&nbsp;

</p><p>

There's a naive approach for checking real-time specifications with
TLC that I had thought for a while about trying.&nbsp; It involves checking
the specification for all runs up to some maximum time value that one
hopes is large enough to find any bugs.&nbsp; So I did that using as
examples two versions of Fischer's mutual exclusion protocol, which is
mentioned in the discussion of <a href="#lamport-old-fashioned">[107]</a>.&nbsp;

</p><p>

One possible reason to use a special real-time approach is for model
checking.&nbsp; I figured that model checkers using special algorithms for
real time should do much better than this naive approach, so I wanted
some justification for using TLA+ and TLC instead.&nbsp;
Looking through the literature, I found that all the real-time model
checkers seemed to use low-level languages that could describe only
simple controllers.&nbsp; So I added the example of a distributed algorithm
that they couldn't represent.&nbsp; Then I discovered that, since the
papers describing it had been published, the Uppaal model checker had
been enhanced with new language features that enabled it to model this
algorithm.&nbsp; This left me no choice but to compare TLC with Uppaal on
the example.&nbsp;

</p><p>

I asked Kim Larsen of Aalborg University, the developer of Uppaal, for
help writing an Uppaal spec of the algorithm.&nbsp; Although I really did
this because I'm lazy, I could justify my request because I had never
used Uppaal and couldn't see how to write a nice model with it.&nbsp;
Larsen got his colleague Arne Skou to write a model that was quite
nice, though it did require a bit of a "hack" to encode the
high-level constructs of TLA+ in Uppaal's lower-level
language.&nbsp; Skou was helped by Larsen and his colleague, Gerd Behrmann.&nbsp;
As I expected, Uppaal was much faster than TLC--except in one
puzzling case in which Uppaal ran out of memory.&nbsp;

 </p><p>

I put the paper aside for a while.&nbsp; When I got back to it, I realized
that there's a simple way of using TLC to do complete checking of
these real-time specifications that is much faster than what I had
been doing.&nbsp; The idea is so simple that I figured it was well known,
and I kicked myself for not seeing it right away.&nbsp; I checked with Tom
Henzinger, who informed me that the method was known, but it had
apparently not been published.&nbsp; It seems to be an idea that is obvious
to the experts and unknown to others.&nbsp; So this provided another
incentive for publishing my paper, with a new section on how to use an
explicit-time model checker like TLC to check real-time specs.&nbsp;
Henzinger also corrected a basic misunderstanding I had about
real-time model checkers.&nbsp; Rather than trying to be faster, most of
them try to be better by using continuous time.&nbsp; He wrote:
 </p><blockquote><p> 
If you are happy with discrete time, I doubt you can do any better
[than my naive approach].&nbsp; Uppaal, Kronos etc. deal with
real-numbered time, and therefore rely on elaborate and expensive
clock region constructions.&nbsp;
 </p></blockquote>
I was then inspired to do some more serious data gathering.&nbsp; I
discovered the explanation of that puzzling case: Uppaal runs out of
memory when the ratio of two parameters becomes too large.&nbsp; The
results reported in the paper show that neither TLC nor Uppaal comes
out clearly better on this example.&nbsp; 


 <p>

The Uppaal distribution comes with a model of a version of Fischer's
algorithm, and I decided to get some data for that example too.&nbsp; Uppaal
did clearly better than TLC on it.&nbsp; However, I suspected that the
reason was not because real-time model checkers are better, but
because TLC is less efficient for this kind of simple algorithm than a
model checker that uses a lower-level language.&nbsp; So I got data for two
ordinary model checkers that use lower-level languages, Spin and
SMV.&nbsp; I was again lazy and got the developers of those model
checkers, Gerard Holzmann and Ken McMillan, to do all the work of
writing and checking the models.&nbsp; 


 </p><p>

I submitted this paper to the journal <i>Formal Methods in Systems
Design</i>.&nbsp; I thought that the part about model checking was interesting
enough to be worth putting into a separate conference paper.&nbsp; I
therefore wrote <a href="#charme2005">[158]</a>, which was accepted at the 2005
Charme conference.&nbsp; However, the journal submission was rejected
because it didn't contain enough new ideas.&nbsp; 


<br>&nbsp;</p><p></p></li><li> <a name="PaxosGST"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">最终同步能以多快的速度达成共识？</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Partha Dutta 和 Rachid Guerraoui 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">可靠系统和网络国际会议记录 (DSN 2005)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/PaxosGST.ps"><font style="vertical-align:inherit"><font style="vertical-align:inherit">Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/PaxosGST.ps.gz"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> gzipped Postscript</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">  &nbsp;&nbsp;-&nbsp;&nbsp; 
</font></font><a href="http://lamport.azurewebsites.net/pubs/PaxosGST.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit"> PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2004 年 3 月我访问 EPFL 期间，Dutta 和 Guerraoui 解释了他们正在解决的一个问题。</font><font style="vertical-align:inherit">异步共识算法，如 Paxos&nbsp; </font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">尽管存在异步，但仍能保持安全性，但只有当系统变得同步时才能保证取得进展——这意味着消息在有限的时间内传递。</font><font style="vertical-align:inherit">Dutta 和 Guerraoui 正在寻找一种算法，在系统同步后，该算法始终能在恒定数量的消息延迟内达成一致。</font><font style="vertical-align:inherit">只有当系统同步之前发送的消息可以在未来任意远的时间传递时，这才是一个难题。</font><font style="vertical-align:inherit">我采用了他们提出的解决方案，并将其与 Paxos 结合起来，以获得本文描述的算法。</font><font style="vertical-align:inherit">这是一个很好的解决方案，解决了一个有点有趣的理论问题，但没有明显的实际应用。</font><font style="vertical-align:inherit">我记得，我想在论文中加入这样一句话：</font><font style="vertical-align:inherit">但我的合著者明智地指出，这样做将确保论文被拒绝。</font><font style="vertical-align:inherit">（我的合著者不记得这一点了。）这个领域的计算机科学家必须继续假装他们所做的一切都是实用的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="PaxosGST"><b>How Fast Can Eventual Synchrony Lead to
Consensus?</b>&nbsp; (with Partha Dutta and Rachid Guerraoui)<br><i>Proceedings of 
the International Conference on Dependable Systems and
Networks (DSN 2005)</i>.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/PaxosGST.ps">Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/PaxosGST.ps.gz">gzipped Postscript</a> &nbsp;&nbsp;-&nbsp;&nbsp; 
<a href="http://lamport.azurewebsites.net/pubs/PaxosGST.pdf">PDF</a><hr>


During a visit I made to the EPFL in March 2004, Dutta and Guerraoui
explained a problem they were working on.&nbsp; Asynchronous consensus
algorithms like Paxos&nbsp;<a href="#lamport-paxos">[123]</a> maintain
safety despite asynchrony, but are guaranteed to make progress only
when the system becomes synchronous--meaning that messages are
delivered in a bounded length of time.&nbsp; Dutta and Guerraoui were
looking for an algorithm that always reaches agreement within a
constant number of message delays after the system becomes
synchronous.&nbsp; This is a hard problem only if messages sent before the
system becomes synchronous can be delivered arbitrarily far in the
future.&nbsp; I took the solution they had come up with and combined it
with Paxos to obtain the algorithm described is this paper.&nbsp; It's a
nice solution to a mildly interesting theoretical problem with no
apparent practical application.&nbsp; As I recall, I wanted to include a
sentence in the paper saying this, but my co-authors sensibly pointed
out that doing so would ensure the paper's rejection.&nbsp; (My co-authors
don't remember this.)&nbsp; Computer scientists in this field must keep up
the pretense that everything they do is practical.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="charme2005"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">实时模型检查确实很简单</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">正确的硬件设计和验证方法</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">
（CHARME 2005），Dominique Borrione 和 Wolfgang J. Paul 编辑，Springer-Verlag 计算机科学讲义第 3725 卷（2005 年），162-175。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/charme2005.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"></font><a href="#real-simple"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[156]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的删节版本</font><font style="vertical-align:inherit">，仅包含有关模型检查的材料。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="charme2005"><b>Real-Time Model Checking is Really
Simple</b><br><i>Correct Hardware Design and Verification Methods</i>
(CHARME 2005), Dominique Borrione and Wolfgang J. Paul editors,
Springer-Verlag Lecture Notes in Computer Science Volume 3725 (2005),
162-175.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/charme2005.pdf">PDF</a><hr>


This is an abridged version of <a href="#real-simple">[156]</a>, containing only
the material on model checking.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="fast-paxos"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">快速 Paxos</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 19</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2（2006 年 10 月）79-103。</font><font style="vertical-align:inherit">还出现为 Microsoft Research 技术报告 MSR-TR-2005-112（2005 年 7 月 14 日）。</font><font style="vertical-align:inherit">。</font></font><br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供</font></font></a><hr><font style="vertical-align:inherit"></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的 Paxos 共识算法</font><font style="vertical-align:inherit">需要在领导者提出一个值和其他进程得知该值已被选择之间有两次消息延迟。</font><font style="vertical-align:inherit">自从发明 Paxos 以来，我一直认为这是最佳的消息延迟。</font><font style="vertical-align:inherit">然而，在 2001 年末的某个时候，我意识到在大多数使用共识的系统中，值并不是由系统本身凭空挑选出来的；而是由系统本身决定的。</font><font style="vertical-align:inherit">相反，它们来自客户。</font><font style="vertical-align:inherit">如果统计来自客户端的消息，Paxos 需要 3 个消息延迟。</font><font style="vertical-align:inherit">这让我想知道是否有可能在两次消息延迟（包括客户端的消息）上达成共识。</font></font><a href="#bertinoro"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我证明了[144]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中宣布的下限结果</font><font style="vertical-align:inherit">，即一种算法可以在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">f 的情况下取得进展</font></font></i><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">尽管e个</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">故障需要超过
</font></font><tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">2e+f</font></font></tt><font style="vertical-align:inherit"><font style="vertical-align:inherit">个进程，但仍能在两次消息延迟内达成共识</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">这个结果的证明很快让我想到了这里描述的 Fast Paxos 算法。</font><font style="vertical-align:inherit">Fast Paxos 概括了经典的 Paxos 共识算法。</font><font style="vertical-align:inherit">它可以根据正在运行的进程数量，在两个或三个消息延迟内进行学习之间的切换。</font><font style="vertical-align:inherit">更准确地说，只有在没有并发冲突提议的情况下，它才能在两个消息延迟中实现学习，</font></font><a href="#lower-bound"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[154]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">表明这是通用算法可以做到的最好的。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="fast-paxos"><b>Fast Paxos</b><br><i>Distributed Computing 19</i>, 2 (October
2006) 79-103.&nbsp; Also appeared as Microsoft Research Technical Report
MSR-TR-2005-112 (14 July 2005).&nbsp; .<br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2005-112.pdf">Available
On-Line</a><hr>


The Paxos consensus algorithm of <a href="#lamport-paxos">[123]</a> requires two
message delays between when the leader proposes a value and when other
processes learn that the value has been chosen.&nbsp; Since inventing
Paxos, I had thought that this was the optimal message delay.&nbsp;
However, sometime in late 2001 I realized that in most systems that
use consensus, values aren't picked out of the air by the system
itself; instead, they come from clients.&nbsp; When one counts the message
from the client, Paxos requires three message delays.&nbsp; This led me to
wonder whether consensus in two message delays, including the client's
message, was in fact possible.&nbsp; I proved the lower-bound result
announced in <a href="#bertinoro">[144]</a> that an algorithm that can make
progress despite <i>f</i> faults and can achieve consensus in two
message delays despite <i>e</i> faults requires more than
<tt>2e+f</tt> processes.&nbsp; The proof of that result led
me pretty quickly to the Fast Paxos algorithm described here.&nbsp; Fast
Paxos generalizes the classic Paxos consensus algorithm.&nbsp; It can
switch between learning in two or three message delays depending on
how many processes are working.&nbsp; More precisely, it can achieve
learning in two message delays only in the absence of concurrent
conflicting proposals, which <a href="#lower-bound">[154]</a> shows is the best a
general algorithm can do.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="celebrity"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">《测量</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">不可思议的研究的名人年鉴》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，2006 年 1 月/2 月，14-15。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/celebrity.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2005 年 9 月，我与 Andreas Podelski 共进晚餐，当时他正在参观微软的剑桥研究实验室。</font><font style="vertical-align:inherit">他提到，他的主页是谷歌搜索他的名字返回的第四个项目。</font><font style="vertical-align:inherit">他的随意言论启发了这里报道的科学研究。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="celebrity"><b>Measuring Celebrity</b><br><i>Annals
of Improbable Research</i>, Jan/Feb 2006, 14-15.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/celebrity.pdf">PDF</a><hr>


In September 2005, I had dinner with Andreas Podelski, who was
visiting Microsoft's Cambridge Research Laboratory.&nbsp; He mentioned that
his home page was the fourth item returned by a Google search on his
first name.&nbsp; His casual remark inspired the scientific research
reported here.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="dcas"><b><font style="vertical-align:inherit"></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">在
分布式计算中</font><b><font style="vertical-align:inherit">使用 +CAL 检查多线程算法</font></b></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">：第 20 届国际会议，DISC 2006</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Shlomi Dolev，编辑。</font><font style="vertical-align:inherit">施普林格出版社 (2006) 11-163。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/dcas.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2006 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


袁宇告诉我一个多线程算法，后来被报道有一个错误。</font></font><a href="#pluscal"><font style="vertical-align:inherit"><font style="vertical-align:inherit">我认为用 PlusCal（以前称为 +CAL） [162]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">编写算法
</font><font style="vertical-align:inherit">并使用 TLC 模型检查器
</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">对其进行检查将是对 PlusCal 语言的良好测试。</font><font style="vertical-align:inherit">这就是我所做的事情的故事。</font></font><a href="http://lamport.azurewebsites.net/tla/dcas-example.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">提供了该算法的 PlusCal 规范及其发现的错误跟踪</font><font style="vertical-align:inherit">。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="dcas"><b>Checking a Multithreaded Algorithm with +CAL</b><br>In
<i>Distributed Computing: 20th International Conference, DISC 2006</i>,
Shlomi Dolev, editor.&nbsp; Springer-Verlag (2006) 11-163.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/dcas.pdf">PDF</a>
<br><font size="-2">Copyright 
2006 by Springer-Verlag.</font><hr>


Yuan Yu told me about a multithreaded algorithm that was later
reported to have a bug.&nbsp; I thought that writing the algorithm in 
PlusCal (formerly called +CAL)
<a href="#pluscal">[162]</a> and checking it with the TLC model checker
<a href="#lamport-spec-tla-plus">[128]</a> would be a good test of the PlusCal
language.&nbsp; This is the story of what I did.&nbsp; The PlusCal specification of
the algorithm and the error trace it found are available <a href="http://lamport.azurewebsites.net/tla/dcas-example.html">here</a>.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="pluscal"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">PlusCal 算法语言</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算理论方面 -ICTAC 2009</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Martin Leucker 和 Carroll Morgan 编辑。</font><font style="vertical-align:inherit">计算机科学讲义，编号 568​​4，36-60。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/pluscal.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


PlusCal（以前称为+CAL）是一种算法语言。</font><font style="vertical-align:inherit">它旨在取代伪代码来编写算法的高级描述。</font><font style="vertical-align:inherit">用 PlusCal 编写的算法被转换为 TLA+ 规范，可以使用 TLC 模型检查器&nbsp;</font></font><a href="#lamport-spec-tla-plus"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[128]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">进行检查。</font><font style="vertical-align:inherit">本文描述了该语言及其设计原理。</font></font><a href="http://lamport.azurewebsites.net/tla/pluscal.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">提供语言手册和更多信息</font><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

早期版本被 POPL 2007 拒绝。根据我收到的评论和 Simon Peyton-Jones 的评论，我修改了论文并将其提交给 TOPLAS，但再次被拒绝。</font><font style="vertical-align:inherit">或许可以写一篇关于 PlusCal 的论文，该论文将被编程语言社区视为可以发表。</font><font style="vertical-align:inherit">然而，这样的论文并不是我想写的。</font><font style="vertical-align:inherit">例如，三位 TOPLAS 审稿人中的两位希望论文包含正式的语义——我希望对使用 PlusCal 感兴趣的人会觉得这很无聊。</font><font style="vertical-align:inherit">（正式的 TLA+ 语义规范可在网上找到。）因此，我决定将其作为受邀论文发布在 ICTAC 会议记录中。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="pluscal"><b>The PlusCal Algorithm Language</b><br><i>Theoretical Aspects
of Computing-ICTAC 2009</i>, Martin Leucker and Carroll Morgan editors.&nbsp;
Lecture Notes in Computer Science, number 5684, 36-60.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/pluscal.pdf">PDF</a><hr>


PlusCal (formerly called +CAL) is an algorithm language.&nbsp; It is meant
to replace pseudo-code for writing high-level descriptions of
algorithms.&nbsp; An algorithm written in PlusCal is translated into a TLA+
specification that can be checked with the TLC model
checker&nbsp;<a href="#lamport-spec-tla-plus">[128]</a>.&nbsp; This paper
describes the language and the rationale for its design.&nbsp; A language
manual and further information are available <a href="http://lamport.azurewebsites.net/tla/pluscal.html">here</a>.&nbsp;

<p>

An earlier version was rejected from POPL 2007.&nbsp; Based on the reviews
I received and comments from Simon Peyton-Jones, I revised the paper
and submitted it to TOPLAS, but it was again rejected.&nbsp; It may be
possible to write a paper about PlusCal that would be considered
publishable by the programming-language community.&nbsp; However, such a
paper is not the one I want to write.&nbsp; For example, two of the three
TOPLAS reviewers wanted the paper to contain a formal
semantics--something that I would expect people interested in using
PlusCal to find quite boring.&nbsp; (A formal TLA+ specification of the
semantics is available on the Web.)&nbsp; I therefore decided to publish it
as an invited paper in the ICTAC conference proceedings.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="spec-book-chap"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">软件规范方法中的TLA+</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">章节</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">：使用案例研究的概述</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Henri Habrias 和 Marc Frappier，编辑。</font><font style="vertical-align:inherit">爱马仕，2006 年 4 月</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec-book-chap.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">。PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我被要求为这本书写一章，其中包含以多种不同形式编写的同一示例系统的形式规范的集合。</font><font style="vertical-align:inherit">该系统非常简单，以至于在任何合理的形式主义中，规范都应该是微不足道的。</font><font style="vertical-align:inherit">我之所以费心编写这一章，是因为在书中呈现 TLA+ 似乎是一个好主意，而且因为我能够从 Jonathan Bowen 的章节中的 Z 规范中复制很多内容，并简单地解释如何以及为何，所以这并不需要太多工作。 Z 和 TLA+ 规格有所不同。</font><font style="vertical-align:inherit">鲍文的章节可以 
   </font></font><a href="http://lamport.azurewebsites.net/pubs/bowen-chapter.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在这里</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">找到。&nbsp;

 </font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

由于该示例非常简单且不涉及并发，因此其 TLA+ 规范既不有趣也不具有启发性。</font><font style="vertical-align:inherit">然而，我对规范过程的评论可能会引起一些兴趣。&nbsp; 

</font></font><br>&nbsp;</p><p></p></li><li> <a name="spec-book-chap"><b>TLA+</b><br>Chapter in <i>Software
Specification Methods: An Overview Using a Case Study</i>, Henri Habrias
and Marc Frappier, editors.&nbsp; Hermes, April 2006.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/spec-book-chap.pdf">PDF</a><hr>


I was asked to write a chapter for this book, which consists of a
collection of formal specifications of the same example system written
in a multitude of different formalisms.&nbsp; The system is so simple that
the specification should be trivial in any sensible formalism.&nbsp; I
bothered writing the chapter because it seemed like a good idea to
have TLA+ represented in the book, and because it wasn't
much work since I was able to copy a lot from the Z specification 
in Jonathan Bowen's chapter and
simply explain how and why the Z and TLA+ specifications
differ.&nbsp; Bowen's chapter
is available 
   <a href="http://lamport.azurewebsites.net/pubs/bowen-chapter.pdf">here</a>.&nbsp;

 <p>

Because the example is so simple and involves no concurrency, its
TLA+ specification is neither interesting nor
enlightening.&nbsp; However, my comments about the specification process
may be of some interest.&nbsp; 

<br>&nbsp;</p><p></p></li><li> <a name="synchronizing"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用线程</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算实现数据流 21</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 3 (2008), 163-181。</font><font style="vertical-align:inherit">还以 Microsoft Research 技术报告 MSR-TR-2006-181（2006 年 12 月）的形式出现</font></font><br></a><font style="vertical-align:inherit"><font size="-2"><font style="vertical-align:inherit">。Springer-Verlag</font></font></font><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2006-181.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在线提供版权所有 2008 年。</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2005 年夏天，我正在 PlusCal
 </font></font><a href="#pluscal"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[162]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中编写一个算法，本质上需要屏障同步作为原语。</font><font style="vertical-align:inherit">在 PlusCal 中执行此操作的最简单方法是编写一些屏障同步算法。</font><font style="vertical-align:inherit">我使用了我能想到的最简单的算法，其中每个进程维护一个三值变量</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">——Barrier</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">1 本文算法。</font><font style="vertical-align:inherit">这个算法看起来很不错，我想知道它是否是新的。</font><font style="vertical-align:inherit">网络搜索表明确实如此。</font><font style="vertical-align:inherit">（2008 年，Wim Hesselink 告诉我，他在 2001 年就发现了这个算法，但他只在课程笔记中“发表”了它。）我很好奇 Windows 操作系统内部使用了什么屏障同步算法，以及它与我的，所以我问尼尔·克利夫特。</font><font style="vertical-align:inherit">他和 John Rector 发现我的算法优于 Windows 内部的算法。</font><font style="vertical-align:inherit">与此同时，我向 Dahlia Malkhi 展示了我的算法，她提出了一些变体，包括论文中的</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Barrier</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 2 算法。&nbsp;

</font></font><p><font style="vertical-align:inherit"></font><a href="#proving"><font style="vertical-align:inherit"><font style="vertical-align:inherit">到 1980 年左右，我知道[23]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">
中引入的生产者/消费者算法</font><font style="vertical-align:inherit">应该推广到任意标记图，但我从未认为它重要到需要费心去解决细节。</font><a href="#arbiter-free"><font style="vertical-align:inherit">（指定数据流计算的标记图在[142]</font></a><font style="vertical-align:inherit">的讨论中进行了描述</font></font><a href="#arbiter-free"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">.）我意识到这些新的屏障同步算法也应该是该概括的实例。</font><font style="vertical-align:inherit">事实上，屏障算法在真正的多处理器上运行良好，使得通用算法看起来更有趣。</font><font style="vertical-align:inherit">进一步的思考表明，这些屏障算法的良好性能并非偶然。</font><font style="vertical-align:inherit">它们具有最佳的缓存行为，并且在一般情况下可以实现最佳的行为。</font><font style="vertical-align:inherit">所有这些使得通用同步算法与下一代多核处理器芯片相关。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="synchronizing"><b>Implementing Dataflow With Threads</b><br><i>Distributed Computing 21</i>, 3 (2008), 163-181.&nbsp; Also appeared as
Microsoft Research Technical
Report MSR-TR-2006-181 (December 2006)..<br></a><a href="https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-2006-181.pdf">Available
On-Line</a>
<br><font size="-2">Copyright 
2008 by Springer-Verlag.</font><hr>


In the summer of 2005, I was writing an algorithm in PlusCal
<a href="#pluscal">[162]</a> and essentially needed barrier synchronization as a
primitive.&nbsp; The easiest way to do this in PlusCal was to write a little
barrier synchronization algorithm.&nbsp; I used the simplest algorithm I
could think of, in which each process maintains a single 3-valued
variable--the <i>Barrier</i>1 algorithm of this paper.&nbsp; The algorithm
seemed quite nice, and I wondered if it was new.&nbsp; A Web search
revealed that it was.&nbsp; (In 2008, Wim Hesselink informed me that he had
discovered this algorithm in 2001, but he had "published" it only in
course notes.)&nbsp; I was curious about what barrier synchronization
algorithm was used inside the Windows operating system and how it
compared with mine, so I asked Neill Clift.&nbsp; He and John Rector found
that my algorithm outperformed the one inside Windows.&nbsp; Meanwhile, I
showed my algorithm to Dahlia Malkhi, who suggested some variants,
including the paper's <i>Barrier</i>2 algorithm.&nbsp;

<p>
By around 1980, I knew that the producer/consumer algorithm introduced
in <a href="#proving">[23]</a> should generalize to an arbitrary marked graph,
but I never thought it important enough to bother working out the
details.&nbsp; (Marked graphs, which specify dataflow computation, are
described in the discussion of <a href="#arbiter-free">[142]</a>.)&nbsp; I realized
that these new barrier synchronization algorithms should also be
instances of that generalization.&nbsp; The fact that the barrier
algorithms worked well on a real multiprocessor made the general
algorithm seem more interesting.&nbsp; Further thought revealed that the
good performance of these barrier algorithms was not an accident.&nbsp;
They have optimal caching behavior, and that optimal behavior can be
achieved in the general case.&nbsp; All this makes the general
synchronization algorithm relevant for the coming generation of
multicore processor chips.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="commentary-web"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Leslie Lamport：《规范语言</font></font></b><br><font style="vertical-align:inherit"></font></a><a href="https://www.springer.com/west/home?SGWID=4-102-22-173762603-0&amp;changeHeader=true&amp;SHORTCUT=www.springer.com/978-3-540-74106-0"><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">逻辑</font></font></i><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"><a name="commentary-web"><font style="vertical-align:inherit">中 
的 TLA+ </font></a><a href="https://www.springer.com/west/home?SGWID=4-102-22-173762603-0&amp;changeHeader=true&amp;SHORTCUT=www.springer.com/978-3-540-74106-0"><font style="vertical-align:inherit">》，Dines Bjørner 和 Martin C. Henson，编辑。</font></a><a href="https://www.springer.com/west/home?SGWID=4-102-22-173762603-0&amp;changeHeader=true&amp;SHORTCUT=www.springer.com/978-3-540-74106-0"><font style="vertical-align:inherit">施普林格（2008）</font></a><font style="vertical-align:inherit">，616-620。</font></font><br>
<a href="http://lamport.azurewebsites.net/pubs/commentary-web.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2008 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是对同一本书中斯蒂芬·梅尔茨 (Stephan Merz) 的章节的“评论”。</font><font style="vertical-align:inherit">主要是简单介绍TLA和TLA+背后的历史。</font><font style="vertical-align:inherit">其中包括布兰农·巴特森的一句有趣的话。</font><font style="vertical-align:inherit">（参见</font></font><a href="#high-level"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[147]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。）&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="commentary-web"><b>Leslie Lamport: The Specification Language
TLA+</b><br>In 
</a><a href="https://www.springer.com/west/home?SGWID=4-102-22-173762603-0&amp;changeHeader=true&amp;SHORTCUT=www.springer.com/978-3-540-74106-0"><i>Logics 
of Specification Languages</i>, Dines
Bjørner and Martin C. Henson, editors.&nbsp;
Springer (2008)</a>, 616-620.<br>
<a href="http://lamport.azurewebsites.net/pubs/commentary-web.pdf">PDF</a>
<br><font size="-2">Copyright 
2008 by Springer-Verlag.</font><hr>


This is a "review" of a chapter by Stephan Merz in the same book.&nbsp;
It is mainly a brief account of the history behind TLA and
TLA+.&nbsp; It includes an interesting quote from Brannon
Battson.&nbsp; (See <a href="#high-level">[147]</a>.)&nbsp;

<br>&nbsp;<p></p></li><li> <a name="state-machine"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算和状态机</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布（2008 年 2 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/state-machine.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我一直认为计算机科学是关于概念的，而不是语言。</font><font style="vertical-align:inherit">在 2006 年访问卢加诺大学时，出现了这样的问题：这意味着如何教授计算机科学。</font><font style="vertical-align:inherit">这是对答案的第一次尝试性尝试。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="state-machine"><b>Computation and State Machines</b><br>Unpublished 
  (February 2008).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/state-machine.pdf">PDF</a><hr>


I have long thought that computer science is about concepts, not
languages.&nbsp; On a visit to the University of Lugano in 2006, the
question arose of what that implied about how computer science should
be taught.&nbsp; This is a first, tentative attempt at an answer.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="keappa08-web"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 证明系统</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Kaustuv Chaudhuri、Damien Doligez 和 Stephan Merz 合作）</font></font><br>
 <i><font style="vertical-align:inherit"><font style="vertical-align:inherit">LPAR 研讨会论文集</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，CEUR 研讨会论文集 No.~418, 17-37 (2008)。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/keappa08-web.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是对用于编写形式证明的 TLA+ 构造的描述，也是对 TLA 证明系统的初步描述。</font><font style="vertical-align:inherit">它包括一个附录，其中包含 TLA+ 证明的形式语义。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="keappa08-web"><b>A TLA+ Proof System</b>&nbsp; (with Kaustuv Chaudhuri, Damien Doligez, and Stephan Merz)<br>
 <i>Proceedings of the LPAR Workshops</i>, CEUR Workshop Proceedings
No.~418, 17-37  (2008).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/keappa08-web.pdf">PDF</a><hr>


This is a description of the TLA+ constructs for
writing formal proofs, and a preliminary description of the TLA proof
system.&nbsp; It includes an appendix with a formal semantics of
TLA+ proofs.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="mailbox-web"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">邮箱问题</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Marcos Aguilera 和 Eli Gafni 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算 23</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 2 (2010), 113-134。</font><font style="vertical-align:inherit">（较短的版本出现在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 22 届分布式计算国际研讨会论文集 (DISC 2008)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1-15 中。）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/mailbox-web.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2010 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文解决了我在 20 世纪 80 年代首次想到的一个同步问题。</font><font style="vertical-align:inherit">2008 年加夫尼访问 MSR 硅谷时，我向他提出了这个想法，我们就开始着手研究。</font><font style="vertical-align:inherit">我认为这个问题无法解决，但我们开始怀疑是否有解决方案。</font><font style="vertical-align:inherit">加夫尼有一个算法的想法，但我没有试图理解这个想法，而是要求一个实际的算法。</font><font style="vertical-align:inherit">然后我们经历了一系列迭代，其中 Gafni 提出了一个算法，我在 PlusCal 中对其进行了编码（参见</font></font><a href="#pluscal"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[162]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">）并让模型检查器找到错误跟踪，然后我会将其提供给他。</font><font style="vertical-align:inherit">（在某个时候，他学会了足够的 PlusCal 来自己进行编码，但他从未安装 TLA+ 工具，而我继续运行模型检查器。）当 Aguilera 加入 MSR 并开始与我们合作时，这个过程停止了。</font><font style="vertical-align:inherit">他将加夫尼的想法变成了模型检查员认可的算法。</font><font style="vertical-align:inherit">加夫尼和阿奎莱拉得出了不可能的结果。</font><font style="vertical-align:inherit">阿奎莱拉和我完成了大部分实际写作工作，其中包括制定校样的细节。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="mailbox-web"><b>The Mailbox Problem</b>&nbsp; (with Marcos Aguilera and 
Eli Gafni)<br><i>Distributed Computing 23</i>, 2 (2010), 113-134.&nbsp; 
(A shorter version appeared
in <i>Proceedings of the 22nd International Symposium
               on Distributed Computing, (DISC 2008)</i>, 1-15.).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/mailbox-web.pdf">PDF</a>
<br><font size="-2">Copyright 
2010 by Springer-Verlag.</font><hr>


This paper addresses a little synchronization problem that I first
thought about in the 1980s.&nbsp; When Gafni visited MSR Silicon valley in
2008, I proposed it to him and we began working on it.&nbsp; I thought the
problem was unsolvable, but we began to suspect that there was a
solution.&nbsp; Gafni had an idea for an algorithm, but instead of trying
to understand the idea, I asked for an actual algorithm.&nbsp; We then went
through a series of iterations in which Gafni would propose an
algorithm, I'd code it in PlusCal (see <a href="#pluscal">[162]</a>) and let the
model checker find an error trace, which I would then give to him.&nbsp;
(At some point, he learned enough PlusCal to do the coding himself,
but he never installed the TLA+ tools and I continued to run the model
checker.)&nbsp; This process stopped when Aguilera joined MSR and began
collaborating with us.&nbsp; He turned Gafni's idea into an algorithm that
the model checker approved of.&nbsp; Gafni and Aguilera came up with the
impossibility results.&nbsp; Aguilera and I did most of the actual writing,
which included working out the details of the proofs.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="teaching-concurrency"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发教学</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGACT 新闻第 40 卷</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，第 1 期（2009 年 3 月），58-62。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/teaching-concurrency.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Idit Keidar 邀请我向 SIGACT News 的分布式计算专栏提交一篇笔记，该专栏致力于教授并发性。</font><font style="vertical-align:inherit">她在引言中写道，我的笔记“从地点、内容和方式的细节中退一步，并为教会学生如何清晰思考的高层次目标提供了理由。” </font><font style="vertical-align:inherit">必须提出教授如何清晰思考的案例，这说明了计算机科学教育的现状吗？

</font></font><br>&nbsp;<p></p></li><li> <a name="teaching-concurrency"><b>Teaching Concurrency</b><br><i>ACM SIGACT News 
Volume 40</i>,  Issue 1  (March 2009), 58-62.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/teaching-concurrency.pdf">PDF</a><hr>


Idit Keidar invited me to submit a note to a distributed computing
column in SIGACT News devoted to teaching concurrency.&nbsp; In an
introduction, she wrote that my note "takes a step back from the
details of where, what, and how, and makes a case for the high level
goal of teaching students how to think clearly." What does it say
about the state of computer science education that one must make a
case for teaching how to think clearly?

<br>&nbsp;<p></p></li><li> <a name="vertical-paxos"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">垂直 Paxos 和主备份复制</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Dahlia Malkhi 和 Lidong Zhou）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 28 届年度 ACM 分布式计算原理研讨会论文集，PODC 2009</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Srikanta Tirthapura 和 Lorenzo Alvisi，编辑。</font><font style="vertical-align:inherit">ACM（2009），312-313。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/vertical-paxos.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇论文是 Malkhi、Zhou 和我之间关于重新配置的大量讨论的结果。</font><font style="vertical-align:inherit">有一天，我们所做的可能会产生一篇关于状态机重新配置的长篇论文，其中包含这些结果和其他尚未发表的结果。</font></font><a href="#web-dsn-submission"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这里的想法与[152]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的原始未发布版本相关
</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="vertical-paxos"><b>Vertical Paxos and Primary-Backup
Replication</b>&nbsp; (with Dahlia Malkhi and Lidong Zhou)<br><i>Proceedings of the
28th Annual ACM Symposium on Principles of Distributed Computing, PODC
2009</i>, Srikanta Tirthapura and Lorenzo Alvisi, editors.&nbsp; ACM (2009),
312-313.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/vertical-paxos.pdf">PDF</a><hr>


This paper came out of much discussion between Malkhi, Zhou, and
myself about reconfiguration.&nbsp; Some day, what we did may result in a
long paper about state-machine reconfiguration containing these
results and others that have not yet been published.&nbsp; The ideas here
are related to the original, unpublished version of
<a href="#web-dsn-submission">[152]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="deroever-festschrift"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">计算机科学和状态机</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发性、组合性和正确性（纪念 Willem-Paul de Roever 的论文）。</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">丹尼斯·达姆斯、乌尔里希·汉内曼和马丁·史蒂芬编辑。</font><font style="vertical-align:inherit">计算机科学讲义，编号 5930 (2010)，60-65。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/deroever-festschrift.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"></font><a href="#state-machine"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这是[166]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">


的六页版本</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">我想这也是我第一次在印刷品中提到沃尔夫综合症。</font><font style="vertical-align:inherit">它是围绕一个可爱的简单示例构建的，其中通过用表达式替换规范的变量，从一个简单的规范中派生出重要的硬件协议。</font></font><a href="#teaching-concurrency"><font style="vertical-align:inherit"><font style="vertical-align:inherit">这个例子支持了[169]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的论点
</font><font style="vertical-align:inherit">：计算应该用数学来描述。</font><font style="vertical-align:inherit">（用表达式替换变量是数学的基本运算，但在编程语言中毫无意义。）&nbsp; 

</font></font><br>&nbsp;<p></p></li><li> <a name="deroever-festschrift"><b>Computer Science and State
Machines</b><br><i>Concurrency, Compositionality, and Correctness (Essays
in Honor of Willem-Paul de Roever).</i> Dennis Dams, Ulrich Hannemann,
and Martin Steffen editors.&nbsp; Lecture Notes in Computer Science, number
5930 (2010), 60-65.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/deroever-festschrift.pdf">PDF</a><hr>


This is the six-page version of <a href="#state-machine">[166]</a>.&nbsp; I think it is
also the first place I have mentioned the Whorfian syndrome in print.&nbsp;
It is structured around a lovely simple example in which an important
hardware protocol is derived from a trivial specification by
substituting an expression for the specification's variable.&nbsp; This
example is supporting evidence for the thesis of
<a href="#teaching-concurrency">[169]</a> that computation should be described
with mathematics.&nbsp; (Substitution of an expression for a variable is an
elementary operation of mathematics, but is meaningless in a
programming language.)&nbsp; 

<br>&nbsp;<p></p></li><li> <a name="reconfiguration-tutorial"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">重新配置状态机</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Dahlia Malkhi 和 Lidong Zhou 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM SIGACT 新闻第 41 卷</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，第 1 期（2010 年 3 月）.. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/reconfiguration-tutorial.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">



本文描述了重新配置状态机的几种方法。</font><font style="vertical-align:inherit">除了其中一个之外，所有这些都可以很容易地从 Paxos 论文
</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中提出的基本状态机重新配置方法中导出。</font><font style="vertical-align:inherit">我们认为发布它们是值得的，因为似乎很少有人理解基本方法。</font></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">（基本方法有一个参数α，我在[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中将其设为3，</font><font style="vertical-align:inherit">因为我愚蠢地认为每个人都会意识到3可以是任何正整数。）一种新算法，这里称为“砖墙”方法，只是草图。</font></font><a href="#stoppable"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在[173]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中有详细描述</font><font style="vertical-align:inherit">。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 

该论文被2008年PODC会议拒绝。</font><font style="vertical-align:inherit">Idit Keidar 邀请我们将其作为教程提交到她在 SIGACT News 中的分布式计算专栏。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="reconfiguration-tutorial"><b>Reconfiguring a State Machine</b>&nbsp; (with Dahlia Malkhi and Lidong Zhou)<br><i>ACM SIGACT News 
Volume 41</i>,  Issue 1  (March 2010)..<br>
</a><a href="http://lamport.azurewebsites.net/pubs/reconfiguration-tutorial.pdf">PDF</a><hr>



This paper describes several methods of reconfiguring a state machine.&nbsp;
All but one of them can be fairly easily derived from the basic
state-machine reconfiguration method presented in the Paxos paper
<a href="#lamport-paxos">[123]</a>.&nbsp; We felt that it was worthwhile publishing
them because few people seemed to understand the basic method.&nbsp; (The
basic method has a parameter α that I took
to be 3 in <a href="#lamport-paxos">[123]</a> because I stupidly thought that
everyone would realize that the 3 could be any positive integer.)&nbsp;
The one new algorithm, here called the "brick wall" method,
is just sketched.&nbsp; It is described in detail in <a href="#stoppable">[173]</a>.&nbsp;

<p> 

This paper was rejected by the 2008 PODC conference.&nbsp; Idit Keidar
invited us to submit it as a tutorial to her distributed computing
column in SIGACT News.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="stoppable"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Stoppable Paxos</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit"> &nbsp; （与 Dahlia Malkhi 和 Lidong Zhou）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发布（2009 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/stoppable.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文包含对
</font></font><a href="#reconfiguration-tutorial"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[172]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中概述的“砖墙”算法的完整描述和证明。</font><font style="vertical-align:inherit">它被 2008 年 DISC 会议拒绝。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="stoppable"><b>Stoppable Paxos</b>&nbsp; (with Dahlia Malkhi and Lidong Zhou)<br>Unpublished
(April 2009).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/stoppable.pdf">PDF</a><hr>


This paper contains a complete description and proof of the "brick
wall" algorithm that was sketched in
<a href="#reconfiguration-tutorial">[172]</a>.&nbsp; It was rejected from the 2008 DISC
conference.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="pnueli"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">时态逻辑：三害相权取其轻，</font></font></b><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未出版（2010 年 4 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/pnueli.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇论文是为 2010 年 5 月在纽约大学举办的纪念 Amir Pnueli 的研讨会而写的。我喜欢并非常尊重 Amir，但我犯了一个错误，写了一篇他会喜欢的论文。</font><font style="vertical-align:inherit">这是一个错误，因为纪念不是为了死者，而是为了爱他的人。</font><font style="vertical-align:inherit">那些人认为这张纸不适合作为纪念，我不质疑他们的判断。</font><font style="vertical-align:inherit">我希望已经过去了足够的时间，以便人们现在可以阅读这篇论文，并在其中看到我对阿米尔所做的事情的感激之情，就像我向他表达的那样。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="pnueli"><b>Temporal Logic: The Lesser of Three
  Evils</b><br>Unpublished (April 2010).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/pnueli.pdf">PDF</a><hr>


This paper was written for a symposium in memory of Amir Pnueli held
at New York University in May of 2010.&nbsp; I liked and greatly respected
Amir, and I made the mistake of writing a paper he would have enjoyed.&nbsp;
This was a mistake because a memorial is not for the dead, but for the
people who loved him.&nbsp; Those people found the paper unsuitable for a
memorial, and I don't question their judgement.&nbsp; I hope enough time
has passed so that people can now read the paper and see in it a small
indication of my gratitude to Amir for what he did, as I would have
expressed it to him.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="verifying-safety"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA+ 证明系统验证安全属性</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Kaustuv Chaudhuri 等人合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">第五届国际自动推理联合会议 (IJCAR)，英国爱丁堡。</font><font style="vertical-align:inherit">（2010 年 7 月）142-148。</font></font><br></a><a href="https://arxiv.org/pdf/1011.2560.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可从 Math arXiv 获取。</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这本质上是 TLAPS 证明系统开发的进度报告。</font><font style="vertical-align:inherit">我相信它描述了该系统的状态，该系统主要由 Chaudhuri 在该项目的博士后职位结束时实施。 

</font></font><br>&nbsp;<p></p></li><li> <a name="verifying-safety"><b>Verifying Safety Properties With the 
  TLA+ Proof System</b>&nbsp; (with Kaustuv Chaudhuri et al.)<br>Fifth International Joint 
  Conference on Automated Reasoning (IJCAR), Edinburgh, UK. (July 2010)
  142-148.<br></a><a href="https://arxiv.org/pdf/1011.2560.pdf">Available 
     from Math arXiv.</a><hr>


This was essentially a progress report on the development of the TLAPS
proof system.&nbsp; I believe it describes the state of the system, largely
implemented by Chaudhuri, at the end of his post-doc position on the
project. 

<br>&nbsp;<p></p></li><li> <a name="web-byzpaxos"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">通过细化</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算拜占庭化 Paxos：第 25 届国际研讨会：DISC 2011</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，David Peleg，编辑。</font><font style="vertical-align:inherit">施普林格出版社 (2011) 211-224。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/web-byzpaxos.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Castro-Liskov 算法（Miguel Castro 和 Barbara Liskov，
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">实用拜占庭容错和主动恢复，TOCS 20:4 [2002] 398-461）直观上看起来像是对 Paxos </font></font></i><font style="vertical-align:inherit"></font><a href="#lamport-paxos"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[123]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的修改</font><font style="vertical-align:inherit">，使用 3n+1 来处理拜占庭故障进程而不是 2n+1 来处理 n 个故障。</font><font style="vertical-align:inherit">2003 年，我意识到思考该算法的一个好方法是，2n+1 个无故障进程试图在存在 n 个恶意进程的情况下实现普通 Paxos——每个正常进程都不知道其他进程中哪些是恶意的。</font><font style="vertical-align:inherit">虽然我在讲座中提到了这个想法，但我并没有弄清楚细节。&nbsp;

</font></font><p><font style="vertical-align:inherit"></font><a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">
TLAPS（TLA+ 证明系统）</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">

的开发</font><font style="vertical-align:inherit">启发我编写了两种算法的正式 TLA+ 规范，以及 Castro-Liskov 算法改进普通 Paxos 的 TLAPS 检查证明。</font><font style="vertical-align:inherit">本文描述了结果。</font><font style="vertical-align:inherit">完整的规格和证明可
  </font><a href="http://lamport.azurewebsites.net/tla/byzpaxos.html"><font style="vertical-align:inherit">在此处</font></a><font style="vertical-align:inherit">获取。&nbsp;


</font></font><!---at
   \url{https://lamport.azurewebsites.net//tla/byzpaxos.html}%
   ---><a href="http://lamport.azurewebsites.net/tla/byzpaxos.html"><font style="vertical-align:inherit"></font></a><font style="vertical-align:inherit"></font><br>&nbsp;</p><p></p></li><li> <a name="web-byzpaxos"><b>Byzantizing Paxos by Refinement</b><br><i>Distributed 
Computing: 25th International Symposium: DISC 2011</i>,
David Peleg, editor.&nbsp; Springer-Verlag (2011) 211-224.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/web-byzpaxos.pdf">PDF</a><hr>


The Castro-Liskov algorithm (Miguel Castro and Barbara Liskov,
<i>Practical Byzantine Fault Tolerance and Proactive Recovery</i>,
TOCS 20:4 [2002] 398-461) intuitively seems like a modification of
Paxos <a href="#lamport-paxos">[123]</a> to handle Byzantine failures, using
3n+1 processes instead of 2n+1 to handle
n failures.&nbsp; In 2003 I realized that a nice way to think about
the algorithm is that 2n+1 non-faulty processes are
trying to implement ordinary Paxos in the presence of n
malicious processes--each good process not knowing which of the other
processes are malicious.&nbsp; Although I mentioned the idea in lectures, I
didn't work out the details.&nbsp;

<p>

The development 
  of<a href="https://tla.msr-inria.inria.fr/tlaps/content/Home.html">
TLAPS, the TLA+ proof system</a>,
inspired me to write formal TLA+ specifications of the
two algorithms and a TLAPS-checked proof that the Castro-Liskov
algorithm refines ordinary Paxos.&nbsp; This paper describes the results.&nbsp;
The complete specifications and proof are
available
  <!---at
   \url{https://lamport.azurewebsites.net//tla/byzpaxos.html}%
   ---><a href="http://lamport.azurewebsites.net/tla/byzpaxos.html">here</a>.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="disc-leaderless-web"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">Leaderless Byzantine Paxos</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">分布式计算：第 25 届国际研讨会：DISC 2011</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，David Peleg，编辑。</font><font style="vertical-align:inherit">施普林格出版社 (2011) 141-142。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/disc-leaderless-web.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这篇两页纸的笔记描述了我在 2005 年提出的一个简单想法。我发现 Castro-Liskov 算法和其他“拜占庭 Paxos”算法并不令人满意，因为它们使用领导者，并且为了取得进展，它们需要检测和删除恶意领导者。</font><font style="vertical-align:inherit">我的想法是通过使用同步拜占庭协议算法来实现虚拟领导者来消除领导者。</font><font style="vertical-align:inherit">该注释太短，无法讨论实际细节，但它们似乎很简单。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="disc-leaderless-web"><b>Leaderless Byzantine Paxos</b><br><i>Distributed 
Computing: 25th International Symposium: DISC 2011</i>,
David Peleg, editor.&nbsp; Springer-Verlag (2011) 141-142.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/disc-leaderless-web.pdf">PDF</a><hr>


This two-page note describes a simple idea that I had in 2005.&nbsp; I have
found the Castro-Liskov algorithm and other "Byzantine Paxos"
algorithms unsatisfactory because they use a leader and, for progress,
they require detecting and removing a malicious leader.&nbsp; My idea was
to eliminate the leader by using a synchronous Byzantine agreement
algorithm to implement a virtual leader.&nbsp; The note is too short to
discuss the practical details, but they seem to be straightforward.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="euclid"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">欧几里得编写算法：童话般的</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">国际软件和信息学杂志 5</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> , 1-2 (2011) 第 1 部分, 7-20。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/euclid.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是为纪念曼弗雷德·布罗伊 (Manfred Broy) 60 岁生日而特邀撰写的论文。</font><font style="vertical-align:inherit">这是对 TLA+ 的异想天开的介绍，包括证明。</font><font style="vertical-align:inherit">作为文学来评判，这可能是我写过的最好的东西。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="euclid"><b>Euclid Writes an Algorithm: A
Fairytale</b><br><i>International Journal of Software and Informatics 5</i>,
1-2 (2011) Part 1, 7-20.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/euclid.pdf">PDF</a><hr>


This was an invited paper for a festschrift in honor of Manfred Broy's
60th birthday.&nbsp; It's a whimsical introduction to TLA+,
including proofs.&nbsp; Judged as literature, it's probably the best thing
I have ever written.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="proof"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如何撰写</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">定点理论和应用的 21 世纪证明期刊</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">doi:10.1007/s11784-012-0071-6（2012 年 3 月 6 日）.. </font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/proof.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a>
<br><font size="-2"><font style="vertical-align:inherit"><font style="vertical-align:inherit">版权所有 2012 Springer-Verlag。</font></font></font><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我受邀在理查德·帕莱 (Richard Palais) 80 岁生日庆祝活动上发表演讲。</font><font style="vertical-align:inherit">正是在他 60 岁生日的庆祝活动上，我第一次发表了关于如何编写证明的演讲——这次演讲导致了
</font></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">因此，我认为进行同样的演讲会很有趣，并进行更新以反映我 20 年编写结构化证明的经验。</font><font style="vertical-align:inherit">这次演讲比我之前的演讲更平静，数学家们也愿意考虑我可能有一些关于写证明的有趣的事情要说。</font><font style="vertical-align:inherit">也许在过去的20年里，我学会了变得更有说服力，或者也许观众席上的数学家们变得更老、更冷静了。</font><font style="vertical-align:inherit">无论如何，他们仍然没有准备好尝试改变自己编写证明的方式。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

我准备和发表演讲的经历让我意识到是时候就这个主题写一篇新论文了。</font><font style="vertical-align:inherit">本文围绕一个简单的例子构建——来自 Michael Spivak 的微积分文本的引理。</font><font style="vertical-align:inherit">我试图展示数学家如何轻松地将她现在编写的证明转换为结构化证明。</font><font style="vertical-align:inherit">该论文还简要描述了如何用 TLA+ 编写正式的结构化证明，并且附录包含 Spivak 引理的机器检查证明。</font><font style="vertical-align:inherit">虽然数学家在可预见的将来不会编写正式证明，但我认为学习如何编写它们是学习如何编写严格的非正式证明的好方法。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="proof"><b>How to Write a 21st Century Proof</b><br><i>Journal of 
Fixed Point Theory and Applications</i> doi:10.1007/s11784-012-0071-6 
(6 March 2012)..<br>
</a><a href="http://lamport.azurewebsites.net/pubs/proof.pdf">PDF</a>
<br><font size="-2">Copyright 
2012 by Springer-Verlag.</font><hr>


I was invited to give a talk at a celebration of the 80th birthday of
Richard Palais.&nbsp; It was at a celebration of his 60th birthday that I
first gave a talk about how to write a proof--a talk that led to
<a href="#lamport-how-to-write">[102]</a>.&nbsp; So, I thought it would be fun to give
the same talk, updated to reflect my 20 years of experience writing
structured proofs.&nbsp; The talk was received much more calmly than my
earlier one, and the mathematicians were open to considering that I
might have something interesting to say about writing proofs.&nbsp; Perhaps
in the last 20 years I have learned to be more persuasive, or perhaps
the mathematicians in the audience had just grown older and calmer.&nbsp;
In any case, they were still not ready to try changing how they write
their own proofs.&nbsp;

<p>

My experience preparing and giving the talk made me realize it was
time for a new paper on the subject.&nbsp; This paper is built around a
simple example--a lemma from Michael Spivak's calculus text.&nbsp; I tried
to show how a mathematician can easily transform the proofs she now
writes into structured proofs.&nbsp; The paper also briefly describes how
formal structured proofs are written in TLA+, and an
appendix contains a machine-checked proof of Spivak's lemma.&nbsp; While
mathematicians will not write formal proofs in the
foreseeable future, I argue that learning how to write them is a good
way to learn how to write rigorous informal proofs.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="tlaps"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 证明</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Denis Cousineau 等人合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 18 届国际形式方法研讨会论文集 (FM 2012)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，Dimitra Giannakopoulou 和 Dominique Mery，编辑。</font><font style="vertical-align:inherit">Springer-Verlag 计算机科学讲义，第 7436 卷 (2012) 147-154。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/tlaps.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是一篇描述 TLAPS 的简短论文，即 Microsoft Research-INRIA 联合中心正在开发的 TLA+ 证明系统。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="tlaps"><b>TLA+ Proofs</b>&nbsp; (with Denis Cousineau et al.)<br><i>Proceedings of
the 18th International Symposium on Formal Methods (FM 2012)</i>, 
Dimitra Giannakopoulou and Dominique Mery, editors.&nbsp;
 Springer-Verlag Lecture Notes in Computer Science,
   Volume 7436 (2012) 147-154.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/tlaps.pdf">PDF</a><hr>


This is a short paper describing TLAPS, the TLA+ proof system being
developed at the Microsoft Research-INRIA Joint Centre.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="wired"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">为什么我们应该像建造房屋一样构建软件</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">连线</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（在线版本）2013 年 1 月 25 日。</font></font><br></a><a href="https://www.wired.com/opinion/2013/01/code-bugs-programming-why-we-need-specs/"><font style="vertical-align:inherit"><font style="vertical-align:inherit">网络出版物</font></font></a><hr><font style="vertical-align:inherit"></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《连线》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">


杂志的一位编辑找到我</font><font style="vertical-align:inherit">为他们写一篇文章。</font><font style="vertical-align:inherit">经过大量的讨论和重写，我们最终在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">《连线》</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">想要的内容和我愿意签名的内容之间达成了妥协。</font><font style="vertical-align:inherit">这篇文章的基本信息是，在编程时，在编码之前思考是个好主意。</font><font style="vertical-align:inherit">当发布的评论显示这是一个有争议的声明时，我感到很惊讶。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="wired"><b>Why We Should Build 
Software Like We Build Houses</b><br><i>Wired</i> (on-line version) 25 January 2013.<br></a><a href="https://www.wired.com/opinion/2013/01/code-bugs-programming-why-we-need-specs/">web publication</a><hr>


I was approached by an editor at <i>Wired</i> to write an article for
them.&nbsp; After a great deal of discussion and rewriting, we finally came
up with this compromise between what <i>Wired</i> wanted and what I was
willing to sign my name to.&nbsp; The basic message of the piece is that,
when programming, it's a good idea to think before you code.&nbsp; I was
surprised when the posted comments revealed that this is a
controversial statement.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="adaptive"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">具有线性寄存器数量的自适应寄存器分配</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Delporte-Gallet 等人合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 27 届国际分布式计算研讨会论文集 (DISC 2013)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> 269-283。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/adaptive.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我与本文中的算法关系不大。</font><font style="vertical-align:inherit">我主要负责在 PlusCal 中编写它们并编写 
 </font></font><a href="http://lamport.azurewebsites.net/tla/snapshot.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 证明 
 </font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="adaptive"><b>Adaptive Register Allocation with a Linear Number
of Registers</b>&nbsp; (with Delporte-Gallet et al.)<br><i> Proceedings of the 27th
International Symposium on Distributed Computing (DISC 2013)</i> 269-283.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/adaptive.pdf">PDF</a><hr>


I had little to do with the algorithms in this paper.&nbsp; I was mainly
responsible for writing them in PlusCal and getting a 
 <a href="http://lamport.azurewebsites.net/tla/snapshot.html">TLA+ proof 
 </a>written.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="coalescing"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">合并：一阶模态逻辑推理的句法抽象</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Damien Doligez 等人合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">量化非经典逻辑自动推理研讨会论文集 (ARNL 2014)</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/coalescing.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


当使用对某一类数学运算符进行推理的定理证明器来推理包含更大类运算符的表达式时，我们必须向证明者隐藏它无法处理的运算符。</font><font style="vertical-align:inherit">&nbsp;例如，如果普通数学的证明者将启动 ( ) 视为普通数学运算符，则它</font><font style="vertical-align:inherit">会（错误地）推断出 TLA+ 动作公式 
 
  </font></font><code>(x = y) =&gt; (x' = y')</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">
是同义反复&nbsp;。</font></font><code>'</code><font style="vertical-align:inherit"><font style="vertical-align:inherit">我们称这种隐藏 
 </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">合并</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">本文表明合并比人们想象的要微妙一些，并解释了如何在一些重要情况下正确地进行合并。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="coalescing"><b>Coalescing: Syntactic Abstraction for Reasoning in
 First-Order Modal Logics</b>&nbsp; (with Damien Doligez et al.)<br><i>Proceedings of the Workshop
 on Automated Reasoning in Quantified Non-Classical Logics (ARNL 2014)</i>.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/coalescing.pdf">PDF</a><hr>


When using a theorem prover that reasons about a certain class of
mathematical operators to reason about expressions containing a larger
class of operators, we have to hide from the prover the operators it
can't handle.&nbsp; For example, a prover for ordinary mathematics would 
(incorrectly) deduce that the TLA+ action formula 
 
  <code>(x = y) =&gt; (x' = y')</code>
is a tautology if it were to treat priming 
 (&nbsp;<code>'</code>&nbsp;) as an ordinary
mathematical operator.&nbsp; We call this kind of hiding 
 <i>coalescing</i>.&nbsp; 
This paper shows that coalescing is somewhat more subtle than one
might think, and explains how to do it correctly in some important
cases.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="blueprints"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">谁不画蓝图就盖房子？</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM 通讯 58、4</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（2015 年 4 月）、38-41。</font></font><br></a><a href="https://cacm.acm.org/magazines/2015/4/184705-who-builds-a-house-without-drawing-blueprints/fulltext"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可在 ACM 网站上获取。</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


讨论非正式规范。</font></font><a href="#wired"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它是[181]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的扩展版本</font><font style="vertical-align:inherit">。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="blueprints"><b>Who Builds a House without Drawing Blueprints?</b><br><i>Communications of the ACM 58</i>, 4 (April 2015), 38-41.<br></a><a href="https://cacm.acm.org/magazines/2015/4/184705-who-builds-a-house-without-drawing-blueprints/fulltext">Available on ACM
web site.</a><hr>


Discusses informal specification.&nbsp; It is an
expanded version of <a href="#wired">[181]</a>.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="turing"><b><font style="vertical-align:inherit"></font></b><br>
<i><font style="vertical-align:inherit"><font style="vertical-align:inherit">并发计算机科学： ACM 的</font></font></i><font style="vertical-align:inherit"><b><font style="vertical-align:inherit">早期</font></b><font style="vertical-align:inherit">交流，2015 年 6 月，卷。</font><font style="vertical-align:inherit">58 第 6 期，第 71-76 页。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/turing.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


这是我 2014 年 7 月在巴黎 PODC 会议上发表的图灵演讲的书面版本。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="turing"><b>The Computer Science of Concurrency: The Early Years</b><br>
<i>Communications of the ACM, June 2015</i>, Vol. 58 No. 6, Pages 71-76.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/turing.pdf">PDF</a><hr>


This is the written version of my Turing lecture, which I gave at
the PODC conference in Paris in July, 2014.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="auxiliary"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 中的辅助变量</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Stephan Merz 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">未发表，arXiv 论文 1703.05121（2017 年 5 月）。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/auxiliary.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


尽管大多数想法在当时已经很成熟，但论文</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">已成为关于细化映射和辅助变量的标准参考——添加到规范中以允许构建细化映射的变量，在该映射下它实现了更高级别的规格。</font><font style="vertical-align:inherit">论文引入的一个主要新思想是预言变量，它是预测未来的辅助变量。</font><font style="vertical-align:inherit">预言变量看起来非常优雅，因为历史变量是倒退的。</font><font style="vertical-align:inherit">它们有一个严重的问题：即使对我来说，在实践中使用它们也极其困难。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">


Martín Abadi 在 2015 年发表的一篇论文介绍了一种使预言变量更易于使用的方法，这启发了我重新审视它们。</font><font style="vertical-align:inherit">我想出了一种全新的预言变量——我发现它非常容易使用。</font><font style="vertical-align:inherit">我相信阿巴迪和我在 1988 年没有发现这种变量，因为我还没有发明 TLA+，所以我们只考虑状态而不是动作（状态对的谓词）。</font><font style="vertical-align:inherit">有了最初的想法后，我请 Stephan Merz 与我一起确定细节。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

本文是为工程师编写的。</font><font style="vertical-align:inherit">它包含针对每种类型的辅助变量的 TLA+ 模块，并演示如何使用该模块中定义的运算符将此类辅助变量添加到规范中。</font><font style="vertical-align:inherit">这些模块以及本文中所有示例的模块都可以</font></font><a href="https://lamport.azurewebsites.net/tla/auxiliary/auxiliary.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在 Web 上获得</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

辅助变量分为三种类型，每种都有自己的模块。</font><font style="vertical-align:inherit">除了记录过去的历史变量和预测未来的预言变量之外，还有添加口吃步骤（不执行任何操作的步骤）的口吃变量。</font><font style="vertical-align:inherit">论文
</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用预言变量来添加口吃步骤，但我们很早就知道最好使用一种单独的变量来实现此目的。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">

论文中描述的辅助变量可以进行语义定义；</font><font style="vertical-align:inherit">它们并非特定于 TLA+ 语言。</font><font style="vertical-align:inherit">我们希望在以后的论文中以独立于语言的方式定义它们，并证明与论文
</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">类似的完整性结果。</font><font style="vertical-align:inherit">我们认为，新的预言变量比原来的预言变量更强大，并且完整性不需要原始预言变量所需的有限内部非确定性假设。&nbsp;

</font></font><br>&nbsp;</p><p></p></li><li> <a name="auxiliary"><b>Auxiliary Variables in TLA+</b>&nbsp; (with Stephan
Merz)<br>Unpublished, arXiv paper 1703.05121 
(May 2017).<br>
</a><a href="http://lamport.azurewebsites.net/pubs/auxiliary.pdf">PDF</a><hr>


Although most of the ideas were already well-established at the time,
paper <a href="#abadi-existence">[92]</a> has become the standard reference on
refinement mappings and auxiliary variables--variables added to a
specification to permit constructing a refinement mapping under which
it implements a higher-level specification.&nbsp; A major new idea that
paper introduced was prophecy variables, which are auxiliary variables
that predict the future.&nbsp; Prophecy variables seemed very elegant,
being history variables run backwards.&nbsp; They had one serious problem:
they were extremely difficult even for me to use in practice.&nbsp;

<p>


A 2015 paper by Martín Abadi
introducing a method for making prophecy variables easier to use
inspired me to take a new look at them.&nbsp; I came up with a completely
new kind of prophecy variable--one that I find quite easy to use.&nbsp; I
believe that Abadi and I did not discover this kind of variable in
1988 because I had not yet invented TLA+, so we were
thinking only in terms of states and not in terms of actions
(predicates on pairs of states).&nbsp; After I had the initial idea, I
asked Stephan Merz to work with me to get the details right.&nbsp;

</p><p>

This paper is written for engineers.&nbsp; It contains a TLA+
module for each type of auxiliary variable and shows how to use
operators defined in that module to add such an auxiliary variable to
a specification.&nbsp; These modules, along with the modules for all the
examples in the paper, are <a href="https://lamport.azurewebsites.net/tla/auxiliary/auxiliary.html">available on the
Web</a>.&nbsp;

</p><p>

There are three types of auxiliary variables, each with its own
module.&nbsp; In addition to history variables that record the past and
prophecy variables that predict the future, there are stuttering
variables that add stuttering steps (steps that do nothing).&nbsp; Paper
<a href="#abadi-existence">[92]</a> used prophecy variables to add stuttering
steps, but we have long known that it's better to use a separate kind
of variable for that purpose.&nbsp;

</p><p>

The auxiliary variables described in the paper can be defined
semantically; they are not specific to the TLA+ language.&nbsp;
We hope in a later paper to define them in a language-independent
fashion, and to prove a completeness result similar to that of paper
<a href="#abadi-existence">[92]</a>.&nbsp; We believe that the new kind of prophecy
variable is more powerful than the original one, and that completeness
does not require the hypothesis of finite internal nondeterminism
needed for the original prophecy variables.&nbsp;

<br>&nbsp;</p><p></p></li><li> <a name="eatcs"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">如果您不编写程序，请勿使用编程语言</font></font></b><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">EATCS（欧洲理论计算机科学协会）公告，</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 125 期，2018 年 6 月。</font></font><br></a><a href="http://bulletin.eatcs.org/index.php/beatcs/article/view/539"><font style="vertical-align:inherit"><font style="vertical-align:inherit">网络出版物</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


2018 年 1 月，我受邀为 EATCS Bulletin 的分布式计算专栏投稿。</font><font style="vertical-align:inherit">我回答说我对 EATCS 社区对此主题无话可说，并且我提出按照
</font></font><a href="#teaching-concurrency"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[169]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的思路写一些东西。</font><font style="vertical-align:inherit">这个提议被接受了，我写了这篇文章。</font><font style="vertical-align:inherit">它详细讨论了我在之前的文章中只能概述的内容：如何用数学描述算法。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="eatcs"><b>If You’re Not Writing a Program,
 Don’t Use a Programming Language</b><br><i>Bulletin of EATCS (The 
 European Association for Theoretical Computer Science)</i> No. 125, June 2018.<br></a><a href="http://bulletin.eatcs.org/index.php/beatcs/article/view/539">web publication</a><hr>


In January, 2018 I was invited to contribute an article to the
Distributed Computing column of the EATCS Bulletin.&nbsp; I replied that I
had nothing to say on that subject to the EATCS community, and I offered
instead to write something along the lines of
<a href="#teaching-concurrency">[169]</a>.&nbsp; That offer was accepted, and I wrote
this article.&nbsp; It discusses in detail what I could only sketch in my
earlier article: how to describe algorithms with mathematics.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="recursive-ops"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">递归运算符定义</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Georges Gonthier 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Inria 研究报告第 9341 号</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，2020 年 5 月。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/recursive-ops.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


我们可以通过将空集的基数定义为 0 并将任何其他有限集的基数定义为 1 加上通过删除其中一个元素而从中获得的集合的基数，来递归地定义有限集的基数。</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">数学家会把基数</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">称为
</font><font style="vertical-align:inherit">函数，直到你提醒他们函数有一个域，该域必须是集合，而所有有限集合的集合不是集合。&nbsp; </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">基数</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">不是一个函数；而是一个函数。</font><font style="vertical-align:inherit">我称其为操作员。</font><font style="vertical-align:inherit">TLA+规范语言原本允许递归函数定义；</font><font style="vertical-align:inherit">它不允许递归运算符定义，因为我不知道如何定义它们的语义，而且显然其他人也没有这样做。</font><i><font style="vertical-align:inherit">要理解这个问题，请考虑运算符Op</font></i><font style="vertical-align:inherit">的递归定义</font></font><i><font style="vertical-align:inherit"></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">断言对于任何</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">，</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Op</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ( </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ) 等于某个不等于 
</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">Op</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ( </font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">v</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit"> ) 的值。</font><font style="vertical-align:inherit">（在 TLA+ 中编写这个定义很容易。）2005 年，我有了一个如何为递归运算符定义定义语义的想法，Georges Gonthier 将我的想法转换为正确的定义。</font><font style="vertical-align:inherit">2019 年，我决定应该记录该定义，并说服乔治和我一起撰写这篇论文。&nbsp;

</font></font><br>&nbsp;<p></p></li><li> <a name="recursive-ops"><b>Recursive Operator Definitions</b>&nbsp; (with Georges 
 Gonthier)<br><i>Inria Research Report No. 9341</i>, May 2020.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/recursive-ops.pdf">PDF</a><hr>


We can recursively define the cardinality of a finite set by defining
the cardinality of the empty set to be 0 and the cardinality of any
other finite set to be 1 plus the cardinality of the set obtained from
it by removing one of its elements.&nbsp; Mathematicians will call
<i>cardinality</i> a function, until you remind them that a function
has a domain that must be a set, and the collection of all finite sets
is not a set.&nbsp; <i>Cardinality</i> is not a function; I call it an
operator.&nbsp; The TLA+ specification language originally allowed
recursive function definitions; it did not allow recursive operator
definitions because I didn't know how to define their semantics, and
apparently no one else did either.&nbsp; To appreciate the problem,
consider the recursive definition of an operator <i>Op</i> asserting,
for any <i>v</i>, that <i>Op</i>(<i>v</i>) equals some value not equal to 
<i>Op</i>(<i>v</i>).&nbsp; (It's easy to write this
definition in TLA+.)&nbsp; In 2005, I had an idea of how to define a
semantics for recursive operator definitions, and Georges Gonthier
converted my idea into a correct definition.&nbsp; In 2019 I decided that
the definition should be documented, and I persuaded Georges to join
me in writing this paper.&nbsp;

<br>&nbsp;<p></p></li><li> <a name="toolbox"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">TLA+ 工具箱</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Markus Kuppe 和 Daniel Ricketts 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">第五届正式集成开发环境研讨会论文集（2019 年 10 月），第 50-62 页。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/toolbox.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


TLA+ Toolbox 是 TLA+ 工具的集成开发环境。</font><font style="vertical-align:inherit">它最初是由 Simon Zambrovski 在我的监督下编写的。</font><font style="vertical-align:inherit">此后不久，Daniel Ricketts 添加了一个漂亮的界面，用于从工具箱运行 TLAPS 证明器。</font><font style="vertical-align:inherit">近年来，Markus Kuppe 一直在改进工具箱。</font><font style="vertical-align:inherit">库佩和我决定是时候写一篇论文来描述工具箱最新颖的功能了。</font><font style="vertical-align:inherit">库佩撰写了这篇论文的几乎所有内容，里基茨和我编辑了他所写的内容。 


</font></font><br>&nbsp;<p></p></li><li> <a name="toolbox"><b>The TLA+ Toolbox</b>&nbsp; (with Markus Kuppe and Daniel 
Ricketts)<br>Proceedings of the Fifth Workshop on Formal Integrated Development 
               Environments (October 2019), pages 50-62.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/toolbox.pdf">PDF</a><hr>


The TLA+ Toolbox is an integrated development environment for the TLA+
tools.&nbsp; It was originally written by Simon Zambrovski under my
supervision.&nbsp; Shortly thereafter, Daniel Ricketts added a nice
interface for running the TLAPS prover from the Toolbox.&nbsp; In recent
years, Markus Kuppe has been improving the Toolbox.&nbsp; Kuppe and I
decided it was time to write a paper describing the most novel
features of the Toolbox.&nbsp; Kuppe wrote almost all of the paper, and
Ricketts and I edited what he had written. 


<br>&nbsp;<p></p></li><li> <a name="simple"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">预言变得简单</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Stephan Merz 合作）</font></font><br><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">ACM Transactions on 编程语言和系统 44、2</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">（2022 年 6 月）、1-27。</font><font style="vertical-align:inherit">已发布的版本 
</font></font></a><a href="https://dl.acm.org/doi/10.1145/3492545"><font style="vertical-align:inherit"><font style="vertical-align:inherit">可在此处获取。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/simple.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


本文提供了我们希望对</font></font><a href="#auxiliary"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[186]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中的想法的简单解释。</font><font style="vertical-align:inherit">该论文包含了对辅助变量的描述，这些变量被埋藏在如何在实际 TLA+ 规范中使用它们的大量细节之下。</font></font><a href="#abadi-existence"><font style="vertical-align:inherit"><font style="vertical-align:inherit">它最重要的贡献是一种新型的预言变量，它比[92]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">中引入的原始预言变量更强大且使用起来更简单
</font><font style="vertical-align:inherit">。</font><font style="vertical-align:inherit">本文通过一系列简单的例子来解释辅助变量，重点关注预言变量。</font><font style="vertical-align:inherit">此外，它还解释了预言常数——Hesselink 在 2005 年提出的一个想法——并勾勒出完整的结果。</font><font style="vertical-align:inherit">它假设没有 TLA 或辅助变量的先验知识。&nbsp;


</font></font><br>&nbsp;<p></p></li><li> <a name="simple"><b>Prophecy Made Simple</b>&nbsp; (with Stephan Merz)<br><i>ACM Transactions on Programming Languages and Systems 44</i>, 2 (June 2022), 1-27. Published version 
</a><a href="https://dl.acm.org/doi/10.1145/3492545">available here.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/simple.pdf">PDF</a><hr>


This paper provides what we hope is a simple explanation of the ideas
in <a href="#auxiliary">[186]</a>.&nbsp; That paper contained an account of auxiliary
variables that was buried under a mountain of details on how to use
them in actual TLA+ specifications.&nbsp; Its most important contribution
was a new kind of prophecy variable that is more powerful and much
simpler to use than the original prophecy variable introduced in
<a href="#abadi-existence">[92]</a>.&nbsp; This paper explains auxiliary variables
through a series of simple examples, concentrating on prophecy
variables.&nbsp; In addition, it explains prophecy constants-an idea
introduced by Hesselink in 2005-and sketches a completeness result.&nbsp;
It assumes no prior knowledge of TLA or auxiliary variables.&nbsp;


<br>&nbsp;<p></p></li><li> <a name="hyper2"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">使用 TLA 验证超属性</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与 Fred B. Schneider 合作）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">出现在</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">第 34 届 {IEEE} 计算机安全基金会研讨会 ({CSF} 2021) 的会议记录</font></font></i><font style="vertical-align:inherit"><font style="vertical-align:inherit">中。</font></font><br>
</a><a href="http://lamport.azurewebsites.net/pubs/hyper2.pdf"><font style="vertical-align:inherit"><font style="vertical-align:inherit">PDF</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">


在 2018 年挪威的一次研讨会上，我听到 Fred Schneider 发表了有关超级财产的演讲。</font><font style="vertical-align:inherit">普通属性是系统执行的谓词；</font><font style="vertical-align:inherit">超属性是执行集的谓词。</font><font style="vertical-align:inherit">超属性已被用来表达安全条件——通常是禁止信息泄露的条件。&nbsp;

</font></font><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">系统规范可以写成 TLA 公式，该公式仅在系统的可能执行情况下成立。</font><font style="vertical-align:inherit">在听 Schneider 的演讲时，我突然想到，对于仅依赖于有限执行次数的超性质，系统满足超性质的断言可以写成包含系统规范的多个副本的 TLA 公式。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">施耐德和我在接下来的两年里花了一部分时间来弄清楚如何使这个想法发挥作用，并就此撰写了这篇论文。</font><font style="vertical-align:inherit">我们发现 TLA 和 TLA+ 工具原则上可以检查高级系统设计是否满足我们在文献中看到的所有安全超属性。</font><font style="vertical-align:inherit">然而，TLA 必须以验证普通属性不需要的新方式使用。</font><font style="vertical-align:inherit">该论文荣获美国国家安全局2022年度最佳科学网络安全论文竞赛。&nbsp;

</font></font></p><p><font style="vertical-align:inherit"><font style="vertical-align:inherit">包含本文中示例及其验证的 TLA+ 文件（及其精美打印版本）可
</font></font><a href="https://lamport.azurewebsites.net/tla/hyperproperties/hyper.html"><font style="vertical-align:inherit"><font style="vertical-align:inherit">在此处</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">获取。&nbsp;


</font></font><br>&nbsp;</p><p></p></li><li> <a name="hyper2"><b>Verifying Hyperproperties with TLA</b>&nbsp; (with Fred B.&nbsp;
Schneider)<br>To appear in the <i>Proceedings of the 34th {IEEE}
Computer Security Foundations Symposium, {CSF} 2021</i>.<br>
</a><a href="http://lamport.azurewebsites.net/pubs/hyper2.pdf">PDF</a><hr>


At a workshop in Norway in 2018, I heard Fred Schneider give a talk
about hyperproperties.&nbsp; An ordinary property is a predicate on system
executions; a hyperproperty is a predicate on sets of executions.&nbsp;
Hyperproperties have been used to express security
conditions--usually ones that forbid information leaks.&nbsp;

<p>A system specification can be written as a TLA formula that
is true just on possible executions of the system.&nbsp; When listening to
Schneider's talk, it occurred to me that for a hyperproperty depending
on only a finite number of executions, the assertion that a system
satisfies the hyperproperty can can be written as a TLA formula
containing multiple copies of the system's specification.&nbsp;

</p><p>Schneider and I spent part of the following two years
figuring out how to make the idea work and writing this paper about
it.&nbsp; We found that TLA and the TLA+ tools can in principle check if
high-level system designs satisfy all the security hyperproperties we
saw in the literature.&nbsp; However, TLA had to be used in a new way that
was not needed for verifying ordinary properties.&nbsp;
This paper won the USA National Security Agency's 
2022 Annual Best Scientific Cybersecurity Paper Competition.&nbsp;

</p><p>TLA+ files (and their pretty-printed versions)  containing 
the examples in the paper and their verifications are available
<a href="https://lamport.azurewebsites.net/tla/hyperproperties/hyper.html">here</a>.&nbsp;


<br>&nbsp;</p><p></p></li><li> <a name="generations"><b><font style="vertical-align:inherit"><font style="vertical-align:inherit">代际间的数学证明</font></font></b><font style="vertical-align:inherit"><font style="vertical-align:inherit">&nbsp; （与乔纳斯·拜尔等人）</font></font><br><font style="vertical-align:inherit"><font style="vertical-align:inherit">出现。</font></font><br></a><a href="https://arxiv.org/abs/2207.04779"><font style="vertical-align:inherit"><font style="vertical-align:inherit">
arXiv:2207.04779（数学.HO）</font></font></a><hr><font style="vertical-align:inherit"><font style="vertical-align:inherit">

  
我和其他九个人一起被邀请提交一篇关于数学证明的论文的一部分。</font><font style="vertical-align:inherit">我认为目的是讨论机器检查证明对数学的潜在影响。</font><font style="vertical-align:inherit">我贡献了一个标题为“</font></font><i><font style="vertical-align:inherit"><font style="vertical-align:inherit">让数学更加严谨”的部分，本质上是论文</font></font></i><font style="vertical-align:inherit"></font><a href="#lamport-how-to-write"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[102]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">和
</font></font><a href="#proof"><font style="vertical-align:inherit"><font style="vertical-align:inherit">[179]</font></font></a><font style="vertical-align:inherit"><font style="vertical-align:inherit">的三页广告</font><font style="vertical-align:inherit">。&nbsp;
 

</font></font></li><li> <a name="generations"><b>Mathematical Proof Between Generations</b>&nbsp; (with Jonas Bayer et al.)<br>To appear.<br></a><a href="https://arxiv.org/abs/2207.04779">
arXiv:2207.04779 (math.HO)</a><hr>

  
I was invited along with nine other people to submit a section of a
paper on mathematical proofs.&nbsp; I think the purpose was to discuss the
potential influence on mathematics of machine checked proofs.&nbsp; I contributed
a section titled <i>Making Math More Rigorous</i> that is essentially
a three-page  advertisement for papers <a href="#lamport-how-to-write">[102]</a> and
<a href="#proof">[179]</a>.&nbsp;
 

</li></ol> 
</div>

 
<script id="res-script" src="/res/dist/res/main.js" type="text/javascript"></script>
</body></html>